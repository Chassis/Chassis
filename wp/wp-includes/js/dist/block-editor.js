/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 6411:
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	autosize 4.0.4
	license: MIT
	http://www.jacklmoore.com/autosize
*/
(function (global, factory) {
	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else { var mod; }
})(this, function (module, exports) {
	'use strict';

	var map = typeof Map === "function" ? new Map() : function () {
		var keys = [];
		var values = [];

		return {
			has: function has(key) {
				return keys.indexOf(key) > -1;
			},
			get: function get(key) {
				return values[keys.indexOf(key)];
			},
			set: function set(key, value) {
				if (keys.indexOf(key) === -1) {
					keys.push(key);
					values.push(value);
				}
			},
			delete: function _delete(key) {
				var index = keys.indexOf(key);
				if (index > -1) {
					keys.splice(index, 1);
					values.splice(index, 1);
				}
			}
		};
	}();

	var createEvent = function createEvent(name) {
		return new Event(name, { bubbles: true });
	};
	try {
		new Event('test');
	} catch (e) {
		// IE does not support `new Event()`
		createEvent = function createEvent(name) {
			var evt = document.createEvent('Event');
			evt.initEvent(name, true, false);
			return evt;
		};
	}

	function assign(ta) {
		if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || map.has(ta)) return;

		var heightOffset = null;
		var clientWidth = null;
		var cachedHeight = null;

		function init() {
			var style = window.getComputedStyle(ta, null);

			if (style.resize === 'vertical') {
				ta.style.resize = 'none';
			} else if (style.resize === 'both') {
				ta.style.resize = 'horizontal';
			}

			if (style.boxSizing === 'content-box') {
				heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
			} else {
				heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
			}
			// Fix when a textarea is not on document body and heightOffset is Not a Number
			if (isNaN(heightOffset)) {
				heightOffset = 0;
			}

			update();
		}

		function changeOverflow(value) {
			{
				// Chrome/Safari-specific fix:
				// When the textarea y-overflow is hidden, Chrome/Safari do not reflow the text to account for the space
				// made available by removing the scrollbar. The following forces the necessary text reflow.
				var width = ta.style.width;
				ta.style.width = '0px';
				// Force reflow:
				/* jshint ignore:start */
				ta.offsetWidth;
				/* jshint ignore:end */
				ta.style.width = width;
			}

			ta.style.overflowY = value;
		}

		function getParentOverflows(el) {
			var arr = [];

			while (el && el.parentNode && el.parentNode instanceof Element) {
				if (el.parentNode.scrollTop) {
					arr.push({
						node: el.parentNode,
						scrollTop: el.parentNode.scrollTop
					});
				}
				el = el.parentNode;
			}

			return arr;
		}

		function resize() {
			if (ta.scrollHeight === 0) {
				// If the scrollHeight is 0, then the element probably has display:none or is detached from the DOM.
				return;
			}

			var overflows = getParentOverflows(ta);
			var docTop = document.documentElement && document.documentElement.scrollTop; // Needed for Mobile IE (ticket #240)

			ta.style.height = '';
			ta.style.height = ta.scrollHeight + heightOffset + 'px';

			// used to check if an update is actually necessary on window.resize
			clientWidth = ta.clientWidth;

			// prevents scroll-position jumping
			overflows.forEach(function (el) {
				el.node.scrollTop = el.scrollTop;
			});

			if (docTop) {
				document.documentElement.scrollTop = docTop;
			}
		}

		function update() {
			resize();

			var styleHeight = Math.round(parseFloat(ta.style.height));
			var computed = window.getComputedStyle(ta, null);

			// Using offsetHeight as a replacement for computed.height in IE, because IE does not account use of border-box
			var actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(computed.height)) : ta.offsetHeight;

			// The actual height not matching the style height (set via the resize method) indicates that 
			// the max-height has been exceeded, in which case the overflow should be allowed.
			if (actualHeight < styleHeight) {
				if (computed.overflowY === 'hidden') {
					changeOverflow('scroll');
					resize();
					actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
				}
			} else {
				// Normally keep overflow set to hidden, to avoid flash of scrollbar as the textarea expands.
				if (computed.overflowY !== 'hidden') {
					changeOverflow('hidden');
					resize();
					actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
				}
			}

			if (cachedHeight !== actualHeight) {
				cachedHeight = actualHeight;
				var evt = createEvent('autosize:resized');
				try {
					ta.dispatchEvent(evt);
				} catch (err) {
					// Firefox will throw an error on dispatchEvent for a detached element
					// https://bugzilla.mozilla.org/show_bug.cgi?id=889376
				}
			}
		}

		var pageResize = function pageResize() {
			if (ta.clientWidth !== clientWidth) {
				update();
			}
		};

		var destroy = function (style) {
			window.removeEventListener('resize', pageResize, false);
			ta.removeEventListener('input', update, false);
			ta.removeEventListener('keyup', update, false);
			ta.removeEventListener('autosize:destroy', destroy, false);
			ta.removeEventListener('autosize:update', update, false);

			Object.keys(style).forEach(function (key) {
				ta.style[key] = style[key];
			});

			map.delete(ta);
		}.bind(ta, {
			height: ta.style.height,
			resize: ta.style.resize,
			overflowY: ta.style.overflowY,
			overflowX: ta.style.overflowX,
			wordWrap: ta.style.wordWrap
		});

		ta.addEventListener('autosize:destroy', destroy, false);

		// IE9 does not fire onpropertychange or oninput for deletions,
		// so binding to onkeyup to catch most of those events.
		// There is no way that I know of to detect something like 'cut' in IE9.
		if ('onpropertychange' in ta && 'oninput' in ta) {
			ta.addEventListener('keyup', update, false);
		}

		window.addEventListener('resize', pageResize, false);
		ta.addEventListener('input', update, false);
		ta.addEventListener('autosize:update', update, false);
		ta.style.overflowX = 'hidden';
		ta.style.wordWrap = 'break-word';

		map.set(ta, {
			destroy: destroy,
			update: update
		});

		init();
	}

	function destroy(ta) {
		var methods = map.get(ta);
		if (methods) {
			methods.destroy();
		}
	}

	function update(ta) {
		var methods = map.get(ta);
		if (methods) {
			methods.update();
		}
	}

	var autosize = null;

	// Do nothing in Node.js environment and IE8 (or lower)
	if (typeof window === 'undefined' || typeof window.getComputedStyle !== 'function') {
		autosize = function autosize(el) {
			return el;
		};
		autosize.destroy = function (el) {
			return el;
		};
		autosize.update = function (el) {
			return el;
		};
	} else {
		autosize = function autosize(el, options) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], function (x) {
					return assign(x, options);
				});
			}
			return el;
		};
		autosize.destroy = function (el) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], destroy);
			}
			return el;
		};
		autosize.update = function (el) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], update);
			}
			return el;
		};
	}

	exports.default = autosize;
	module.exports = exports['default'];
});

/***/ }),

/***/ 4403:
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;
	var nativeCodeString = '[native code]';

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				if (arg.length) {
					var inner = classNames.apply(null, arg);
					if (inner) {
						classes.push(inner);
					}
				}
			} else if (argType === 'object') {
				if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
					classes.push(arg.toString());
					continue;
				}

				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),

/***/ 4827:
/***/ (function(module) {

// This code has been refactored for 140 bytes
// You can see the original here: https://github.com/twolfson/computedStyle/blob/04cd1da2e30fa45844f95f5cb1ac898e9b9ef050/lib/computedStyle.js
var computedStyle = function (el, prop, getComputedStyle) {
  getComputedStyle = window.getComputedStyle;

  // In one fell swoop
  return (
    // If we have getComputedStyle
    getComputedStyle ?
      // Query it
      // TODO: From CSS-Query notes, we might need (node, null) for FF
      getComputedStyle(el) :

    // Otherwise, we are in IE and use currentStyle
      el.currentStyle
  )[
    // Switch to camelCase for CSSOM
    // DEV: Grabbed from jQuery
    // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194
    // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597
    prop.replace(/-(\w)/gi, function (word, letter) {
      return letter.toUpperCase();
    })
  ];
};

module.exports = computedStyle;


/***/ }),

/***/ 1198:
/***/ (function(__unused_webpack_module, exports) {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = Diff;

/*istanbul ignore end*/
function Diff() {}

Diff.prototype = {
  /*istanbul ignore start*/

  /*istanbul ignore end*/
  diff: function diff(oldString, newString) {
    /*istanbul ignore start*/
    var
    /*istanbul ignore end*/
    options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var callback = options.callback;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    this.options = options;
    var self = this;

    function done(value) {
      if (callback) {
        setTimeout(function () {
          callback(undefined, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    } // Allow subclasses to massage the input prior to running


    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length,
        oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    var bestPath = [{
      newPos: -1,
      components: []
    }]; // Seed editLength = 0, i.e. the content starts with the same values

    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);

    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
      // Identity per the equality and tokenizer
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    } // Main worker method. checks all permutations of a given edit length for acceptance.


    function execEditLength() {
      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
        var basePath =
        /*istanbul ignore start*/
        void 0
        /*istanbul ignore end*/
        ;

        var addPath = bestPath[diagonalPath - 1],
            removePath = bestPath[diagonalPath + 1],
            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;

        if (addPath) {
          // No one else is going to attempt to use this value, clear it
          bestPath[diagonalPath - 1] = undefined;
        }

        var canAdd = addPath && addPath.newPos + 1 < newLen,
            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;

        if (!canAdd && !canRemove) {
          // If this path is a terminal then prune
          bestPath[diagonalPath] = undefined;
          continue;
        } // Select the diagonal that we want to branch from. We select the prior
        // path whose position in the new string is the farthest from the origin
        // and does not pass the bounds of the diff graph


        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
          basePath = clonePath(removePath);
          self.pushComponent(basePath.components, undefined, true);
        } else {
          basePath = addPath; // No need to clone, we've pulled it from the list

          basePath.newPos++;
          self.pushComponent(basePath.components, true, undefined);
        }

        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done

        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
        } else {
          // Otherwise track this path as a potential candidate and continue.
          bestPath[diagonalPath] = basePath;
        }
      }

      editLength++;
    } // Performs the length of edit iteration. Is a bit fugly as this has to support the
    // sync and async mode which is never fun. Loops over execEditLength until a value
    // is produced.


    if (callback) {
      (function exec() {
        setTimeout(function () {
          // This should not happen, but we want to be safe.

          /* istanbul ignore next */
          if (editLength > maxEditLength) {
            return callback();
          }

          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength) {
        var ret = execEditLength();

        if (ret) {
          return ret;
        }
      }
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  pushComponent: function pushComponent(components, added, removed) {
    var last = components[components.length - 1];

    if (last && last.added === added && last.removed === removed) {
      // We need to clone here as the component clone operation is just
      // as shallow array clone
      components[components.length - 1] = {
        count: last.count + 1,
        added: added,
        removed: removed
      };
    } else {
      components.push({
        count: 1,
        added: added,
        removed: removed
      });
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length,
        oldLen = oldString.length,
        newPos = basePath.newPos,
        oldPos = newPos - diagonalPath,
        commonCount = 0;

    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }

    if (commonCount) {
      basePath.components.push({
        count: commonCount
      });
    }

    basePath.newPos = newPos;
    return oldPos;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  removeEmpty: function removeEmpty(array) {
    var ret = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }

    return ret;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  castInput: function castInput(value) {
    return value;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  tokenize: function tokenize(value) {
    return value.split('');
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  join: function join(chars) {
    return chars.join('');
  }
};

function buildValues(diff, components, newString, oldString, useLongestToken) {
  var componentPos = 0,
      componentLen = components.length,
      newPos = 0,
      oldPos = 0;

  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];

    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function (value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        });
        component.value = diff.join(value);
      } else {
        component.value = diff.join(newString.slice(newPos, newPos + component.count));
      }

      newPos += component.count; // Common case

      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
      // The diffing algorithm is tied to add then remove output and this is the simplest
      // route to get the desired output with minimal overhead.

      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  } // Special case handle for when one terminal is ignored (i.e. whitespace).
  // For this case we merge the terminal into the prior string and drop the change.
  // This is only available for string mode.


  var lastComponent = components[componentLen - 1];

  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
    components[componentLen - 2].value += lastComponent.value;
    components.pop();
  }

  return components;
}

function clonePath(path) {
  return {
    newPos: path.newPos,
    components: path.components.slice(0)
  };
}


/***/ }),

/***/ 1973:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
var __webpack_unused_export__;
/*istanbul ignore start*/


__webpack_unused_export__ = ({
  value: true
});
exports.Kx = diffChars;
__webpack_unused_export__ = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(1198))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*istanbul ignore end*/
var characterDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
.
/*istanbul ignore start*/
default
/*istanbul ignore end*/
();

/*istanbul ignore start*/
__webpack_unused_export__ = characterDiff;

/*istanbul ignore end*/
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}


/***/ }),

/***/ 1345:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(5022);

function scrollIntoView(elem, container, config) {
  config = config || {};
  // document 归一化到 window
  if (container.nodeType === 9) {
    container = util.getWindow(container);
  }

  var allowHorizontalScroll = config.allowHorizontalScroll;
  var onlyScrollIfNeeded = config.onlyScrollIfNeeded;
  var alignWithTop = config.alignWithTop;
  var alignWithLeft = config.alignWithLeft;
  var offsetTop = config.offsetTop || 0;
  var offsetLeft = config.offsetLeft || 0;
  var offsetBottom = config.offsetBottom || 0;
  var offsetRight = config.offsetRight || 0;

  allowHorizontalScroll = allowHorizontalScroll === undefined ? true : allowHorizontalScroll;

  var isWin = util.isWindow(container);
  var elemOffset = util.offset(elem);
  var eh = util.outerHeight(elem);
  var ew = util.outerWidth(elem);
  var containerOffset = undefined;
  var ch = undefined;
  var cw = undefined;
  var containerScroll = undefined;
  var diffTop = undefined;
  var diffBottom = undefined;
  var win = undefined;
  var winScroll = undefined;
  var ww = undefined;
  var wh = undefined;

  if (isWin) {
    win = container;
    wh = util.height(win);
    ww = util.width(win);
    winScroll = {
      left: util.scrollLeft(win),
      top: util.scrollTop(win)
    };
    // elem 相对 container 可视视窗的距离
    diffTop = {
      left: elemOffset.left - winScroll.left - offsetLeft,
      top: elemOffset.top - winScroll.top - offsetTop
    };
    diffBottom = {
      left: elemOffset.left + ew - (winScroll.left + ww) + offsetRight,
      top: elemOffset.top + eh - (winScroll.top + wh) + offsetBottom
    };
    containerScroll = winScroll;
  } else {
    containerOffset = util.offset(container);
    ch = container.clientHeight;
    cw = container.clientWidth;
    containerScroll = {
      left: container.scrollLeft,
      top: container.scrollTop
    };
    // elem 相对 container 可视视窗的距离
    // 注意边框, offset 是边框到根节点
    diffTop = {
      left: elemOffset.left - (containerOffset.left + (parseFloat(util.css(container, 'borderLeftWidth')) || 0)) - offsetLeft,
      top: elemOffset.top - (containerOffset.top + (parseFloat(util.css(container, 'borderTopWidth')) || 0)) - offsetTop
    };
    diffBottom = {
      left: elemOffset.left + ew - (containerOffset.left + cw + (parseFloat(util.css(container, 'borderRightWidth')) || 0)) + offsetRight,
      top: elemOffset.top + eh - (containerOffset.top + ch + (parseFloat(util.css(container, 'borderBottomWidth')) || 0)) + offsetBottom
    };
  }

  if (diffTop.top < 0 || diffBottom.top > 0) {
    // 强制向上
    if (alignWithTop === true) {
      util.scrollTop(container, containerScroll.top + diffTop.top);
    } else if (alignWithTop === false) {
      util.scrollTop(container, containerScroll.top + diffBottom.top);
    } else {
      // 自动调整
      if (diffTop.top < 0) {
        util.scrollTop(container, containerScroll.top + diffTop.top);
      } else {
        util.scrollTop(container, containerScroll.top + diffBottom.top);
      }
    }
  } else {
    if (!onlyScrollIfNeeded) {
      alignWithTop = alignWithTop === undefined ? true : !!alignWithTop;
      if (alignWithTop) {
        util.scrollTop(container, containerScroll.top + diffTop.top);
      } else {
        util.scrollTop(container, containerScroll.top + diffBottom.top);
      }
    }
  }

  if (allowHorizontalScroll) {
    if (diffTop.left < 0 || diffBottom.left > 0) {
      // 强制向上
      if (alignWithLeft === true) {
        util.scrollLeft(container, containerScroll.left + diffTop.left);
      } else if (alignWithLeft === false) {
        util.scrollLeft(container, containerScroll.left + diffBottom.left);
      } else {
        // 自动调整
        if (diffTop.left < 0) {
          util.scrollLeft(container, containerScroll.left + diffTop.left);
        } else {
          util.scrollLeft(container, containerScroll.left + diffBottom.left);
        }
      }
    } else {
      if (!onlyScrollIfNeeded) {
        alignWithLeft = alignWithLeft === undefined ? true : !!alignWithLeft;
        if (alignWithLeft) {
          util.scrollLeft(container, containerScroll.left + diffTop.left);
        } else {
          util.scrollLeft(container, containerScroll.left + diffBottom.left);
        }
      }
    }
  }
}

module.exports = scrollIntoView;

/***/ }),

/***/ 5425:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(1345);

/***/ }),

/***/ 5022:
/***/ (function(module) {

"use strict";


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;

function getClientPosition(elem) {
  var box = undefined;
  var x = undefined;
  var y = undefined;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement;
  // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式
  box = elem.getBoundingClientRect();

  // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop
  // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确
  // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin

  x = box.left;
  y = box.top;

  // In IE, most of the time, 2 extra pixels are added to the top and left
  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
  // IE6 standards mode, this border can be overridden by setting the
  // document element's border to zero -- thus, we cannot rely on the
  // offset always being 2 pixels.

  // In quirks mode, the offset can be determined by querying the body's
  // clientLeft/clientTop, but in standards mode, it is found by querying
  // the document element's clientLeft/clientTop.  Since we already called
  // getClientBoundingRect we have already forced a reflow, so it is not
  // too expensive just to query them all.

  // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的
  // 窗口边框标准是设 documentElement ,quirks 时设置 body
  // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去
  // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置
  // 标准 ie 下 docElem.clientTop 就是 border-top
  // ie7 html 即窗口边框改变不了。永远为 2
  // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0

  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;

  return {
    left: x,
    top: y
  };
}

function getScroll(w, top) {
  var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
  var method = 'scroll' + (top ? 'Top' : 'Left');
  if (typeof ret !== 'number') {
    var d = w.document;
    // ie6,7,8 standard mode
    ret = d.documentElement[method];
    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }
  return ret;
}

function getScrollLeft(w) {
  return getScroll(w);
}

function getScrollTop(w) {
  return getScroll(w, true);
}

function getOffset(el) {
  var pos = getClientPosition(el);
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w);
  pos.top += getScrollTop(w);
  return pos;
}
function _getComputedStyle(elem, name, computedStyle_) {
  var val = '';
  var d = elem.ownerDocument;
  var computedStyle = computedStyle_ || d.defaultView.getComputedStyle(elem, null);

  // https://github.com/kissyteam/kissy/issues/61
  if (computedStyle) {
    val = computedStyle.getPropertyValue(name) || computedStyle[name];
  }

  return val;
}

var _RE_NUM_NO_PX = new RegExp('^(' + RE_NUM + ')(?!px)[a-z%]+$', 'i');
var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = 'currentStyle';
var RUNTIME_STYLE = 'runtimeStyle';
var LEFT = 'left';
var PX = 'px';

function _getComputedStyleIE(elem, name) {
  // currentStyle maybe null
  // http://msdn.microsoft.com/en-us/library/ms535231.aspx
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];

  // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值
  // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19
  // 在 ie 下不对，需要直接用 offset 方式
  // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了

  // From the awesome hack by Dean Edwards
  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
  // If we're not dealing with a regular pixel number
  // but a number that has a weird ending, we need to convert it to pixels
  // exclude left right for relativity
  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
    // Remember the original values
    var style = elem.style;
    var left = style[LEFT];
    var rsLeft = elem[RUNTIME_STYLE][LEFT];

    // prevent flashing of content
    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];

    // Put in the new values to get a computed value out
    style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
    ret = style.pixelLeft + PX;

    // Revert the changed values
    style[LEFT] = left;

    elem[RUNTIME_STYLE][LEFT] = rsLeft;
  }
  return ret === '' ? 'auto' : ret;
}

var getComputedStyleX = undefined;
if (typeof window !== 'undefined') {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}

function each(arr, fn) {
  for (var i = 0; i < arr.length; i++) {
    fn(arr[i]);
  }
}

function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
}

var BOX_MODELS = ['margin', 'border', 'padding'];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;

function swap(elem, options, callback) {
  var old = {};
  var style = elem.style;
  var name = undefined;

  // Remember the old values, and insert the new ones
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      old[name] = style[name];
      style[name] = options[name];
    }
  }

  callback.call(elem);

  // Revert the old values
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      style[name] = old[name];
    }
  }
}

function getPBMWidth(elem, props, which) {
  var value = 0;
  var prop = undefined;
  var j = undefined;
  var i = undefined;
  for (j = 0; j < props.length; j++) {
    prop = props[j];
    if (prop) {
      for (i = 0; i < which.length; i++) {
        var cssProp = undefined;
        if (prop === 'border') {
          cssProp = prop + which[i] + 'Width';
        } else {
          cssProp = prop + which[i];
        }
        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }
  return value;
}

/**
 * A crude way of determining if an object is a window
 * @member util
 */
function isWindow(obj) {
  // must use == for ie8
  /* eslint eqeqeq:0 */
  return obj != null && obj == obj.window;
}

var domUtils = {};

each(['Width', 'Height'], function (name) {
  domUtils['doc' + name] = function (refWin) {
    var d = refWin.document;
    return Math.max(
    // firefox chrome documentElement.scrollHeight< body.scrollHeight
    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
    d.documentElement['scroll' + name],
    // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
    d.body['scroll' + name], domUtils['viewport' + name](d));
  };

  domUtils['viewport' + name] = function (win) {
    // pc browser includes scrollbar in window.innerWidth
    var prop = 'client' + name;
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop];
    // 标准模式取 documentElement
    // backcompat 取 body
    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
  };
});

/*
 得到元素的大小信息
 @param elem
 @param name
 @param {String} [extra]  'padding' : (css width) + padding
 'border' : (css width) + padding + border
 'margin' : (css width) + padding + border + margin
 */
function getWH(elem, name, extra) {
  if (isWindow(elem)) {
    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }
  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
  var borderBoxValue = name === 'width' ? elem.offsetWidth : elem.offsetHeight;
  var computedStyle = getComputedStyleX(elem);
  var isBorderBox = isBorderBoxFn(elem, computedStyle);
  var cssBoxValue = 0;
  if (borderBoxValue == null || borderBoxValue <= 0) {
    borderBoxValue = undefined;
    // Fall back to computed then un computed css if necessary
    cssBoxValue = getComputedStyleX(elem, name);
    if (cssBoxValue == null || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    }
    // Normalize '', auto, and prepare for extra
    cssBoxValue = parseFloat(cssBoxValue) || 0;
  }
  if (extra === undefined) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }
  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
  var val = borderBoxValue || cssBoxValue;
  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ['border', 'padding'], which, computedStyle);
    }
    return cssBoxValue;
  }
  if (borderBoxValueOrIsBorderBox) {
    var padding = extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which, computedStyle) : getPBMWidth(elem, ['margin'], which, computedStyle);
    return val + (extra === BORDER_INDEX ? 0 : padding);
  }
  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which, computedStyle);
}

var cssShow = {
  position: 'absolute',
  visibility: 'hidden',
  display: 'block'
};

// fix #119 : https://github.com/kissyteam/kissy/issues/119
function getWHIgnoreDisplay(elem) {
  var val = undefined;
  var args = arguments;
  // in case elem is window
  // elem.offsetWidth === undefined
  if (elem.offsetWidth !== 0) {
    val = getWH.apply(undefined, args);
  } else {
    swap(elem, cssShow, function () {
      val = getWH.apply(undefined, args);
    });
  }
  return val;
}

function css(el, name, v) {
  var value = v;
  if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
    for (var i in name) {
      if (name.hasOwnProperty(i)) {
        css(el, i, name[i]);
      }
    }
    return undefined;
  }
  if (typeof value !== 'undefined') {
    if (typeof value === 'number') {
      value += 'px';
    }
    el.style[name] = value;
    return undefined;
  }
  return getComputedStyleX(el, name);
}

each(['width', 'height'], function (name) {
  var first = name.charAt(0).toUpperCase() + name.slice(1);
  domUtils['outer' + first] = function (el, includeMargin) {
    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };
  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];

  domUtils[name] = function (elem, val) {
    if (val !== undefined) {
      if (elem) {
        var computedStyle = getComputedStyleX(elem);
        var isBorderBox = isBorderBoxFn(elem);
        if (isBorderBox) {
          val += getPBMWidth(elem, ['padding', 'border'], which, computedStyle);
        }
        return css(elem, name, val);
      }
      return undefined;
    }
    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
  };
});

// 设置 elem 相对 elem.ownerDocument 的坐标
function setOffset(elem, offset) {
  // set position first, in-case top/left are set even on static elem
  if (css(elem, 'position') === 'static') {
    elem.style.position = 'relative';
  }

  var old = getOffset(elem);
  var ret = {};
  var current = undefined;
  var key = undefined;

  for (key in offset) {
    if (offset.hasOwnProperty(key)) {
      current = parseFloat(css(elem, key)) || 0;
      ret[key] = current + offset[key] - old[key];
    }
  }
  css(elem, ret);
}

module.exports = _extends({
  getWindow: function getWindow(node) {
    var doc = node.ownerDocument || node;
    return doc.defaultView || doc.parentWindow;
  },
  offset: function offset(el, value) {
    if (typeof value !== 'undefined') {
      setOffset(el, value);
    } else {
      return getOffset(el);
    }
  },

  isWindow: isWindow,
  each: each,
  css: css,
  clone: function clone(obj) {
    var ret = {};
    for (var i in obj) {
      if (obj.hasOwnProperty(i)) {
        ret[i] = obj[i];
      }
    }
    var overflow = obj.overflow;
    if (overflow) {
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          ret.overflow[i] = obj.overflow[i];
        }
      }
    }
    return ret;
  },
  scrollLeft: function scrollLeft(w, v) {
    if (isWindow(w)) {
      if (v === undefined) {
        return getScrollLeft(w);
      }
      window.scrollTo(v, getScrollTop(w));
    } else {
      if (v === undefined) {
        return w.scrollLeft;
      }
      w.scrollLeft = v;
    }
  },
  scrollTop: function scrollTop(w, v) {
    if (isWindow(w)) {
      if (v === undefined) {
        return getScrollTop(w);
      }
      window.scrollTo(getScrollLeft(w), v);
    } else {
      if (v === undefined) {
        return w.scrollTop;
      }
      w.scrollTop = v;
    }
  },

  viewportWidth: 0,
  viewportHeight: 0
}, domUtils);

/***/ }),

/***/ 5619:
/***/ (function(module) {

"use strict";


// do not edit .js files directly - edit src/index.jst


  var envHasBigInt64Array = typeof BigInt64Array !== 'undefined';


module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }


    if ((a instanceof Map) && (b instanceof Map)) {
      if (a.size !== b.size) return false;
      for (i of a.entries())
        if (!b.has(i[0])) return false;
      for (i of a.entries())
        if (!equal(i[1], b.get(i[0]))) return false;
      return true;
    }

    if ((a instanceof Set) && (b instanceof Set)) {
      if (a.size !== b.size) return false;
      for (i of a.entries())
        if (!b.has(i[0])) return false;
      return true;
    }

    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (a[i] !== b[i]) return false;
      return true;
    }


    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ 8575:
/***/ (function(module) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 9894:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Load in dependencies
var computedStyle = __webpack_require__(4827);

/**
 * Calculate the `line-height` of a given node
 * @param {HTMLElement} node Element to calculate line height of. Must be in the DOM.
 * @returns {Number} `line-height` of the element in pixels
 */
function lineHeight(node) {
  // Grab the line-height via style
  var lnHeightStr = computedStyle(node, 'line-height');
  var lnHeight = parseFloat(lnHeightStr, 10);

  // If the lineHeight did not contain a unit (i.e. it was numeric), convert it to ems (e.g. '2.3' === '2.3em')
  if (lnHeightStr === lnHeight + '') {
    // Save the old lineHeight style and update the em unit to the element
    var _lnHeightStyle = node.style.lineHeight;
    node.style.lineHeight = lnHeightStr + 'em';

    // Calculate the em based height
    lnHeightStr = computedStyle(node, 'line-height');
    lnHeight = parseFloat(lnHeightStr, 10);

    // Revert the lineHeight style
    if (_lnHeightStyle) {
      node.style.lineHeight = _lnHeightStyle;
    } else {
      delete node.style.lineHeight;
    }
  }

  // If the lineHeight is in `pt`, convert it to pixels (4px for 3pt)
  // DEV: `em` units are converted to `pt` in IE6
  // Conversion ratio from https://developer.mozilla.org/en-US/docs/Web/CSS/length
  if (lnHeightStr.indexOf('pt') !== -1) {
    lnHeight *= 4;
    lnHeight /= 3;
  // Otherwise, if the lineHeight is in `mm`, convert it to pixels (96px for 25.4mm)
  } else if (lnHeightStr.indexOf('mm') !== -1) {
    lnHeight *= 96;
    lnHeight /= 25.4;
  // Otherwise, if the lineHeight is in `cm`, convert it to pixels (96px for 2.54cm)
  } else if (lnHeightStr.indexOf('cm') !== -1) {
    lnHeight *= 96;
    lnHeight /= 2.54;
  // Otherwise, if the lineHeight is in `in`, convert it to pixels (96px for 1in)
  } else if (lnHeightStr.indexOf('in') !== -1) {
    lnHeight *= 96;
  // Otherwise, if the lineHeight is in `pc`, convert it to pixels (12pt for 1pc)
  } else if (lnHeightStr.indexOf('pc') !== -1) {
    lnHeight *= 16;
  }

  // Continue our computation
  lnHeight = Math.round(lnHeight);

  // If the line-height is "normal", calculate by font-size
  if (lnHeightStr === 'normal') {
    // Create a temporary node
    var nodeName = node.nodeName;
    var _node = document.createElement(nodeName);
    _node.innerHTML = '&nbsp;';

    // If we have a text area, reset it to only 1 row
    // https://github.com/twolfson/line-height/issues/4
    if (nodeName.toUpperCase() === 'TEXTAREA') {
      _node.setAttribute('rows', '1');
    }

    // Set the font-size of the element
    var fontSizeStr = computedStyle(node, 'font-size');
    _node.style.fontSize = fontSizeStr;

    // Remove default padding/border which can affect offset height
    // https://github.com/twolfson/line-height/issues/4
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight
    _node.style.padding = '0px';
    _node.style.border = '0px';

    // Append it to the body
    var body = document.body;
    body.appendChild(_node);

    // Assume the line height of the element is the height
    var height = _node.offsetHeight;
    lnHeight = height;

    // Remove our child from the DOM
    body.removeChild(_node);
  }

  // Return the calculated height
  return lnHeight;
}

// Export lineHeight
module.exports = lineHeight;


/***/ }),

/***/ 7970:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(195);


/***/ }),

/***/ 3110:
/***/ (function(module) {

"use strict";
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ExecutionEnvironment
 */

/*jslint evil: true */



var canUseDOM = !!(
  typeof window !== 'undefined' &&
  window.document &&
  window.document.createElement
);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners:
    canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;


/***/ }),

/***/ 3812:
/***/ (function(module) {

/**
 * Copyright 2004-present Facebook. All Rights Reserved.
 *
 * @providesModule UserAgent_DEPRECATED
 */

/**
 *  Provides entirely client-side User Agent and OS detection. You should prefer
 *  the non-deprecated UserAgent module when possible, which exposes our
 *  authoritative server-side PHP-based detection to the client.
 *
 *  Usage is straightforward:
 *
 *    if (UserAgent_DEPRECATED.ie()) {
 *      //  IE
 *    }
 *
 *  You can also do version checks:
 *
 *    if (UserAgent_DEPRECATED.ie() >= 7) {
 *      //  IE7 or better
 *    }
 *
 *  The browser functions will return NaN if the browser does not match, so
 *  you can also do version compares the other way:
 *
 *    if (UserAgent_DEPRECATED.ie() < 7) {
 *      //  IE6 or worse
 *    }
 *
 *  Note that the version is a float and may include a minor version number,
 *  so you should always use range operators to perform comparisons, not
 *  strict equality.
 *
 *  **Note:** You should **strongly** prefer capability detection to browser
 *  version detection where it's reasonable:
 *
 *    http://www.quirksmode.org/js/support.html
 *
 *  Further, we have a large number of mature wrapper functions and classes
 *  which abstract away many browser irregularities. Check the documentation,
 *  grep for things, or ask on javascript@lists.facebook.com before writing yet
 *  another copy of "event || window.event".
 *
 */

var _populated = false;

// Browsers
var _ie, _firefox, _opera, _webkit, _chrome;

// Actual IE browser for compatibility mode
var _ie_real_version;

// Platforms
var _osx, _windows, _linux, _android;

// Architectures
var _win64;

// Devices
var _iphone, _ipad, _native;

var _mobile;

function _populate() {
  if (_populated) {
    return;
  }

  _populated = true;

  // To work around buggy JS libraries that can't handle multi-digit
  // version numbers, Opera 10's user agent string claims it's Opera
  // 9, then later includes a Version/X.Y field:
  //
  // Opera/9.80 (foo) Presto/2.2.15 Version/10.10
  var uas = navigator.userAgent;
  var agent = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(uas);
  var os    = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);

  _iphone = /\b(iPhone|iP[ao]d)/.exec(uas);
  _ipad = /\b(iP[ao]d)/.exec(uas);
  _android = /Android/i.exec(uas);
  _native = /FBAN\/\w+;/i.exec(uas);
  _mobile = /Mobile/i.exec(uas);

  // Note that the IE team blog would have you believe you should be checking
  // for 'Win64; x64'.  But MSDN then reveals that you can actually be coming
  // from either x64 or ia64;  so ultimately, you should just check for Win64
  // as in indicator of whether you're in 64-bit IE.  32-bit IE on 64-bit
  // Windows will send 'WOW64' instead.
  _win64 = !!(/Win64/.exec(uas));

  if (agent) {
    _ie = agent[1] ? parseFloat(agent[1]) : (
          agent[5] ? parseFloat(agent[5]) : NaN);
    // IE compatibility mode
    if (_ie && document && document.documentMode) {
      _ie = document.documentMode;
    }
    // grab the "true" ie version from the trident token if available
    var trident = /(?:Trident\/(\d+.\d+))/.exec(uas);
    _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;

    _firefox = agent[2] ? parseFloat(agent[2]) : NaN;
    _opera   = agent[3] ? parseFloat(agent[3]) : NaN;
    _webkit  = agent[4] ? parseFloat(agent[4]) : NaN;
    if (_webkit) {
      // We do not add the regexp to the above test, because it will always
      // match 'safari' only since 'AppleWebKit' appears before 'Chrome' in
      // the userAgent string.
      agent = /(?:Chrome\/(\d+\.\d+))/.exec(uas);
      _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;
    } else {
      _chrome = NaN;
    }
  } else {
    _ie = _firefox = _opera = _chrome = _webkit = NaN;
  }

  if (os) {
    if (os[1]) {
      // Detect OS X version.  If no version number matches, set _osx to true.
      // Version examples:  10, 10_6_1, 10.7
      // Parses version number as a float, taking only first two sets of
      // digits.  If only one set of digits is found, returns just the major
      // version number.
      var ver = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(uas);

      _osx = ver ? parseFloat(ver[1].replace('_', '.')) : true;
    } else {
      _osx = false;
    }
    _windows = !!os[2];
    _linux   = !!os[3];
  } else {
    _osx = _windows = _linux = false;
  }
}

var UserAgent_DEPRECATED = {

  /**
   *  Check if the UA is Internet Explorer.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  ie: function() {
    return _populate() || _ie;
  },

  /**
   * Check if we're in Internet Explorer compatibility mode.
   *
   * @return bool true if in compatibility mode, false if
   * not compatibility mode or not ie
   */
  ieCompatibilityMode: function() {
    return _populate() || (_ie_real_version > _ie);
  },


  /**
   * Whether the browser is 64-bit IE.  Really, this is kind of weak sauce;  we
   * only need this because Skype can't handle 64-bit IE yet.  We need to remove
   * this when we don't need it -- tracked by #601957.
   */
  ie64: function() {
    return UserAgent_DEPRECATED.ie() && _win64;
  },

  /**
   *  Check if the UA is Firefox.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  firefox: function() {
    return _populate() || _firefox;
  },


  /**
   *  Check if the UA is Opera.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  opera: function() {
    return _populate() || _opera;
  },


  /**
   *  Check if the UA is WebKit.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  webkit: function() {
    return _populate() || _webkit;
  },

  /**
   *  For Push
   *  WILL BE REMOVED VERY SOON. Use UserAgent_DEPRECATED.webkit
   */
  safari: function() {
    return UserAgent_DEPRECATED.webkit();
  },

  /**
   *  Check if the UA is a Chrome browser.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  chrome : function() {
    return _populate() || _chrome;
  },


  /**
   *  Check if the user is running Windows.
   *
   *  @return bool `true' if the user's OS is Windows.
   */
  windows: function() {
    return _populate() || _windows;
  },


  /**
   *  Check if the user is running Mac OS X.
   *
   *  @return float|bool   Returns a float if a version number is detected,
   *                       otherwise true/false.
   */
  osx: function() {
    return _populate() || _osx;
  },

  /**
   * Check if the user is running Linux.
   *
   * @return bool `true' if the user's OS is some flavor of Linux.
   */
  linux: function() {
    return _populate() || _linux;
  },

  /**
   * Check if the user is running on an iPhone or iPod platform.
   *
   * @return bool `true' if the user is running some flavor of the
   *    iPhone OS.
   */
  iphone: function() {
    return _populate() || _iphone;
  },

  mobile: function() {
    return _populate() || (_iphone || _ipad || _android || _mobile);
  },

  nativeApp: function() {
    // webviews inside of the native apps
    return _populate() || _native;
  },

  android: function() {
    return _populate() || _android;
  },

  ipad: function() {
    return _populate() || _ipad;
  }
};

module.exports = UserAgent_DEPRECATED;


/***/ }),

/***/ 7939:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isEventSupported
 */



var ExecutionEnvironment = __webpack_require__(3110);

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature =
    document.implementation &&
    document.implementation.hasFeature &&
    // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM ||
      capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;


/***/ }),

/***/ 195:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule normalizeWheel
 * @typechecks
 */



var UserAgent_DEPRECATED = __webpack_require__(3812);

var isEventSupported = __webpack_require__(7939);


// Reasonable defaults
var PIXEL_STEP  = 10;
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;

/**
 * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
 * complicated, thus this doc is long and (hopefully) detailed enough to answer
 * your questions.
 *
 * If you need to react to the mouse wheel in a predictable way, this code is
 * like your bestest friend. * hugs *
 *
 * As of today, there are 4 DOM event types you can listen to:
 *
 *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
 *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
 *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
 *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
 *
 * So what to do?  The is the best:
 *
 *   normalizeWheel.getEventType();
 *
 * In your event callback, use this code to get sane interpretation of the
 * deltas.  This code will return an object with properties:
 *
 *   spinX   -- normalized spin speed (use for zoom) - x plane
 *   spinY   -- " - y plane
 *   pixelX  -- normalized distance (to pixels) - x plane
 *   pixelY  -- " - y plane
 *
 * Wheel values are provided by the browser assuming you are using the wheel to
 * scroll a web page by a number of lines or pixels (or pages).  Values can vary
 * significantly on different platforms and browsers, forgetting that you can
 * scroll at different speeds.  Some devices (like trackpads) emit more events
 * at smaller increments with fine granularity, and some emit massive jumps with
 * linear speed or acceleration.
 *
 * This code does its best to normalize the deltas for you:
 *
 *   - spin is trying to normalize how far the wheel was spun (or trackpad
 *     dragged).  This is super useful for zoom support where you want to
 *     throw away the chunky scroll steps on the PC and make those equal to
 *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
 *     resolve a single slow step on a wheel to 1.
 *
 *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
 *     get the crazy differences between browsers, but at least it'll be in
 *     pixels!
 *
 *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
 *     should translate to positive value zooming IN, negative zooming OUT.
 *     This matches the newer 'wheel' event.
 *
 * Why are there spinX, spinY (or pixels)?
 *
 *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
 *     with a mouse.  It results in side-scrolling in the browser by default.
 *
 *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
 *
 *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
 *     probably is by browsers in conjunction with fancy 3D controllers .. but
 *     you know.
 *
 * Implementation info:
 *
 * Examples of 'wheel' event if you scroll slowly (down) by one step with an
 * average mouse:
 *
 *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
 *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
 *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
 *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
 *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
 *
 * On the trackpad:
 *
 *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
 *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
 *
 * On other/older browsers.. it's more complicated as there can be multiple and
 * also missing delta values.
 *
 * The 'wheel' event is more standard:
 *
 * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
 *
 * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
 * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
 * backward compatibility with older events.  Those other values help us
 * better normalize spin speed.  Example of what the browsers provide:
 *
 *                          | event.wheelDelta | event.detail
 *        ------------------+------------------+--------------
 *          Safari v5/OS X  |       -120       |       0
 *          Safari v5/Win7  |       -120       |       0
 *         Chrome v17/OS X  |       -120       |       0
 *         Chrome v17/Win7  |       -120       |       0
 *                IE9/Win7  |       -120       |   undefined
 *         Firefox v4/OS X  |     undefined    |       1
 *         Firefox v4/Win7  |     undefined    |       3
 *
 */
function normalizeWheel(/*object*/ event) /*object*/ {
  var sX = 0, sY = 0,       // spinX, spinY
      pX = 0, pY = 0;       // pixelX, pixelY

  // Legacy
  if ('detail'      in event) { sY = event.detail; }
  if ('wheelDelta'  in event) { sY = -event.wheelDelta / 120; }
  if ('wheelDeltaY' in event) { sY = -event.wheelDeltaY / 120; }
  if ('wheelDeltaX' in event) { sX = -event.wheelDeltaX / 120; }

  // side scrolling on FF with DOMMouseScroll
  if ( 'axis' in event && event.axis === event.HORIZONTAL_AXIS ) {
    sX = sY;
    sY = 0;
  }

  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;

  if ('deltaY' in event) { pY = event.deltaY; }
  if ('deltaX' in event) { pX = event.deltaX; }

  if ((pX || pY) && event.deltaMode) {
    if (event.deltaMode == 1) {          // delta in LINE units
      pX *= LINE_HEIGHT;
      pY *= LINE_HEIGHT;
    } else {                             // delta in PAGE units
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  }

  // Fall-back if spin cannot be determined
  if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }
  if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }

  return { spinX  : sX,
           spinY  : sY,
           pixelX : pX,
           pixelY : pY };
}


/**
 * The best combination if you prefer spinX + spinY normalization.  It favors
 * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with
 * 'wheel' event, making spin speed determination impossible.
 */
normalizeWheel.getEventType = function() /*string*/ {
  return (UserAgent_DEPRECATED.firefox())
           ? 'DOMMouseScroll'
           : (isEventSupported('wheel'))
               ? 'wheel'
               : 'mousewheel';
};

module.exports = normalizeWheel;


/***/ }),

/***/ 5372:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__(9567);

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ 2652:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) { var throwOnDirectAccess, ReactIs; } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(5372)();
}


/***/ }),

/***/ 9567:
/***/ (function(module) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ 5438:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
exports.__esModule = true;
var React = __webpack_require__(9196);
var PropTypes = __webpack_require__(2652);
var autosize = __webpack_require__(6411);
var _getLineHeight = __webpack_require__(9894);
var getLineHeight = _getLineHeight;
var RESIZED = "autosize:resized";
/**
 * A light replacement for built-in textarea component
 * which automaticaly adjusts its height to match the content
 */
var TextareaAutosizeClass = /** @class */ (function (_super) {
    __extends(TextareaAutosizeClass, _super);
    function TextareaAutosizeClass() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            lineHeight: null
        };
        _this.textarea = null;
        _this.onResize = function (e) {
            if (_this.props.onResize) {
                _this.props.onResize(e);
            }
        };
        _this.updateLineHeight = function () {
            if (_this.textarea) {
                _this.setState({
                    lineHeight: getLineHeight(_this.textarea)
                });
            }
        };
        _this.onChange = function (e) {
            var onChange = _this.props.onChange;
            _this.currentValue = e.currentTarget.value;
            onChange && onChange(e);
        };
        return _this;
    }
    TextareaAutosizeClass.prototype.componentDidMount = function () {
        var _this = this;
        var _a = this.props, maxRows = _a.maxRows, async = _a.async;
        if (typeof maxRows === "number") {
            this.updateLineHeight();
        }
        if (typeof maxRows === "number" || async) {
            /*
              the defer is needed to:
                - force "autosize" to activate the scrollbar when this.props.maxRows is passed
                - support StyledComponents (see #71)
            */
            setTimeout(function () { return _this.textarea && autosize(_this.textarea); });
        }
        else {
            this.textarea && autosize(this.textarea);
        }
        if (this.textarea) {
            this.textarea.addEventListener(RESIZED, this.onResize);
        }
    };
    TextareaAutosizeClass.prototype.componentWillUnmount = function () {
        if (this.textarea) {
            this.textarea.removeEventListener(RESIZED, this.onResize);
            autosize.destroy(this.textarea);
        }
    };
    TextareaAutosizeClass.prototype.render = function () {
        var _this = this;
        var _a = this, _b = _a.props, onResize = _b.onResize, maxRows = _b.maxRows, onChange = _b.onChange, style = _b.style, innerRef = _b.innerRef, children = _b.children, props = __rest(_b, ["onResize", "maxRows", "onChange", "style", "innerRef", "children"]), lineHeight = _a.state.lineHeight;
        var maxHeight = maxRows && lineHeight ? lineHeight * maxRows : null;
        return (React.createElement("textarea", __assign({}, props, { onChange: this.onChange, style: maxHeight ? __assign({}, style, { maxHeight: maxHeight }) : style, ref: function (element) {
                _this.textarea = element;
                if (typeof _this.props.innerRef === 'function') {
                    _this.props.innerRef(element);
                }
                else if (_this.props.innerRef) {
                    _this.props.innerRef.current = element;
                }
            } }), children));
    };
    TextareaAutosizeClass.prototype.componentDidUpdate = function () {
        this.textarea && autosize.update(this.textarea);
    };
    TextareaAutosizeClass.defaultProps = {
        rows: 1,
        async: false
    };
    TextareaAutosizeClass.propTypes = {
        rows: PropTypes.number,
        maxRows: PropTypes.number,
        onResize: PropTypes.func,
        innerRef: PropTypes.any,
        async: PropTypes.bool
    };
    return TextareaAutosizeClass;
}(React.Component));
exports.TextareaAutosize = React.forwardRef(function (props, ref) {
    return React.createElement(TextareaAutosizeClass, __assign({}, props, { innerRef: ref }));
});


/***/ }),

/***/ 773:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = true;
var TextareaAutosize_1 = __webpack_require__(5438);
exports.Z = TextareaAutosize_1.TextareaAutosize;


/***/ }),

/***/ 4793:
/***/ (function(module) {

var characterMap = {
	"À": "A",
	"Á": "A",
	"Â": "A",
	"Ã": "A",
	"Ä": "A",
	"Å": "A",
	"Ấ": "A",
	"Ắ": "A",
	"Ẳ": "A",
	"Ẵ": "A",
	"Ặ": "A",
	"Æ": "AE",
	"Ầ": "A",
	"Ằ": "A",
	"Ȃ": "A",
	"Ç": "C",
	"Ḉ": "C",
	"È": "E",
	"É": "E",
	"Ê": "E",
	"Ë": "E",
	"Ế": "E",
	"Ḗ": "E",
	"Ề": "E",
	"Ḕ": "E",
	"Ḝ": "E",
	"Ȇ": "E",
	"Ì": "I",
	"Í": "I",
	"Î": "I",
	"Ï": "I",
	"Ḯ": "I",
	"Ȋ": "I",
	"Ð": "D",
	"Ñ": "N",
	"Ò": "O",
	"Ó": "O",
	"Ô": "O",
	"Õ": "O",
	"Ö": "O",
	"Ø": "O",
	"Ố": "O",
	"Ṍ": "O",
	"Ṓ": "O",
	"Ȏ": "O",
	"Ù": "U",
	"Ú": "U",
	"Û": "U",
	"Ü": "U",
	"Ý": "Y",
	"à": "a",
	"á": "a",
	"â": "a",
	"ã": "a",
	"ä": "a",
	"å": "a",
	"ấ": "a",
	"ắ": "a",
	"ẳ": "a",
	"ẵ": "a",
	"ặ": "a",
	"æ": "ae",
	"ầ": "a",
	"ằ": "a",
	"ȃ": "a",
	"ç": "c",
	"ḉ": "c",
	"è": "e",
	"é": "e",
	"ê": "e",
	"ë": "e",
	"ế": "e",
	"ḗ": "e",
	"ề": "e",
	"ḕ": "e",
	"ḝ": "e",
	"ȇ": "e",
	"ì": "i",
	"í": "i",
	"î": "i",
	"ï": "i",
	"ḯ": "i",
	"ȋ": "i",
	"ð": "d",
	"ñ": "n",
	"ò": "o",
	"ó": "o",
	"ô": "o",
	"õ": "o",
	"ö": "o",
	"ø": "o",
	"ố": "o",
	"ṍ": "o",
	"ṓ": "o",
	"ȏ": "o",
	"ù": "u",
	"ú": "u",
	"û": "u",
	"ü": "u",
	"ý": "y",
	"ÿ": "y",
	"Ā": "A",
	"ā": "a",
	"Ă": "A",
	"ă": "a",
	"Ą": "A",
	"ą": "a",
	"Ć": "C",
	"ć": "c",
	"Ĉ": "C",
	"ĉ": "c",
	"Ċ": "C",
	"ċ": "c",
	"Č": "C",
	"č": "c",
	"C̆": "C",
	"c̆": "c",
	"Ď": "D",
	"ď": "d",
	"Đ": "D",
	"đ": "d",
	"Ē": "E",
	"ē": "e",
	"Ĕ": "E",
	"ĕ": "e",
	"Ė": "E",
	"ė": "e",
	"Ę": "E",
	"ę": "e",
	"Ě": "E",
	"ě": "e",
	"Ĝ": "G",
	"Ǵ": "G",
	"ĝ": "g",
	"ǵ": "g",
	"Ğ": "G",
	"ğ": "g",
	"Ġ": "G",
	"ġ": "g",
	"Ģ": "G",
	"ģ": "g",
	"Ĥ": "H",
	"ĥ": "h",
	"Ħ": "H",
	"ħ": "h",
	"Ḫ": "H",
	"ḫ": "h",
	"Ĩ": "I",
	"ĩ": "i",
	"Ī": "I",
	"ī": "i",
	"Ĭ": "I",
	"ĭ": "i",
	"Į": "I",
	"į": "i",
	"İ": "I",
	"ı": "i",
	"Ĳ": "IJ",
	"ĳ": "ij",
	"Ĵ": "J",
	"ĵ": "j",
	"Ķ": "K",
	"ķ": "k",
	"Ḱ": "K",
	"ḱ": "k",
	"K̆": "K",
	"k̆": "k",
	"Ĺ": "L",
	"ĺ": "l",
	"Ļ": "L",
	"ļ": "l",
	"Ľ": "L",
	"ľ": "l",
	"Ŀ": "L",
	"ŀ": "l",
	"Ł": "l",
	"ł": "l",
	"Ḿ": "M",
	"ḿ": "m",
	"M̆": "M",
	"m̆": "m",
	"Ń": "N",
	"ń": "n",
	"Ņ": "N",
	"ņ": "n",
	"Ň": "N",
	"ň": "n",
	"ŉ": "n",
	"N̆": "N",
	"n̆": "n",
	"Ō": "O",
	"ō": "o",
	"Ŏ": "O",
	"ŏ": "o",
	"Ő": "O",
	"ő": "o",
	"Œ": "OE",
	"œ": "oe",
	"P̆": "P",
	"p̆": "p",
	"Ŕ": "R",
	"ŕ": "r",
	"Ŗ": "R",
	"ŗ": "r",
	"Ř": "R",
	"ř": "r",
	"R̆": "R",
	"r̆": "r",
	"Ȓ": "R",
	"ȓ": "r",
	"Ś": "S",
	"ś": "s",
	"Ŝ": "S",
	"ŝ": "s",
	"Ş": "S",
	"Ș": "S",
	"ș": "s",
	"ş": "s",
	"Š": "S",
	"š": "s",
	"ß": "ss",
	"Ţ": "T",
	"ţ": "t",
	"ț": "t",
	"Ț": "T",
	"Ť": "T",
	"ť": "t",
	"Ŧ": "T",
	"ŧ": "t",
	"T̆": "T",
	"t̆": "t",
	"Ũ": "U",
	"ũ": "u",
	"Ū": "U",
	"ū": "u",
	"Ŭ": "U",
	"ŭ": "u",
	"Ů": "U",
	"ů": "u",
	"Ű": "U",
	"ű": "u",
	"Ų": "U",
	"ų": "u",
	"Ȗ": "U",
	"ȗ": "u",
	"V̆": "V",
	"v̆": "v",
	"Ŵ": "W",
	"ŵ": "w",
	"Ẃ": "W",
	"ẃ": "w",
	"X̆": "X",
	"x̆": "x",
	"Ŷ": "Y",
	"ŷ": "y",
	"Ÿ": "Y",
	"Y̆": "Y",
	"y̆": "y",
	"Ź": "Z",
	"ź": "z",
	"Ż": "Z",
	"ż": "z",
	"Ž": "Z",
	"ž": "z",
	"ſ": "s",
	"ƒ": "f",
	"Ơ": "O",
	"ơ": "o",
	"Ư": "U",
	"ư": "u",
	"Ǎ": "A",
	"ǎ": "a",
	"Ǐ": "I",
	"ǐ": "i",
	"Ǒ": "O",
	"ǒ": "o",
	"Ǔ": "U",
	"ǔ": "u",
	"Ǖ": "U",
	"ǖ": "u",
	"Ǘ": "U",
	"ǘ": "u",
	"Ǚ": "U",
	"ǚ": "u",
	"Ǜ": "U",
	"ǜ": "u",
	"Ứ": "U",
	"ứ": "u",
	"Ṹ": "U",
	"ṹ": "u",
	"Ǻ": "A",
	"ǻ": "a",
	"Ǽ": "AE",
	"ǽ": "ae",
	"Ǿ": "O",
	"ǿ": "o",
	"Þ": "TH",
	"þ": "th",
	"Ṕ": "P",
	"ṕ": "p",
	"Ṥ": "S",
	"ṥ": "s",
	"X́": "X",
	"x́": "x",
	"Ѓ": "Г",
	"ѓ": "г",
	"Ќ": "К",
	"ќ": "к",
	"A̋": "A",
	"a̋": "a",
	"E̋": "E",
	"e̋": "e",
	"I̋": "I",
	"i̋": "i",
	"Ǹ": "N",
	"ǹ": "n",
	"Ồ": "O",
	"ồ": "o",
	"Ṑ": "O",
	"ṑ": "o",
	"Ừ": "U",
	"ừ": "u",
	"Ẁ": "W",
	"ẁ": "w",
	"Ỳ": "Y",
	"ỳ": "y",
	"Ȁ": "A",
	"ȁ": "a",
	"Ȅ": "E",
	"ȅ": "e",
	"Ȉ": "I",
	"ȉ": "i",
	"Ȍ": "O",
	"ȍ": "o",
	"Ȑ": "R",
	"ȑ": "r",
	"Ȕ": "U",
	"ȕ": "u",
	"B̌": "B",
	"b̌": "b",
	"Č̣": "C",
	"č̣": "c",
	"Ê̌": "E",
	"ê̌": "e",
	"F̌": "F",
	"f̌": "f",
	"Ǧ": "G",
	"ǧ": "g",
	"Ȟ": "H",
	"ȟ": "h",
	"J̌": "J",
	"ǰ": "j",
	"Ǩ": "K",
	"ǩ": "k",
	"M̌": "M",
	"m̌": "m",
	"P̌": "P",
	"p̌": "p",
	"Q̌": "Q",
	"q̌": "q",
	"Ř̩": "R",
	"ř̩": "r",
	"Ṧ": "S",
	"ṧ": "s",
	"V̌": "V",
	"v̌": "v",
	"W̌": "W",
	"w̌": "w",
	"X̌": "X",
	"x̌": "x",
	"Y̌": "Y",
	"y̌": "y",
	"A̧": "A",
	"a̧": "a",
	"B̧": "B",
	"b̧": "b",
	"Ḑ": "D",
	"ḑ": "d",
	"Ȩ": "E",
	"ȩ": "e",
	"Ɛ̧": "E",
	"ɛ̧": "e",
	"Ḩ": "H",
	"ḩ": "h",
	"I̧": "I",
	"i̧": "i",
	"Ɨ̧": "I",
	"ɨ̧": "i",
	"M̧": "M",
	"m̧": "m",
	"O̧": "O",
	"o̧": "o",
	"Q̧": "Q",
	"q̧": "q",
	"U̧": "U",
	"u̧": "u",
	"X̧": "X",
	"x̧": "x",
	"Z̧": "Z",
	"z̧": "z",
	"й":"и",
	"Й":"И",
	"ё":"е",
	"Ё":"Е",
};

var chars = Object.keys(characterMap).join('|');
var allAccents = new RegExp(chars, 'g');
var firstAccent = new RegExp(chars, '');

function matcher(match) {
	return characterMap[match];
}

var removeAccents = function(string) {	
	return string.replace(allAccents, matcher);
};

var hasAccents = function(string) {
	return !!string.match(firstAccent);
};

module.exports = removeAccents;
module.exports.has = hasAccents;
module.exports.remove = removeAccents;


/***/ }),

/***/ 3124:
/***/ (function(module) {

"use strict";


// TODO: use call-bind, is-date, is-regex, is-string, is-boolean-object, is-number-object
function toS(obj) { return Object.prototype.toString.call(obj); }
function isDate(obj) { return toS(obj) === '[object Date]'; }
function isRegExp(obj) { return toS(obj) === '[object RegExp]'; }
function isError(obj) { return toS(obj) === '[object Error]'; }
function isBoolean(obj) { return toS(obj) === '[object Boolean]'; }
function isNumber(obj) { return toS(obj) === '[object Number]'; }
function isString(obj) { return toS(obj) === '[object String]'; }

// TODO: use isarray
var isArray = Array.isArray || function isArray(xs) {
	return Object.prototype.toString.call(xs) === '[object Array]';
};

// TODO: use for-each?
function forEach(xs, fn) {
	if (xs.forEach) { return xs.forEach(fn); }
	for (var i = 0; i < xs.length; i++) {
		fn(xs[i], i, xs);
	}
	return void undefined;
}

// TODO: use object-keys
var objectKeys = Object.keys || function keys(obj) {
	var res = [];
	for (var key in obj) { res.push(key); } // eslint-disable-line no-restricted-syntax
	return res;
};

// TODO: use object.hasown
var hasOwnProperty = Object.prototype.hasOwnProperty || function (obj, key) {
	return key in obj;
};

function copy(src) {
	if (typeof src === 'object' && src !== null) {
		var dst;

		if (isArray(src)) {
			dst = [];
		} else if (isDate(src)) {
			dst = new Date(src.getTime ? src.getTime() : src);
		} else if (isRegExp(src)) {
			dst = new RegExp(src);
		} else if (isError(src)) {
			dst = { message: src.message };
		} else if (isBoolean(src) || isNumber(src) || isString(src)) {
			dst = Object(src);
		} else if (Object.create && Object.getPrototypeOf) {
			dst = Object.create(Object.getPrototypeOf(src));
		} else if (src.constructor === Object) {
			dst = {};
		} else {
			var proto = (src.constructor && src.constructor.prototype)
                || src.__proto__
                || {};
			var T = function T() {}; // eslint-disable-line func-style, func-name-matching
			T.prototype = proto;
			dst = new T();
		}

		forEach(objectKeys(src), function (key) {
			dst[key] = src[key];
		});
		return dst;
	}
	return src;
}

function walk(root, cb, immutable) {
	var path = [];
	var parents = [];
	var alive = true;

	return (function walker(node_) {
		var node = immutable ? copy(node_) : node_;
		var modifiers = {};

		var keepGoing = true;

		var state = {
			node: node,
			node_: node_,
			path: [].concat(path),
			parent: parents[parents.length - 1],
			parents: parents,
			key: path[path.length - 1],
			isRoot: path.length === 0,
			level: path.length,
			circular: null,
			update: function (x, stopHere) {
				if (!state.isRoot) {
					state.parent.node[state.key] = x;
				}
				state.node = x;
				if (stopHere) { keepGoing = false; }
			},
			delete: function (stopHere) {
				delete state.parent.node[state.key];
				if (stopHere) { keepGoing = false; }
			},
			remove: function (stopHere) {
				if (isArray(state.parent.node)) {
					state.parent.node.splice(state.key, 1);
				} else {
					delete state.parent.node[state.key];
				}
				if (stopHere) { keepGoing = false; }
			},
			keys: null,
			before: function (f) { modifiers.before = f; },
			after: function (f) { modifiers.after = f; },
			pre: function (f) { modifiers.pre = f; },
			post: function (f) { modifiers.post = f; },
			stop: function () { alive = false; },
			block: function () { keepGoing = false; },
		};

		if (!alive) { return state; }

		function updateState() {
			if (typeof state.node === 'object' && state.node !== null) {
				if (!state.keys || state.node_ !== state.node) {
					state.keys = objectKeys(state.node);
				}

				state.isLeaf = state.keys.length === 0;

				for (var i = 0; i < parents.length; i++) {
					if (parents[i].node_ === node_) {
						state.circular = parents[i];
						break; // eslint-disable-line no-restricted-syntax
					}
				}
			} else {
				state.isLeaf = true;
				state.keys = null;
			}

			state.notLeaf = !state.isLeaf;
			state.notRoot = !state.isRoot;
		}

		updateState();

		// use return values to update if defined
		var ret = cb.call(state, state.node);
		if (ret !== undefined && state.update) { state.update(ret); }

		if (modifiers.before) { modifiers.before.call(state, state.node); }

		if (!keepGoing) { return state; }

		if (
			typeof state.node === 'object'
			&& state.node !== null
			&& !state.circular
		) {
			parents.push(state);

			updateState();

			forEach(state.keys, function (key, i) {
				path.push(key);

				if (modifiers.pre) { modifiers.pre.call(state, state.node[key], key); }

				var child = walker(state.node[key]);
				if (immutable && hasOwnProperty.call(state.node, key)) {
					state.node[key] = child.node;
				}

				child.isLast = i === state.keys.length - 1;
				child.isFirst = i === 0;

				if (modifiers.post) { modifiers.post.call(state, child); }

				path.pop();
			});
			parents.pop();
		}

		if (modifiers.after) { modifiers.after.call(state, state.node); }

		return state;
	}(root)).node;
}

function Traverse(obj) {
	this.value = obj;
}

Traverse.prototype.get = function (ps) {
	var node = this.value;
	for (var i = 0; i < ps.length; i++) {
		var key = ps[i];
		if (!node || !hasOwnProperty.call(node, key)) {
			return void undefined;
		}
		node = node[key];
	}
	return node;
};

Traverse.prototype.has = function (ps) {
	var node = this.value;
	for (var i = 0; i < ps.length; i++) {
		var key = ps[i];
		if (!node || !hasOwnProperty.call(node, key)) {
			return false;
		}
		node = node[key];
	}
	return true;
};

Traverse.prototype.set = function (ps, value) {
	var node = this.value;
	for (var i = 0; i < ps.length - 1; i++) {
		var key = ps[i];
		if (!hasOwnProperty.call(node, key)) { node[key] = {}; }
		node = node[key];
	}
	node[ps[i]] = value;
	return value;
};

Traverse.prototype.map = function (cb) {
	return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
	this.value = walk(this.value, cb, false);
	return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
	var skip = arguments.length === 1;
	var acc = skip ? this.value : init;
	this.forEach(function (x) {
		if (!this.isRoot || !skip) {
			acc = cb.call(this, acc, x);
		}
	});
	return acc;
};

Traverse.prototype.paths = function () {
	var acc = [];
	this.forEach(function () {
		acc.push(this.path);
	});
	return acc;
};

Traverse.prototype.nodes = function () {
	var acc = [];
	this.forEach(function () {
		acc.push(this.node);
	});
	return acc;
};

Traverse.prototype.clone = function () {
	var parents = [];
	var nodes = [];

	return (function clone(src) {
		for (var i = 0; i < parents.length; i++) {
			if (parents[i] === src) {
				return nodes[i];
			}
		}

		if (typeof src === 'object' && src !== null) {
			var dst = copy(src);

			parents.push(src);
			nodes.push(dst);

			forEach(objectKeys(src), function (key) {
				dst[key] = clone(src[key]);
			});

			parents.pop();
			nodes.pop();
			return dst;
		}

		return src;

	}(this.value));
};

function traverse(obj) {
	return new Traverse(obj);
}

// TODO: replace with object.assign?
forEach(objectKeys(Traverse.prototype), function (key) {
	traverse[key] = function (obj) {
		var args = [].slice.call(arguments, 1);
		var t = new Traverse(obj);
		return t[key].apply(t, args);
	};
});

module.exports = traverse;


/***/ }),

/***/ 9196:
/***/ (function(module) {

"use strict";
module.exports = window["React"];

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "AlignmentControl": function() { return /* reexport */ AlignmentControl; },
  "AlignmentToolbar": function() { return /* reexport */ AlignmentToolbar; },
  "Autocomplete": function() { return /* reexport */ autocomplete; },
  "BlockAlignmentControl": function() { return /* reexport */ BlockAlignmentControl; },
  "BlockAlignmentToolbar": function() { return /* reexport */ BlockAlignmentToolbar; },
  "BlockBreadcrumb": function() { return /* reexport */ block_breadcrumb; },
  "BlockColorsStyleSelector": function() { return /* reexport */ color_style_selector; },
  "BlockContextProvider": function() { return /* reexport */ BlockContextProvider; },
  "BlockControls": function() { return /* reexport */ block_controls; },
  "BlockEdit": function() { return /* reexport */ BlockEdit; },
  "BlockEditorKeyboardShortcuts": function() { return /* reexport */ keyboard_shortcuts; },
  "BlockEditorProvider": function() { return /* reexport */ provider; },
  "BlockFormatControls": function() { return /* reexport */ BlockFormatControls; },
  "BlockIcon": function() { return /* reexport */ block_icon; },
  "BlockInspector": function() { return /* reexport */ block_inspector; },
  "BlockList": function() { return /* reexport */ BlockList; },
  "BlockMover": function() { return /* reexport */ block_mover; },
  "BlockNavigationDropdown": function() { return /* reexport */ dropdown; },
  "BlockPreview": function() { return /* reexport */ block_preview; },
  "BlockSelectionClearer": function() { return /* reexport */ BlockSelectionClearer; },
  "BlockSettingsMenu": function() { return /* reexport */ block_settings_menu; },
  "BlockSettingsMenuControls": function() { return /* reexport */ block_settings_menu_controls; },
  "BlockStyles": function() { return /* reexport */ block_styles; },
  "BlockTitle": function() { return /* reexport */ BlockTitle; },
  "BlockToolbar": function() { return /* reexport */ block_toolbar; },
  "BlockTools": function() { return /* reexport */ BlockTools; },
  "BlockVerticalAlignmentControl": function() { return /* reexport */ BlockVerticalAlignmentControl; },
  "BlockVerticalAlignmentToolbar": function() { return /* reexport */ BlockVerticalAlignmentToolbar; },
  "ButtonBlockAppender": function() { return /* reexport */ button_block_appender; },
  "ButtonBlockerAppender": function() { return /* reexport */ ButtonBlockerAppender; },
  "ColorPalette": function() { return /* reexport */ color_palette; },
  "ColorPaletteControl": function() { return /* reexport */ ColorPaletteControl; },
  "ContrastChecker": function() { return /* reexport */ contrast_checker; },
  "CopyHandler": function() { return /* reexport */ copy_handler; },
  "DefaultBlockAppender": function() { return /* reexport */ default_block_appender; },
  "FontSizePicker": function() { return /* reexport */ font_size_picker; },
  "HeadingLevelDropdown": function() { return /* reexport */ HeadingLevelDropdown; },
  "HeightControl": function() { return /* reexport */ HeightControl; },
  "InnerBlocks": function() { return /* reexport */ inner_blocks; },
  "Inserter": function() { return /* reexport */ inserter; },
  "InspectorAdvancedControls": function() { return /* reexport */ InspectorAdvancedControls; },
  "InspectorControls": function() { return /* reexport */ inspector_controls; },
  "JustifyContentControl": function() { return /* reexport */ JustifyContentControl; },
  "JustifyToolbar": function() { return /* reexport */ JustifyToolbar; },
  "LineHeightControl": function() { return /* reexport */ line_height_control; },
  "MediaPlaceholder": function() { return /* reexport */ media_placeholder; },
  "MediaReplaceFlow": function() { return /* reexport */ media_replace_flow; },
  "MediaUpload": function() { return /* reexport */ media_upload; },
  "MediaUploadCheck": function() { return /* reexport */ check; },
  "MultiSelectScrollIntoView": function() { return /* reexport */ MultiSelectScrollIntoView; },
  "NavigableToolbar": function() { return /* reexport */ navigable_toolbar; },
  "ObserveTyping": function() { return /* reexport */ observe_typing; },
  "PanelColorSettings": function() { return /* reexport */ panel_color_settings; },
  "PlainText": function() { return /* reexport */ plain_text; },
  "RichText": function() { return /* reexport */ rich_text; },
  "RichTextShortcut": function() { return /* reexport */ RichTextShortcut; },
  "RichTextToolbarButton": function() { return /* reexport */ RichTextToolbarButton; },
  "SETTINGS_DEFAULTS": function() { return /* reexport */ SETTINGS_DEFAULTS; },
  "SkipToSelectedBlock": function() { return /* reexport */ skip_to_selected_block; },
  "ToolSelector": function() { return /* reexport */ tool_selector; },
  "Typewriter": function() { return /* reexport */ typewriter; },
  "URLInput": function() { return /* reexport */ url_input; },
  "URLInputButton": function() { return /* reexport */ url_input_button; },
  "URLPopover": function() { return /* reexport */ url_popover; },
  "Warning": function() { return /* reexport */ warning; },
  "WritingFlow": function() { return /* reexport */ writing_flow; },
  "__experimentalBlockAlignmentMatrixControl": function() { return /* reexport */ block_alignment_matrix_control; },
  "__experimentalBlockFullHeightAligmentControl": function() { return /* reexport */ block_full_height_alignment_control; },
  "__experimentalBlockPatternSetup": function() { return /* reexport */ block_pattern_setup; },
  "__experimentalBlockPatternsList": function() { return /* reexport */ block_patterns_list; },
  "__experimentalBlockVariationPicker": function() { return /* reexport */ block_variation_picker; },
  "__experimentalBlockVariationTransforms": function() { return /* reexport */ block_variation_transforms; },
  "__experimentalBorderRadiusControl": function() { return /* reexport */ BorderRadiusControl; },
  "__experimentalColorGradientControl": function() { return /* reexport */ control; },
  "__experimentalColorGradientSettingsDropdown": function() { return /* reexport */ ColorGradientSettingsDropdown; },
  "__experimentalDateFormatPicker": function() { return /* reexport */ DateFormatPicker; },
  "__experimentalDuotoneControl": function() { return /* reexport */ duotone_control; },
  "__experimentalFontAppearanceControl": function() { return /* reexport */ FontAppearanceControl; },
  "__experimentalFontFamilyControl": function() { return /* reexport */ FontFamilyControl; },
  "__experimentalGetBorderClassesAndStyles": function() { return /* reexport */ getBorderClassesAndStyles; },
  "__experimentalGetColorClassesAndStyles": function() { return /* reexport */ getColorClassesAndStyles; },
  "__experimentalGetElementClassName": function() { return /* reexport */ __experimentalGetElementClassName; },
  "__experimentalGetGapCSSValue": function() { return /* reexport */ getGapCSSValue; },
  "__experimentalGetGradientClass": function() { return /* reexport */ __experimentalGetGradientClass; },
  "__experimentalGetGradientObjectByGradientValue": function() { return /* reexport */ __experimentalGetGradientObjectByGradientValue; },
  "__experimentalGetMatchingVariation": function() { return /* reexport */ __experimentalGetMatchingVariation; },
  "__experimentalGetSpacingClassesAndStyles": function() { return /* reexport */ getSpacingClassesAndStyles; },
  "__experimentalImageEditor": function() { return /* reexport */ ImageEditor; },
  "__experimentalImageSizeControl": function() { return /* reexport */ ImageSizeControl; },
  "__experimentalImageURLInputUI": function() { return /* reexport */ ImageURLInputUI; },
  "__experimentalInspectorPopoverHeader": function() { return /* reexport */ InspectorPopoverHeader; },
  "__experimentalLetterSpacingControl": function() { return /* reexport */ LetterSpacingControl; },
  "__experimentalLibrary": function() { return /* reexport */ library; },
  "__experimentalLinkControl": function() { return /* reexport */ link_control; },
  "__experimentalLinkControlSearchInput": function() { return /* reexport */ search_input; },
  "__experimentalLinkControlSearchItem": function() { return /* reexport */ search_item; },
  "__experimentalLinkControlSearchResults": function() { return /* reexport */ LinkControlSearchResults; },
  "__experimentalListView": function() { return /* reexport */ components_list_view; },
  "__experimentalPanelColorGradientSettings": function() { return /* reexport */ panel_color_gradient_settings; },
  "__experimentalPreviewOptions": function() { return /* reexport */ PreviewOptions; },
  "__experimentalPublishDateTimePicker": function() { return /* reexport */ publish_date_time_picker; },
  "__experimentalRecursionProvider": function() { return /* reexport */ RecursionProvider; },
  "__experimentalResponsiveBlockControl": function() { return /* reexport */ responsive_block_control; },
  "__experimentalSpacingSizesControl": function() { return /* reexport */ SpacingSizesControl; },
  "__experimentalTextDecorationControl": function() { return /* reexport */ TextDecorationControl; },
  "__experimentalTextTransformControl": function() { return /* reexport */ TextTransformControl; },
  "__experimentalUnitControl": function() { return /* reexport */ UnitControl; },
  "__experimentalUseBlockOverlayActive": function() { return /* reexport */ useBlockOverlayActive; },
  "__experimentalUseBlockPreview": function() { return /* reexport */ useBlockPreview; },
  "__experimentalUseBorderProps": function() { return /* reexport */ useBorderProps; },
  "__experimentalUseColorProps": function() { return /* reexport */ useColorProps; },
  "__experimentalUseCustomSides": function() { return /* reexport */ useCustomSides; },
  "__experimentalUseGradient": function() { return /* reexport */ __experimentalUseGradient; },
  "__experimentalUseHasRecursion": function() { return /* reexport */ useHasRecursion; },
  "__experimentalUseMultipleOriginColorsAndGradients": function() { return /* reexport */ useMultipleOriginColorsAndGradients; },
  "__experimentalUseResizeCanvas": function() { return /* reexport */ useResizeCanvas; },
  "__unstableBlockNameContext": function() { return /* reexport */ block_name_context; },
  "__unstableBlockSettingsMenuFirstItem": function() { return /* reexport */ block_settings_menu_first_item; },
  "__unstableBlockToolbarLastItem": function() { return /* reexport */ block_toolbar_last_item; },
  "__unstableDuotoneFilter": function() { return /* reexport */ DuotoneFilter; },
  "__unstableDuotoneStylesheet": function() { return /* reexport */ DuotoneStylesheet; },
  "__unstableDuotoneUnsetStylesheet": function() { return /* reexport */ DuotoneUnsetStylesheet; },
  "__unstableEditorStyles": function() { return /* reexport */ EditorStyles; },
  "__unstableGetValuesFromColors": function() { return /* reexport */ getValuesFromColors; },
  "__unstableIframe": function() { return /* reexport */ iframe; },
  "__unstableInserterMenuExtension": function() { return /* reexport */ inserter_menu_extension; },
  "__unstablePresetDuotoneFilter": function() { return /* reexport */ PresetDuotoneFilter; },
  "__unstableRichTextInputEvent": function() { return /* reexport */ __unstableRichTextInputEvent; },
  "__unstableUseBlockSelectionClearer": function() { return /* reexport */ useBlockSelectionClearer; },
  "__unstableUseClipboardHandler": function() { return /* reexport */ useClipboardHandler; },
  "__unstableUseMouseMoveTypingReset": function() { return /* reexport */ useMouseMoveTypingReset; },
  "__unstableUseTypewriter": function() { return /* reexport */ useTypewriter; },
  "__unstableUseTypingObserver": function() { return /* reexport */ useTypingObserver; },
  "createCustomColorsHOC": function() { return /* reexport */ createCustomColorsHOC; },
  "getColorClassName": function() { return /* reexport */ getColorClassName; },
  "getColorObjectByAttributeValues": function() { return /* reexport */ getColorObjectByAttributeValues; },
  "getColorObjectByColorValue": function() { return /* reexport */ getColorObjectByColorValue; },
  "getComputedFluidTypographyValue": function() { return /* reexport */ getComputedFluidTypographyValue; },
  "getCustomValueFromPreset": function() { return /* reexport */ getCustomValueFromPreset; },
  "getFontSize": function() { return /* reexport */ utils_getFontSize; },
  "getFontSizeClass": function() { return /* reexport */ getFontSizeClass; },
  "getFontSizeObjectByValue": function() { return /* reexport */ utils_getFontSizeObjectByValue; },
  "getGradientSlugByValue": function() { return /* reexport */ getGradientSlugByValue; },
  "getGradientValueBySlug": function() { return /* reexport */ getGradientValueBySlug; },
  "getPxFromCssUnit": function() { return /* reexport */ parse_css_unit_to_px; },
  "getSpacingPresetCssVar": function() { return /* reexport */ getSpacingPresetCssVar; },
  "getTypographyClassesAndStyles": function() { return /* reexport */ getTypographyClassesAndStyles; },
  "isValueSpacingPreset": function() { return /* reexport */ isValueSpacingPreset; },
  "privateApis": function() { return /* reexport */ privateApis; },
  "store": function() { return /* reexport */ store; },
  "storeConfig": function() { return /* reexport */ storeConfig; },
  "transformStyles": function() { return /* reexport */ transform_styles; },
  "useBlockDisplayInformation": function() { return /* reexport */ useBlockDisplayInformation; },
  "useBlockEditContext": function() { return /* reexport */ useBlockEditContext; },
  "useBlockProps": function() { return /* reexport */ useBlockProps; },
  "useCachedTruthy": function() { return /* reexport */ useCachedTruthy; },
  "useInnerBlocksProps": function() { return /* reexport */ useInnerBlocksProps; },
  "useSetting": function() { return /* reexport */ use_setting_useSetting; },
  "withColorContext": function() { return /* reexport */ with_color_context; },
  "withColors": function() { return /* reexport */ withColors; },
  "withFontSizes": function() { return /* reexport */ with_font_sizes; }
});

// NAMESPACE OBJECT: ./node_modules/@wordpress/block-editor/build-module/store/private-selectors.js
var private_selectors_namespaceObject = {};
__webpack_require__.r(private_selectors_namespaceObject);
__webpack_require__.d(private_selectors_namespaceObject, {
  "getBlockEditingMode": function() { return getBlockEditingMode; },
  "getBlockRemovalRules": function() { return getBlockRemovalRules; },
  "getEnabledBlockParents": function() { return getEnabledBlockParents; },
  "getEnabledClientIdsTree": function() { return getEnabledClientIdsTree; },
  "getLastInsertedBlocksClientIds": function() { return getLastInsertedBlocksClientIds; },
  "getRemovalPromptData": function() { return getRemovalPromptData; },
  "isBlockInterfaceHidden": function() { return private_selectors_isBlockInterfaceHidden; },
  "isBlockSubtreeDisabled": function() { return isBlockSubtreeDisabled; }
});

// NAMESPACE OBJECT: ./node_modules/@wordpress/block-editor/build-module/store/selectors.js
var selectors_namespaceObject = {};
__webpack_require__.r(selectors_namespaceObject);
__webpack_require__.d(selectors_namespaceObject, {
  "__experimentalGetActiveBlockIdByBlockNames": function() { return __experimentalGetActiveBlockIdByBlockNames; },
  "__experimentalGetAllowedBlocks": function() { return __experimentalGetAllowedBlocks; },
  "__experimentalGetAllowedPatterns": function() { return __experimentalGetAllowedPatterns; },
  "__experimentalGetBlockListSettingsForBlocks": function() { return __experimentalGetBlockListSettingsForBlocks; },
  "__experimentalGetDirectInsertBlock": function() { return __experimentalGetDirectInsertBlock; },
  "__experimentalGetGlobalBlocksByName": function() { return __experimentalGetGlobalBlocksByName; },
  "__experimentalGetLastBlockAttributeChanges": function() { return __experimentalGetLastBlockAttributeChanges; },
  "__experimentalGetParsedPattern": function() { return __experimentalGetParsedPattern; },
  "__experimentalGetPatternTransformItems": function() { return __experimentalGetPatternTransformItems; },
  "__experimentalGetPatternsByBlockTypes": function() { return __experimentalGetPatternsByBlockTypes; },
  "__experimentalGetReusableBlockTitle": function() { return __experimentalGetReusableBlockTitle; },
  "__unstableGetBlockWithoutInnerBlocks": function() { return __unstableGetBlockWithoutInnerBlocks; },
  "__unstableGetClientIdWithClientIdsTree": function() { return __unstableGetClientIdWithClientIdsTree; },
  "__unstableGetClientIdsTree": function() { return __unstableGetClientIdsTree; },
  "__unstableGetContentLockingParent": function() { return __unstableGetContentLockingParent; },
  "__unstableGetEditorMode": function() { return __unstableGetEditorMode; },
  "__unstableGetSelectedBlocksWithPartialSelection": function() { return __unstableGetSelectedBlocksWithPartialSelection; },
  "__unstableGetTemporarilyEditingAsBlocks": function() { return __unstableGetTemporarilyEditingAsBlocks; },
  "__unstableGetVisibleBlocks": function() { return __unstableGetVisibleBlocks; },
  "__unstableHasActiveBlockOverlayActive": function() { return __unstableHasActiveBlockOverlayActive; },
  "__unstableIsFullySelected": function() { return __unstableIsFullySelected; },
  "__unstableIsLastBlockChangeIgnored": function() { return __unstableIsLastBlockChangeIgnored; },
  "__unstableIsSelectionCollapsed": function() { return __unstableIsSelectionCollapsed; },
  "__unstableIsSelectionMergeable": function() { return __unstableIsSelectionMergeable; },
  "__unstableIsWithinBlockOverlay": function() { return __unstableIsWithinBlockOverlay; },
  "__unstableSelectionHasUnmergeableBlock": function() { return __unstableSelectionHasUnmergeableBlock; },
  "areInnerBlocksControlled": function() { return areInnerBlocksControlled; },
  "canEditBlock": function() { return canEditBlock; },
  "canInsertBlockType": function() { return canInsertBlockType; },
  "canInsertBlocks": function() { return canInsertBlocks; },
  "canLockBlockType": function() { return canLockBlockType; },
  "canMoveBlock": function() { return canMoveBlock; },
  "canMoveBlocks": function() { return canMoveBlocks; },
  "canRemoveBlock": function() { return canRemoveBlock; },
  "canRemoveBlocks": function() { return canRemoveBlocks; },
  "didAutomaticChange": function() { return didAutomaticChange; },
  "getAdjacentBlockClientId": function() { return getAdjacentBlockClientId; },
  "getAllowedBlocks": function() { return getAllowedBlocks; },
  "getBehaviors": function() { return getBehaviors; },
  "getBlock": function() { return getBlock; },
  "getBlockAttributes": function() { return getBlockAttributes; },
  "getBlockCount": function() { return getBlockCount; },
  "getBlockHierarchyRootClientId": function() { return getBlockHierarchyRootClientId; },
  "getBlockIndex": function() { return getBlockIndex; },
  "getBlockInsertionPoint": function() { return getBlockInsertionPoint; },
  "getBlockListSettings": function() { return getBlockListSettings; },
  "getBlockMode": function() { return getBlockMode; },
  "getBlockName": function() { return getBlockName; },
  "getBlockNamesByClientId": function() { return getBlockNamesByClientId; },
  "getBlockOrder": function() { return getBlockOrder; },
  "getBlockParents": function() { return getBlockParents; },
  "getBlockParentsByBlockName": function() { return getBlockParentsByBlockName; },
  "getBlockRootClientId": function() { return getBlockRootClientId; },
  "getBlockSelectionEnd": function() { return getBlockSelectionEnd; },
  "getBlockSelectionStart": function() { return getBlockSelectionStart; },
  "getBlockTransformItems": function() { return getBlockTransformItems; },
  "getBlocks": function() { return getBlocks; },
  "getBlocksByClientId": function() { return getBlocksByClientId; },
  "getClientIdsOfDescendants": function() { return getClientIdsOfDescendants; },
  "getClientIdsWithDescendants": function() { return getClientIdsWithDescendants; },
  "getDraggedBlockClientIds": function() { return getDraggedBlockClientIds; },
  "getFirstMultiSelectedBlockClientId": function() { return getFirstMultiSelectedBlockClientId; },
  "getGlobalBlockCount": function() { return getGlobalBlockCount; },
  "getInserterItems": function() { return getInserterItems; },
  "getLastMultiSelectedBlockClientId": function() { return getLastMultiSelectedBlockClientId; },
  "getLowestCommonAncestorWithSelectedBlock": function() { return getLowestCommonAncestorWithSelectedBlock; },
  "getMultiSelectedBlockClientIds": function() { return getMultiSelectedBlockClientIds; },
  "getMultiSelectedBlocks": function() { return getMultiSelectedBlocks; },
  "getMultiSelectedBlocksEndClientId": function() { return getMultiSelectedBlocksEndClientId; },
  "getMultiSelectedBlocksStartClientId": function() { return getMultiSelectedBlocksStartClientId; },
  "getNextBlockClientId": function() { return getNextBlockClientId; },
  "getPatternsByBlockTypes": function() { return getPatternsByBlockTypes; },
  "getPreviousBlockClientId": function() { return getPreviousBlockClientId; },
  "getSelectedBlock": function() { return getSelectedBlock; },
  "getSelectedBlockClientId": function() { return getSelectedBlockClientId; },
  "getSelectedBlockClientIds": function() { return getSelectedBlockClientIds; },
  "getSelectedBlockCount": function() { return getSelectedBlockCount; },
  "getSelectedBlocksInitialCaretPosition": function() { return getSelectedBlocksInitialCaretPosition; },
  "getSelectionEnd": function() { return getSelectionEnd; },
  "getSelectionStart": function() { return getSelectionStart; },
  "getSettings": function() { return getSettings; },
  "getTemplate": function() { return getTemplate; },
  "getTemplateLock": function() { return getTemplateLock; },
  "hasBlockMovingClientId": function() { return selectors_hasBlockMovingClientId; },
  "hasDraggedInnerBlock": function() { return hasDraggedInnerBlock; },
  "hasInserterItems": function() { return hasInserterItems; },
  "hasMultiSelection": function() { return hasMultiSelection; },
  "hasSelectedBlock": function() { return hasSelectedBlock; },
  "hasSelectedInnerBlock": function() { return hasSelectedInnerBlock; },
  "isAncestorBeingDragged": function() { return isAncestorBeingDragged; },
  "isAncestorMultiSelected": function() { return isAncestorMultiSelected; },
  "isBlockBeingDragged": function() { return isBlockBeingDragged; },
  "isBlockHighlighted": function() { return isBlockHighlighted; },
  "isBlockInsertionPointVisible": function() { return isBlockInsertionPointVisible; },
  "isBlockMultiSelected": function() { return isBlockMultiSelected; },
  "isBlockSelected": function() { return isBlockSelected; },
  "isBlockValid": function() { return isBlockValid; },
  "isBlockVisible": function() { return isBlockVisible; },
  "isBlockWithinSelection": function() { return isBlockWithinSelection; },
  "isCaretWithinFormattedText": function() { return isCaretWithinFormattedText; },
  "isDraggingBlocks": function() { return isDraggingBlocks; },
  "isFirstMultiSelectedBlock": function() { return isFirstMultiSelectedBlock; },
  "isLastBlockChangePersistent": function() { return isLastBlockChangePersistent; },
  "isMultiSelecting": function() { return selectors_isMultiSelecting; },
  "isNavigationMode": function() { return isNavigationMode; },
  "isSelectionEnabled": function() { return selectors_isSelectionEnabled; },
  "isTyping": function() { return selectors_isTyping; },
  "isValidTemplate": function() { return isValidTemplate; },
  "wasBlockJustInserted": function() { return wasBlockJustInserted; }
});

// NAMESPACE OBJECT: ./node_modules/@wordpress/block-editor/build-module/store/private-actions.js
var private_actions_namespaceObject = {};
__webpack_require__.r(private_actions_namespaceObject);
__webpack_require__.d(private_actions_namespaceObject, {
  "__experimentalUpdateSettings": function() { return __experimentalUpdateSettings; },
  "clearBlockRemovalPrompt": function() { return clearBlockRemovalPrompt; },
  "ensureDefaultBlock": function() { return ensureDefaultBlock; },
  "hideBlockInterface": function() { return hideBlockInterface; },
  "privateRemoveBlocks": function() { return privateRemoveBlocks; },
  "setBlockEditingMode": function() { return setBlockEditingMode; },
  "setBlockRemovalRules": function() { return setBlockRemovalRules; },
  "showBlockInterface": function() { return showBlockInterface; },
  "unsetBlockEditingMode": function() { return unsetBlockEditingMode; }
});

// NAMESPACE OBJECT: ./node_modules/@wordpress/block-editor/build-module/store/actions.js
var actions_namespaceObject = {};
__webpack_require__.r(actions_namespaceObject);
__webpack_require__.d(actions_namespaceObject, {
  "__unstableDeleteSelection": function() { return __unstableDeleteSelection; },
  "__unstableExpandSelection": function() { return __unstableExpandSelection; },
  "__unstableMarkAutomaticChange": function() { return __unstableMarkAutomaticChange; },
  "__unstableMarkLastChangeAsPersistent": function() { return __unstableMarkLastChangeAsPersistent; },
  "__unstableMarkNextChangeAsNotPersistent": function() { return __unstableMarkNextChangeAsNotPersistent; },
  "__unstableSaveReusableBlock": function() { return __unstableSaveReusableBlock; },
  "__unstableSetEditorMode": function() { return __unstableSetEditorMode; },
  "__unstableSetTemporarilyEditingAsBlocks": function() { return __unstableSetTemporarilyEditingAsBlocks; },
  "__unstableSplitSelection": function() { return __unstableSplitSelection; },
  "clearSelectedBlock": function() { return clearSelectedBlock; },
  "duplicateBlocks": function() { return duplicateBlocks; },
  "enterFormattedText": function() { return enterFormattedText; },
  "exitFormattedText": function() { return exitFormattedText; },
  "flashBlock": function() { return flashBlock; },
  "hideInsertionPoint": function() { return hideInsertionPoint; },
  "insertAfterBlock": function() { return insertAfterBlock; },
  "insertBeforeBlock": function() { return insertBeforeBlock; },
  "insertBlock": function() { return insertBlock; },
  "insertBlocks": function() { return insertBlocks; },
  "insertDefaultBlock": function() { return insertDefaultBlock; },
  "mergeBlocks": function() { return mergeBlocks; },
  "moveBlockToPosition": function() { return moveBlockToPosition; },
  "moveBlocksDown": function() { return moveBlocksDown; },
  "moveBlocksToPosition": function() { return moveBlocksToPosition; },
  "moveBlocksUp": function() { return moveBlocksUp; },
  "multiSelect": function() { return multiSelect; },
  "receiveBlocks": function() { return receiveBlocks; },
  "removeBlock": function() { return removeBlock; },
  "removeBlocks": function() { return removeBlocks; },
  "replaceBlock": function() { return replaceBlock; },
  "replaceBlocks": function() { return replaceBlocks; },
  "replaceInnerBlocks": function() { return replaceInnerBlocks; },
  "resetBlocks": function() { return resetBlocks; },
  "resetSelection": function() { return resetSelection; },
  "selectBlock": function() { return selectBlock; },
  "selectNextBlock": function() { return selectNextBlock; },
  "selectPreviousBlock": function() { return selectPreviousBlock; },
  "selectionChange": function() { return selectionChange; },
  "setBlockMovingClientId": function() { return setBlockMovingClientId; },
  "setBlockVisibility": function() { return setBlockVisibility; },
  "setHasControlledInnerBlocks": function() { return setHasControlledInnerBlocks; },
  "setNavigationMode": function() { return setNavigationMode; },
  "setTemplateValidity": function() { return setTemplateValidity; },
  "showInsertionPoint": function() { return showInsertionPoint; },
  "startDraggingBlocks": function() { return startDraggingBlocks; },
  "startMultiSelect": function() { return startMultiSelect; },
  "startTyping": function() { return startTyping; },
  "stopDraggingBlocks": function() { return stopDraggingBlocks; },
  "stopMultiSelect": function() { return stopMultiSelect; },
  "stopTyping": function() { return stopTyping; },
  "synchronizeTemplate": function() { return synchronizeTemplate; },
  "toggleBlockHighlight": function() { return toggleBlockHighlight; },
  "toggleBlockMode": function() { return toggleBlockMode; },
  "toggleSelection": function() { return toggleSelection; },
  "updateBlock": function() { return updateBlock; },
  "updateBlockAttributes": function() { return updateBlockAttributes; },
  "updateBlockListSettings": function() { return updateBlockListSettings; },
  "updateSettings": function() { return updateSettings; },
  "validateBlocksToTemplate": function() { return validateBlocksToTemplate; }
});

// NAMESPACE OBJECT: ./node_modules/@wordpress/block-editor/build-module/components/global-styles/index.js
var global_styles_namespaceObject = {};
__webpack_require__.r(global_styles_namespaceObject);
__webpack_require__.d(global_styles_namespaceObject, {
  "AdvancedPanel": function() { return AdvancedPanel; },
  "BorderPanel": function() { return BorderPanel; },
  "ColorPanel": function() { return ColorPanel; },
  "DimensionsPanel": function() { return DimensionsPanel; },
  "EffectsPanel": function() { return EffectsPanel; },
  "FiltersPanel": function() { return FiltersPanel; },
  "GlobalStylesContext": function() { return GlobalStylesContext; },
  "TypographyPanel": function() { return TypographyPanel; },
  "areGlobalStyleConfigsEqual": function() { return areGlobalStyleConfigsEqual; },
  "getBlockCSSSelector": function() { return getBlockCSSSelector; },
  "getLayoutStyles": function() { return getLayoutStyles; },
  "useGlobalSetting": function() { return useGlobalSetting; },
  "useGlobalStyle": function() { return useGlobalStyle; },
  "useGlobalStylesOutput": function() { return useGlobalStylesOutput; },
  "useGlobalStylesOutputWithConfig": function() { return useGlobalStylesOutputWithConfig; },
  "useGlobalStylesReset": function() { return useGlobalStylesReset; },
  "useHasBorderPanel": function() { return useHasBorderPanel; },
  "useHasColorPanel": function() { return useHasColorPanel; },
  "useHasDimensionsPanel": function() { return useHasDimensionsPanel; },
  "useHasEffectsPanel": function() { return useHasEffectsPanel; },
  "useHasFiltersPanel": function() { return useHasFiltersPanel; },
  "useHasTypographyPanel": function() { return useHasTypographyPanel; },
  "useSettingsForBlockElement": function() { return useSettingsForBlockElement; }
});

;// CONCATENATED MODULE: external ["wp","blocks"]
var external_wp_blocks_namespaceObject = window["wp"]["blocks"];
;// CONCATENATED MODULE: external ["wp","hooks"]
var external_wp_hooks_namespaceObject = window["wp"]["hooks"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/compat.js
/**
 * WordPress dependencies
 */



function migrateLightBlockWrapper(settings) {
  const {
    apiVersion = 1
  } = settings;

  if (apiVersion < 2 && (0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, 'lightBlockWrapper', false)) {
    settings.apiVersion = 2;
  }

  return settings;
}

(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/compat/migrateLightBlockWrapper', migrateLightBlockWrapper);

;// CONCATENATED MODULE: external ["wp","element"]
var external_wp_element_namespaceObject = window["wp"]["element"];
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(4403);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
;// CONCATENATED MODULE: external ["wp","compose"]
var external_wp_compose_namespaceObject = window["wp"]["compose"];
;// CONCATENATED MODULE: external ["wp","components"]
var external_wp_components_namespaceObject = window["wp"]["components"];
;// CONCATENATED MODULE: external ["wp","data"]
var external_wp_data_namespaceObject = window["wp"]["data"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-controls/groups.js
/**
 * WordPress dependencies
 */

const BlockControlsDefault = (0,external_wp_components_namespaceObject.createSlotFill)('BlockControls');
const BlockControlsBlock = (0,external_wp_components_namespaceObject.createSlotFill)('BlockControlsBlock');
const BlockControlsInline = (0,external_wp_components_namespaceObject.createSlotFill)('BlockFormatControls');
const BlockControlsOther = (0,external_wp_components_namespaceObject.createSlotFill)('BlockControlsOther');
const BlockControlsParent = (0,external_wp_components_namespaceObject.createSlotFill)('BlockControlsParent');
const groups = {
  default: BlockControlsDefault,
  block: BlockControlsBlock,
  inline: BlockControlsInline,
  other: BlockControlsOther,
  parent: BlockControlsParent
};
/* harmony default export */ var block_controls_groups = (groups);

// EXTERNAL MODULE: ./node_modules/fast-deep-equal/es6/index.js
var es6 = __webpack_require__(5619);
var es6_default = /*#__PURE__*/__webpack_require__.n(es6);
;// CONCATENATED MODULE: external ["wp","i18n"]
var external_wp_i18n_namespaceObject = window["wp"]["i18n"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/store/defaults.js
/**
 * WordPress dependencies
 */

const PREFERENCES_DEFAULTS = {
  insertUsage: {}
};
/**
 * The default editor settings
 *
 * @typedef {Object} SETTINGS_DEFAULT
 * @property {boolean}       alignWide                              Enable/Disable Wide/Full Alignments
 * @property {boolean}       supportsLayout                         Enable/disable layouts support in container blocks.
 * @property {boolean}       imageEditing                           Image Editing settings set to false to disable.
 * @property {Array}         imageSizes                             Available image sizes
 * @property {number}        maxWidth                               Max width to constraint resizing
 * @property {boolean|Array} allowedBlockTypes                      Allowed block types
 * @property {boolean}       hasFixedToolbar                        Whether or not the editor toolbar is fixed
 * @property {boolean}       distractionFree                        Whether or not the editor UI is distraction free
 * @property {boolean}       focusMode                              Whether the focus mode is enabled or not
 * @property {Array}         styles                                 Editor Styles
 * @property {boolean}       keepCaretInsideBlock                   Whether caret should move between blocks in edit mode
 * @property {string}        bodyPlaceholder                        Empty post placeholder
 * @property {string}        titlePlaceholder                       Empty title placeholder
 * @property {boolean}       canLockBlocks                          Whether the user can manage Block Lock state
 * @property {boolean}       codeEditingEnabled                     Whether or not the user can switch to the code editor
 * @property {boolean}       generateAnchors                        Enable/Disable auto anchor generation for Heading blocks
 * @property {boolean}       enableOpenverseMediaCategory           Enable/Disable the Openverse media category in the inserter.
 * @property {boolean}       clearBlockSelection                    Whether the block editor should clear selection on mousedown when a block is not clicked.
 * @property {boolean}       __experimentalCanUserUseUnfilteredHTML Whether the user should be able to use unfiltered HTML or the HTML should be filtered e.g., to remove elements considered insecure like iframes.
 * @property {boolean}       __experimentalBlockDirectory           Whether the user has enabled the Block Directory
 * @property {Array}         __experimentalBlockPatterns            Array of objects representing the block patterns
 * @property {Array}         __experimentalBlockPatternCategories   Array of objects representing the block pattern categories
 * @property {boolean}       __unstableGalleryWithImageBlocks       Whether the user has enabled the refactored gallery block which uses InnerBlocks
 */

const SETTINGS_DEFAULTS = {
  alignWide: false,
  supportsLayout: true,
  // colors setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
  // The setting is only kept for backward compatibility purposes.
  colors: [{
    name: (0,external_wp_i18n_namespaceObject.__)('Black'),
    slug: 'black',
    color: '#000000'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Cyan bluish gray'),
    slug: 'cyan-bluish-gray',
    color: '#abb8c3'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('White'),
    slug: 'white',
    color: '#ffffff'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Pale pink'),
    slug: 'pale-pink',
    color: '#f78da7'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Vivid red'),
    slug: 'vivid-red',
    color: '#cf2e2e'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Luminous vivid orange'),
    slug: 'luminous-vivid-orange',
    color: '#ff6900'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Luminous vivid amber'),
    slug: 'luminous-vivid-amber',
    color: '#fcb900'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Light green cyan'),
    slug: 'light-green-cyan',
    color: '#7bdcb5'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Vivid green cyan'),
    slug: 'vivid-green-cyan',
    color: '#00d084'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Pale cyan blue'),
    slug: 'pale-cyan-blue',
    color: '#8ed1fc'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Vivid cyan blue'),
    slug: 'vivid-cyan-blue',
    color: '#0693e3'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Vivid purple'),
    slug: 'vivid-purple',
    color: '#9b51e0'
  }],
  // fontSizes setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
  // The setting is only kept for backward compatibility purposes.
  fontSizes: [{
    name: (0,external_wp_i18n_namespaceObject._x)('Small', 'font size name'),
    size: 13,
    slug: 'small'
  }, {
    name: (0,external_wp_i18n_namespaceObject._x)('Normal', 'font size name'),
    size: 16,
    slug: 'normal'
  }, {
    name: (0,external_wp_i18n_namespaceObject._x)('Medium', 'font size name'),
    size: 20,
    slug: 'medium'
  }, {
    name: (0,external_wp_i18n_namespaceObject._x)('Large', 'font size name'),
    size: 36,
    slug: 'large'
  }, {
    name: (0,external_wp_i18n_namespaceObject._x)('Huge', 'font size name'),
    size: 42,
    slug: 'huge'
  }],
  // Image default size slug.
  imageDefaultSize: 'large',
  imageSizes: [{
    slug: 'thumbnail',
    name: (0,external_wp_i18n_namespaceObject.__)('Thumbnail')
  }, {
    slug: 'medium',
    name: (0,external_wp_i18n_namespaceObject.__)('Medium')
  }, {
    slug: 'large',
    name: (0,external_wp_i18n_namespaceObject.__)('Large')
  }, {
    slug: 'full',
    name: (0,external_wp_i18n_namespaceObject.__)('Full Size')
  }],
  // Allow plugin to disable Image Editor if need be.
  imageEditing: true,
  // This is current max width of the block inner area
  // It's used to constraint image resizing and this value could be overridden later by themes
  maxWidth: 580,
  // Allowed block types for the editor, defaulting to true (all supported).
  allowedBlockTypes: true,
  // Maximum upload size in bytes allowed for the site.
  maxUploadFileSize: 0,
  // List of allowed mime types and file extensions.
  allowedMimeTypes: null,
  // Allows to disable block locking interface.
  canLockBlocks: true,
  // Allows to disable Openverse media category in the inserter.
  enableOpenverseMediaCategory: true,
  clearBlockSelection: true,
  __experimentalCanUserUseUnfilteredHTML: false,
  __experimentalBlockDirectory: false,
  __mobileEnablePageTemplates: false,
  __experimentalBlockPatterns: [],
  __experimentalBlockPatternCategories: [],
  __unstableGalleryWithImageBlocks: false,
  __unstableIsPreviewMode: false,
  // These settings will be completely revamped in the future.
  // The goal is to evolve this into an API which will instruct
  // the block inspector to animate transitions between what it
  // displays based on the relationship between the selected block
  // and its parent, and only enable it if the parent is controlling
  // its children blocks.
  blockInspectorAnimation: {
    animationParent: 'core/navigation',
    'core/navigation': {
      enterDirection: 'leftToRight'
    },
    'core/navigation-submenu': {
      enterDirection: 'rightToLeft'
    },
    'core/navigation-link': {
      enterDirection: 'rightToLeft'
    },
    'core/search': {
      enterDirection: 'rightToLeft'
    },
    'core/social-links': {
      enterDirection: 'rightToLeft'
    },
    'core/page-list': {
      enterDirection: 'rightToLeft'
    },
    'core/spacer': {
      enterDirection: 'rightToLeft'
    },
    'core/home-link': {
      enterDirection: 'rightToLeft'
    },
    'core/site-title': {
      enterDirection: 'rightToLeft'
    },
    'core/site-logo': {
      enterDirection: 'rightToLeft'
    }
  },
  generateAnchors: false,
  // gradients setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
  // The setting is only kept for backward compatibility purposes.
  gradients: [{
    name: (0,external_wp_i18n_namespaceObject.__)('Vivid cyan blue to vivid purple'),
    gradient: 'linear-gradient(135deg,rgba(6,147,227,1) 0%,rgb(155,81,224) 100%)',
    slug: 'vivid-cyan-blue-to-vivid-purple'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Light green cyan to vivid green cyan'),
    gradient: 'linear-gradient(135deg,rgb(122,220,180) 0%,rgb(0,208,130) 100%)',
    slug: 'light-green-cyan-to-vivid-green-cyan'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Luminous vivid amber to luminous vivid orange'),
    gradient: 'linear-gradient(135deg,rgba(252,185,0,1) 0%,rgba(255,105,0,1) 100%)',
    slug: 'luminous-vivid-amber-to-luminous-vivid-orange'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Luminous vivid orange to vivid red'),
    gradient: 'linear-gradient(135deg,rgba(255,105,0,1) 0%,rgb(207,46,46) 100%)',
    slug: 'luminous-vivid-orange-to-vivid-red'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Very light gray to cyan bluish gray'),
    gradient: 'linear-gradient(135deg,rgb(238,238,238) 0%,rgb(169,184,195) 100%)',
    slug: 'very-light-gray-to-cyan-bluish-gray'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Cool to warm spectrum'),
    gradient: 'linear-gradient(135deg,rgb(74,234,220) 0%,rgb(151,120,209) 20%,rgb(207,42,186) 40%,rgb(238,44,130) 60%,rgb(251,105,98) 80%,rgb(254,248,76) 100%)',
    slug: 'cool-to-warm-spectrum'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Blush light purple'),
    gradient: 'linear-gradient(135deg,rgb(255,206,236) 0%,rgb(152,150,240) 100%)',
    slug: 'blush-light-purple'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Blush bordeaux'),
    gradient: 'linear-gradient(135deg,rgb(254,205,165) 0%,rgb(254,45,45) 50%,rgb(107,0,62) 100%)',
    slug: 'blush-bordeaux'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Luminous dusk'),
    gradient: 'linear-gradient(135deg,rgb(255,203,112) 0%,rgb(199,81,192) 50%,rgb(65,88,208) 100%)',
    slug: 'luminous-dusk'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Pale ocean'),
    gradient: 'linear-gradient(135deg,rgb(255,245,203) 0%,rgb(182,227,212) 50%,rgb(51,167,181) 100%)',
    slug: 'pale-ocean'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Electric grass'),
    gradient: 'linear-gradient(135deg,rgb(202,248,128) 0%,rgb(113,206,126) 100%)',
    slug: 'electric-grass'
  }, {
    name: (0,external_wp_i18n_namespaceObject.__)('Midnight'),
    gradient: 'linear-gradient(135deg,rgb(2,3,129) 0%,rgb(40,116,252) 100%)',
    slug: 'midnight'
  }],
  __unstableResolvedAssets: {
    styles: [],
    scripts: []
  }
};

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/store/array.js
/**
 * Insert one or multiple elements into a given position of an array.
 *
 * @param {Array}  array    Source array.
 * @param {*}      elements Elements to insert.
 * @param {number} index    Insert Position.
 *
 * @return {Array} Result.
 */
function insertAt(array, elements, index) {
  return [...array.slice(0, index), ...(Array.isArray(elements) ? elements : [elements]), ...array.slice(index)];
}
/**
 * Moves an element in an array.
 *
 * @param {Array}  array Source array.
 * @param {number} from  Source index.
 * @param {number} to    Destination index.
 * @param {number} count Number of elements to move.
 *
 * @return {Array} Result.
 */

function moveTo(array, from, to, count = 1) {
  const withoutMovedElements = [...array];
  withoutMovedElements.splice(from, count);
  return insertAt(withoutMovedElements, array.slice(from, from + count), to);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/store/reducer.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




const identity = x => x;
/**
 * Given an array of blocks, returns an object where each key is a nesting
 * context, the value of which is an array of block client IDs existing within
 * that nesting context.
 *
 * @param {Array}   blocks       Blocks to map.
 * @param {?string} rootClientId Assumed root client ID.
 *
 * @return {Object} Block order map object.
 */


function mapBlockOrder(blocks, rootClientId = '') {
  const result = new Map();
  const current = [];
  result.set(rootClientId, current);
  blocks.forEach(block => {
    const {
      clientId,
      innerBlocks
    } = block;
    current.push(clientId);
    mapBlockOrder(innerBlocks, clientId).forEach((order, subClientId) => {
      result.set(subClientId, order);
    });
  });
  return result;
}
/**
 * Given an array of blocks, returns an object where each key contains
 * the clientId of the block and the value is the parent of the block.
 *
 * @param {Array}   blocks       Blocks to map.
 * @param {?string} rootClientId Assumed root client ID.
 *
 * @return {Object} Block order map object.
 */


function mapBlockParents(blocks, rootClientId = '') {
  const result = [];
  const stack = [[rootClientId, blocks]];

  while (stack.length) {
    const [parent, currentBlocks] = stack.shift();
    currentBlocks.forEach(({
      innerBlocks,
      ...block
    }) => {
      result.push([block.clientId, parent]);

      if (innerBlocks?.length) {
        stack.push([block.clientId, innerBlocks]);
      }
    });
  }

  return result;
}
/**
 * Helper method to iterate through all blocks, recursing into inner blocks,
 * applying a transformation function to each one.
 * Returns a flattened object with the transformed blocks.
 *
 * @param {Array}    blocks    Blocks to flatten.
 * @param {Function} transform Transforming function to be applied to each block.
 *
 * @return {Array} Flattened object.
 */


function flattenBlocks(blocks, transform = identity) {
  const result = [];
  const stack = [...blocks];

  while (stack.length) {
    const {
      innerBlocks,
      ...block
    } = stack.shift();
    stack.push(...innerBlocks);
    result.push([block.clientId, transform(block)]);
  }

  return result;
}

function getFlattenedClientIds(blocks) {
  const result = {};
  const stack = [...blocks];

  while (stack.length) {
    const {
      innerBlocks,
      ...block
    } = stack.shift();
    stack.push(...innerBlocks);
    result[block.clientId] = true;
  }

  return result;
}
/**
 * Given an array of blocks, returns an object containing all blocks, without
 * attributes, recursing into inner blocks. Keys correspond to the block client
 * ID, the value of which is the attributes object.
 *
 * @param {Array} blocks Blocks to flatten.
 *
 * @return {Array} Flattened block attributes object.
 */


function getFlattenedBlocksWithoutAttributes(blocks) {
  return flattenBlocks(blocks, block => {
    const {
      attributes,
      ...restBlock
    } = block;
    return restBlock;
  });
}
/**
 * Given an array of blocks, returns an object containing all block attributes,
 * recursing into inner blocks. Keys correspond to the block client ID, the
 * value of which is the attributes object.
 *
 * @param {Array} blocks Blocks to flatten.
 *
 * @return {Array} Flattened block attributes object.
 */


function getFlattenedBlockAttributes(blocks) {
  return flattenBlocks(blocks, block => block.attributes);
}
/**
 * Returns true if the two object arguments have the same keys, or false
 * otherwise.
 *
 * @param {Object} a First object.
 * @param {Object} b Second object.
 *
 * @return {boolean} Whether the two objects have the same keys.
 */


function hasSameKeys(a, b) {
  return es6_default()(Object.keys(a), Object.keys(b));
}
/**
 * Returns true if, given the currently dispatching action and the previously
 * dispatched action, the two actions are updating the same block attribute, or
 * false otherwise.
 *
 * @param {Object} action     Currently dispatching action.
 * @param {Object} lastAction Previously dispatched action.
 *
 * @return {boolean} Whether actions are updating the same block attribute.
 */

function isUpdatingSameBlockAttribute(action, lastAction) {
  return action.type === 'UPDATE_BLOCK_ATTRIBUTES' && lastAction !== undefined && lastAction.type === 'UPDATE_BLOCK_ATTRIBUTES' && es6_default()(action.clientIds, lastAction.clientIds) && hasSameKeys(action.attributes, lastAction.attributes);
}

function updateBlockTreeForBlocks(state, blocks) {
  const treeToUpdate = state.tree;
  const stack = [...blocks];
  const flattenedBlocks = [...blocks];

  while (stack.length) {
    const block = stack.shift();
    stack.push(...block.innerBlocks);
    flattenedBlocks.push(...block.innerBlocks);
  } // Create objects before mutating them, that way it's always defined.


  for (const block of flattenedBlocks) {
    treeToUpdate.set(block.clientId, {});
  }

  for (const block of flattenedBlocks) {
    treeToUpdate.set(block.clientId, Object.assign(treeToUpdate.get(block.clientId), { ...state.byClientId.get(block.clientId),
      attributes: state.attributes.get(block.clientId),
      innerBlocks: block.innerBlocks.map(subBlock => treeToUpdate.get(subBlock.clientId))
    }));
  }
}

function updateParentInnerBlocksInTree(state, updatedClientIds, updateChildrenOfUpdatedClientIds = false) {
  const treeToUpdate = state.tree;
  const uncontrolledParents = new Set([]);
  const controlledParents = new Set();

  for (const clientId of updatedClientIds) {
    let current = updateChildrenOfUpdatedClientIds ? clientId : state.parents.get(clientId);

    do {
      if (state.controlledInnerBlocks[current]) {
        // Should stop on controlled blocks.
        // If we reach a controlled parent, break out of the loop.
        controlledParents.add(current);
        break;
      } else {
        // Else continue traversing up through parents.
        uncontrolledParents.add(current);
        current = state.parents.get(current);
      }
    } while (current !== undefined);
  } // To make sure the order of assignments doesn't matter,
  // we first create empty objects and mutates the inner blocks later.


  for (const clientId of uncontrolledParents) {
    treeToUpdate.set(clientId, { ...treeToUpdate.get(clientId)
    });
  }

  for (const clientId of uncontrolledParents) {
    treeToUpdate.get(clientId).innerBlocks = (state.order.get(clientId) || []).map(subClientId => treeToUpdate.get(subClientId));
  } // Controlled parent blocks, need a dedicated key for their inner blocks
  // to be used when doing getBlocks( controlledBlockClientId ).


  for (const clientId of controlledParents) {
    treeToUpdate.set('controlled||' + clientId, {
      innerBlocks: (state.order.get(clientId) || []).map(subClientId => treeToUpdate.get(subClientId))
    });
  }
}
/**
 * Higher-order reducer intended to compute full block objects key for each block in the post.
 * This is a denormalization to optimize the performance of the getBlock selectors and avoid
 * recomputing the block objects and avoid heavy memoization.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withBlockTree = reducer => (state = {}, action) => {
  const newState = reducer(state, action);

  if (newState === state) {
    return state;
  }

  newState.tree = state.tree ? state.tree : new Map();

  switch (action.type) {
    case 'RECEIVE_BLOCKS':
    case 'INSERT_BLOCKS':
      {
        newState.tree = new Map(newState.tree);
        updateBlockTreeForBlocks(newState, action.blocks);
        updateParentInnerBlocksInTree(newState, action.rootClientId ? [action.rootClientId] : [''], true);
        break;
      }

    case 'UPDATE_BLOCK':
      newState.tree = new Map(newState.tree);
      newState.tree.set(action.clientId, { ...newState.tree.get(action.clientId),
        ...newState.byClientId.get(action.clientId),
        attributes: newState.attributes.get(action.clientId)
      });
      updateParentInnerBlocksInTree(newState, [action.clientId], false);
      break;

    case 'UPDATE_BLOCK_ATTRIBUTES':
      {
        newState.tree = new Map(newState.tree);
        action.clientIds.forEach(clientId => {
          newState.tree.set(clientId, { ...newState.tree.get(clientId),
            attributes: newState.attributes.get(clientId)
          });
        });
        updateParentInnerBlocksInTree(newState, action.clientIds, false);
        break;
      }

    case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
      {
        const inserterClientIds = getFlattenedClientIds(action.blocks);
        newState.tree = new Map(newState.tree);
        action.replacedClientIds.concat( // Controlled inner blocks are only removed
        // if the block doesn't move to another position
        // otherwise their content will be lost.
        action.replacedClientIds.filter(clientId => !inserterClientIds[clientId]).map(clientId => 'controlled||' + clientId)).forEach(key => {
          newState.tree.delete(key);
        });
        updateBlockTreeForBlocks(newState, action.blocks);
        updateParentInnerBlocksInTree(newState, action.blocks.map(b => b.clientId), false); // If there are no replaced blocks, it means we're removing blocks so we need to update their parent.

        const parentsOfRemovedBlocks = [];

        for (const clientId of action.clientIds) {
          if (state.parents.get(clientId) !== undefined && (state.parents.get(clientId) === '' || newState.byClientId.get(state.parents.get(clientId)))) {
            parentsOfRemovedBlocks.push(state.parents.get(clientId));
          }
        }

        updateParentInnerBlocksInTree(newState, parentsOfRemovedBlocks, true);
        break;
      }

    case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
      const parentsOfRemovedBlocks = [];

      for (const clientId of action.clientIds) {
        if (state.parents.get(clientId) !== undefined && (state.parents.get(clientId) === '' || newState.byClientId.get(state.parents.get(clientId)))) {
          parentsOfRemovedBlocks.push(state.parents.get(clientId));
        }
      }

      newState.tree = new Map(newState.tree);
      action.removedClientIds.concat(action.removedClientIds.map(clientId => 'controlled||' + clientId)).forEach(key => {
        newState.tree.delete(key);
      });
      updateParentInnerBlocksInTree(newState, parentsOfRemovedBlocks, true);
      break;

    case 'MOVE_BLOCKS_TO_POSITION':
      {
        const updatedBlockUids = [];

        if (action.fromRootClientId) {
          updatedBlockUids.push(action.fromRootClientId);
        } else {
          updatedBlockUids.push('');
        }

        if (action.toRootClientId) {
          updatedBlockUids.push(action.toRootClientId);
        }

        newState.tree = new Map(newState.tree);
        updateParentInnerBlocksInTree(newState, updatedBlockUids, true);
        break;
      }

    case 'MOVE_BLOCKS_UP':
    case 'MOVE_BLOCKS_DOWN':
      {
        const updatedBlockUids = [action.rootClientId ? action.rootClientId : ''];
        newState.tree = new Map(newState.tree);
        updateParentInnerBlocksInTree(newState, updatedBlockUids, true);
        break;
      }

    case 'SAVE_REUSABLE_BLOCK_SUCCESS':
      {
        const updatedBlockUids = [];
        newState.attributes.forEach((attributes, clientId) => {
          if (newState.byClientId.get(clientId).name === 'core/block' && attributes.ref === action.updatedId) {
            updatedBlockUids.push(clientId);
          }
        });
        newState.tree = new Map(newState.tree);
        updatedBlockUids.forEach(clientId => {
          newState.tree.set(clientId, { ...newState.byClientId.get(clientId),
            attributes: newState.attributes.get(clientId),
            innerBlocks: newState.tree.get(clientId).innerBlocks
          });
        });
        updateParentInnerBlocksInTree(newState, updatedBlockUids, false);
      }
  }

  return newState;
};
/**
 * Higher-order reducer intended to augment the blocks reducer, assigning an
 * `isPersistentChange` property value corresponding to whether a change in
 * state can be considered as persistent. All changes are considered persistent
 * except when updating the same block attribute as in the previous action.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


function withPersistentBlockChange(reducer) {
  let lastAction;
  let markNextChangeAsNotPersistent = false;
  return (state, action) => {
    let nextState = reducer(state, action);
    const isExplicitPersistentChange = action.type === 'MARK_LAST_CHANGE_AS_PERSISTENT' || markNextChangeAsNotPersistent; // Defer to previous state value (or default) unless changing or
    // explicitly marking as persistent.

    if (state === nextState && !isExplicitPersistentChange) {
      var _state$isPersistentCh;

      markNextChangeAsNotPersistent = action.type === 'MARK_NEXT_CHANGE_AS_NOT_PERSISTENT';
      const nextIsPersistentChange = (_state$isPersistentCh = state?.isPersistentChange) !== null && _state$isPersistentCh !== void 0 ? _state$isPersistentCh : true;

      if (state.isPersistentChange === nextIsPersistentChange) {
        return state;
      }

      return { ...nextState,
        isPersistentChange: nextIsPersistentChange
      };
    }

    nextState = { ...nextState,
      isPersistentChange: isExplicitPersistentChange ? !markNextChangeAsNotPersistent : !isUpdatingSameBlockAttribute(action, lastAction)
    }; // In comparing against the previous action, consider only those which
    // would have qualified as one which would have been ignored or not
    // have resulted in a changed state.

    lastAction = action;
    markNextChangeAsNotPersistent = action.type === 'MARK_NEXT_CHANGE_AS_NOT_PERSISTENT';
    return nextState;
  };
}
/**
 * Higher-order reducer intended to augment the blocks reducer, assigning an
 * `isIgnoredChange` property value corresponding to whether a change in state
 * can be considered as ignored. A change is considered ignored when the result
 * of an action not incurred by direct user interaction.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


function withIgnoredBlockChange(reducer) {
  /**
   * Set of action types for which a blocks state change should be ignored.
   *
   * @type {Set}
   */
  const IGNORED_ACTION_TYPES = new Set(['RECEIVE_BLOCKS']);
  return (state, action) => {
    const nextState = reducer(state, action);

    if (nextState !== state) {
      nextState.isIgnoredChange = IGNORED_ACTION_TYPES.has(action.type);
    }

    return nextState;
  };
}
/**
 * Higher-order reducer targeting the combined blocks reducer, augmenting
 * block client IDs in remove action to include cascade of inner blocks.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withInnerBlocksRemoveCascade = reducer => (state, action) => {
  // Gets all children which need to be removed.
  const getAllChildren = clientIds => {
    let result = clientIds;

    for (let i = 0; i < result.length; i++) {
      if (!state.order.get(result[i]) || action.keepControlledInnerBlocks && action.keepControlledInnerBlocks[result[i]]) {
        continue;
      }

      if (result === clientIds) {
        result = [...result];
      }

      result.push(...state.order.get(result[i]));
    }

    return result;
  };

  if (state) {
    switch (action.type) {
      case 'REMOVE_BLOCKS':
        action = { ...action,
          type: 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN',
          removedClientIds: getAllChildren(action.clientIds)
        };
        break;

      case 'REPLACE_BLOCKS':
        action = { ...action,
          type: 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN',
          replacedClientIds: getAllChildren(action.clientIds)
        };
        break;
    }
  }

  return reducer(state, action);
};
/**
 * Higher-order reducer which targets the combined blocks reducer and handles
 * the `RESET_BLOCKS` action. When dispatched, this action will replace all
 * blocks that exist in the post, leaving blocks that exist only in state (e.g.
 * reusable blocks and blocks controlled by inner blocks controllers) alone.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withBlockReset = reducer => (state, action) => {
  if (action.type === 'RESET_BLOCKS') {
    const newState = { ...state,
      byClientId: new Map(getFlattenedBlocksWithoutAttributes(action.blocks)),
      attributes: new Map(getFlattenedBlockAttributes(action.blocks)),
      order: mapBlockOrder(action.blocks),
      parents: new Map(mapBlockParents(action.blocks)),
      controlledInnerBlocks: {}
    };
    newState.tree = new Map(state?.tree);
    updateBlockTreeForBlocks(newState, action.blocks);
    newState.tree.set('', {
      innerBlocks: action.blocks.map(subBlock => newState.tree.get(subBlock.clientId))
    });
    return newState;
  }

  return reducer(state, action);
};
/**
 * Higher-order reducer which targets the combined blocks reducer and handles
 * the `REPLACE_INNER_BLOCKS` action. When dispatched, this action the state
 * should become equivalent to the execution of a `REMOVE_BLOCKS` action
 * containing all the child's of the root block followed by the execution of
 * `INSERT_BLOCKS` with the new blocks.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withReplaceInnerBlocks = reducer => (state, action) => {
  if (action.type !== 'REPLACE_INNER_BLOCKS') {
    return reducer(state, action);
  } // Finds every nested inner block controller. We must check the action blocks
  // and not just the block parent state because some inner block controllers
  // should be deleted if specified, whereas others should not be deleted. If
  // a controlled should not be deleted, then we need to avoid deleting its
  // inner blocks from the block state because its inner blocks will not be
  // attached to the block in the action.


  const nestedControllers = {};

  if (Object.keys(state.controlledInnerBlocks).length) {
    const stack = [...action.blocks];

    while (stack.length) {
      const {
        innerBlocks,
        ...block
      } = stack.shift();
      stack.push(...innerBlocks);

      if (!!state.controlledInnerBlocks[block.clientId]) {
        nestedControllers[block.clientId] = true;
      }
    }
  } // The `keepControlledInnerBlocks` prop will keep the inner blocks of the
  // marked block in the block state so that they can be reattached to the
  // marked block when we re-insert everything a few lines below.


  let stateAfterBlocksRemoval = state;

  if (state.order.get(action.rootClientId)) {
    stateAfterBlocksRemoval = reducer(stateAfterBlocksRemoval, {
      type: 'REMOVE_BLOCKS',
      keepControlledInnerBlocks: nestedControllers,
      clientIds: state.order.get(action.rootClientId)
    });
  }

  let stateAfterInsert = stateAfterBlocksRemoval;

  if (action.blocks.length) {
    stateAfterInsert = reducer(stateAfterInsert, { ...action,
      type: 'INSERT_BLOCKS',
      index: 0
    }); // We need to re-attach the controlled inner blocks to the blocks tree and
    // preserve their block order. Otherwise, an inner block controller's blocks
    // will be deleted entirely from its entity.

    const stateAfterInsertOrder = new Map(stateAfterInsert.order);
    Object.keys(nestedControllers).forEach(key => {
      if (state.order.get(key)) {
        stateAfterInsertOrder.set(key, state.order.get(key));
      }
    });
    stateAfterInsert.order = stateAfterInsertOrder;
    stateAfterInsert.tree = new Map(stateAfterInsert.tree);
    Object.keys(nestedControllers).forEach(_key => {
      const key = `controlled||${_key}`;

      if (state.tree.has(key)) {
        stateAfterInsert.tree.set(key, state.tree.get(key));
      }
    });
  }

  return stateAfterInsert;
};
/**
 * Higher-order reducer which targets the combined blocks reducer and handles
 * the `SAVE_REUSABLE_BLOCK_SUCCESS` action. This action can't be handled by
 * regular reducers and needs a higher-order reducer since it needs access to
 * both `byClientId` and `attributes` simultaneously.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withSaveReusableBlock = reducer => (state, action) => {
  if (state && action.type === 'SAVE_REUSABLE_BLOCK_SUCCESS') {
    const {
      id,
      updatedId
    } = action; // If a temporary reusable block is saved, we swap the temporary id with the final one.

    if (id === updatedId) {
      return state;
    }

    state = { ...state
    };
    state.attributes = new Map(state.attributes);
    state.attributes.forEach((attributes, clientId) => {
      const {
        name
      } = state.byClientId.get(clientId);

      if (name === 'core/block' && attributes.ref === id) {
        state.attributes.set(clientId, { ...attributes,
          ref: updatedId
        });
      }
    });
  }

  return reducer(state, action);
};
/**
 * Higher-order reducer which removes blocks from state when switching parent block controlled state.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withResetControlledBlocks = reducer => (state, action) => {
  if (action.type === 'SET_HAS_CONTROLLED_INNER_BLOCKS') {
    // when switching a block from controlled to uncontrolled or inverse,
    // we need to remove its content first.
    const tempState = reducer(state, {
      type: 'REPLACE_INNER_BLOCKS',
      rootClientId: action.clientId,
      blocks: []
    });
    return reducer(tempState, action);
  }

  return reducer(state, action);
};
/**
 * Reducer returning the blocks state.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */


const blocks = (0,external_wp_compose_namespaceObject.pipe)(external_wp_data_namespaceObject.combineReducers, withSaveReusableBlock, // Needs to be before withBlockCache.
withBlockTree, // Needs to be before withInnerBlocksRemoveCascade.
withInnerBlocksRemoveCascade, withReplaceInnerBlocks, // Needs to be after withInnerBlocksRemoveCascade.
withBlockReset, withPersistentBlockChange, withIgnoredBlockChange, withResetControlledBlocks)({
  // The state is using a Map instead of a plain object for performance reasons.
  // You can run the "./test/performance.js" unit test to check the impact
  // code changes can have on this reducer.
  byClientId(state = new Map(), action) {
    switch (action.type) {
      case 'RECEIVE_BLOCKS':
      case 'INSERT_BLOCKS':
        {
          const newState = new Map(state);
          getFlattenedBlocksWithoutAttributes(action.blocks).forEach(([key, value]) => {
            newState.set(key, value);
          });
          return newState;
        }

      case 'UPDATE_BLOCK':
        {
          // Ignore updates if block isn't known.
          if (!state.has(action.clientId)) {
            return state;
          } // Do nothing if only attributes change.


          const {
            attributes,
            ...changes
          } = action.updates;

          if (Object.values(changes).length === 0) {
            return state;
          }

          const newState = new Map(state);
          newState.set(action.clientId, { ...state.get(action.clientId),
            ...changes
          });
          return newState;
        }

      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        {
          if (!action.blocks) {
            return state;
          }

          const newState = new Map(state);
          action.replacedClientIds.forEach(clientId => {
            newState.delete(clientId);
          });
          getFlattenedBlocksWithoutAttributes(action.blocks).forEach(([key, value]) => {
            newState.set(key, value);
          });
          return newState;
        }

      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        {
          const newState = new Map(state);
          action.removedClientIds.forEach(clientId => {
            newState.delete(clientId);
          });
          return newState;
        }
    }

    return state;
  },

  // The state is using a Map instead of a plain object for performance reasons.
  // You can run the "./test/performance.js" unit test to check the impact
  // code changes can have on this reducer.
  attributes(state = new Map(), action) {
    switch (action.type) {
      case 'RECEIVE_BLOCKS':
      case 'INSERT_BLOCKS':
        {
          const newState = new Map(state);
          getFlattenedBlockAttributes(action.blocks).forEach(([key, value]) => {
            newState.set(key, value);
          });
          return newState;
        }

      case 'UPDATE_BLOCK':
        {
          // Ignore updates if block isn't known or there are no attribute changes.
          if (!state.get(action.clientId) || !action.updates.attributes) {
            return state;
          }

          const newState = new Map(state);
          newState.set(action.clientId, { ...state.get(action.clientId),
            ...action.updates.attributes
          });
          return newState;
        }

      case 'UPDATE_BLOCK_ATTRIBUTES':
        {
          // Avoid a state change if none of the block IDs are known.
          if (action.clientIds.every(id => !state.get(id))) {
            return state;
          }

          let hasChange = false;
          const newState = new Map(state);

          for (const clientId of action.clientIds) {
            var _action$attributes;

            const updatedAttributeEntries = Object.entries(action.uniqueByBlock ? action.attributes[clientId] : (_action$attributes = action.attributes) !== null && _action$attributes !== void 0 ? _action$attributes : {});

            if (updatedAttributeEntries.length === 0) {
              continue;
            }

            let hasUpdatedAttributes = false;
            const existingAttributes = state.get(clientId);
            const newAttributes = {};
            updatedAttributeEntries.forEach(([key, value]) => {
              if (existingAttributes[key] !== value) {
                hasUpdatedAttributes = true;
                newAttributes[key] = value;
              }
            });
            hasChange = hasChange || hasUpdatedAttributes;

            if (hasUpdatedAttributes) {
              newState.set(clientId, { ...existingAttributes,
                ...newAttributes
              });
            }
          }

          return hasChange ? newState : state;
        }

      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        {
          if (!action.blocks) {
            return state;
          }

          const newState = new Map(state);
          action.replacedClientIds.forEach(clientId => {
            newState.delete(clientId);
          });
          getFlattenedBlockAttributes(action.blocks).forEach(([key, value]) => {
            newState.set(key, value);
          });
          return newState;
        }

      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        {
          const newState = new Map(state);
          action.removedClientIds.forEach(clientId => {
            newState.delete(clientId);
          });
          return newState;
        }
    }

    return state;
  },

  // The state is using a Map instead of a plain object for performance reasons.
  // You can run the "./test/performance.js" unit test to check the impact
  // code changes can have on this reducer.
  order(state = new Map(), action) {
    switch (action.type) {
      case 'RECEIVE_BLOCKS':
        {
          var _state$get;

          const blockOrder = mapBlockOrder(action.blocks);
          const newState = new Map(state);
          blockOrder.forEach((order, clientId) => {
            if (clientId !== '') {
              newState.set(clientId, order);
            }
          });
          newState.set('', ((_state$get = state.get('')) !== null && _state$get !== void 0 ? _state$get : []).concat(blockOrder['']));
          return newState;
        }

      case 'INSERT_BLOCKS':
        {
          const {
            rootClientId = ''
          } = action;
          const subState = state.get(rootClientId) || [];
          const mappedBlocks = mapBlockOrder(action.blocks, rootClientId);
          const {
            index = subState.length
          } = action;
          const newState = new Map(state);
          mappedBlocks.forEach((order, clientId) => {
            newState.set(clientId, order);
          });
          newState.set(rootClientId, insertAt(subState, mappedBlocks.get(rootClientId), index));
          return newState;
        }

      case 'MOVE_BLOCKS_TO_POSITION':
        {
          var _state$get$filter;

          const {
            fromRootClientId = '',
            toRootClientId = '',
            clientIds
          } = action;
          const {
            index = state.get(toRootClientId).length
          } = action; // Moving inside the same parent block.

          if (fromRootClientId === toRootClientId) {
            const subState = state.get(toRootClientId);
            const fromIndex = subState.indexOf(clientIds[0]);
            const newState = new Map(state);
            newState.set(toRootClientId, moveTo(state.get(toRootClientId), fromIndex, index, clientIds.length));
            return newState;
          } // Moving from a parent block to another.


          const newState = new Map(state);
          newState.set(fromRootClientId, (_state$get$filter = state.get(fromRootClientId)?.filter(id => !clientIds.includes(id))) !== null && _state$get$filter !== void 0 ? _state$get$filter : []);
          newState.set(toRootClientId, insertAt(state.get(toRootClientId), clientIds, index));
          return newState;
        }

      case 'MOVE_BLOCKS_UP':
        {
          const {
            clientIds,
            rootClientId = ''
          } = action;
          const firstClientId = clientIds[0];
          const subState = state.get(rootClientId);

          if (!subState.length || firstClientId === subState[0]) {
            return state;
          }

          const firstIndex = subState.indexOf(firstClientId);
          const newState = new Map(state);
          newState.set(rootClientId, moveTo(subState, firstIndex, firstIndex - 1, clientIds.length));
          return newState;
        }

      case 'MOVE_BLOCKS_DOWN':
        {
          const {
            clientIds,
            rootClientId = ''
          } = action;
          const firstClientId = clientIds[0];
          const lastClientId = clientIds[clientIds.length - 1];
          const subState = state.get(rootClientId);

          if (!subState.length || lastClientId === subState[subState.length - 1]) {
            return state;
          }

          const firstIndex = subState.indexOf(firstClientId);
          const newState = new Map(state);
          newState.set(rootClientId, moveTo(subState, firstIndex, firstIndex + 1, clientIds.length));
          return newState;
        }

      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        {
          const {
            clientIds
          } = action;

          if (!action.blocks) {
            return state;
          }

          const mappedBlocks = mapBlockOrder(action.blocks);
          const newState = new Map(state);
          action.replacedClientIds.forEach(clientId => {
            newState.delete(clientId);
          });
          mappedBlocks.forEach((order, clientId) => {
            if (clientId !== '') {
              newState.set(clientId, order);
            }
          });
          newState.forEach((order, clientId) => {
            const newSubOrder = Object.values(order).reduce((result, subClientId) => {
              if (subClientId === clientIds[0]) {
                return [...result, ...mappedBlocks.get('')];
              }

              if (clientIds.indexOf(subClientId) === -1) {
                result.push(subClientId);
              }

              return result;
            }, []);
            newState.set(clientId, newSubOrder);
          });
          return newState;
        }

      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        {
          const newState = new Map(state); // Remove inner block ordering for removed blocks.

          action.removedClientIds.forEach(clientId => {
            newState.delete(clientId);
          });
          newState.forEach((order, clientId) => {
            var _order$filter;

            const newSubOrder = (_order$filter = order?.filter(id => !action.removedClientIds.includes(id))) !== null && _order$filter !== void 0 ? _order$filter : [];

            if (newSubOrder.length !== order.length) {
              newState.set(clientId, newSubOrder);
            }
          });
          return newState;
        }
    }

    return state;
  },

  // While technically redundant data as the inverse of `order`, it serves as
  // an optimization for the selectors which derive the ancestry of a block.
  parents(state = new Map(), action) {
    switch (action.type) {
      case 'RECEIVE_BLOCKS':
        {
          const newState = new Map(state);
          mapBlockParents(action.blocks).forEach(([key, value]) => {
            newState.set(key, value);
          });
          return newState;
        }

      case 'INSERT_BLOCKS':
        {
          const newState = new Map(state);
          mapBlockParents(action.blocks, action.rootClientId || '').forEach(([key, value]) => {
            newState.set(key, value);
          });
          return newState;
        }

      case 'MOVE_BLOCKS_TO_POSITION':
        {
          const newState = new Map(state);
          action.clientIds.forEach(id => {
            newState.set(id, action.toRootClientId || '');
          });
          return newState;
        }

      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        {
          const newState = new Map(state);
          action.replacedClientIds.forEach(clientId => {
            newState.delete(clientId);
          });
          mapBlockParents(action.blocks, state.get(action.clientIds[0])).forEach(([key, value]) => {
            newState.set(key, value);
          });
          return newState;
        }

      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        {
          const newState = new Map(state);
          action.removedClientIds.forEach(clientId => {
            newState.delete(clientId);
          });
          return newState;
        }
    }

    return state;
  },

  controlledInnerBlocks(state = {}, {
    type,
    clientId,
    hasControlledInnerBlocks
  }) {
    if (type === 'SET_HAS_CONTROLLED_INNER_BLOCKS') {
      return { ...state,
        [clientId]: hasControlledInnerBlocks
      };
    }

    return state;
  }

});
/**
 * Reducer returning visibility status of block interface.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */

function isBlockInterfaceHidden(state = false, action) {
  switch (action.type) {
    case 'HIDE_BLOCK_INTERFACE':
      return true;

    case 'SHOW_BLOCK_INTERFACE':
      return false;
  }

  return state;
}
/**
 * Reducer returning typing state.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */

function isTyping(state = false, action) {
  switch (action.type) {
    case 'START_TYPING':
      return true;

    case 'STOP_TYPING':
      return false;
  }

  return state;
}
/**
 * Reducer returning dragged block client id.
 *
 * @param {string[]} state  Current state.
 * @param {Object}   action Dispatched action.
 *
 * @return {string[]} Updated state.
 */

function draggedBlocks(state = [], action) {
  switch (action.type) {
    case 'START_DRAGGING_BLOCKS':
      return action.clientIds;

    case 'STOP_DRAGGING_BLOCKS':
      return [];
  }

  return state;
}
/**
 * Reducer tracking the visible blocks.
 *
 * @param {Record<string,boolean>} state  Current state.
 * @param {Object}                 action Dispatched action.
 *
 * @return {Record<string,boolean>} Block visibility.
 */

function blockVisibility(state = {}, action) {
  if (action.type === 'SET_BLOCK_VISIBILITY') {
    return { ...state,
      ...action.updates
    };
  }

  return state;
}
/**
 * Internal helper reducer for selectionStart and selectionEnd. Can hold a block
 * selection, represented by an object with property clientId.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function selectionHelper(state = {}, action) {
  switch (action.type) {
    case 'CLEAR_SELECTED_BLOCK':
      {
        if (state.clientId) {
          return {};
        }

        return state;
      }

    case 'SELECT_BLOCK':
      if (action.clientId === state.clientId) {
        return state;
      }

      return {
        clientId: action.clientId
      };

    case 'REPLACE_INNER_BLOCKS':
    case 'INSERT_BLOCKS':
      {
        if (!action.updateSelection || !action.blocks.length) {
          return state;
        }

        return {
          clientId: action.blocks[0].clientId
        };
      }

    case 'REMOVE_BLOCKS':
      if (!action.clientIds || !action.clientIds.length || action.clientIds.indexOf(state.clientId) === -1) {
        return state;
      }

      return {};

    case 'REPLACE_BLOCKS':
      {
        if (action.clientIds.indexOf(state.clientId) === -1) {
          return state;
        }

        const blockToSelect = action.blocks[action.indexToSelect] || action.blocks[action.blocks.length - 1];

        if (!blockToSelect) {
          return {};
        }

        if (blockToSelect.clientId === state.clientId) {
          return state;
        }

        return {
          clientId: blockToSelect.clientId
        };
      }
  }

  return state;
}
/**
 * Reducer returning the selection state.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */


function selection(state = {}, action) {
  switch (action.type) {
    case 'SELECTION_CHANGE':
      if (action.clientId) {
        return {
          selectionStart: {
            clientId: action.clientId,
            attributeKey: action.attributeKey,
            offset: action.startOffset
          },
          selectionEnd: {
            clientId: action.clientId,
            attributeKey: action.attributeKey,
            offset: action.endOffset
          }
        };
      }

      return {
        selectionStart: action.start || state.selectionStart,
        selectionEnd: action.end || state.selectionEnd
      };

    case 'RESET_SELECTION':
      const {
        selectionStart,
        selectionEnd
      } = action;
      return {
        selectionStart,
        selectionEnd
      };

    case 'MULTI_SELECT':
      const {
        start,
        end
      } = action;

      if (start === state.selectionStart?.clientId && end === state.selectionEnd?.clientId) {
        return state;
      }

      return {
        selectionStart: {
          clientId: start
        },
        selectionEnd: {
          clientId: end
        }
      };

    case 'RESET_BLOCKS':
      const startClientId = state?.selectionStart?.clientId;
      const endClientId = state?.selectionEnd?.clientId; // Do nothing if there's no selected block.

      if (!startClientId && !endClientId) {
        return state;
      } // If the start of the selection won't exist after reset, remove selection.


      if (!action.blocks.some(block => block.clientId === startClientId)) {
        return {
          selectionStart: {},
          selectionEnd: {}
        };
      } // If the end of the selection won't exist after reset, collapse selection.


      if (!action.blocks.some(block => block.clientId === endClientId)) {
        return { ...state,
          selectionEnd: state.selectionStart
        };
      }

  }

  const selectionStart = selectionHelper(state.selectionStart, action);
  const selectionEnd = selectionHelper(state.selectionEnd, action);

  if (selectionStart === state.selectionStart && selectionEnd === state.selectionEnd) {
    return state;
  }

  return {
    selectionStart,
    selectionEnd
  };
}
/**
 * Reducer returning whether the user is multi-selecting.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */

function isMultiSelecting(state = false, action) {
  switch (action.type) {
    case 'START_MULTI_SELECT':
      return true;

    case 'STOP_MULTI_SELECT':
      return false;
  }

  return state;
}
/**
 * Reducer returning whether selection is enabled.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */

function isSelectionEnabled(state = true, action) {
  switch (action.type) {
    case 'TOGGLE_SELECTION':
      return action.isSelectionEnabled;
  }

  return state;
}
/**
 * Reducer returning the data needed to display a prompt when certain blocks
 * are removed, or `false` if no such prompt is requested.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {Object|false} Data for removal prompt display, if any.
 */

function removalPromptData(state = false, action) {
  switch (action.type) {
    case 'DISPLAY_BLOCK_REMOVAL_PROMPT':
      const {
        clientIds,
        selectPrevious,
        blockNamesForPrompt
      } = action;
      return {
        clientIds,
        selectPrevious,
        blockNamesForPrompt
      };

    case 'CLEAR_BLOCK_REMOVAL_PROMPT':
      return false;
  }

  return state;
}
/**
 * Reducer returning any rules that a block editor may provide in order to
 * prevent a user from accidentally removing certain blocks. These rules are
 * then used to display a confirmation prompt to the user. For instance, in the
 * Site Editor, the Query Loop block is important enough to warrant such
 * confirmation.
 *
 * The data is a record whose keys are block types (e.g. 'core/query') and
 * whose values are the explanation to be shown to users (e.g. 'Query Loop
 * displays a list of posts or pages.').
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {Record<string,string>} Updated state.
 */


function blockRemovalRules(state = false, action) {
  switch (action.type) {
    case 'SET_BLOCK_REMOVAL_RULES':
      return action.rules;
  }

  return state;
}
/**
 * Reducer returning the initial block selection.
 *
 * Currently this in only used to restore the selection after block deletion and
 * pasting new content.This reducer should eventually be removed in favour of setting
 * selection directly.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {number|null} Initial position: 0, -1 or null.
 */


function initialPosition(state = null, action) {
  if (action.type === 'REPLACE_BLOCKS' && action.initialPosition !== undefined) {
    return action.initialPosition;
  } else if (['MULTI_SELECT', 'SELECT_BLOCK', 'RESET_SELECTION', 'INSERT_BLOCKS', 'REPLACE_INNER_BLOCKS'].includes(action.type)) {
    return action.initialPosition;
  }

  return state;
}
function blocksMode(state = {}, action) {
  if (action.type === 'TOGGLE_BLOCK_MODE') {
    const {
      clientId
    } = action;
    return { ...state,
      [clientId]: state[clientId] && state[clientId] === 'html' ? 'visual' : 'html'
    };
  }

  return state;
}
/**
 * Reducer returning the block insertion point visibility, either null if there
 * is not an explicit insertion point assigned, or an object of its `index` and
 * `rootClientId`.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function insertionPoint(state = null, action) {
  switch (action.type) {
    case 'SHOW_INSERTION_POINT':
      {
        const {
          rootClientId,
          index,
          __unstableWithInserter,
          operation
        } = action;
        const nextState = {
          rootClientId,
          index,
          __unstableWithInserter,
          operation
        }; // Bail out updates if the states are the same.

        return es6_default()(state, nextState) ? state : nextState;
      }

    case 'HIDE_INSERTION_POINT':
      return null;
  }

  return state;
}
/**
 * Reducer returning whether the post blocks match the defined template or not.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {boolean} Updated state.
 */

function template(state = {
  isValid: true
}, action) {
  switch (action.type) {
    case 'SET_TEMPLATE_VALIDITY':
      return { ...state,
        isValid: action.isValid
      };
  }

  return state;
}
/**
 * Reducer returning the editor setting.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function settings(state = SETTINGS_DEFAULTS, action) {
  switch (action.type) {
    case 'UPDATE_SETTINGS':
      return { ...state,
        ...action.settings
      };
  }

  return state;
}
/**
 * Reducer returning the user preferences.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {string} Updated state.
 */

function preferences(state = PREFERENCES_DEFAULTS, action) {
  switch (action.type) {
    case 'INSERT_BLOCKS':
    case 'REPLACE_BLOCKS':
      return action.blocks.reduce((prevState, block) => {
        const {
          attributes,
          name: blockName
        } = block;
        let id = blockName; // If a block variation match is found change the name to be the same with the
        // one that is used for block variations in the Inserter (`getItemFromVariation`).

        const match = (0,external_wp_data_namespaceObject.select)(external_wp_blocks_namespaceObject.store).getActiveBlockVariation(blockName, attributes);

        if (match?.name) {
          id += '/' + match.name;
        }

        if (blockName === 'core/block') {
          id += '/' + attributes.ref;
        }

        return { ...prevState,
          insertUsage: { ...prevState.insertUsage,
            [id]: {
              time: action.time,
              count: prevState.insertUsage[id] ? prevState.insertUsage[id].count + 1 : 1
            }
          }
        };
      }, state);
  }

  return state;
}
/**
 * Reducer returning an object where each key is a block client ID, its value
 * representing the settings for its nested blocks.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

const blockListSettings = (state = {}, action) => {
  switch (action.type) {
    // Even if the replaced blocks have the same client ID, our logic
    // should correct the state.
    case 'REPLACE_BLOCKS':
    case 'REMOVE_BLOCKS':
      {
        return Object.fromEntries(Object.entries(state).filter(([id]) => !action.clientIds.includes(id)));
      }

    case 'UPDATE_BLOCK_LIST_SETTINGS':
      {
        const {
          clientId
        } = action;

        if (!action.settings) {
          if (state.hasOwnProperty(clientId)) {
            const {
              [clientId]: removedBlock,
              ...restBlocks
            } = state;
            return restBlocks;
          }

          return state;
        }

        if (es6_default()(state[clientId], action.settings)) {
          return state;
        }

        return { ...state,
          [clientId]: action.settings
        };
      }
  }

  return state;
};
/**
 * Reducer returning which mode is enabled.
 *
 * @param {string} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {string} Updated state.
 */

function editorMode(state = 'edit', action) {
  // Let inserting block in navigation mode always trigger Edit mode.
  if (action.type === 'INSERT_BLOCKS' && state === 'navigation') {
    return 'edit';
  }

  if (action.type === 'SET_EDITOR_MODE') {
    return action.mode;
  }

  return state;
}
/**
 * Reducer returning whether the block moving mode is enabled or not.
 *
 * @param {string|null} state  Current state.
 * @param {Object}      action Dispatched action.
 *
 * @return {string|null} Updated state.
 */

function hasBlockMovingClientId(state = null, action) {
  if (action.type === 'SET_BLOCK_MOVING_MODE') {
    return action.hasBlockMovingClientId;
  }

  if (action.type === 'SET_EDITOR_MODE') {
    return null;
  }

  return state;
}
/**
 * Reducer return an updated state representing the most recent block attribute
 * update. The state is structured as an object where the keys represent the
 * client IDs of blocks, the values a subset of attributes from the most recent
 * block update. The state is always reset to null if the last action is
 * anything other than an attributes update.
 *
 * @param {Object<string,Object>} state  Current state.
 * @param {Object}                action Action object.
 *
 * @return {[string,Object]} Updated state.
 */

function lastBlockAttributesChange(state = null, action) {
  switch (action.type) {
    case 'UPDATE_BLOCK':
      if (!action.updates.attributes) {
        break;
      }

      return {
        [action.clientId]: action.updates.attributes
      };

    case 'UPDATE_BLOCK_ATTRIBUTES':
      return action.clientIds.reduce((accumulator, id) => ({ ...accumulator,
        [id]: action.uniqueByBlock ? action.attributes[id] : action.attributes
      }), {});
  }

  return state;
}
/**
 * Reducer returning current highlighted block.
 *
 * @param {boolean} state  Current highlighted block.
 * @param {Object}  action Dispatched action.
 *
 * @return {string} Updated state.
 */

function highlightedBlock(state, action) {
  switch (action.type) {
    case 'TOGGLE_BLOCK_HIGHLIGHT':
      const {
        clientId,
        isHighlighted
      } = action;

      if (isHighlighted) {
        return clientId;
      } else if (state === clientId) {
        return null;
      }

      return state;

    case 'SELECT_BLOCK':
      if (action.clientId !== state) {
        return null;
      }

  }

  return state;
}
/**
 * Reducer returning the block insertion event list state.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function lastBlockInserted(state = {}, action) {
  switch (action.type) {
    case 'INSERT_BLOCKS':
    case 'REPLACE_BLOCKS':
    case 'REPLACE_INNER_BLOCKS':
      if (!action.blocks.length) {
        return state;
      }

      const clientIds = action.blocks.map(block => {
        return block.clientId;
      });
      const source = action.meta?.source;
      return {
        clientIds,
        source
      };

    case 'RESET_BLOCKS':
      return {};
  }

  return state;
}
/**
 * Reducer returning the block that is eding temporarily edited as blocks.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function temporarilyEditingAsBlocks(state = '', action) {
  if (action.type === 'SET_TEMPORARILY_EDITING_AS_BLOCKS') {
    return action.temporarilyEditingAsBlocks;
  }

  return state;
}
/**
 * Reducer returning a map of block client IDs to block editing modes.
 *
 * @param {Map}    state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Map} Updated state.
 */

function blockEditingModes(state = new Map(), action) {
  switch (action.type) {
    case 'SET_BLOCK_EDITING_MODE':
      return new Map(state).set(action.clientId, action.mode);

    case 'UNSET_BLOCK_EDITING_MODE':
      {
        const newState = new Map(state);
        newState.delete(action.clientId);
        return newState;
      }

    case 'RESET_BLOCKS':
      {
        return state.has('') ? new Map().set('', state.get('')) : state;
      }
  }

  return state;
}
const combinedReducers = (0,external_wp_data_namespaceObject.combineReducers)({
  blocks,
  isTyping,
  isBlockInterfaceHidden,
  draggedBlocks,
  selection,
  isMultiSelecting,
  isSelectionEnabled,
  initialPosition,
  blocksMode,
  blockListSettings,
  insertionPoint,
  template,
  settings,
  preferences,
  lastBlockAttributesChange,
  editorMode,
  hasBlockMovingClientId,
  highlightedBlock,
  lastBlockInserted,
  temporarilyEditingAsBlocks,
  blockVisibility,
  blockEditingModes,
  removalPromptData,
  blockRemovalRules
});

function withAutomaticChangeReset(reducer) {
  return (state, action) => {
    const nextState = reducer(state, action);

    if (!state) {
      return nextState;
    } // Take over the last value without creating a new reference.


    nextState.automaticChangeStatus = state.automaticChangeStatus;

    if (action.type === 'MARK_AUTOMATIC_CHANGE') {
      return { ...nextState,
        automaticChangeStatus: 'pending'
      };
    }

    if (action.type === 'MARK_AUTOMATIC_CHANGE_FINAL' && state.automaticChangeStatus === 'pending') {
      return { ...nextState,
        automaticChangeStatus: 'final'
      };
    } // If there's a change that doesn't affect blocks or selection, maintain
    // the current status.


    if (nextState.blocks === state.blocks && nextState.selection === state.selection) {
      return nextState;
    } // As long as the state is not final, ignore any selection changes.


    if (nextState.automaticChangeStatus !== 'final' && nextState.selection !== state.selection) {
      return nextState;
    } // Reset the status if blocks change or selection changes (when status is final).


    return { ...nextState,
      automaticChangeStatus: undefined
    };
  };
}

/* harmony default export */ var reducer = (withAutomaticChangeReset(combinedReducers));

;// CONCATENATED MODULE: ./node_modules/rememo/rememo.js


/** @typedef {(...args: any[]) => *[]} GetDependants */

/** @typedef {() => void} Clear */

/**
 * @typedef {{
 *   getDependants: GetDependants,
 *   clear: Clear
 * }} EnhancedSelector
 */

/**
 * Internal cache entry.
 *
 * @typedef CacheNode
 *
 * @property {?CacheNode|undefined} [prev] Previous node.
 * @property {?CacheNode|undefined} [next] Next node.
 * @property {*[]} args Function arguments for cache entry.
 * @property {*} val Function result.
 */

/**
 * @typedef Cache
 *
 * @property {Clear} clear Function to clear cache.
 * @property {boolean} [isUniqueByDependants] Whether dependants are valid in
 * considering cache uniqueness. A cache is unique if dependents are all arrays
 * or objects.
 * @property {CacheNode?} [head] Cache head.
 * @property {*[]} [lastDependants] Dependants from previous invocation.
 */

/**
 * Arbitrary value used as key for referencing cache object in WeakMap tree.
 *
 * @type {{}}
 */
var LEAF_KEY = {};

/**
 * Returns the first argument as the sole entry in an array.
 *
 * @template T
 *
 * @param {T} value Value to return.
 *
 * @return {[T]} Value returned as entry in array.
 */
function arrayOf(value) {
	return [value];
}

/**
 * Returns true if the value passed is object-like, or false otherwise. A value
 * is object-like if it can support property assignment, e.g. object or array.
 *
 * @param {*} value Value to test.
 *
 * @return {boolean} Whether value is object-like.
 */
function isObjectLike(value) {
	return !!value && 'object' === typeof value;
}

/**
 * Creates and returns a new cache object.
 *
 * @return {Cache} Cache object.
 */
function createCache() {
	/** @type {Cache} */
	var cache = {
		clear: function () {
			cache.head = null;
		},
	};

	return cache;
}

/**
 * Returns true if entries within the two arrays are strictly equal by
 * reference from a starting index.
 *
 * @param {*[]} a First array.
 * @param {*[]} b Second array.
 * @param {number} fromIndex Index from which to start comparison.
 *
 * @return {boolean} Whether arrays are shallowly equal.
 */
function isShallowEqual(a, b, fromIndex) {
	var i;

	if (a.length !== b.length) {
		return false;
	}

	for (i = fromIndex; i < a.length; i++) {
		if (a[i] !== b[i]) {
			return false;
		}
	}

	return true;
}

/**
 * Returns a memoized selector function. The getDependants function argument is
 * called before the memoized selector and is expected to return an immutable
 * reference or array of references on which the selector depends for computing
 * its own return value. The memoize cache is preserved only as long as those
 * dependant references remain the same. If getDependants returns a different
 * reference(s), the cache is cleared and the selector value regenerated.
 *
 * @template {(...args: *[]) => *} S
 *
 * @param {S} selector Selector function.
 * @param {GetDependants=} getDependants Dependant getter returning an array of
 * references used in cache bust consideration.
 */
/* harmony default export */ function rememo(selector, getDependants) {
	/** @type {WeakMap<*,*>} */
	var rootCache;

	/** @type {GetDependants} */
	var normalizedGetDependants = getDependants ? getDependants : arrayOf;

	/**
	 * Returns the cache for a given dependants array. When possible, a WeakMap
	 * will be used to create a unique cache for each set of dependants. This
	 * is feasible due to the nature of WeakMap in allowing garbage collection
	 * to occur on entries where the key object is no longer referenced. Since
	 * WeakMap requires the key to be an object, this is only possible when the
	 * dependant is object-like. The root cache is created as a hierarchy where
	 * each top-level key is the first entry in a dependants set, the value a
	 * WeakMap where each key is the next dependant, and so on. This continues
	 * so long as the dependants are object-like. If no dependants are object-
	 * like, then the cache is shared across all invocations.
	 *
	 * @see isObjectLike
	 *
	 * @param {*[]} dependants Selector dependants.
	 *
	 * @return {Cache} Cache object.
	 */
	function getCache(dependants) {
		var caches = rootCache,
			isUniqueByDependants = true,
			i,
			dependant,
			map,
			cache;

		for (i = 0; i < dependants.length; i++) {
			dependant = dependants[i];

			// Can only compose WeakMap from object-like key.
			if (!isObjectLike(dependant)) {
				isUniqueByDependants = false;
				break;
			}

			// Does current segment of cache already have a WeakMap?
			if (caches.has(dependant)) {
				// Traverse into nested WeakMap.
				caches = caches.get(dependant);
			} else {
				// Create, set, and traverse into a new one.
				map = new WeakMap();
				caches.set(dependant, map);
				caches = map;
			}
		}

		// We use an arbitrary (but consistent) object as key for the last item
		// in the WeakMap to serve as our running cache.
		if (!caches.has(LEAF_KEY)) {
			cache = createCache();
			cache.isUniqueByDependants = isUniqueByDependants;
			caches.set(LEAF_KEY, cache);
		}

		return caches.get(LEAF_KEY);
	}

	/**
	 * Resets root memoization cache.
	 */
	function clear() {
		rootCache = new WeakMap();
	}

	/* eslint-disable jsdoc/check-param-names */
	/**
	 * The augmented selector call, considering first whether dependants have
	 * changed before passing it to underlying memoize function.
	 *
	 * @param {*}    source    Source object for derivation.
	 * @param {...*} extraArgs Additional arguments to pass to selector.
	 *
	 * @return {*} Selector result.
	 */
	/* eslint-enable jsdoc/check-param-names */
	function callSelector(/* source, ...extraArgs */) {
		var len = arguments.length,
			cache,
			node,
			i,
			args,
			dependants;

		// Create copy of arguments (avoid leaking deoptimization).
		args = new Array(len);
		for (i = 0; i < len; i++) {
			args[i] = arguments[i];
		}

		dependants = normalizedGetDependants.apply(null, args);
		cache = getCache(dependants);

		// If not guaranteed uniqueness by dependants (primitive type), shallow
		// compare against last dependants and, if references have changed,
		// destroy cache to recalculate result.
		if (!cache.isUniqueByDependants) {
			if (
				cache.lastDependants &&
				!isShallowEqual(dependants, cache.lastDependants, 0)
			) {
				cache.clear();
			}

			cache.lastDependants = dependants;
		}

		node = cache.head;
		while (node) {
			// Check whether node arguments match arguments
			if (!isShallowEqual(node.args, args, 1)) {
				node = node.next;
				continue;
			}

			// At this point we can assume we've found a match

			// Surface matched node to head if not already
			if (node !== cache.head) {
				// Adjust siblings to point to each other.
				/** @type {CacheNode} */ (node.prev).next = node.next;
				if (node.next) {
					node.next.prev = node.prev;
				}

				node.next = cache.head;
				node.prev = null;
				/** @type {CacheNode} */ (cache.head).prev = node;
				cache.head = node;
			}

			// Return immediately
			return node.val;
		}

		// No cached value found. Continue to insertion phase:

		node = /** @type {CacheNode} */ ({
			// Generate the result from original function
			val: selector.apply(null, args),
		});

		// Avoid including the source object in the cache.
		args[0] = null;
		node.args = args;

		// Don't need to check whether node is already head, since it would
		// have been returned above already if it was

		// Shift existing head down list
		if (cache.head) {
			cache.head.prev = node;
			node.next = cache.head;
		}

		cache.head = node;

		return node.val;
	}

	callSelector.getDependants = normalizedGetDependants;
	callSelector.clear = clear;
	clear();

	return /** @type {S & EnhancedSelector} */ (callSelector);
}

;// CONCATENATED MODULE: external ["wp","primitives"]
var external_wp_primitives_namespaceObject = window["wp"]["primitives"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/symbol.js


/**
 * WordPress dependencies
 */

const symbol = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M21.3 10.8l-5.6-5.6c-.7-.7-1.8-.7-2.5 0l-5.6 5.6c-.7.7-.7 1.8 0 2.5l5.6 5.6c.3.3.8.5 1.2.5s.9-.2 1.2-.5l5.6-5.6c.8-.7.8-1.9.1-2.5zm-1 1.4l-5.6 5.6c-.1.1-.3.1-.4 0l-5.6-5.6c-.1-.1-.1-.3 0-.4l5.6-5.6s.1-.1.2-.1.1 0 .2.1l5.6 5.6c.1.1.1.3 0 .4zm-16.6-.4L10 5.5l-1-1-6.3 6.3c-.7.7-.7 1.8 0 2.5L9 19.5l1.1-1.1-6.3-6.3c-.2 0-.2-.2-.1-.3z"
}));
/* harmony default export */ var library_symbol = (symbol);

;// CONCATENATED MODULE: external ["wp","richText"]
var external_wp_richText_namespaceObject = window["wp"]["richText"];
;// CONCATENATED MODULE: external ["wp","deprecated"]
var external_wp_deprecated_namespaceObject = window["wp"]["deprecated"];
var external_wp_deprecated_default = /*#__PURE__*/__webpack_require__.n(external_wp_deprecated_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/store/utils.js
/**
 * Helper function that maps attribute definition properties to the
 * ones used by RichText utils like `create, toHTMLString, etc..`.
 *
 * @param {Object} attributeDefinition A block's attribute definition object.
 * @return {Object} The mapped object.
 */
function mapRichTextSettings(attributeDefinition) {
  const {
    multiline: multilineTag,
    __unstableMultilineWrapperTags: multilineWrapperTags,
    __unstablePreserveWhiteSpace: preserveWhiteSpace
  } = attributeDefinition;
  return {
    multilineTag,
    multilineWrapperTags,
    preserveWhiteSpace
  };
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/sorting.js
/**
 * Recursive stable sorting comparator function.
 *
 * @param {string|Function} field Field to sort by.
 * @param {Array}           items Items to sort.
 * @param {string}          order Order, 'asc' or 'desc'.
 * @return {Function} Comparison function to be used in a `.sort()`.
 */
const comparator = (field, items, order) => {
  return (a, b) => {
    let cmpA, cmpB;

    if (typeof field === 'function') {
      cmpA = field(a);
      cmpB = field(b);
    } else {
      cmpA = a[field];
      cmpB = b[field];
    }

    if (cmpA > cmpB) {
      return order === 'asc' ? 1 : -1;
    } else if (cmpB > cmpA) {
      return order === 'asc' ? -1 : 1;
    }

    const orderA = items.findIndex(item => item === a);
    const orderB = items.findIndex(item => item === b); // Stable sort: maintaining original array order

    if (orderA > orderB) {
      return 1;
    } else if (orderB > orderA) {
      return -1;
    }

    return 0;
  };
};
/**
 * Order items by a certain key.
 * Supports decorator functions that allow complex picking of a comparison field.
 * Sorts in ascending order by default, but supports descending as well.
 * Stable sort - maintains original order of equal items.
 *
 * @param {Array}           items Items to order.
 * @param {string|Function} field Field to order by.
 * @param {string}          order Sorting order, `asc` or `desc`.
 * @return {Array} Sorted items.
 */


function orderBy(items, field, order = 'asc') {
  return items.concat().sort(comparator(field, items, order));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/store/private-selectors.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Returns true if the block interface is hidden, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether the block toolbar is hidden.
 */

function private_selectors_isBlockInterfaceHidden(state) {
  return state.isBlockInterfaceHidden;
}
/**
 * Gets the client ids of the last inserted blocks.
 *
 * @param {Object} state Global application state.
 * @return {Array|undefined} Client Ids of the last inserted block(s).
 */

function getLastInsertedBlocksClientIds(state) {
  return state?.lastBlockInserted?.clientIds;
}
/**
 * @typedef {import('../components/block-editing-mode').BlockEditingMode} BlockEditingMode
 */

/**
 * Returns the block editing mode for a given block.
 *
 * The mode can be one of three options:
 *
 * - `'disabled'`: Prevents editing the block entirely, i.e. it cannot be
 *   selected.
 * - `'contentOnly'`: Hides all non-content UI, e.g. auxiliary controls in the
 *   toolbar, the block movers, block settings.
 * - `'default'`: Allows editing the block as normal.
 *
 * Blocks can set a mode using the `useBlockEditingMode` hook.
 *
 * The mode is inherited by all of the block's inner blocks, unless they have
 * their own mode.
 *
 * A template lock can also set a mode. If the template lock is `'contentOnly'`,
 * the block's mode is overridden to `'contentOnly'` if the block has a content
 * role attribute, or `'disabled'` otherwise.
 *
 * @see useBlockEditingMode
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId The block client ID, or `''` for the root container.
 *
 * @return {BlockEditingMode} The block editing mode. One of `'disabled'`,
 *                            `'contentOnly'`, or `'default'`.
 */

function getBlockEditingMode(state, clientId = '') {
  if (state.blockEditingModes.has(clientId)) {
    return state.blockEditingModes.get(clientId);
  }

  if (!clientId) {
    return 'default';
  }

  const rootClientId = getBlockRootClientId(state, clientId);
  const templateLock = getTemplateLock(state, rootClientId);

  if (templateLock === 'contentOnly') {
    const name = getBlockName(state, clientId); // TODO: Terrible hack! We're calling the global select() function
    // here instead of using createRegistrySelector(). The problem with
    // using createRegistrySelector() is that then the public
    // block-editor selectors (e.g. canInsertBlockTypeUnmemoized) can't
    // call this private block-editor selector due to a bug in
    // @wordpress/data. See
    // https://github.com/WordPress/gutenberg/pull/50985.

    const isContent = (0,external_wp_data_namespaceObject.select)(external_wp_blocks_namespaceObject.store).__experimentalHasContentRoleAttribute(name);

    return isContent ? 'contentOnly' : 'disabled';
  }

  const parentMode = getBlockEditingMode(state, rootClientId);
  return parentMode === 'contentOnly' ? 'default' : parentMode;
}
/**
 * Returns true if the block with the given client ID and all of its descendants
 * have an editing mode of 'disabled', or false otherwise.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId The block client ID.
 *
 * @return {boolean} Whether the block and its descendants are disabled.
 */

const isBlockSubtreeDisabled = rememo((state, clientId) => {
  const isChildSubtreeDisabled = childClientId => {
    const mode = state.blockEditingModes.get(childClientId);
    return (mode === undefined || mode === 'disabled') && getBlockOrder(state, childClientId).every(isChildSubtreeDisabled);
  };

  return getBlockEditingMode(state, clientId) === 'disabled' && getBlockOrder(state, clientId).every(isChildSubtreeDisabled);
}, state => [state.blockEditingModes, state.blocks.parents]);
/**
 * Returns a tree of block objects with only clientID and innerBlocks set.
 * Blocks with a 'disabled' editing mode are not included.
 *
 * @param {Object}  state        Global application state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Object[]} Tree of block objects with only clientID and innerBlocks set.
 */

const getEnabledClientIdsTree = rememo((state, rootClientId = '') => {
  return getBlockOrder(state, rootClientId).flatMap(clientId => {
    if (getBlockEditingMode(state, clientId) !== 'disabled') {
      return [{
        clientId,
        innerBlocks: getEnabledClientIdsTree(state, clientId)
      }];
    }

    return getEnabledClientIdsTree(state, clientId);
  });
}, state => [state.blocks.order, state.blockEditingModes, state.settings.templateLock, state.blockListSettings]);
/**
 * Returns a list of a given block's ancestors, from top to bottom. Blocks with
 * a 'disabled' editing mode are excluded.
 *
 * @see getBlockParents
 *
 * @param {Object}  state     Global application state.
 * @param {string}  clientId  The block client ID.
 * @param {boolean} ascending Order results from bottom to top (true) or top
 *                            to bottom (false).
 */

const getEnabledBlockParents = rememo((state, clientId, ascending = false) => {
  return getBlockParents(state, clientId, ascending).filter(parent => getBlockEditingMode(state, parent) !== 'disabled');
}, state => [state.blocks.parents, state.blockEditingModes, state.settings.templateLock, state.blockListSettings]);
/**
 * Selector that returns the data needed to display a prompt when certain
 * blocks are removed, or `false` if no such prompt is requested.
 *
 * @param {Object} state Global application state.
 *
 * @return {Object|false} Data for removal prompt display, if any.
 */

function getRemovalPromptData(state) {
  return state.removalPromptData;
}
/**
 * Returns true if removal prompt exists, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether removal prompt exists.
 */

function getBlockRemovalRules(state) {
  return state.blockRemovalRules;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/store/selectors.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */




/**
 * A block selection object.
 *
 * @typedef {Object} WPBlockSelection
 *
 * @property {string} clientId     A block client ID.
 * @property {string} attributeKey A block attribute key.
 * @property {number} offset       An attribute value offset, based on the rich
 *                                 text value. See `wp.richText.create`.
 */
// Module constants.

const MILLISECONDS_PER_HOUR = 3600 * 1000;
const MILLISECONDS_PER_DAY = 24 * 3600 * 1000;
const MILLISECONDS_PER_WEEK = 7 * 24 * 3600 * 1000;
/**
 * Shared reference to an empty array for cases where it is important to avoid
 * returning a new array reference on every invocation, as in a connected or
 * other pure component which performs `shouldComponentUpdate` check on props.
 * This should be used as a last resort, since the normalized data should be
 * maintained by the reducer result in state.
 *
 * @type {Array}
 */

const EMPTY_ARRAY = [];
/**
 * Shared reference to an empty Set for cases where it is important to avoid
 * returning a new Set reference on every invocation, as in a connected or
 * other pure component which performs `shouldComponentUpdate` check on props.
 * This should be used as a last resort, since the normalized data should be
 * maintained by the reducer result in state.
 *
 * @type {Set}
 */

const EMPTY_SET = new Set();
/**
 * Returns a block's name given its client ID, or null if no block exists with
 * the client ID.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {string} Block name.
 */

function getBlockName(state, clientId) {
  const block = state.blocks.byClientId.get(clientId);
  const socialLinkName = 'core/social-link';

  if (external_wp_element_namespaceObject.Platform.OS !== 'web' && block?.name === socialLinkName) {
    const attributes = state.blocks.attributes.get(clientId);
    const {
      service
    } = attributes !== null && attributes !== void 0 ? attributes : {};
    return service ? `${socialLinkName}-${service}` : socialLinkName;
  }

  return block ? block.name : null;
}
/**
 * Returns whether a block is valid or not.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Is Valid.
 */

function isBlockValid(state, clientId) {
  const block = state.blocks.byClientId.get(clientId);
  return !!block && block.isValid;
}
/**
 * Returns a block's attributes given its client ID, or null if no block exists with
 * the client ID.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {Object?} Block attributes.
 */

function getBlockAttributes(state, clientId) {
  const block = state.blocks.byClientId.get(clientId);

  if (!block) {
    return null;
  }

  return state.blocks.attributes.get(clientId);
}
/**
 * Returns a block given its client ID. This is a parsed copy of the block,
 * containing its `blockName`, `clientId`, and current `attributes` state. This
 * is not the block's registration settings, which must be retrieved from the
 * blocks module registration store.
 *
 * getBlock recurses through its inner blocks until all its children blocks have
 * been retrieved. Note that getBlock will not return the child inner blocks of
 * an inner block controller. This is because an inner block controller syncs
 * itself with its own entity, and should therefore not be included with the
 * blocks of a different entity. For example, say you call `getBlocks( TP )` to
 * get the blocks of a template part. If another template part is a child of TP,
 * then the nested template part's child blocks will not be returned. This way,
 * the template block itself is considered part of the parent, but the children
 * are not.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {Object} Parsed block object.
 */

function getBlock(state, clientId) {
  if (!state.blocks.byClientId.has(clientId)) {
    return null;
  }

  return state.blocks.tree.get(clientId);
}
const __unstableGetBlockWithoutInnerBlocks = rememo((state, clientId) => {
  if (!state.blocks.byClientId.has(clientId)) {
    return null;
  }

  return { ...state.blocks.byClientId.get(clientId),
    attributes: getBlockAttributes(state, clientId)
  };
}, (state, clientId) => [state.blocks.byClientId.get(clientId), state.blocks.attributes.get(clientId)]);
/**
 * Returns all block objects for the current post being edited as an array in
 * the order they appear in the post. Note that this will exclude child blocks
 * of nested inner block controllers.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Object[]} Post blocks.
 */

function getBlocks(state, rootClientId) {
  const treeKey = !rootClientId || !areInnerBlocksControlled(state, rootClientId) ? rootClientId || '' : 'controlled||' + rootClientId;
  return state.blocks.tree.get(treeKey)?.innerBlocks || EMPTY_ARRAY;
}
/**
 * Returns a stripped down block object containing only its client ID,
 * and its inner blocks' client IDs.
 *
 * @deprecated
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Client ID of the block to get.
 *
 * @return {Object} Client IDs of the post blocks.
 */

const __unstableGetClientIdWithClientIdsTree = rememo((state, clientId) => {
  external_wp_deprecated_default()("wp.data.select( 'core/block-editor' ).__unstableGetClientIdWithClientIdsTree", {
    since: '6.3',
    version: '6.5'
  });
  return {
    clientId,
    innerBlocks: __unstableGetClientIdsTree(state, clientId)
  };
}, state => [state.blocks.order]);
/**
 * Returns the block tree represented in the block-editor store from the
 * given root, consisting of stripped down block objects containing only
 * their client IDs, and their inner blocks' client IDs.
 *
 * @deprecated
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Object[]} Client IDs of the post blocks.
 */

const __unstableGetClientIdsTree = rememo((state, rootClientId = '') => {
  external_wp_deprecated_default()("wp.data.select( 'core/block-editor' ).__unstableGetClientIdsTree", {
    since: '6.3',
    version: '6.5'
  });
  return getBlockOrder(state, rootClientId).map(clientId => __unstableGetClientIdWithClientIdsTree(state, clientId));
}, state => [state.blocks.order]);
/**
 * Returns an array containing the clientIds of all descendants of the blocks
 * given. Returned ids are ordered first by the order of the ids given, then
 * by the order that they appear in the editor.
 *
 * @param {Object} state     Global application state.
 * @param {Array}  clientIds Array of blocks to inspect.
 *
 * @return {Array} ids of descendants.
 */

const getClientIdsOfDescendants = rememo((state, clientIds) => {
  const collectedIds = [];

  for (const givenId of clientIds) {
    for (const descendantId of getBlockOrder(state, givenId)) {
      collectedIds.push(descendantId, ...getClientIdsOfDescendants(state, [descendantId]));
    }
  }

  return collectedIds;
}, state => [state.blocks.order]);
/**
 * Returns an array containing the clientIds of the top-level blocks and
 * their descendants of any depth (for nested blocks). Ids are returned
 * in the same order that they appear in the editor.
 *
 * @param {Object} state Global application state.
 *
 * @return {Array} ids of top-level and descendant blocks.
 */

const getClientIdsWithDescendants = rememo(state => {
  const collectedIds = [];

  for (const topLevelId of getBlockOrder(state)) {
    collectedIds.push(topLevelId, ...getClientIdsOfDescendants(state, [topLevelId]));
  }

  return collectedIds;
}, state => [state.blocks.order]);
/**
 * Returns the total number of blocks, or the total number of blocks with a specific name in a post.
 * The number returned includes nested blocks.
 *
 * @param {Object}  state     Global application state.
 * @param {?string} blockName Optional block name, if specified only blocks of that type will be counted.
 *
 * @return {number} Number of blocks in the post, or number of blocks with name equal to blockName.
 */

const getGlobalBlockCount = rememo((state, blockName) => {
  const clientIds = getClientIdsWithDescendants(state);

  if (!blockName) {
    return clientIds.length;
  }

  return clientIds.reduce((accumulator, clientId) => {
    const block = state.blocks.byClientId.get(clientId);
    return block.name === blockName ? accumulator + 1 : accumulator;
  }, 0);
}, state => [state.blocks.order, state.blocks.byClientId]);
/**
 * Returns all global blocks that match a blockName. Results include nested blocks.
 *
 * @param {Object}  state     Global application state.
 * @param {?string} blockName Optional block name, if not specified, returns an empty array.
 *
 * @return {Array} Array of clientIds of blocks with name equal to blockName.
 */

const __experimentalGetGlobalBlocksByName = rememo((state, blockName) => {
  if (!blockName) {
    return EMPTY_ARRAY;
  }

  const blockNames = Array.isArray(blockName) ? blockName : [blockName];
  const clientIds = getClientIdsWithDescendants(state);
  const foundBlocks = clientIds.filter(clientId => {
    const block = state.blocks.byClientId.get(clientId);
    return blockNames.includes(block.name);
  });
  return foundBlocks.length > 0 ? foundBlocks : EMPTY_ARRAY;
}, state => [state.blocks.order, state.blocks.byClientId]);
/**
 * Given an array of block client IDs, returns the corresponding array of block
 * objects.
 *
 * @param {Object}   state     Editor state.
 * @param {string[]} clientIds Client IDs for which blocks are to be returned.
 *
 * @return {WPBlock[]} Block objects.
 */

const getBlocksByClientId = rememo((state, clientIds) => (Array.isArray(clientIds) ? clientIds : [clientIds]).map(clientId => getBlock(state, clientId)), (state, clientIds) => (Array.isArray(clientIds) ? clientIds : [clientIds]).map(clientId => state.blocks.tree.get(clientId)));
/**
 * Given an array of block client IDs, returns the corresponding array of block
 * names.
 *
 * @param {Object}   state     Editor state.
 * @param {string[]} clientIds Client IDs for which block names are to be returned.
 *
 * @return {string[]} Block names.
 */

const getBlockNamesByClientId = rememo((state, clientIds) => getBlocksByClientId(state, clientIds).filter(Boolean).map(block => block.name), (state, clientIds) => getBlocksByClientId(state, clientIds));
/**
 * Returns the number of blocks currently present in the post.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {number} Number of blocks in the post.
 */

function getBlockCount(state, rootClientId) {
  return getBlockOrder(state, rootClientId).length;
}
/**
 * Returns the current selection start block client ID, attribute key and text
 * offset.
 *
 * @param {Object} state Block editor state.
 *
 * @return {WPBlockSelection} Selection start information.
 */

function getSelectionStart(state) {
  return state.selection.selectionStart;
}
/**
 * Returns the current selection end block client ID, attribute key and text
 * offset.
 *
 * @param {Object} state Block editor state.
 *
 * @return {WPBlockSelection} Selection end information.
 */

function getSelectionEnd(state) {
  return state.selection.selectionEnd;
}
/**
 * Returns the current block selection start. This value may be null, and it
 * may represent either a singular block selection or multi-selection start.
 * A selection is singular if its start and end match.
 *
 * @param {Object} state Global application state.
 *
 * @return {?string} Client ID of block selection start.
 */

function getBlockSelectionStart(state) {
  return state.selection.selectionStart.clientId;
}
/**
 * Returns the current block selection end. This value may be null, and it
 * may represent either a singular block selection or multi-selection end.
 * A selection is singular if its start and end match.
 *
 * @param {Object} state Global application state.
 *
 * @return {?string} Client ID of block selection end.
 */

function getBlockSelectionEnd(state) {
  return state.selection.selectionEnd.clientId;
}
/**
 * Returns the number of blocks currently selected in the post.
 *
 * @param {Object} state Global application state.
 *
 * @return {number} Number of blocks selected in the post.
 */

function getSelectedBlockCount(state) {
  const multiSelectedBlockCount = getMultiSelectedBlockClientIds(state).length;

  if (multiSelectedBlockCount) {
    return multiSelectedBlockCount;
  }

  return state.selection.selectionStart.clientId ? 1 : 0;
}
/**
 * Returns true if there is a single selected block, or false otherwise.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Whether a single block is selected.
 */

function hasSelectedBlock(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  return !!selectionStart.clientId && selectionStart.clientId === selectionEnd.clientId;
}
/**
 * Returns the currently selected block client ID, or null if there is no
 * selected block.
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Selected block client ID.
 */

function getSelectedBlockClientId(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  const {
    clientId
  } = selectionStart;

  if (!clientId || clientId !== selectionEnd.clientId) {
    return null;
  }

  return clientId;
}
/**
 * Returns the currently selected block, or null if there is no selected block.
 *
 * @param {Object} state Global application state.
 *
 * @return {?Object} Selected block.
 */

function getSelectedBlock(state) {
  const clientId = getSelectedBlockClientId(state);
  return clientId ? getBlock(state, clientId) : null;
}
/**
 * Given a block client ID, returns the root block from which the block is
 * nested, an empty string for top-level blocks, or null if the block does not
 * exist.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find root client ID.
 *
 * @return {?string} Root client ID, if exists
 */

function getBlockRootClientId(state, clientId) {
  return state.blocks.parents.has(clientId) ? state.blocks.parents.get(clientId) : null;
}
/**
 * Given a block client ID, returns the list of all its parents from top to bottom.
 *
 * @param {Object}  state     Editor state.
 * @param {string}  clientId  Block from which to find root client ID.
 * @param {boolean} ascending Order results from bottom to top (true) or top to bottom (false).
 *
 * @return {Array} ClientIDs of the parent blocks.
 */

const getBlockParents = rememo((state, clientId, ascending = false) => {
  const parents = [];
  let current = clientId;

  while (!!state.blocks.parents.get(current)) {
    current = state.blocks.parents.get(current);
    parents.push(current);
  }

  if (!parents.length) {
    return EMPTY_ARRAY;
  }

  return ascending ? parents : parents.reverse();
}, state => [state.blocks.parents]);
/**
 * Given a block client ID and a block name, returns the list of all its parents
 * from top to bottom, filtered by the given name(s). For example, if passed
 * 'core/group' as the blockName, it will only return parents which are group
 * blocks. If passed `[ 'core/group', 'core/cover']`, as the blockName, it will
 * return parents which are group blocks and parents which are cover blocks.
 *
 * @param {Object}          state     Editor state.
 * @param {string}          clientId  Block from which to find root client ID.
 * @param {string|string[]} blockName Block name(s) to filter.
 * @param {boolean}         ascending Order results from bottom to top (true) or top to bottom (false).
 *
 * @return {Array} ClientIDs of the parent blocks.
 */

const getBlockParentsByBlockName = rememo((state, clientId, blockName, ascending = false) => {
  const parents = getBlockParents(state, clientId, ascending);
  const hasName = Array.isArray(blockName) ? name => blockName.includes(name) : name => blockName === name;
  return parents.filter(id => hasName(getBlockName(state, id)));
}, state => [state.blocks.parents]);
/**
 * Given a block client ID, returns the root of the hierarchy from which the block is nested, return the block itself for root level blocks.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find root client ID.
 *
 * @return {string} Root client ID
 */

function getBlockHierarchyRootClientId(state, clientId) {
  let current = clientId;
  let parent;

  do {
    parent = current;
    current = state.blocks.parents.get(current);
  } while (current);

  return parent;
}
/**
 * Given a block client ID, returns the lowest common ancestor with selected client ID.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find common ancestor client ID.
 *
 * @return {string} Common ancestor client ID or undefined
 */

function getLowestCommonAncestorWithSelectedBlock(state, clientId) {
  const selectedId = getSelectedBlockClientId(state);
  const clientParents = [...getBlockParents(state, clientId), clientId];
  const selectedParents = [...getBlockParents(state, selectedId), selectedId];
  let lowestCommonAncestor;
  const maxDepth = Math.min(clientParents.length, selectedParents.length);

  for (let index = 0; index < maxDepth; index++) {
    if (clientParents[index] === selectedParents[index]) {
      lowestCommonAncestor = clientParents[index];
    } else {
      break;
    }
  }

  return lowestCommonAncestor;
}
/**
 * Returns the client ID of the block adjacent one at the given reference
 * startClientId and modifier directionality. Defaults start startClientId to
 * the selected block, and direction as next block. Returns null if there is no
 * adjacent block.
 *
 * @param {Object}  state         Editor state.
 * @param {?string} startClientId Optional client ID of block from which to
 *                                search.
 * @param {?number} modifier      Directionality multiplier (1 next, -1
 *                                previous).
 *
 * @return {?string} Return the client ID of the block, or null if none exists.
 */

function getAdjacentBlockClientId(state, startClientId, modifier = 1) {
  // Default to selected block.
  if (startClientId === undefined) {
    startClientId = getSelectedBlockClientId(state);
  } // Try multi-selection starting at extent based on modifier.


  if (startClientId === undefined) {
    if (modifier < 0) {
      startClientId = getFirstMultiSelectedBlockClientId(state);
    } else {
      startClientId = getLastMultiSelectedBlockClientId(state);
    }
  } // Validate working start client ID.


  if (!startClientId) {
    return null;
  } // Retrieve start block root client ID, being careful to allow the falsey
  // empty string top-level root by explicitly testing against null.


  const rootClientId = getBlockRootClientId(state, startClientId);

  if (rootClientId === null) {
    return null;
  }

  const {
    order
  } = state.blocks;
  const orderSet = order.get(rootClientId);
  const index = orderSet.indexOf(startClientId);
  const nextIndex = index + 1 * modifier; // Block was first in set and we're attempting to get previous.

  if (nextIndex < 0) {
    return null;
  } // Block was last in set and we're attempting to get next.


  if (nextIndex === orderSet.length) {
    return null;
  } // Assume incremented index is within the set.


  return orderSet[nextIndex];
}
/**
 * Returns the previous block's client ID from the given reference start ID.
 * Defaults start to the selected block. Returns null if there is no previous
 * block.
 *
 * @param {Object}  state         Editor state.
 * @param {?string} startClientId Optional client ID of block from which to
 *                                search.
 *
 * @return {?string} Adjacent block's client ID, or null if none exists.
 */

function getPreviousBlockClientId(state, startClientId) {
  return getAdjacentBlockClientId(state, startClientId, -1);
}
/**
 * Returns the next block's client ID from the given reference start ID.
 * Defaults start to the selected block. Returns null if there is no next
 * block.
 *
 * @param {Object}  state         Editor state.
 * @param {?string} startClientId Optional client ID of block from which to
 *                                search.
 *
 * @return {?string} Adjacent block's client ID, or null if none exists.
 */

function getNextBlockClientId(state, startClientId) {
  return getAdjacentBlockClientId(state, startClientId, 1);
}
/* eslint-disable jsdoc/valid-types */

/**
 * Returns the initial caret position for the selected block.
 * This position is to used to position the caret properly when the selected block changes.
 * If the current block is not a RichText, having initial position set to 0 means "focus block"
 *
 * @param {Object} state Global application state.
 *
 * @return {0|-1|null} Initial position.
 */

function getSelectedBlocksInitialCaretPosition(state) {
  /* eslint-enable jsdoc/valid-types */
  return state.initialPosition;
}
/**
 * Returns the current selection set of block client IDs (multiselection or single selection).
 *
 * @param {Object} state Editor state.
 *
 * @return {Array} Multi-selected block client IDs.
 */

const getSelectedBlockClientIds = rememo(state => {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (!selectionStart.clientId || !selectionEnd.clientId) {
    return EMPTY_ARRAY;
  }

  if (selectionStart.clientId === selectionEnd.clientId) {
    return [selectionStart.clientId];
  } // Retrieve root client ID to aid in retrieving relevant nested block
  // order, being careful to allow the falsey empty string top-level root
  // by explicitly testing against null.


  const rootClientId = getBlockRootClientId(state, selectionStart.clientId);

  if (rootClientId === null) {
    return EMPTY_ARRAY;
  }

  const blockOrder = getBlockOrder(state, rootClientId);
  const startIndex = blockOrder.indexOf(selectionStart.clientId);
  const endIndex = blockOrder.indexOf(selectionEnd.clientId);

  if (startIndex > endIndex) {
    return blockOrder.slice(endIndex, startIndex + 1);
  }

  return blockOrder.slice(startIndex, endIndex + 1);
}, state => [state.blocks.order, state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId]);
/**
 * Returns the current multi-selection set of block client IDs, or an empty
 * array if there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {Array} Multi-selected block client IDs.
 */

function getMultiSelectedBlockClientIds(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (selectionStart.clientId === selectionEnd.clientId) {
    return EMPTY_ARRAY;
  }

  return getSelectedBlockClientIds(state);
}
/**
 * Returns the current multi-selection set of blocks, or an empty array if
 * there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {Array} Multi-selected block objects.
 */

const getMultiSelectedBlocks = rememo(state => {
  const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds(state);

  if (!multiSelectedBlockClientIds.length) {
    return EMPTY_ARRAY;
  }

  return multiSelectedBlockClientIds.map(clientId => getBlock(state, clientId));
}, state => [...getSelectedBlockClientIds.getDependants(state), state.blocks.byClientId, state.blocks.order, state.blocks.attributes]);
/**
 * Returns the client ID of the first block in the multi-selection set, or null
 * if there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} First block client ID in the multi-selection set.
 */

function getFirstMultiSelectedBlockClientId(state) {
  return getMultiSelectedBlockClientIds(state)[0] || null;
}
/**
 * Returns the client ID of the last block in the multi-selection set, or null
 * if there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Last block client ID in the multi-selection set.
 */

function getLastMultiSelectedBlockClientId(state) {
  const selectedClientIds = getMultiSelectedBlockClientIds(state);
  return selectedClientIds[selectedClientIds.length - 1] || null;
}
/**
 * Returns true if a multi-selection exists, and the block corresponding to the
 * specified client ID is the first block of the multi-selection set, or false
 * otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is first in multi-selection.
 */

function isFirstMultiSelectedBlock(state, clientId) {
  return getFirstMultiSelectedBlockClientId(state) === clientId;
}
/**
 * Returns true if the client ID occurs within the block multi-selection, or
 * false otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is in multi-selection set.
 */

function isBlockMultiSelected(state, clientId) {
  return getMultiSelectedBlockClientIds(state).indexOf(clientId) !== -1;
}
/**
 * Returns true if an ancestor of the block is multi-selected, or false
 * otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether an ancestor of the block is in multi-selection
 *                   set.
 */

const isAncestorMultiSelected = rememo((state, clientId) => {
  let ancestorClientId = clientId;
  let isMultiSelected = false;

  while (ancestorClientId && !isMultiSelected) {
    ancestorClientId = getBlockRootClientId(state, ancestorClientId);
    isMultiSelected = isBlockMultiSelected(state, ancestorClientId);
  }

  return isMultiSelected;
}, state => [state.blocks.order, state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId]);
/**
 * Returns the client ID of the block which begins the multi-selection set, or
 * null if there is no multi-selection.
 *
 * This is not necessarily the first client ID in the selection.
 *
 * @see getFirstMultiSelectedBlockClientId
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Client ID of block beginning multi-selection.
 */

function getMultiSelectedBlocksStartClientId(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (selectionStart.clientId === selectionEnd.clientId) {
    return null;
  }

  return selectionStart.clientId || null;
}
/**
 * Returns the client ID of the block which ends the multi-selection set, or
 * null if there is no multi-selection.
 *
 * This is not necessarily the last client ID in the selection.
 *
 * @see getLastMultiSelectedBlockClientId
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Client ID of block ending multi-selection.
 */

function getMultiSelectedBlocksEndClientId(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (selectionStart.clientId === selectionEnd.clientId) {
    return null;
  }

  return selectionEnd.clientId || null;
}
/**
 * Returns true if the selection is not partial.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Whether the selection is mergeable.
 */

function __unstableIsFullySelected(state) {
  const selectionAnchor = getSelectionStart(state);
  const selectionFocus = getSelectionEnd(state);
  return !selectionAnchor.attributeKey && !selectionFocus.attributeKey && typeof selectionAnchor.offset === 'undefined' && typeof selectionFocus.offset === 'undefined';
}
/**
 * Returns true if the selection is collapsed.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Whether the selection is collapsed.
 */

function __unstableIsSelectionCollapsed(state) {
  const selectionAnchor = getSelectionStart(state);
  const selectionFocus = getSelectionEnd(state);
  return !!selectionAnchor && !!selectionFocus && selectionAnchor.clientId === selectionFocus.clientId && selectionAnchor.attributeKey === selectionFocus.attributeKey && selectionAnchor.offset === selectionFocus.offset;
}
function __unstableSelectionHasUnmergeableBlock(state) {
  return getSelectedBlockClientIds(state).some(clientId => {
    const blockName = getBlockName(state, clientId);
    const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockName);
    return !blockType.merge;
  });
}
/**
 * Check whether the selection is mergeable.
 *
 * @param {Object}  state     Editor state.
 * @param {boolean} isForward Whether to merge forwards.
 *
 * @return {boolean} Whether the selection is mergeable.
 */

function __unstableIsSelectionMergeable(state, isForward) {
  const selectionAnchor = getSelectionStart(state);
  const selectionFocus = getSelectionEnd(state); // It's not mergeable if the start and end are within the same block.

  if (selectionAnchor.clientId === selectionFocus.clientId) return false; // It's not mergeable if there's no rich text selection.

  if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === 'undefined' || typeof selectionFocus.offset === 'undefined') return false;
  const anchorRootClientId = getBlockRootClientId(state, selectionAnchor.clientId);
  const focusRootClientId = getBlockRootClientId(state, selectionFocus.clientId); // It's not mergeable if the selection doesn't start and end in the same
  // block list. Maybe in the future it should be allowed.

  if (anchorRootClientId !== focusRootClientId) {
    return false;
  }

  const blockOrder = getBlockOrder(state, anchorRootClientId);
  const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
  const focusIndex = blockOrder.indexOf(selectionFocus.clientId); // Reassign selection start and end based on order.

  let selectionStart, selectionEnd;

  if (anchorIndex > focusIndex) {
    selectionStart = selectionFocus;
    selectionEnd = selectionAnchor;
  } else {
    selectionStart = selectionAnchor;
    selectionEnd = selectionFocus;
  }

  const targetBlockClientId = isForward ? selectionEnd.clientId : selectionStart.clientId;
  const blockToMergeClientId = isForward ? selectionStart.clientId : selectionEnd.clientId;
  const targetBlockName = getBlockName(state, targetBlockClientId);
  const targetBlockType = (0,external_wp_blocks_namespaceObject.getBlockType)(targetBlockName);
  if (!targetBlockType.merge) return false;
  const blockToMerge = getBlock(state, blockToMergeClientId); // It's mergeable if the blocks are of the same type.

  if (blockToMerge.name === targetBlockName) return true; // If the blocks are of a different type, try to transform the block being
  // merged into the same type of block.

  const blocksToMerge = (0,external_wp_blocks_namespaceObject.switchToBlockType)(blockToMerge, targetBlockName);
  return blocksToMerge && blocksToMerge.length;
}
/**
 * Get partial selected blocks with their content updated
 * based on the selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {Object[]} Updated partial selected blocks.
 */

const __unstableGetSelectedBlocksWithPartialSelection = state => {
  const selectionAnchor = getSelectionStart(state);
  const selectionFocus = getSelectionEnd(state);

  if (selectionAnchor.clientId === selectionFocus.clientId) {
    return EMPTY_ARRAY;
  } // Can't split if the selection is not set.


  if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === 'undefined' || typeof selectionFocus.offset === 'undefined') {
    return EMPTY_ARRAY;
  }

  const anchorRootClientId = getBlockRootClientId(state, selectionAnchor.clientId);
  const focusRootClientId = getBlockRootClientId(state, selectionFocus.clientId); // It's not splittable if the selection doesn't start and end in the same
  // block list. Maybe in the future it should be allowed.

  if (anchorRootClientId !== focusRootClientId) {
    return EMPTY_ARRAY;
  }

  const blockOrder = getBlockOrder(state, anchorRootClientId);
  const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
  const focusIndex = blockOrder.indexOf(selectionFocus.clientId); // Reassign selection start and end based on order.

  const [selectionStart, selectionEnd] = anchorIndex > focusIndex ? [selectionFocus, selectionAnchor] : [selectionAnchor, selectionFocus];
  const blockA = getBlock(state, selectionStart.clientId);
  const blockAType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockA.name);
  const blockB = getBlock(state, selectionEnd.clientId);
  const blockBType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockB.name);
  const htmlA = blockA.attributes[selectionStart.attributeKey];
  const htmlB = blockB.attributes[selectionEnd.attributeKey];
  const attributeDefinitionA = blockAType.attributes[selectionStart.attributeKey];
  const attributeDefinitionB = blockBType.attributes[selectionEnd.attributeKey];
  let valueA = (0,external_wp_richText_namespaceObject.create)({
    html: htmlA,
    ...mapRichTextSettings(attributeDefinitionA)
  });
  let valueB = (0,external_wp_richText_namespaceObject.create)({
    html: htmlB,
    ...mapRichTextSettings(attributeDefinitionB)
  });
  valueA = (0,external_wp_richText_namespaceObject.remove)(valueA, 0, selectionStart.offset);
  valueB = (0,external_wp_richText_namespaceObject.remove)(valueB, selectionEnd.offset, valueB.text.length);
  return [{ ...blockA,
    attributes: { ...blockA.attributes,
      [selectionStart.attributeKey]: (0,external_wp_richText_namespaceObject.toHTMLString)({
        value: valueA,
        ...mapRichTextSettings(attributeDefinitionA)
      })
    }
  }, { ...blockB,
    attributes: { ...blockB.attributes,
      [selectionEnd.attributeKey]: (0,external_wp_richText_namespaceObject.toHTMLString)({
        value: valueB,
        ...mapRichTextSettings(attributeDefinitionB)
      })
    }
  }];
};
/**
 * Returns an array containing all block client IDs in the editor in the order
 * they appear. Optionally accepts a root client ID of the block list for which
 * the order should be returned, defaulting to the top-level block order.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Array} Ordered client IDs of editor blocks.
 */

function getBlockOrder(state, rootClientId) {
  return state.blocks.order.get(rootClientId || '') || EMPTY_ARRAY;
}
/**
 * Returns the index at which the block corresponding to the specified client
 * ID occurs within the block order, or `-1` if the block does not exist.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {number} Index at which block exists in order.
 */

function getBlockIndex(state, clientId) {
  const rootClientId = getBlockRootClientId(state, clientId);
  return getBlockOrder(state, rootClientId).indexOf(clientId);
}
/**
 * Returns true if the block corresponding to the specified client ID is
 * currently selected and no multi-selection exists, or false otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is selected and multi-selection exists.
 */

function isBlockSelected(state, clientId) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (selectionStart.clientId !== selectionEnd.clientId) {
    return false;
  }

  return selectionStart.clientId === clientId;
}
/**
 * Returns true if one of the block's inner blocks is selected.
 *
 * @param {Object}  state    Editor state.
 * @param {string}  clientId Block client ID.
 * @param {boolean} deep     Perform a deep check.
 *
 * @return {boolean} Whether the block has an inner block selected
 */

function hasSelectedInnerBlock(state, clientId, deep = false) {
  return getBlockOrder(state, clientId).some(innerClientId => isBlockSelected(state, innerClientId) || isBlockMultiSelected(state, innerClientId) || deep && hasSelectedInnerBlock(state, innerClientId, deep));
}
/**
 * Returns true if one of the block's inner blocks is dragged.
 *
 * @param {Object}  state    Editor state.
 * @param {string}  clientId Block client ID.
 * @param {boolean} deep     Perform a deep check.
 *
 * @return {boolean} Whether the block has an inner block dragged
 */

function hasDraggedInnerBlock(state, clientId, deep = false) {
  return getBlockOrder(state, clientId).some(innerClientId => isBlockBeingDragged(state, innerClientId) || deep && hasDraggedInnerBlock(state, innerClientId, deep));
}
/**
 * Returns true if the block corresponding to the specified client ID is
 * currently selected but isn't the last of the selected blocks. Here "last"
 * refers to the block sequence in the document, _not_ the sequence of
 * multi-selection, which is why `state.selectionEnd` isn't used.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is selected and not the last in the
 *                   selection.
 */

function isBlockWithinSelection(state, clientId) {
  if (!clientId) {
    return false;
  }

  const clientIds = getMultiSelectedBlockClientIds(state);
  const index = clientIds.indexOf(clientId);
  return index > -1 && index < clientIds.length - 1;
}
/**
 * Returns true if a multi-selection has been made, or false otherwise.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Whether multi-selection has been made.
 */

function hasMultiSelection(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  return selectionStart.clientId !== selectionEnd.clientId;
}
/**
 * Whether in the process of multi-selecting or not. This flag is only true
 * while the multi-selection is being selected (by mouse move), and is false
 * once the multi-selection has been settled.
 *
 * @see hasMultiSelection
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} True if multi-selecting, false if not.
 */

function selectors_isMultiSelecting(state) {
  return state.isMultiSelecting;
}
/**
 * Selector that returns if multi-selection is enabled or not.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} True if it should be possible to multi-select blocks, false if multi-selection is disabled.
 */

function selectors_isSelectionEnabled(state) {
  return state.isSelectionEnabled;
}
/**
 * Returns the block's editing mode, defaulting to "visual" if not explicitly
 * assigned.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {Object} Block editing mode.
 */

function getBlockMode(state, clientId) {
  return state.blocksMode[clientId] || 'visual';
}
/**
 * Returns true if the user is typing, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether user is typing.
 */

function selectors_isTyping(state) {
  return state.isTyping;
}
/**
 * Returns true if the user is dragging blocks, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether user is dragging blocks.
 */

function isDraggingBlocks(state) {
  return !!state.draggedBlocks.length;
}
/**
 * Returns the client ids of any blocks being directly dragged.
 *
 * This does not include children of a parent being dragged.
 *
 * @param {Object} state Global application state.
 *
 * @return {string[]} Array of dragged block client ids.
 */

function getDraggedBlockClientIds(state) {
  return state.draggedBlocks;
}
/**
 * Returns whether the block is being dragged.
 *
 * Only returns true if the block is being directly dragged,
 * not if the block is a child of a parent being dragged.
 * See `isAncestorBeingDragged` for child blocks.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId Client id for block to check.
 *
 * @return {boolean} Whether the block is being dragged.
 */

function isBlockBeingDragged(state, clientId) {
  return state.draggedBlocks.includes(clientId);
}
/**
 * Returns whether a parent/ancestor of the block is being dragged.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId Client id for block to check.
 *
 * @return {boolean} Whether the block's ancestor is being dragged.
 */

function isAncestorBeingDragged(state, clientId) {
  // Return early if no blocks are being dragged rather than
  // the more expensive check for parents.
  if (!isDraggingBlocks(state)) {
    return false;
  }

  const parents = getBlockParents(state, clientId);
  return parents.some(parentClientId => isBlockBeingDragged(state, parentClientId));
}
/**
 * Returns true if the caret is within formatted text, or false otherwise.
 *
 * @deprecated
 *
 * @return {boolean} Whether the caret is within formatted text.
 */

function isCaretWithinFormattedText() {
  external_wp_deprecated_default()('wp.data.select( "core/block-editor" ).isCaretWithinFormattedText', {
    since: '6.1',
    version: '6.3'
  });
  return false;
}
/**
 * Returns the insertion point, the index at which the new inserted block would
 * be placed. Defaults to the last index.
 *
 * @param {Object} state Editor state.
 *
 * @return {Object} Insertion point object with `rootClientId`, `index`.
 */

const getBlockInsertionPoint = rememo(state => {
  let rootClientId, index;
  const {
    insertionPoint,
    selection: {
      selectionEnd
    }
  } = state;

  if (insertionPoint !== null) {
    return insertionPoint;
  }

  const {
    clientId
  } = selectionEnd;

  if (clientId) {
    rootClientId = getBlockRootClientId(state, clientId) || undefined;
    index = getBlockIndex(state, selectionEnd.clientId) + 1;
  } else {
    index = getBlockOrder(state).length;
  }

  return {
    rootClientId,
    index
  };
}, state => [state.insertionPoint, state.selection.selectionEnd.clientId, state.blocks.parents, state.blocks.order]);
/**
 * Returns true if we should show the block insertion point.
 *
 * @param {Object} state Global application state.
 *
 * @return {?boolean} Whether the insertion point is visible or not.
 */

function isBlockInsertionPointVisible(state) {
  return state.insertionPoint !== null;
}
/**
 * Returns whether the blocks matches the template or not.
 *
 * @param {boolean} state
 * @return {?boolean} Whether the template is valid or not.
 */

function isValidTemplate(state) {
  return state.template.isValid;
}
/**
 * Returns the defined block template
 *
 * @param {boolean} state
 *
 * @return {?Array} Block Template.
 */

function getTemplate(state) {
  return state.settings.template;
}
/**
 * Returns the defined block template lock. Optionally accepts a root block
 * client ID as context, otherwise defaulting to the global context.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional block root client ID.
 *
 * @return {string|false} Block Template Lock
 */

function getTemplateLock(state, rootClientId) {
  var _getBlockListSettings;

  if (!rootClientId) {
    var _state$settings$templ;

    return (_state$settings$templ = state.settings.templateLock) !== null && _state$settings$templ !== void 0 ? _state$settings$templ : false;
  }

  return (_getBlockListSettings = getBlockListSettings(state, rootClientId)?.templateLock) !== null && _getBlockListSettings !== void 0 ? _getBlockListSettings : false;
}

const checkAllowList = (list, item, defaultResult = null) => {
  if (typeof list === 'boolean') {
    return list;
  }

  if (Array.isArray(list)) {
    // TODO: when there is a canonical way to detect that we are editing a post
    // the following check should be changed to something like:
    // if ( list.includes( 'core/post-content' ) && getEditorMode() === 'post-content' && item === null )
    if (list.includes('core/post-content') && item === null) {
      return true;
    }

    return list.includes(item);
  }

  return defaultResult;
};
/**
 * Determines if the given block type is allowed to be inserted into the block list.
 * This function is not exported and not memoized because using a memoized selector
 * inside another memoized selector is just a waste of time.
 *
 * @param {Object}        state        Editor state.
 * @param {string|Object} blockName    The block type object, e.g., the response
 *                                     from the block directory; or a string name of
 *                                     an installed block type, e.g.' core/paragraph'.
 * @param {?string}       rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block type is allowed to be inserted.
 */


const canInsertBlockTypeUnmemoized = (state, blockName, rootClientId = null) => {
  let blockType;

  if (blockName && 'object' === typeof blockName) {
    blockType = blockName;
    blockName = blockType.name;
  } else {
    blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockName);
  }

  if (!blockType) {
    return false;
  }

  const {
    allowedBlockTypes
  } = getSettings(state);
  const isBlockAllowedInEditor = checkAllowList(allowedBlockTypes, blockName, true);

  if (!isBlockAllowedInEditor) {
    return false;
  }

  const isLocked = !!getTemplateLock(state, rootClientId);

  if (isLocked) {
    return false;
  }

  if (getBlockEditingMode(state, rootClientId !== null && rootClientId !== void 0 ? rootClientId : '') === 'disabled') {
    return false;
  }

  const parentBlockListSettings = getBlockListSettings(state, rootClientId); // The parent block doesn't have settings indicating it doesn't support
  // inner blocks, return false.

  if (rootClientId && parentBlockListSettings === undefined) {
    return false;
  }

  const parentAllowedBlocks = parentBlockListSettings?.allowedBlocks;
  const hasParentAllowedBlock = checkAllowList(parentAllowedBlocks, blockName);
  const blockAllowedParentBlocks = blockType.parent;
  const parentName = getBlockName(state, rootClientId);
  const hasBlockAllowedParent = checkAllowList(blockAllowedParentBlocks, parentName);
  let hasBlockAllowedAncestor = true;
  const blockAllowedAncestorBlocks = blockType.ancestor;

  if (blockAllowedAncestorBlocks) {
    const ancestors = [rootClientId, ...getBlockParents(state, rootClientId)];
    hasBlockAllowedAncestor = ancestors.some(ancestorClientId => checkAllowList(blockAllowedAncestorBlocks, getBlockName(state, ancestorClientId)));
  }

  const canInsert = hasBlockAllowedAncestor && (hasParentAllowedBlock === null && hasBlockAllowedParent === null || hasParentAllowedBlock === true || hasBlockAllowedParent === true);

  if (!canInsert) {
    return canInsert;
  }
  /**
   * This filter is an ad-hoc solution to prevent adding template parts inside post content.
   * Conceptually, having a filter inside a selector is bad pattern so this code will be
   * replaced by a declarative API that doesn't the following drawbacks:
   *
   * Filters are not reactive: Upon switching between "template mode" and non "template mode",
   * the filter and selector won't necessarily be executed again. For now, it doesn't matter much
   * because you can't switch between the two modes while the inserter stays open.
   *
   * Filters are global: Once they're defined, they will affect all editor instances and all registries.
   * An ideal API would only affect specific editor instances.
   */


  return (0,external_wp_hooks_namespaceObject.applyFilters)('blockEditor.__unstableCanInsertBlockType', canInsert, blockType, rootClientId, {
    // Pass bound selectors of the current registry. If we're in a nested
    // context, the data will differ from the one selected from the root
    // registry.
    getBlock: getBlock.bind(null, state),
    getBlockParentsByBlockName: getBlockParentsByBlockName.bind(null, state)
  });
};
/**
 * Determines if the given block type is allowed to be inserted into the block list.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  blockName    The name of the block type, e.g.' core/paragraph'.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block type is allowed to be inserted.
 */


const canInsertBlockType = rememo(canInsertBlockTypeUnmemoized, (state, blockName, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId.get(rootClientId), state.settings.allowedBlockTypes, state.settings.templateLock, state.blockEditingModes]);
/**
 * Determines if the given blocks are allowed to be inserted into the block
 * list.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  clientIds    The block client IDs to be inserted.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given blocks are allowed to be inserted.
 */

function canInsertBlocks(state, clientIds, rootClientId = null) {
  return clientIds.every(id => canInsertBlockType(state, getBlockName(state, id), rootClientId));
}
/**
 * Determines if the given block is allowed to be deleted.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  clientId     The block client Id.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block is allowed to be removed.
 */

function canRemoveBlock(state, clientId, rootClientId = null) {
  const attributes = getBlockAttributes(state, clientId);

  if (attributes === null) {
    return true;
  }

  if (attributes.lock?.remove !== undefined) {
    return !attributes.lock.remove;
  }

  if (getTemplateLock(state, rootClientId)) {
    return false;
  }

  return getBlockEditingMode(state, rootClientId) !== 'disabled';
}
/**
 * Determines if the given blocks are allowed to be removed.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  clientIds    The block client IDs to be removed.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given blocks are allowed to be removed.
 */

function canRemoveBlocks(state, clientIds, rootClientId = null) {
  return clientIds.every(clientId => canRemoveBlock(state, clientId, rootClientId));
}
/**
 * Determines if the given block is allowed to be moved.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  clientId     The block client Id.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean | undefined} Whether the given block is allowed to be moved.
 */

function canMoveBlock(state, clientId, rootClientId = null) {
  const attributes = getBlockAttributes(state, clientId);

  if (attributes === null) {
    return true;
  }

  if (attributes.lock?.move !== undefined) {
    return !attributes.lock.move;
  }

  if (getTemplateLock(state, rootClientId) === 'all') {
    return false;
  }

  return getBlockEditingMode(state, rootClientId) !== 'disabled';
}
/**
 * Determines if the given blocks are allowed to be moved.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  clientIds    The block client IDs to be moved.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given blocks are allowed to be moved.
 */

function canMoveBlocks(state, clientIds, rootClientId = null) {
  return clientIds.every(clientId => canMoveBlock(state, clientId, rootClientId));
}
/**
 * Determines if the given block is allowed to be edited.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId The block client Id.
 *
 * @return {boolean} Whether the given block is allowed to be edited.
 */

function canEditBlock(state, clientId) {
  const attributes = getBlockAttributes(state, clientId);

  if (attributes === null) {
    return true;
  }

  const {
    lock
  } = attributes; // When the edit is true, we cannot edit the block.

  return !lock?.edit;
}
/**
 * Determines if the given block type can be locked/unlocked by a user.
 *
 * @param {Object}          state      Editor state.
 * @param {(string|Object)} nameOrType Block name or type object.
 *
 * @return {boolean} Whether a given block type can be locked/unlocked.
 */

function canLockBlockType(state, nameOrType) {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(nameOrType, 'lock', true)) {
    return false;
  } // Use block editor settings as the default value.


  return !!state.settings?.canLockBlocks;
}
/**
 * Returns information about how recently and frequently a block has been inserted.
 *
 * @param {Object} state Global application state.
 * @param {string} id    A string which identifies the insert, e.g. 'core/block/12'
 *
 * @return {?{ time: number, count: number }} An object containing `time` which is when the last
 *                                            insert occurred as a UNIX epoch, and `count` which is
 *                                            the number of inserts that have occurred.
 */

function getInsertUsage(state, id) {
  var _state$preferences$in;

  return (_state$preferences$in = state.preferences.insertUsage?.[id]) !== null && _state$preferences$in !== void 0 ? _state$preferences$in : null;
}
/**
 * Returns whether we can show a block type in the inserter
 *
 * @param {Object}  state        Global State
 * @param {Object}  blockType    BlockType
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block type is allowed to be shown in the inserter.
 */


const canIncludeBlockTypeInInserter = (state, blockType, rootClientId) => {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, 'inserter', true)) {
    return false;
  }

  return canInsertBlockTypeUnmemoized(state, blockType.name, rootClientId);
};
/**
 * Return a function to be used to tranform a block variation to an inserter item
 *
 * @param {Object} state Global State
 * @param {Object} item  Denormalized inserter item
 * @return {Function} Function to transform a block variation to inserter item
 */


const getItemFromVariation = (state, item) => variation => {
  const variationId = `${item.id}/${variation.name}`;
  const {
    time,
    count = 0
  } = getInsertUsage(state, variationId) || {};
  return { ...item,
    id: variationId,
    icon: variation.icon || item.icon,
    title: variation.title || item.title,
    description: variation.description || item.description,
    category: variation.category || item.category,
    // If `example` is explicitly undefined for the variation, the preview will not be shown.
    example: variation.hasOwnProperty('example') ? variation.example : item.example,
    initialAttributes: { ...item.initialAttributes,
      ...variation.attributes
    },
    innerBlocks: variation.innerBlocks,
    keywords: variation.keywords || item.keywords,
    frecency: calculateFrecency(time, count)
  };
};
/**
 * Returns the calculated frecency.
 *
 * 'frecency' is a heuristic (https://en.wikipedia.org/wiki/Frecency)
 * that combines block usage frequenty and recency.
 *
 * @param {number} time  When the last insert occurred as a UNIX epoch
 * @param {number} count The number of inserts that have occurred.
 *
 * @return {number} The calculated frecency.
 */


const calculateFrecency = (time, count) => {
  if (!time) {
    return count;
  } // The selector is cached, which means Date.now() is the last time that the
  // relevant state changed. This suits our needs.


  const duration = Date.now() - time;

  switch (true) {
    case duration < MILLISECONDS_PER_HOUR:
      return count * 4;

    case duration < MILLISECONDS_PER_DAY:
      return count * 2;

    case duration < MILLISECONDS_PER_WEEK:
      return count / 2;

    default:
      return count / 4;
  }
};
/**
 * Returns a function that accepts a block type and builds an item to be shown
 * in a specific context. It's used for building items for Inserter and available
 * block Transfroms list.
 *
 * @param {Object} state              Editor state.
 * @param {Object} options            Options object for handling the building of a block type.
 * @param {string} options.buildScope The scope for which the item is going to be used.
 * @return {Function} Function returns an item to be shown in a specific context (Inserter|Transforms list).
 */


const buildBlockTypeItem = (state, {
  buildScope = 'inserter'
}) => blockType => {
  const id = blockType.name;
  let isDisabled = false;

  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType.name, 'multiple', true)) {
    isDisabled = getBlocksByClientId(state, getClientIdsWithDescendants(state)).some(({
      name
    }) => name === blockType.name);
  }

  const {
    time,
    count = 0
  } = getInsertUsage(state, id) || {};
  const blockItemBase = {
    id,
    name: blockType.name,
    title: blockType.title,
    icon: blockType.icon,
    isDisabled,
    frecency: calculateFrecency(time, count)
  };
  if (buildScope === 'transform') return blockItemBase;
  const inserterVariations = (0,external_wp_blocks_namespaceObject.getBlockVariations)(blockType.name, 'inserter');
  return { ...blockItemBase,
    initialAttributes: {},
    description: blockType.description,
    category: blockType.category,
    keywords: blockType.keywords,
    variations: inserterVariations,
    example: blockType.example,
    utility: 1 // Deprecated.

  };
};
/**
 * Determines the items that appear in the inserter. Includes both static
 * items (e.g. a regular block type) and dynamic items (e.g. a reusable block).
 *
 * Each item object contains what's necessary to display a button in the
 * inserter and handle its selection.
 *
 * The 'frecency' property is a heuristic (https://en.wikipedia.org/wiki/Frecency)
 * that combines block usage frequenty and recency.
 *
 * Items are returned ordered descendingly by their 'utility' and 'frecency'.
 *
 * @param    {Object}   state             Editor state.
 * @param    {?string}  rootClientId      Optional root client ID of block list.
 *
 * @return {WPEditorInserterItem[]} Items that appear in inserter.
 *
 * @typedef {Object} WPEditorInserterItem
 * @property {string}   id                Unique identifier for the item.
 * @property {string}   name              The type of block to create.
 * @property {Object}   initialAttributes Attributes to pass to the newly created block.
 * @property {string}   title             Title of the item, as it appears in the inserter.
 * @property {string}   icon              Dashicon for the item, as it appears in the inserter.
 * @property {string}   category          Block category that the item is associated with.
 * @property {string[]} keywords          Keywords that can be searched to find this item.
 * @property {boolean}  isDisabled        Whether or not the user should be prevented from inserting
 *                                        this item.
 * @property {number}   frecency          Heuristic that combines frequency and recency.
 */


const getInserterItems = rememo((state, rootClientId = null) => {
  /*
   * Matches block comment delimiters amid serialized content.
   *
   * @see `tokenizer` in `@wordpress/block-serialization-default-parser`
   * package
   *
   * blockParserTokenizer differs from the original tokenizer in the
   * following ways:
   *
   * - removed global flag (/g)
   * - prepended ^\s*
   *
   */
  const blockParserTokenizer = /^\s*<!--\s+(\/)?wp:([a-z][a-z0-9_-]*\/)?([a-z][a-z0-9_-]*)\s+({(?:(?=([^}]+|}+(?=})|(?!}\s+\/?-->)[^])*)\5|[^]*?)}\s+)?(\/)?-->/;

  const buildReusableBlockInserterItem = reusableBlock => {
    let icon = library_symbol;
    /*
     * Instead of always displaying a generic "symbol" icon for every
     * reusable block, try to use an icon that represents the first
     * outermost block contained in the reusable block. This requires
     * scanning the serialized form of the reusable block to find its
     * first block delimiter, then looking up the corresponding block
     * type, if available.
     */

    if (external_wp_element_namespaceObject.Platform.OS === 'web') {
      const content = typeof reusableBlock.content.raw === 'string' ? reusableBlock.content.raw : reusableBlock.content;
      const rawBlockMatch = content.match(blockParserTokenizer);

      if (rawBlockMatch) {
        const [,, namespace = 'core/', blockName] = rawBlockMatch;
        const referencedBlockType = (0,external_wp_blocks_namespaceObject.getBlockType)(namespace + blockName);

        if (referencedBlockType) {
          icon = referencedBlockType.icon;
        }
      }
    }

    const id = `core/block/${reusableBlock.id}`;
    const {
      time,
      count = 0
    } = getInsertUsage(state, id) || {};
    const frecency = calculateFrecency(time, count);
    return {
      id,
      name: 'core/block',
      initialAttributes: {
        ref: reusableBlock.id
      },
      title: reusableBlock.title.raw,
      icon,
      category: 'reusable',
      keywords: ['reusable'],
      isDisabled: false,
      utility: 1,
      // Deprecated.
      frecency,
      content: reusableBlock.content.raw
    };
  };

  const syncedPatternInserterItems = canInsertBlockTypeUnmemoized(state, 'core/block', rootClientId) ? getReusableBlocks(state).filter(reusableBlock => // Reusable blocks that are fully synced should have no sync status set
  // for backwards compat between patterns and old reusable blocks, but
  // some in release 16.1 may have had sync status inadvertantly set to
  // 'fully' if created in the site editor.
  reusableBlock.wp_pattern_sync_status === 'fully' || reusableBlock.wp_pattern_sync_status === '' || !reusableBlock.wp_pattern_sync_status).map(buildReusableBlockInserterItem) : [];
  const buildBlockTypeInserterItem = buildBlockTypeItem(state, {
    buildScope: 'inserter'
  });
  const blockTypeInserterItems = (0,external_wp_blocks_namespaceObject.getBlockTypes)().filter(blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId)).map(buildBlockTypeInserterItem);
  const items = blockTypeInserterItems.reduce((accumulator, item) => {
    const {
      variations = []
    } = item; // Exclude any block type item that is to be replaced by a default variation.

    if (!variations.some(({
      isDefault
    }) => isDefault)) {
      accumulator.push(item);
    }

    if (variations.length) {
      const variationMapper = getItemFromVariation(state, item);
      accumulator.push(...variations.map(variationMapper));
    }

    return accumulator;
  }, []); // Ensure core blocks are prioritized in the returned results,
  // because third party blocks can be registered earlier than
  // the core blocks (usually by using the `init` action),
  // thus affecting the display order.
  // We don't sort reusable blocks as they are handled differently.

  const groupByType = (blocks, block) => {
    const {
      core,
      noncore
    } = blocks;
    const type = block.name.startsWith('core/') ? core : noncore;
    type.push(block);
    return blocks;
  };

  const {
    core: coreItems,
    noncore: nonCoreItems
  } = items.reduce(groupByType, {
    core: [],
    noncore: []
  });
  const sortedBlockTypes = [...coreItems, ...nonCoreItems];
  return [...sortedBlockTypes, ...syncedPatternInserterItems];
}, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.blocks.order, state.preferences.insertUsage, state.settings.allowedBlockTypes, state.settings.templateLock, getReusableBlocks(state), (0,external_wp_blocks_namespaceObject.getBlockTypes)()]);
/**
 * Determines the items that appear in the available block transforms list.
 *
 * Each item object contains what's necessary to display a menu item in the
 * transform list and handle its selection.
 *
 * The 'frecency' property is a heuristic (https://en.wikipedia.org/wiki/Frecency)
 * that combines block usage frequenty and recency.
 *
 * Items are returned ordered descendingly by their 'frecency'.
 *
 * @param    {Object}          state        Editor state.
 * @param    {Object|Object[]} blocks       Block object or array objects.
 * @param    {?string}         rootClientId Optional root client ID of block list.
 *
 * @return {WPEditorTransformItem[]} Items that appear in inserter.
 *
 * @typedef {Object} WPEditorTransformItem
 * @property {string}          id           Unique identifier for the item.
 * @property {string}          name         The type of block to create.
 * @property {string}          title        Title of the item, as it appears in the inserter.
 * @property {string}          icon         Dashicon for the item, as it appears in the inserter.
 * @property {boolean}         isDisabled   Whether or not the user should be prevented from inserting
 *                                          this item.
 * @property {number}          frecency     Heuristic that combines frequency and recency.
 */

const getBlockTransformItems = rememo((state, blocks, rootClientId = null) => {
  const normalizedBlocks = Array.isArray(blocks) ? blocks : [blocks];
  const buildBlockTypeTransformItem = buildBlockTypeItem(state, {
    buildScope: 'transform'
  });
  const blockTypeTransformItems = (0,external_wp_blocks_namespaceObject.getBlockTypes)().filter(blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId)).map(buildBlockTypeTransformItem);
  const itemsByName = Object.fromEntries(Object.entries(blockTypeTransformItems).map(([, value]) => [value.name, value]));
  const possibleTransforms = (0,external_wp_blocks_namespaceObject.getPossibleBlockTransformations)(normalizedBlocks).reduce((accumulator, block) => {
    if (itemsByName[block?.name]) {
      accumulator.push(itemsByName[block.name]);
    }

    return accumulator;
  }, []);
  return orderBy(possibleTransforms, block => itemsByName[block.name].frecency, 'desc');
}, (state, blocks, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.preferences.insertUsage, state.settings.allowedBlockTypes, state.settings.templateLock, (0,external_wp_blocks_namespaceObject.getBlockTypes)()]);
/**
 * Determines whether there are items to show in the inserter.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Items that appear in inserter.
 */

const hasInserterItems = rememo((state, rootClientId = null) => {
  const hasBlockType = (0,external_wp_blocks_namespaceObject.getBlockTypes)().some(blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId));

  if (hasBlockType) {
    return true;
  }

  const hasReusableBlock = canInsertBlockTypeUnmemoized(state, 'core/block', rootClientId) && getReusableBlocks(state).length > 0;
  return hasReusableBlock;
}, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.settings.allowedBlockTypes, state.settings.templateLock, getReusableBlocks(state), (0,external_wp_blocks_namespaceObject.getBlockTypes)()]);
/**
 * Returns the list of allowed inserter blocks for inner blocks children.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Array?} The list of allowed block types.
 */

const getAllowedBlocks = rememo((state, rootClientId = null) => {
  if (!rootClientId) {
    return;
  }

  return (0,external_wp_blocks_namespaceObject.getBlockTypes)().filter(blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId));
}, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.settings.allowedBlockTypes, state.settings.templateLock, (0,external_wp_blocks_namespaceObject.getBlockTypes)()]);
const __experimentalGetAllowedBlocks = rememo((state, rootClientId = null) => {
  external_wp_deprecated_default()('wp.data.select( "core/block-editor" ).__experimentalGetAllowedBlocks', {
    alternative: 'wp.data.select( "core/block-editor" ).getAllowedBlocks',
    since: '6.2',
    version: '6.4'
  });
  return getAllowedBlocks(state, rootClientId);
}, (state, rootClientId) => [...getAllowedBlocks.getDependants(state, rootClientId)]);
/**
 * Returns the block to be directly inserted by the block appender.
 *
 * @param    {Object}         state            Editor state.
 * @param    {?string}        rootClientId     Optional root client ID of block list.
 *
 * @return {?WPDirectInsertBlock}              The block type to be directly inserted.
 *
 * @typedef {Object} WPDirectInsertBlock
 * @property {string}         name             The type of block.
 * @property {?Object}        attributes       Attributes to pass to the newly created block.
 * @property {?Array<string>} attributesToCopy Attributes to be copied from adjecent blocks when inserted.
 */

const __experimentalGetDirectInsertBlock = rememo((state, rootClientId = null) => {
  if (!rootClientId) {
    return;
  }

  const defaultBlock = state.blockListSettings[rootClientId]?.__experimentalDefaultBlock;
  const directInsert = state.blockListSettings[rootClientId]?.__experimentalDirectInsert;

  if (!defaultBlock || !directInsert) {
    return;
  }

  if (typeof directInsert === 'function') {
    return directInsert(getBlock(state, rootClientId)) ? defaultBlock : null;
  }

  return defaultBlock;
}, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.tree.get(rootClientId)]);

const checkAllowListRecursive = (blocks, allowedBlockTypes) => {
  if (typeof allowedBlockTypes === 'boolean') {
    return allowedBlockTypes;
  }

  const blocksQueue = [...blocks];

  while (blocksQueue.length > 0) {
    const block = blocksQueue.shift();
    const isAllowed = checkAllowList(allowedBlockTypes, block.name || block.blockName, true);

    if (!isAllowed) {
      return false;
    }

    block.innerBlocks?.forEach(innerBlock => {
      blocksQueue.push(innerBlock);
    });
  }

  return true;
};

function getUnsyncedPatterns(state) {
  var _state$settings$__exp;

  const reusableBlocks = (_state$settings$__exp = state?.settings?.__experimentalReusableBlocks) !== null && _state$settings$__exp !== void 0 ? _state$settings$__exp : EMPTY_ARRAY;
  return reusableBlocks.filter(reusableBlock => reusableBlock.wp_pattern_sync_status === 'unsynced').map(reusableBlock => {
    return {
      name: `core/block/${reusableBlock.id}`,
      title: reusableBlock.title.raw,
      categories: ['custom'],
      content: reusableBlock.content.raw
    };
  });
}

const __experimentalGetParsedPattern = rememo((state, patternName) => {
  const patterns = state.settings.__experimentalBlockPatterns;
  const unsyncedPatterns = getUnsyncedPatterns(state);
  const pattern = [...patterns, ...unsyncedPatterns].find(({
    name
  }) => name === patternName);

  if (!pattern) {
    return null;
  }

  return { ...pattern,
    blocks: (0,external_wp_blocks_namespaceObject.parse)(pattern.content, {
      __unstableSkipMigrationLogs: true
    })
  };
}, state => [state.settings.__experimentalBlockPatterns, state.settings.__experimentalReusableBlocks]);
const getAllAllowedPatterns = rememo(state => {
  const patterns = state.settings.__experimentalBlockPatterns;
  const unsyncedPatterns = getUnsyncedPatterns(state);
  const {
    allowedBlockTypes
  } = getSettings(state);
  const parsedPatterns = [...patterns, ...unsyncedPatterns].filter(({
    inserter = true
  }) => !!inserter).map(({
    name
  }) => __experimentalGetParsedPattern(state, name));
  const allowedPatterns = parsedPatterns.filter(({
    blocks
  }) => checkAllowListRecursive(blocks, allowedBlockTypes));
  return allowedPatterns;
}, state => [state.settings.__experimentalBlockPatterns, state.settings.__experimentalReusableBlocks, state.settings.allowedBlockTypes]);
/**
 * Returns the list of allowed patterns for inner blocks children.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional target root client ID.
 *
 * @return {Array?} The list of allowed patterns.
 */

const __experimentalGetAllowedPatterns = rememo((state, rootClientId = null) => {
  const availableParsedPatterns = getAllAllowedPatterns(state);
  const patternsAllowed = availableParsedPatterns.filter(({
    blocks
  }) => blocks.every(({
    name
  }) => canInsertBlockType(state, name, rootClientId)));
  return patternsAllowed;
}, (state, rootClientId) => [state.settings.__experimentalBlockPatterns, state.settings.__experimentalReusableBlocks, state.settings.allowedBlockTypes, state.settings.templateLock, state.blockListSettings[rootClientId], state.blocks.byClientId.get(rootClientId)]);
/**
 * Returns the list of patterns based on their declared `blockTypes`
 * and a block's name.
 * Patterns can use `blockTypes` to integrate in work flows like
 * suggesting appropriate patterns in a Placeholder state(during insertion)
 * or blocks transformations.
 *
 * @param {Object}          state        Editor state.
 * @param {string|string[]} blockNames   Block's name or array of block names to find matching pattens.
 * @param {?string}         rootClientId Optional target root client ID.
 *
 * @return {Array} The list of matched block patterns based on declared `blockTypes` and block name.
 */

const getPatternsByBlockTypes = rememo((state, blockNames, rootClientId = null) => {
  if (!blockNames) return EMPTY_ARRAY;

  const patterns = __experimentalGetAllowedPatterns(state, rootClientId);

  const normalizedBlockNames = Array.isArray(blockNames) ? blockNames : [blockNames];
  const filteredPatterns = patterns.filter(pattern => pattern?.blockTypes?.some?.(blockName => normalizedBlockNames.includes(blockName)));

  if (filteredPatterns.length === 0) {
    return EMPTY_ARRAY;
  }

  return filteredPatterns;
}, (state, blockNames, rootClientId) => [...__experimentalGetAllowedPatterns.getDependants(state, rootClientId)]);
const __experimentalGetPatternsByBlockTypes = rememo((state, blockNames, rootClientId = null) => {
  external_wp_deprecated_default()('wp.data.select( "core/block-editor" ).__experimentalGetPatternsByBlockTypes', {
    alternative: 'wp.data.select( "core/block-editor" ).getPatternsByBlockTypes',
    since: '6.2',
    version: '6.4'
  });
  return getPatternsByBlockTypes(state, blockNames, rootClientId);
}, (state, blockNames, rootClientId) => [...__experimentalGetAllowedPatterns.getDependants(state, rootClientId)]);
/**
 * Determines the items that appear in the available pattern transforms list.
 *
 * For now we only handle blocks without InnerBlocks and take into account
 * the `__experimentalRole` property of blocks' attributes for the transformation.
 *
 * We return the first set of possible eligible block patterns,
 * by checking the `blockTypes` property. We still have to recurse through
 * block pattern's blocks and try to find matches from the selected blocks.
 * Now this happens in the consumer to avoid heavy operations in the selector.
 *
 * @param {Object}   state        Editor state.
 * @param {Object[]} blocks       The selected blocks.
 * @param {?string}  rootClientId Optional root client ID of block list.
 *
 * @return {WPBlockPattern[]} Items that are eligible for a pattern transformation.
 */

const __experimentalGetPatternTransformItems = rememo((state, blocks, rootClientId = null) => {
  if (!blocks) return EMPTY_ARRAY;
  /**
   * For now we only handle blocks without InnerBlocks and take into account
   * the `__experimentalRole` property of blocks' attributes for the transformation.
   * Note that the blocks have been retrieved through `getBlock`, which doesn't
   * return the inner blocks of an inner block controller, so we still need
   * to check for this case too.
   */

  if (blocks.some(({
    clientId,
    innerBlocks
  }) => innerBlocks.length || areInnerBlocksControlled(state, clientId))) {
    return EMPTY_ARRAY;
  } // Create a Set of the selected block names that is used in patterns filtering.


  const selectedBlockNames = Array.from(new Set(blocks.map(({
    name
  }) => name)));
  /**
   * Here we will return first set of possible eligible block patterns,
   * by checking the `blockTypes` property. We still have to recurse through
   * block pattern's blocks and try to find matches from the selected blocks.
   * Now this happens in the consumer to avoid heavy operations in the selector.
   */

  return getPatternsByBlockTypes(state, selectedBlockNames, rootClientId);
}, (state, blocks, rootClientId) => [...getPatternsByBlockTypes.getDependants(state, rootClientId)]);
/**
 * Returns the Block List settings of a block, if any exist.
 *
 * @param {Object}  state    Editor state.
 * @param {?string} clientId Block client ID.
 *
 * @return {?Object} Block settings of the block if set.
 */

function getBlockListSettings(state, clientId) {
  return state.blockListSettings[clientId];
}
/**
 * Returns the editor settings.
 *
 * @param {Object} state Editor state.
 *
 * @return {Object} The editor settings object.
 */

function getSettings(state) {
  return state.settings;
}
/**
 * Returns the behaviors registered with the editor.
 *
 * Behaviors are named, reusable pieces of functionality that can be
 * attached to blocks. They are registered with the editor using the
 * `theme.json` file.
 *
 * @example
 *
 * ```js
 * const behaviors = select( blockEditorStore ).getBehaviors();
 * if ( behaviors?.lightbox ) {
 * 	 // Do something with the lightbox.
 * }
 *```
 *
 * @param {Object} state Editor state.
 *
 * @return {Object} The editor behaviors object.
 */

function getBehaviors(state) {
  return state.settings.behaviors;
}
/**
 * Returns true if the most recent block change is be considered persistent, or
 * false otherwise. A persistent change is one committed by BlockEditorProvider
 * via its `onChange` callback, in addition to `onInput`.
 *
 * @param {Object} state Block editor state.
 *
 * @return {boolean} Whether the most recent block change was persistent.
 */

function isLastBlockChangePersistent(state) {
  return state.blocks.isPersistentChange;
}
/**
 * Returns the block list settings for an array of blocks, if any exist.
 *
 * @param {Object} state     Editor state.
 * @param {Array}  clientIds Block client IDs.
 *
 * @return {Object} An object where the keys are client ids and the values are
 *                  a block list setting object.
 */

const __experimentalGetBlockListSettingsForBlocks = rememo((state, clientIds = []) => {
  return clientIds.reduce((blockListSettingsForBlocks, clientId) => {
    if (!state.blockListSettings[clientId]) {
      return blockListSettingsForBlocks;
    }

    return { ...blockListSettingsForBlocks,
      [clientId]: state.blockListSettings[clientId]
    };
  }, {});
}, state => [state.blockListSettings]);
/**
 * Returns the title of a given reusable block
 *
 * @param {Object}        state Global application state.
 * @param {number|string} ref   The shared block's ID.
 *
 * @return {string} The reusable block saved title.
 */

const __experimentalGetReusableBlockTitle = rememo((state, ref) => {
  const reusableBlock = getReusableBlocks(state).find(block => block.id === ref);

  if (!reusableBlock) {
    return null;
  }

  return reusableBlock.title?.raw;
}, state => [getReusableBlocks(state)]);
/**
 * Returns true if the most recent block change is be considered ignored, or
 * false otherwise. An ignored change is one not to be committed by
 * BlockEditorProvider, neither via `onChange` nor `onInput`.
 *
 * @param {Object} state Block editor state.
 *
 * @return {boolean} Whether the most recent block change was ignored.
 */

function __unstableIsLastBlockChangeIgnored(state) {
  // TODO: Removal Plan: Changes incurred by RECEIVE_BLOCKS should not be
  // ignored if in-fact they result in a change in blocks state. The current
  // need to ignore changes not a result of user interaction should be
  // accounted for in the refactoring of reusable blocks as occurring within
  // their own separate block editor / state (#7119).
  return state.blocks.isIgnoredChange;
}
/**
 * Returns the block attributes changed as a result of the last dispatched
 * action.
 *
 * @param {Object} state Block editor state.
 *
 * @return {Object<string,Object>} Subsets of block attributes changed, keyed
 *                                 by block client ID.
 */

function __experimentalGetLastBlockAttributeChanges(state) {
  return state.lastBlockAttributesChange;
}
/**
 * Returns the available reusable blocks
 *
 * @param {Object} state Global application state.
 *
 * @return {Array} Reusable blocks
 */

function getReusableBlocks(state) {
  var _state$settings$__exp2;

  return (_state$settings$__exp2 = state?.settings?.__experimentalReusableBlocks) !== null && _state$settings$__exp2 !== void 0 ? _state$settings$__exp2 : EMPTY_ARRAY;
}
/**
 * Returns whether the navigation mode is enabled.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Is navigation mode enabled.
 */


function isNavigationMode(state) {
  return state.editorMode === 'navigation';
}
/**
 * Returns the current editor mode.
 *
 * @param {Object} state Editor state.
 *
 * @return {string} the editor mode.
 */

function __unstableGetEditorMode(state) {
  return state.editorMode;
}
/**
 * Returns whether block moving mode is enabled.
 *
 * @param {Object} state Editor state.
 *
 * @return {string} Client Id of moving block.
 */

function selectors_hasBlockMovingClientId(state) {
  return state.hasBlockMovingClientId;
}
/**
 * Returns true if the last change was an automatic change, false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether the last change was automatic.
 */

function didAutomaticChange(state) {
  return !!state.automaticChangeStatus;
}
/**
 * Returns true if the current highlighted block matches the block clientId.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId The block to check.
 *
 * @return {boolean} Whether the block is currently highlighted.
 */

function isBlockHighlighted(state, clientId) {
  return state.highlightedBlock === clientId;
}
/**
 * Checks if a given block has controlled inner blocks.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId The block to check.
 *
 * @return {boolean} True if the block has controlled inner blocks.
 */

function areInnerBlocksControlled(state, clientId) {
  return !!state.blocks.controlledInnerBlocks[clientId];
}
/**
 * Returns the clientId for the first 'active' block of a given array of block names.
 * A block is 'active' if it (or a child) is the selected block.
 * Returns the first match moving up the DOM from the selected block.
 *
 * @param {Object}   state            Global application state.
 * @param {string[]} validBlocksNames The names of block types to check for.
 *
 * @return {string} The matching block's clientId.
 */

const __experimentalGetActiveBlockIdByBlockNames = rememo((state, validBlockNames) => {
  if (!validBlockNames.length) {
    return null;
  } // Check if selected block is a valid entity area.


  const selectedBlockClientId = getSelectedBlockClientId(state);

  if (validBlockNames.includes(getBlockName(state, selectedBlockClientId))) {
    return selectedBlockClientId;
  } // Check if first selected block is a child of a valid entity area.


  const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds(state);
  const entityAreaParents = getBlockParentsByBlockName(state, selectedBlockClientId || multiSelectedBlockClientIds[0], validBlockNames);

  if (entityAreaParents) {
    // Last parent closest/most interior.
    return entityAreaParents[entityAreaParents.length - 1];
  }

  return null;
}, (state, validBlockNames) => [state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId, validBlockNames]);
/**
 * Tells if the block with the passed clientId was just inserted.
 *
 * @param {Object}  state    Global application state.
 * @param {Object}  clientId Client Id of the block.
 * @param {?string} source   Optional insertion source of the block.
 * @return {boolean} True if the block matches the last block inserted from the specified source.
 */

function wasBlockJustInserted(state, clientId, source) {
  const {
    lastBlockInserted
  } = state;
  return lastBlockInserted.clientIds?.includes(clientId) && lastBlockInserted.source === source;
}
/**
 * Tells if the block is visible on the canvas or not.
 *
 * @param {Object} state    Global application state.
 * @param {Object} clientId Client Id of the block.
 * @return {boolean} True if the block is visible.
 */

function isBlockVisible(state, clientId) {
  var _state$blockVisibilit;

  return (_state$blockVisibilit = state.blockVisibility?.[clientId]) !== null && _state$blockVisibilit !== void 0 ? _state$blockVisibilit : true;
}
/**
 * Returns the list of all hidden blocks.
 *
 * @param {Object} state Global application state.
 * @return {[string]} List of hidden blocks.
 */

const __unstableGetVisibleBlocks = rememo(state => {
  const visibleBlocks = new Set(Object.keys(state.blockVisibility).filter(key => state.blockVisibility[key]));

  if (visibleBlocks.size === 0) {
    return EMPTY_SET;
  }

  return visibleBlocks;
}, state => [state.blockVisibility]);
/**
 * DO-NOT-USE in production.
 * This selector is created for internal/experimental only usage and may be
 * removed anytime without any warning, causing breakage on any plugin or theme invoking it.
 */

const __unstableGetContentLockingParent = rememo((state, clientId) => {
  let current = clientId;
  let result;

  while (state.blocks.parents.has(current)) {
    current = state.blocks.parents.get(current);

    if (current && getTemplateLock(state, current) === 'contentOnly') {
      result = current;
    }
  }

  return result;
}, state => [state.blocks.parents, state.blockListSettings]);
/**
 * DO-NOT-USE in production.
 * This selector is created for internal/experimental only usage and may be
 * removed anytime without any warning, causing breakage on any plugin or theme invoking it.
 *
 * @param {Object} state Global application state.
 */

function __unstableGetTemporarilyEditingAsBlocks(state) {
  return state.temporarilyEditingAsBlocks;
}
function __unstableHasActiveBlockOverlayActive(state, clientId) {
  // Prevent overlay on blocks with a non-default editing mode. If the mdoe is
  // 'disabled' then the overlay is redundant since the block can't be
  // selected. If the mode is 'contentOnly' then the overlay is redundant
  // since there will be no controls to interact with once selected.
  if (getBlockEditingMode(state, clientId) !== 'default') {
    return false;
  } // If the block editing is locked, the block overlay is always active.


  if (!canEditBlock(state, clientId)) {
    return true;
  }

  const editorMode = __unstableGetEditorMode(state); // In zoom-out mode, the block overlay is always active for top level blocks.


  if (editorMode === 'zoom-out' && clientId && !getBlockRootClientId(state, clientId)) {
    return true;
  } // In navigation mode, the block overlay is active when the block is not
  // selected (and doesn't contain a selected child). The same behavior is
  // also enabled in all modes for blocks that have controlled children
  // (reusable block, template part, navigation), unless explicitly disabled
  // with `supports.__experimentalDisableBlockOverlay`.


  const blockSupportDisable = (0,external_wp_blocks_namespaceObject.hasBlockSupport)(getBlockName(state, clientId), '__experimentalDisableBlockOverlay', false);
  const shouldEnableIfUnselected = editorMode === 'navigation' || (blockSupportDisable ? false : areInnerBlocksControlled(state, clientId));
  return shouldEnableIfUnselected && !isBlockSelected(state, clientId) && !hasSelectedInnerBlock(state, clientId, true);
}
function __unstableIsWithinBlockOverlay(state, clientId) {
  let parent = state.blocks.parents.get(clientId);

  while (!!parent) {
    if (__unstableHasActiveBlockOverlayActive(state, parent)) {
      return true;
    }

    parent = state.blocks.parents.get(parent);
  }

  return false;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/store/private-actions.js
/**
 * WordPress dependencies
 */


const castArray = maybeArray => Array.isArray(maybeArray) ? maybeArray : [maybeArray];
/**
 * A list of private/experimental block editor settings that
 * should not become a part of the WordPress public API.
 * BlockEditorProvider will remove these settings from the
 * settings object it receives.
 *
 * @see https://github.com/WordPress/gutenberg/pull/46131
 */


const privateSettings = ['inserterMediaCategories', 'blockInspectorAnimation'];
/**
 * Action that updates the block editor settings and
 * conditionally preserves the experimental ones.
 *
 * @param {Object}  settings                  Updated settings
 * @param {boolean} stripExperimentalSettings Whether to strip experimental settings.
 * @return {Object} Action object
 */

function __experimentalUpdateSettings(settings, stripExperimentalSettings = false) {
  let cleanSettings = settings; // There are no plugins in the mobile apps, so there is no
  // need to strip the experimental settings:

  if (stripExperimentalSettings && external_wp_element_namespaceObject.Platform.OS === 'web') {
    cleanSettings = {};

    for (const key in settings) {
      if (!privateSettings.includes(key)) {
        cleanSettings[key] = settings[key];
      }
    }
  }

  return {
    type: 'UPDATE_SETTINGS',
    settings: cleanSettings
  };
}
/**
 * Hides the block interface (eg. toolbar, outline, etc.)
 *
 * @return {Object} Action object.
 */

function hideBlockInterface() {
  return {
    type: 'HIDE_BLOCK_INTERFACE'
  };
}
/**
 * Shows the block interface (eg. toolbar, outline, etc.)
 *
 * @return {Object} Action object.
 */

function showBlockInterface() {
  return {
    type: 'SHOW_BLOCK_INTERFACE'
  };
}
/**
 * @typedef {import('../components/block-editing-mode').BlockEditingMode} BlockEditingMode
 */

/**
 * Sets the block editing mode for a given block.
 *
 * @see useBlockEditingMode
 *
 * @param {string}           clientId The block client ID, or `''` for the root container.
 * @param {BlockEditingMode} mode     The block editing mode. One of `'disabled'`,
 *                                    `'contentOnly'`, or `'default'`.
 *
 * @return {Object} Action object.
 */

function setBlockEditingMode(clientId = '', mode) {
  return {
    type: 'SET_BLOCK_EDITING_MODE',
    clientId,
    mode
  };
}
/**
 * Clears the block editing mode for a given block.
 *
 * @see useBlockEditingMode
 *
 * @param {string} clientId The block client ID, or `''` for the root container.
 *
 * @return {Object} Action object.
 */

function unsetBlockEditingMode(clientId = '') {
  return {
    type: 'UNSET_BLOCK_EDITING_MODE',
    clientId
  };
}
/**
 * Yields action objects used in signalling that the blocks corresponding to
 * the set of specified client IDs are to be removed.
 *
 * Compared to `removeBlocks`, this private interface exposes an additional
 * parameter; see `forceRemove`.
 *
 * @param {string|string[]} clientIds      Client IDs of blocks to remove.
 * @param {boolean}         selectPrevious True if the previous block
 *                                         or the immediate parent
 *                                         (if no previous block exists)
 *                                         should be selected
 *                                         when a block is removed.
 * @param {boolean}         forceRemove    Whether to force the operation,
 *                                         bypassing any checks for certain
 *                                         block types.
 */

const privateRemoveBlocks = (clientIds, selectPrevious = true, forceRemove = false) => ({
  select,
  dispatch
}) => {
  if (!clientIds || !clientIds.length) {
    return;
  }

  clientIds = castArray(clientIds);
  const rootClientId = select.getBlockRootClientId(clientIds[0]);
  const canRemoveBlocks = select.canRemoveBlocks(clientIds, rootClientId);

  if (!canRemoveBlocks) {
    return;
  } // In certain editing contexts, we'd like to prevent accidental removal
  // of important blocks. For example, in the site editor, the Query Loop
  // block is deemed important. In such cases, we'll ask the user for
  // confirmation that they intended to remove such block(s). However,
  // the editor instance is responsible for presenting those confirmation
  // prompts to the user. Any instance opting into removal prompts must
  // register using `setBlockRemovalRules()`.
  //
  // @see https://github.com/WordPress/gutenberg/pull/51145


  const rules = !forceRemove && select.getBlockRemovalRules();

  if (rules) {
    const blockNamesForPrompt = new Set(); // Given a list of client IDs of blocks that the user intended to
    // remove, perform a tree search (BFS) to find all block names
    // corresponding to "important" blocks, i.e. blocks that require a
    // removal prompt.

    const queue = [...clientIds];

    while (queue.length) {
      const clientId = queue.shift();
      const blockName = select.getBlockName(clientId);

      if (rules[blockName]) {
        blockNamesForPrompt.add(blockName);
      }

      const innerBlocks = select.getBlockOrder(clientId);
      queue.push(...innerBlocks);
    } // If any such blocks were found, trigger the removal prompt and
    // skip any other steps (thus postponing actual removal).


    if (blockNamesForPrompt.size) {
      dispatch(displayBlockRemovalPrompt(clientIds, selectPrevious, Array.from(blockNamesForPrompt)));
      return;
    }
  }

  if (selectPrevious) {
    dispatch.selectPreviousBlock(clientIds[0], selectPrevious);
  }

  dispatch({
    type: 'REMOVE_BLOCKS',
    clientIds
  }); // To avoid a focus loss when removing the last block, assure there is
  // always a default block if the last of the blocks have been removed.

  dispatch(ensureDefaultBlock());
};
/**
 * Action which will insert a default block insert action if there
 * are no other blocks at the root of the editor. This action should be used
 * in actions which may result in no blocks remaining in the editor (removal,
 * replacement, etc).
 */

const ensureDefaultBlock = () => ({
  select,
  dispatch
}) => {
  // To avoid a focus loss when removing the last block, assure there is
  // always a default block if the last of the blocks have been removed.
  const count = select.getBlockCount();

  if (count > 0) {
    return;
  } // If there's an custom appender, don't insert default block.
  // We have to remember to manually move the focus elsewhere to
  // prevent it from being lost though.


  const {
    __unstableHasCustomAppender
  } = select.getSettings();

  if (__unstableHasCustomAppender) {
    return;
  }

  dispatch.insertDefaultBlock();
};
/**
 * Returns an action object used in signalling that a block removal prompt must
 * be displayed.
 *
 * Contrast with `setBlockRemovalRules`.
 *
 * @param {string|string[]} clientIds           Client IDs of blocks to remove.
 * @param {boolean}         selectPrevious      True if the previous block
 *                                              or the immediate parent
 *                                              (if no previous block exists)
 *                                              should be selected
 *                                              when a block is removed.
 * @param {string[]}        blockNamesForPrompt Names of the blocks that
 *                                              triggered the need for
 *                                              confirmation before removal.
 *
 * @return {Object} Action object.
 */

function displayBlockRemovalPrompt(clientIds, selectPrevious, blockNamesForPrompt) {
  return {
    type: 'DISPLAY_BLOCK_REMOVAL_PROMPT',
    clientIds,
    selectPrevious,
    blockNamesForPrompt
  };
}
/**
 * Returns an action object used in signalling that a block removal prompt must
 * be cleared, either be cause the user has confirmed or canceled the request
 * for removal.
 *
 * @return {Object} Action object.
 */


function clearBlockRemovalPrompt() {
  return {
    type: 'CLEAR_BLOCK_REMOVAL_PROMPT'
  };
}
/**
 * Returns an action object used to set up any rules that a block editor may
 * provide in order to prevent a user from accidentally removing certain
 * blocks. These rules are then used to display a confirmation prompt to the
 * user. For instance, in the Site Editor, the Query Loop block is important
 * enough to warrant such confirmation.
 *
 * IMPORTANT: Registering rules implicitly signals to the `privateRemoveBlocks`
 * action that the editor will be responsible for displaying block removal
 * prompts and confirming deletions. This action is meant to be used by
 * component `BlockRemovalWarningModal` only.
 *
 * The data is a record whose keys are block types (e.g. 'core/query') and
 * whose values are the explanation to be shown to users (e.g. 'Query Loop
 * displays a list of posts or pages.').
 *
 * Contrast with `displayBlockRemovalPrompt`.
 *
 * @param {Record<string,string>|false} rules Block removal rules.
 * @return {Object} Action object.
 */

function setBlockRemovalRules(rules = false) {
  return {
    type: 'SET_BLOCK_REMOVAL_RULES',
    rules
  };
}

;// CONCATENATED MODULE: external ["wp","a11y"]
var external_wp_a11y_namespaceObject = window["wp"]["a11y"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/selection.js
/**
 * A robust way to retain selection position through various
 * transforms is to insert a special character at the position and
 * then recover it.
 */
const START_OF_SELECTED_AREA = '\u0086';
/**
 * Retrieve the block attribute that contains the selection position.
 *
 * @param {Object} blockAttributes Block attributes.
 * @return {string|void} The name of the block attribute that was previously selected.
 */

function retrieveSelectedAttribute(blockAttributes) {
  if (!blockAttributes) {
    return;
  }

  return Object.keys(blockAttributes).find(name => {
    const value = blockAttributes[name];
    return typeof value === 'string' && value.indexOf(START_OF_SELECTED_AREA) !== -1;
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/store/actions.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




/** @typedef {import('../components/use-on-block-drop/types').WPDropOperation} WPDropOperation */

const actions_castArray = maybeArray => Array.isArray(maybeArray) ? maybeArray : [maybeArray];
/**
 * Action that resets blocks state to the specified array of blocks, taking precedence
 * over any other content reflected as an edit in state.
 *
 * @param {Array} blocks Array of blocks.
 */


const resetBlocks = blocks => ({
  dispatch
}) => {
  dispatch({
    type: 'RESET_BLOCKS',
    blocks
  });
  dispatch(validateBlocksToTemplate(blocks));
};
/**
 * Block validity is a function of blocks state (at the point of a
 * reset) and the template setting. As a compromise to its placement
 * across distinct parts of state, it is implemented here as a side
 * effect of the block reset action.
 *
 * @param {Array} blocks Array of blocks.
 */

const validateBlocksToTemplate = blocks => ({
  select,
  dispatch
}) => {
  const template = select.getTemplate();
  const templateLock = select.getTemplateLock(); // Unlocked templates are considered always valid because they act
  // as default values only.

  const isBlocksValidToTemplate = !template || templateLock !== 'all' || (0,external_wp_blocks_namespaceObject.doBlocksMatchTemplate)(blocks, template); // Update if validity has changed.

  const isValidTemplate = select.isValidTemplate();

  if (isBlocksValidToTemplate !== isValidTemplate) {
    dispatch.setTemplateValidity(isBlocksValidToTemplate);
    return isBlocksValidToTemplate;
  }
};
/**
 * A block selection object.
 *
 * @typedef {Object} WPBlockSelection
 *
 * @property {string} clientId     A block client ID.
 * @property {string} attributeKey A block attribute key.
 * @property {number} offset       An attribute value offset, based on the rich
 *                                 text value. See `wp.richText.create`.
 */

/**
 * A selection object.
 *
 * @typedef {Object} WPSelection
 *
 * @property {WPBlockSelection} start The selection start.
 * @property {WPBlockSelection} end   The selection end.
 */

/* eslint-disable jsdoc/valid-types */

/**
 * Returns an action object used in signalling that selection state should be
 * reset to the specified selection.
 *
 * @param {WPBlockSelection} selectionStart  The selection start.
 * @param {WPBlockSelection} selectionEnd    The selection end.
 * @param {0|-1|null}        initialPosition Initial block position.
 *
 * @return {Object} Action object.
 */

function resetSelection(selectionStart, selectionEnd, initialPosition) {
  /* eslint-enable jsdoc/valid-types */
  return {
    type: 'RESET_SELECTION',
    selectionStart,
    selectionEnd,
    initialPosition
  };
}
/**
 * Returns an action object used in signalling that blocks have been received.
 * Unlike resetBlocks, these should be appended to the existing known set, not
 * replacing.
 *
 * @deprecated
 *
 * @param {Object[]} blocks Array of block objects.
 *
 * @return {Object} Action object.
 */

function receiveBlocks(blocks) {
  external_wp_deprecated_default()('wp.data.dispatch( "core/block-editor" ).receiveBlocks', {
    since: '5.9',
    alternative: 'resetBlocks or insertBlocks'
  });
  return {
    type: 'RECEIVE_BLOCKS',
    blocks
  };
}
/**
 * Action that updates attributes of multiple blocks with the specified client IDs.
 *
 * @param {string|string[]} clientIds     Block client IDs.
 * @param {Object}          attributes    Block attributes to be merged. Should be keyed by clientIds if
 *                                        uniqueByBlock is true.
 * @param {boolean}         uniqueByBlock true if each block in clientIds array has a unique set of attributes
 * @return {Object} Action object.
 */

function updateBlockAttributes(clientIds, attributes, uniqueByBlock = false) {
  return {
    type: 'UPDATE_BLOCK_ATTRIBUTES',
    clientIds: actions_castArray(clientIds),
    attributes,
    uniqueByBlock
  };
}
/**
 * Action that updates the block with the specified client ID.
 *
 * @param {string} clientId Block client ID.
 * @param {Object} updates  Block attributes to be merged.
 *
 * @return {Object} Action object.
 */

function updateBlock(clientId, updates) {
  return {
    type: 'UPDATE_BLOCK',
    clientId,
    updates
  };
}
/* eslint-disable jsdoc/valid-types */

/**
 * Returns an action object used in signalling that the block with the
 * specified client ID has been selected, optionally accepting a position
 * value reflecting its selection directionality. An initialPosition of -1
 * reflects a reverse selection.
 *
 * @param {string}    clientId        Block client ID.
 * @param {0|-1|null} initialPosition Optional initial position. Pass as -1 to
 *                                    reflect reverse selection.
 *
 * @return {Object} Action object.
 */

function selectBlock(clientId, initialPosition = 0) {
  /* eslint-enable jsdoc/valid-types */
  return {
    type: 'SELECT_BLOCK',
    initialPosition,
    clientId
  };
}
/**
 * Yields action objects used in signalling that the block preceding the given
 * clientId (or optionally, its first parent from bottom to top)
 * should be selected.
 *
 * @param {string}  clientId         Block client ID.
 * @param {boolean} fallbackToParent If true, select the first parent if there is no previous block.
 */

const selectPreviousBlock = (clientId, fallbackToParent = false) => ({
  select,
  dispatch
}) => {
  const previousBlockClientId = select.getPreviousBlockClientId(clientId);

  if (previousBlockClientId) {
    dispatch.selectBlock(previousBlockClientId, -1);
  } else if (fallbackToParent) {
    const firstParentClientId = select.getBlockRootClientId(clientId);

    if (firstParentClientId) {
      dispatch.selectBlock(firstParentClientId, -1);
    }
  }
};
/**
 * Yields action objects used in signalling that the block following the given
 * clientId should be selected.
 *
 * @param {string} clientId Block client ID.
 */

const selectNextBlock = clientId => ({
  select,
  dispatch
}) => {
  const nextBlockClientId = select.getNextBlockClientId(clientId);

  if (nextBlockClientId) {
    dispatch.selectBlock(nextBlockClientId);
  }
};
/**
 * Action that starts block multi-selection.
 *
 * @return {Object} Action object.
 */

function startMultiSelect() {
  return {
    type: 'START_MULTI_SELECT'
  };
}
/**
 * Action that stops block multi-selection.
 *
 * @return {Object} Action object.
 */

function stopMultiSelect() {
  return {
    type: 'STOP_MULTI_SELECT'
  };
}
/**
 * Action that changes block multi-selection.
 *
 * @param {string}      start                         First block of the multi selection.
 * @param {string}      end                           Last block of the multiselection.
 * @param {number|null} __experimentalInitialPosition Optional initial position. Pass as null to skip focus within editor canvas.
 */

const multiSelect = (start, end, __experimentalInitialPosition = 0) => ({
  select,
  dispatch
}) => {
  const startBlockRootClientId = select.getBlockRootClientId(start);
  const endBlockRootClientId = select.getBlockRootClientId(end); // Only allow block multi-selections at the same level.

  if (startBlockRootClientId !== endBlockRootClientId) {
    return;
  }

  dispatch({
    type: 'MULTI_SELECT',
    start,
    end,
    initialPosition: __experimentalInitialPosition
  });
  const blockCount = select.getSelectedBlockCount();
  (0,external_wp_a11y_namespaceObject.speak)((0,external_wp_i18n_namespaceObject.sprintf)(
  /* translators: %s: number of selected blocks */
  (0,external_wp_i18n_namespaceObject._n)('%s block selected.', '%s blocks selected.', blockCount), blockCount), 'assertive');
};
/**
 * Action that clears the block selection.
 *
 * @return {Object} Action object.
 */

function clearSelectedBlock() {
  return {
    type: 'CLEAR_SELECTED_BLOCK'
  };
}
/**
 * Action that enables or disables block selection.
 *
 * @param {boolean} [isSelectionEnabled=true] Whether block selection should
 *                                            be enabled.
 *
 * @return {Object} Action object.
 */

function toggleSelection(isSelectionEnabled = true) {
  return {
    type: 'TOGGLE_SELECTION',
    isSelectionEnabled
  };
}

function getBlocksWithDefaultStylesApplied(blocks, blockEditorSettings) {
  var _blockEditorSettings$;

  const preferredStyleVariations = (_blockEditorSettings$ = blockEditorSettings?.__experimentalPreferredStyleVariations?.value) !== null && _blockEditorSettings$ !== void 0 ? _blockEditorSettings$ : {};
  return blocks.map(block => {
    const blockName = block.name;

    if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockName, 'defaultStylePicker', true)) {
      return block;
    }

    if (!preferredStyleVariations[blockName]) {
      return block;
    }

    const className = block.attributes?.className;

    if (className?.includes('is-style-')) {
      return block;
    }

    const {
      attributes = {}
    } = block;
    const blockStyle = preferredStyleVariations[blockName];
    return { ...block,
      attributes: { ...attributes,
        className: `${className || ''} is-style-${blockStyle}`.trim()
      }
    };
  });
}
/* eslint-disable jsdoc/valid-types */

/**
 * Action that replaces given blocks with one or more replacement blocks.
 *
 * @param {(string|string[])} clientIds       Block client ID(s) to replace.
 * @param {(Object|Object[])} blocks          Replacement block(s).
 * @param {number}            indexToSelect   Index of replacement block to select.
 * @param {0|-1|null}         initialPosition Index of caret after in the selected block after the operation.
 * @param {?Object}           meta            Optional Meta values to be passed to the action object.
 *
 * @return {Object} Action object.
 */


const replaceBlocks = (clientIds, blocks, indexToSelect, initialPosition = 0, meta) => ({
  select,
  dispatch
}) => {
  /* eslint-enable jsdoc/valid-types */
  clientIds = actions_castArray(clientIds);
  blocks = getBlocksWithDefaultStylesApplied(actions_castArray(blocks), select.getSettings());
  const rootClientId = select.getBlockRootClientId(clientIds[0]); // Replace is valid if the new blocks can be inserted in the root block.

  for (let index = 0; index < blocks.length; index++) {
    const block = blocks[index];
    const canInsertBlock = select.canInsertBlockType(block.name, rootClientId);

    if (!canInsertBlock) {
      return;
    }
  }

  dispatch({
    type: 'REPLACE_BLOCKS',
    clientIds,
    blocks,
    time: Date.now(),
    indexToSelect,
    initialPosition,
    meta
  });
  dispatch(ensureDefaultBlock());
};
/**
 * Action that replaces a single block with one or more replacement blocks.
 *
 * @param {(string|string[])} clientId Block client ID to replace.
 * @param {(Object|Object[])} block    Replacement block(s).
 *
 * @return {Object} Action object.
 */

function replaceBlock(clientId, block) {
  return replaceBlocks(clientId, block);
}
/**
 * Higher-order action creator which, given the action type to dispatch creates
 * an action creator for managing block movement.
 *
 * @param {string} type Action type to dispatch.
 *
 * @return {Function} Action creator.
 */

const createOnMove = type => (clientIds, rootClientId) => ({
  select,
  dispatch
}) => {
  // If one of the blocks is locked or the parent is locked, we cannot move any block.
  const canMoveBlocks = select.canMoveBlocks(clientIds, rootClientId);

  if (!canMoveBlocks) {
    return;
  }

  dispatch({
    type,
    clientIds: actions_castArray(clientIds),
    rootClientId
  });
};

const moveBlocksDown = createOnMove('MOVE_BLOCKS_DOWN');
const moveBlocksUp = createOnMove('MOVE_BLOCKS_UP');
/**
 * Action that moves given blocks to a new position.
 *
 * @param {?string} clientIds        The client IDs of the blocks.
 * @param {?string} fromRootClientId Root client ID source.
 * @param {?string} toRootClientId   Root client ID destination.
 * @param {number}  index            The index to move the blocks to.
 */

const moveBlocksToPosition = (clientIds, fromRootClientId = '', toRootClientId = '', index) => ({
  select,
  dispatch
}) => {
  const canMoveBlocks = select.canMoveBlocks(clientIds, fromRootClientId); // If one of the blocks is locked or the parent is locked, we cannot move any block.

  if (!canMoveBlocks) {
    return;
  } // If moving inside the same root block the move is always possible.


  if (fromRootClientId !== toRootClientId) {
    const canRemoveBlocks = select.canRemoveBlocks(clientIds, fromRootClientId); // If we're moving to another block, it means we're deleting blocks from
    // the original block, so we need to check if removing is possible.

    if (!canRemoveBlocks) {
      return;
    }

    const canInsertBlocks = select.canInsertBlocks(clientIds, toRootClientId); // If moving to other parent block, the move is possible if we can insert a block of the same type inside the new parent block.

    if (!canInsertBlocks) {
      return;
    }
  }

  dispatch({
    type: 'MOVE_BLOCKS_TO_POSITION',
    fromRootClientId,
    toRootClientId,
    clientIds,
    index
  });
};
/**
 * Action that moves given block to a new position.
 *
 * @param {?string} clientId         The client ID of the block.
 * @param {?string} fromRootClientId Root client ID source.
 * @param {?string} toRootClientId   Root client ID destination.
 * @param {number}  index            The index to move the block to.
 */

function moveBlockToPosition(clientId, fromRootClientId = '', toRootClientId = '', index) {
  return moveBlocksToPosition([clientId], fromRootClientId, toRootClientId, index);
}
/**
 * Action that inserts a single block, optionally at a specific index respective a root block list.
 *
 * Only allowed blocks are inserted. The action may fail silently for blocks that are not allowed or if
 * a templateLock is active on the block list.
 *
 * @param {Object}   block           Block object to insert.
 * @param {?number}  index           Index at which block should be inserted.
 * @param {?string}  rootClientId    Optional root client ID of block list on which to insert.
 * @param {?boolean} updateSelection If true block selection will be updated. If false, block selection will not change. Defaults to true.
 * @param {?Object}  meta            Optional Meta values to be passed to the action object.
 *
 * @return {Object} Action object.
 */

function insertBlock(block, index, rootClientId, updateSelection, meta) {
  return insertBlocks([block], index, rootClientId, updateSelection, 0, meta);
}
/* eslint-disable jsdoc/valid-types */

/**
 * Action that inserts an array of blocks, optionally at a specific index respective a root block list.
 *
 * Only allowed blocks are inserted. The action may fail silently for blocks that are not allowed or if
 * a templateLock is active on the block list.
 *
 * @param {Object[]}  blocks          Block objects to insert.
 * @param {?number}   index           Index at which block should be inserted.
 * @param {?string}   rootClientId    Optional root client ID of block list on which to insert.
 * @param {?boolean}  updateSelection If true block selection will be updated.  If false, block selection will not change. Defaults to true.
 * @param {0|-1|null} initialPosition Initial focus position. Setting it to null prevent focusing the inserted block.
 * @param {?Object}   meta            Optional Meta values to be passed to the action object.
 *
 * @return {Object} Action object.
 */

const insertBlocks = (blocks, index, rootClientId, updateSelection = true, initialPosition = 0, meta) => ({
  select,
  dispatch
}) => {
  /* eslint-enable jsdoc/valid-types */
  if (initialPosition !== null && typeof initialPosition === 'object') {
    meta = initialPosition;
    initialPosition = 0;
    external_wp_deprecated_default()("meta argument in wp.data.dispatch('core/block-editor')", {
      since: '5.8',
      hint: 'The meta argument is now the 6th argument of the function'
    });
  }

  blocks = getBlocksWithDefaultStylesApplied(actions_castArray(blocks), select.getSettings());
  const allowedBlocks = [];

  for (const block of blocks) {
    const isValid = select.canInsertBlockType(block.name, rootClientId);

    if (isValid) {
      allowedBlocks.push(block);
    }
  }

  if (allowedBlocks.length) {
    dispatch({
      type: 'INSERT_BLOCKS',
      blocks: allowedBlocks,
      index,
      rootClientId,
      time: Date.now(),
      updateSelection,
      initialPosition: updateSelection ? initialPosition : null,
      meta
    });
  }
};
/**
 * Action that shows the insertion point.
 *
 * @param    {?string}         rootClientId           Optional root client ID of block list on
 *                                                    which to insert.
 * @param    {?number}         index                  Index at which block should be inserted.
 * @param    {?Object}         __unstableOptions      Additional options.
 * @property {boolean}         __unstableWithInserter Whether or not to show an inserter button.
 * @property {WPDropOperation} operation              The operation to perform when applied,
 *                                                    either 'insert' or 'replace' for now.
 *
 * @return {Object} Action object.
 */

function showInsertionPoint(rootClientId, index, __unstableOptions = {}) {
  const {
    __unstableWithInserter,
    operation
  } = __unstableOptions;
  return {
    type: 'SHOW_INSERTION_POINT',
    rootClientId,
    index,
    __unstableWithInserter,
    operation
  };
}
/**
 * Action that hides the insertion point.
 */

const hideInsertionPoint = () => ({
  select,
  dispatch
}) => {
  if (!select.isBlockInsertionPointVisible()) {
    return;
  }

  dispatch({
    type: 'HIDE_INSERTION_POINT'
  });
};
/**
 * Action that resets the template validity.
 *
 * @param {boolean} isValid template validity flag.
 *
 * @return {Object} Action object.
 */

function setTemplateValidity(isValid) {
  return {
    type: 'SET_TEMPLATE_VALIDITY',
    isValid
  };
}
/**
 * Action that synchronizes the template with the list of blocks.
 *
 * @return {Object} Action object.
 */

const synchronizeTemplate = () => ({
  select,
  dispatch
}) => {
  dispatch({
    type: 'SYNCHRONIZE_TEMPLATE'
  });
  const blocks = select.getBlocks();
  const template = select.getTemplate();
  const updatedBlockList = (0,external_wp_blocks_namespaceObject.synchronizeBlocksWithTemplate)(blocks, template);
  dispatch.resetBlocks(updatedBlockList);
};
/**
 * Delete the current selection.
 *
 * @param {boolean} isForward
 */

const __unstableDeleteSelection = isForward => ({
  registry,
  select,
  dispatch
}) => {
  const selectionAnchor = select.getSelectionStart();
  const selectionFocus = select.getSelectionEnd();
  if (selectionAnchor.clientId === selectionFocus.clientId) return; // It's not mergeable if there's no rich text selection.

  if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === 'undefined' || typeof selectionFocus.offset === 'undefined') return false;
  const anchorRootClientId = select.getBlockRootClientId(selectionAnchor.clientId);
  const focusRootClientId = select.getBlockRootClientId(selectionFocus.clientId); // It's not mergeable if the selection doesn't start and end in the same
  // block list. Maybe in the future it should be allowed.

  if (anchorRootClientId !== focusRootClientId) {
    return;
  }

  const blockOrder = select.getBlockOrder(anchorRootClientId);
  const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
  const focusIndex = blockOrder.indexOf(selectionFocus.clientId); // Reassign selection start and end based on order.

  let selectionStart, selectionEnd;

  if (anchorIndex > focusIndex) {
    selectionStart = selectionFocus;
    selectionEnd = selectionAnchor;
  } else {
    selectionStart = selectionAnchor;
    selectionEnd = selectionFocus;
  }

  const targetSelection = isForward ? selectionEnd : selectionStart;
  const targetBlock = select.getBlock(targetSelection.clientId);
  const targetBlockType = (0,external_wp_blocks_namespaceObject.getBlockType)(targetBlock.name);

  if (!targetBlockType.merge) {
    return;
  }

  const selectionA = selectionStart;
  const selectionB = selectionEnd;
  const blockA = select.getBlock(selectionA.clientId);
  const blockAType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockA.name);
  const blockB = select.getBlock(selectionB.clientId);
  const blockBType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockB.name);
  const htmlA = blockA.attributes[selectionA.attributeKey];
  const htmlB = blockB.attributes[selectionB.attributeKey];
  const attributeDefinitionA = blockAType.attributes[selectionA.attributeKey];
  const attributeDefinitionB = blockBType.attributes[selectionB.attributeKey];
  let valueA = (0,external_wp_richText_namespaceObject.create)({
    html: htmlA,
    ...mapRichTextSettings(attributeDefinitionA)
  });
  let valueB = (0,external_wp_richText_namespaceObject.create)({
    html: htmlB,
    ...mapRichTextSettings(attributeDefinitionB)
  });
  valueA = (0,external_wp_richText_namespaceObject.remove)(valueA, selectionA.offset, valueA.text.length);
  valueB = (0,external_wp_richText_namespaceObject.insert)(valueB, START_OF_SELECTED_AREA, 0, selectionB.offset); // Clone the blocks so we don't manipulate the original.

  const cloneA = (0,external_wp_blocks_namespaceObject.cloneBlock)(blockA, {
    [selectionA.attributeKey]: (0,external_wp_richText_namespaceObject.toHTMLString)({
      value: valueA,
      ...mapRichTextSettings(attributeDefinitionA)
    })
  });
  const cloneB = (0,external_wp_blocks_namespaceObject.cloneBlock)(blockB, {
    [selectionB.attributeKey]: (0,external_wp_richText_namespaceObject.toHTMLString)({
      value: valueB,
      ...mapRichTextSettings(attributeDefinitionB)
    })
  });
  const followingBlock = isForward ? cloneA : cloneB; // We can only merge blocks with similar types
  // thus, we transform the block to merge first

  const blocksWithTheSameType = blockA.name === blockB.name ? [followingBlock] : (0,external_wp_blocks_namespaceObject.switchToBlockType)(followingBlock, targetBlockType.name); // If the block types can not match, do nothing

  if (!blocksWithTheSameType || !blocksWithTheSameType.length) {
    return;
  }

  let updatedAttributes;

  if (isForward) {
    const blockToMerge = blocksWithTheSameType.pop();
    updatedAttributes = targetBlockType.merge(blockToMerge.attributes, cloneB.attributes);
  } else {
    const blockToMerge = blocksWithTheSameType.shift();
    updatedAttributes = targetBlockType.merge(cloneA.attributes, blockToMerge.attributes);
  }

  const newAttributeKey = retrieveSelectedAttribute(updatedAttributes);
  const convertedHtml = updatedAttributes[newAttributeKey];
  const convertedValue = (0,external_wp_richText_namespaceObject.create)({
    html: convertedHtml,
    ...mapRichTextSettings(targetBlockType.attributes[newAttributeKey])
  });
  const newOffset = convertedValue.text.indexOf(START_OF_SELECTED_AREA);
  const newValue = (0,external_wp_richText_namespaceObject.remove)(convertedValue, newOffset, newOffset + 1);
  const newHtml = (0,external_wp_richText_namespaceObject.toHTMLString)({
    value: newValue,
    ...mapRichTextSettings(targetBlockType.attributes[newAttributeKey])
  });
  updatedAttributes[newAttributeKey] = newHtml;
  const selectedBlockClientIds = select.getSelectedBlockClientIds();
  const replacement = [...(isForward ? blocksWithTheSameType : []), { // Preserve the original client ID.
    ...targetBlock,
    attributes: { ...targetBlock.attributes,
      ...updatedAttributes
    }
  }, ...(isForward ? [] : blocksWithTheSameType)];
  registry.batch(() => {
    dispatch.selectionChange(targetBlock.clientId, newAttributeKey, newOffset, newOffset);
    dispatch.replaceBlocks(selectedBlockClientIds, replacement, 0, // If we don't pass the `indexToSelect` it will default to the last block.
    select.getSelectedBlocksInitialCaretPosition());
  });
};
/**
 * Split the current selection.
 */

const __unstableSplitSelection = () => ({
  select,
  dispatch
}) => {
  const selectionAnchor = select.getSelectionStart();
  const selectionFocus = select.getSelectionEnd();
  if (selectionAnchor.clientId === selectionFocus.clientId) return; // Can't split if the selection is not set.

  if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === 'undefined' || typeof selectionFocus.offset === 'undefined') return;
  const anchorRootClientId = select.getBlockRootClientId(selectionAnchor.clientId);
  const focusRootClientId = select.getBlockRootClientId(selectionFocus.clientId); // It's not splittable if the selection doesn't start and end in the same
  // block list. Maybe in the future it should be allowed.

  if (anchorRootClientId !== focusRootClientId) {
    return;
  }

  const blockOrder = select.getBlockOrder(anchorRootClientId);
  const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
  const focusIndex = blockOrder.indexOf(selectionFocus.clientId); // Reassign selection start and end based on order.

  let selectionStart, selectionEnd;

  if (anchorIndex > focusIndex) {
    selectionStart = selectionFocus;
    selectionEnd = selectionAnchor;
  } else {
    selectionStart = selectionAnchor;
    selectionEnd = selectionFocus;
  }

  const selectionA = selectionStart;
  const selectionB = selectionEnd;
  const blockA = select.getBlock(selectionA.clientId);
  const blockAType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockA.name);
  const blockB = select.getBlock(selectionB.clientId);
  const blockBType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockB.name);
  const htmlA = blockA.attributes[selectionA.attributeKey];
  const htmlB = blockB.attributes[selectionB.attributeKey];
  const attributeDefinitionA = blockAType.attributes[selectionA.attributeKey];
  const attributeDefinitionB = blockBType.attributes[selectionB.attributeKey];
  let valueA = (0,external_wp_richText_namespaceObject.create)({
    html: htmlA,
    ...mapRichTextSettings(attributeDefinitionA)
  });
  let valueB = (0,external_wp_richText_namespaceObject.create)({
    html: htmlB,
    ...mapRichTextSettings(attributeDefinitionB)
  });
  valueA = (0,external_wp_richText_namespaceObject.remove)(valueA, selectionA.offset, valueA.text.length);
  valueB = (0,external_wp_richText_namespaceObject.remove)(valueB, 0, selectionB.offset);
  dispatch.replaceBlocks(select.getSelectedBlockClientIds(), [{ // Preserve the original client ID.
    ...blockA,
    attributes: { ...blockA.attributes,
      [selectionA.attributeKey]: (0,external_wp_richText_namespaceObject.toHTMLString)({
        value: valueA,
        ...mapRichTextSettings(attributeDefinitionA)
      })
    }
  }, (0,external_wp_blocks_namespaceObject.createBlock)((0,external_wp_blocks_namespaceObject.getDefaultBlockName)()), { // Preserve the original client ID.
    ...blockB,
    attributes: { ...blockB.attributes,
      [selectionB.attributeKey]: (0,external_wp_richText_namespaceObject.toHTMLString)({
        value: valueB,
        ...mapRichTextSettings(attributeDefinitionB)
      })
    }
  }], 1, // If we don't pass the `indexToSelect` it will default to the last block.
  select.getSelectedBlocksInitialCaretPosition());
};
/**
 * Expand the selection to cover the entire blocks, removing partial selection.
 */

const __unstableExpandSelection = () => ({
  select,
  dispatch
}) => {
  const selectionAnchor = select.getSelectionStart();
  const selectionFocus = select.getSelectionEnd();
  dispatch.selectionChange({
    start: {
      clientId: selectionAnchor.clientId
    },
    end: {
      clientId: selectionFocus.clientId
    }
  });
};
/**
 * Action that merges two blocks.
 *
 * @param {string} firstBlockClientId  Client ID of the first block to merge.
 * @param {string} secondBlockClientId Client ID of the second block to merge.
 */

const mergeBlocks = (firstBlockClientId, secondBlockClientId) => ({
  registry,
  select,
  dispatch
}) => {
  const blocks = [firstBlockClientId, secondBlockClientId];
  dispatch({
    type: 'MERGE_BLOCKS',
    blocks
  });
  const [clientIdA, clientIdB] = blocks;
  const blockA = select.getBlock(clientIdA);
  const blockAType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockA.name);
  if (!blockAType) return;
  const blockB = select.getBlock(clientIdB);

  if (blockAType && !blockAType.merge) {
    // If there's no merge function defined, attempt merging inner
    // blocks.
    const blocksWithTheSameType = (0,external_wp_blocks_namespaceObject.switchToBlockType)(blockB, blockAType.name); // Only focus the previous block if it's not mergeable.

    if (blocksWithTheSameType?.length !== 1) {
      dispatch.selectBlock(blockA.clientId);
      return;
    }

    const [blockWithSameType] = blocksWithTheSameType;

    if (blockWithSameType.innerBlocks.length < 1) {
      dispatch.selectBlock(blockA.clientId);
      return;
    }

    registry.batch(() => {
      dispatch.insertBlocks(blockWithSameType.innerBlocks, undefined, clientIdA);
      dispatch.removeBlock(clientIdB);
      dispatch.selectBlock(blockWithSameType.innerBlocks[0].clientId);
    });
    return;
  }

  const blockBType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockB.name);
  const {
    clientId,
    attributeKey,
    offset
  } = select.getSelectionStart();
  const selectedBlockType = clientId === clientIdA ? blockAType : blockBType;
  const attributeDefinition = selectedBlockType.attributes[attributeKey];
  const canRestoreTextSelection = (clientId === clientIdA || clientId === clientIdB) && attributeKey !== undefined && offset !== undefined && // We cannot restore text selection if the RichText identifier
  // is not a defined block attribute key. This can be the case if the
  // fallback intance ID is used to store selection (and no RichText
  // identifier is set), or when the identifier is wrong.
  !!attributeDefinition;

  if (!attributeDefinition) {
    if (typeof attributeKey === 'number') {
      window.console.error(`RichText needs an identifier prop that is the block attribute key of the attribute it controls. Its type is expected to be a string, but was ${typeof attributeKey}`);
    } else {
      window.console.error('The RichText identifier prop does not match any attributes defined by the block.');
    }
  } // Clone the blocks so we don't insert the character in a "live" block.


  const cloneA = (0,external_wp_blocks_namespaceObject.cloneBlock)(blockA);
  const cloneB = (0,external_wp_blocks_namespaceObject.cloneBlock)(blockB);

  if (canRestoreTextSelection) {
    const selectedBlock = clientId === clientIdA ? cloneA : cloneB;
    const html = selectedBlock.attributes[attributeKey];
    const value = (0,external_wp_richText_namespaceObject.insert)((0,external_wp_richText_namespaceObject.create)({
      html,
      ...mapRichTextSettings(attributeDefinition)
    }), START_OF_SELECTED_AREA, offset, offset);
    selectedBlock.attributes[attributeKey] = (0,external_wp_richText_namespaceObject.toHTMLString)({
      value,
      ...mapRichTextSettings(attributeDefinition)
    });
  } // We can only merge blocks with similar types
  // thus, we transform the block to merge first.


  const blocksWithTheSameType = blockA.name === blockB.name ? [cloneB] : (0,external_wp_blocks_namespaceObject.switchToBlockType)(cloneB, blockA.name); // If the block types can not match, do nothing.

  if (!blocksWithTheSameType || !blocksWithTheSameType.length) {
    return;
  } // Calling the merge to update the attributes and remove the block to be merged.


  const updatedAttributes = blockAType.merge(cloneA.attributes, blocksWithTheSameType[0].attributes);

  if (canRestoreTextSelection) {
    const newAttributeKey = retrieveSelectedAttribute(updatedAttributes);
    const convertedHtml = updatedAttributes[newAttributeKey];
    const convertedValue = (0,external_wp_richText_namespaceObject.create)({
      html: convertedHtml,
      ...mapRichTextSettings(blockAType.attributes[newAttributeKey])
    });
    const newOffset = convertedValue.text.indexOf(START_OF_SELECTED_AREA);
    const newValue = (0,external_wp_richText_namespaceObject.remove)(convertedValue, newOffset, newOffset + 1);
    const newHtml = (0,external_wp_richText_namespaceObject.toHTMLString)({
      value: newValue,
      ...mapRichTextSettings(blockAType.attributes[newAttributeKey])
    });
    updatedAttributes[newAttributeKey] = newHtml;
    dispatch.selectionChange(blockA.clientId, newAttributeKey, newOffset, newOffset);
  }

  dispatch.replaceBlocks([blockA.clientId, blockB.clientId], [{ ...blockA,
    attributes: { ...blockA.attributes,
      ...updatedAttributes
    }
  }, ...blocksWithTheSameType.slice(1)], 0 // If we don't pass the `indexToSelect` it will default to the last block.
  );
};
/**
 * Yields action objects used in signalling that the blocks corresponding to
 * the set of specified client IDs are to be removed.
 *
 * @param {string|string[]} clientIds      Client IDs of blocks to remove.
 * @param {boolean}         selectPrevious True if the previous block
 *                                         or the immediate parent
 *                                         (if no previous block exists)
 *                                         should be selected
 *                                         when a block is removed.
 */

const removeBlocks = (clientIds, selectPrevious = true) => privateRemoveBlocks(clientIds, selectPrevious);
/**
 * Returns an action object used in signalling that the block with the
 * specified client ID is to be removed.
 *
 * @param {string}  clientId       Client ID of block to remove.
 * @param {boolean} selectPrevious True if the previous block should be
 *                                 selected when a block is removed.
 *
 * @return {Object} Action object.
 */

function removeBlock(clientId, selectPrevious) {
  return removeBlocks([clientId], selectPrevious);
}
/* eslint-disable jsdoc/valid-types */

/**
 * Returns an action object used in signalling that the inner blocks with the
 * specified client ID should be replaced.
 *
 * @param {string}    rootClientId    Client ID of the block whose InnerBlocks will re replaced.
 * @param {Object[]}  blocks          Block objects to insert as new InnerBlocks
 * @param {?boolean}  updateSelection If true block selection will be updated. If false, block selection will not change. Defaults to false.
 * @param {0|-1|null} initialPosition Initial block position.
 * @return {Object} Action object.
 */

function replaceInnerBlocks(rootClientId, blocks, updateSelection = false, initialPosition = 0) {
  /* eslint-enable jsdoc/valid-types */
  return {
    type: 'REPLACE_INNER_BLOCKS',
    rootClientId,
    blocks,
    updateSelection,
    initialPosition: updateSelection ? initialPosition : null,
    time: Date.now()
  };
}
/**
 * Returns an action object used to toggle the block editing mode between
 * visual and HTML modes.
 *
 * @param {string} clientId Block client ID.
 *
 * @return {Object} Action object.
 */

function toggleBlockMode(clientId) {
  return {
    type: 'TOGGLE_BLOCK_MODE',
    clientId
  };
}
/**
 * Returns an action object used in signalling that the user has begun to type.
 *
 * @return {Object} Action object.
 */

function startTyping() {
  return {
    type: 'START_TYPING'
  };
}
/**
 * Returns an action object used in signalling that the user has stopped typing.
 *
 * @return {Object} Action object.
 */

function stopTyping() {
  return {
    type: 'STOP_TYPING'
  };
}
/**
 * Returns an action object used in signalling that the user has begun to drag blocks.
 *
 * @param {string[]} clientIds An array of client ids being dragged
 *
 * @return {Object} Action object.
 */

function startDraggingBlocks(clientIds = []) {
  return {
    type: 'START_DRAGGING_BLOCKS',
    clientIds
  };
}
/**
 * Returns an action object used in signalling that the user has stopped dragging blocks.
 *
 * @return {Object} Action object.
 */

function stopDraggingBlocks() {
  return {
    type: 'STOP_DRAGGING_BLOCKS'
  };
}
/**
 * Returns an action object used in signalling that the caret has entered formatted text.
 *
 * @deprecated
 *
 * @return {Object} Action object.
 */

function enterFormattedText() {
  external_wp_deprecated_default()('wp.data.dispatch( "core/block-editor" ).enterFormattedText', {
    since: '6.1',
    version: '6.3'
  });
  return {
    type: 'DO_NOTHING'
  };
}
/**
 * Returns an action object used in signalling that the user caret has exited formatted text.
 *
 * @deprecated
 *
 * @return {Object} Action object.
 */

function exitFormattedText() {
  external_wp_deprecated_default()('wp.data.dispatch( "core/block-editor" ).exitFormattedText', {
    since: '6.1',
    version: '6.3'
  });
  return {
    type: 'DO_NOTHING'
  };
}
/**
 * Action that changes the position of the user caret.
 *
 * @param {string|WPSelection} clientId     The selected block client ID.
 * @param {string}             attributeKey The selected block attribute key.
 * @param {number}             startOffset  The start offset.
 * @param {number}             endOffset    The end offset.
 *
 * @return {Object} Action object.
 */

function selectionChange(clientId, attributeKey, startOffset, endOffset) {
  if (typeof clientId === 'string') {
    return {
      type: 'SELECTION_CHANGE',
      clientId,
      attributeKey,
      startOffset,
      endOffset
    };
  }

  return {
    type: 'SELECTION_CHANGE',
    ...clientId
  };
}
/**
 * Action that adds a new block of the default type to the block list.
 *
 * @param {?Object} attributes   Optional attributes of the block to assign.
 * @param {?string} rootClientId Optional root client ID of block list on which
 *                               to append.
 * @param {?number} index        Optional index where to insert the default block.
 */

const insertDefaultBlock = (attributes, rootClientId, index) => ({
  dispatch
}) => {
  // Abort if there is no default block type (if it has been unregistered).
  const defaultBlockName = (0,external_wp_blocks_namespaceObject.getDefaultBlockName)();

  if (!defaultBlockName) {
    return;
  }

  const block = (0,external_wp_blocks_namespaceObject.createBlock)(defaultBlockName, attributes);
  return dispatch.insertBlock(block, index, rootClientId);
};
/**
 * Action that changes the nested settings of a given block.
 *
 * @param {string} clientId Client ID of the block whose nested setting are
 *                          being received.
 * @param {Object} settings Object with the new settings for the nested block.
 *
 * @return {Object} Action object
 */

function updateBlockListSettings(clientId, settings) {
  return {
    type: 'UPDATE_BLOCK_LIST_SETTINGS',
    clientId,
    settings
  };
}
/**
 * Action that updates the block editor settings.
 *
 * @param {Object} settings Updated settings
 *
 * @return {Object} Action object
 */

function updateSettings(settings) {
  return __experimentalUpdateSettings(settings, true);
}
/**
 * Action that signals that a temporary reusable block has been saved
 * in order to switch its temporary id with the real id.
 *
 * @param {string} id        Reusable block's id.
 * @param {string} updatedId Updated block's id.
 *
 * @return {Object} Action object.
 */

function __unstableSaveReusableBlock(id, updatedId) {
  return {
    type: 'SAVE_REUSABLE_BLOCK_SUCCESS',
    id,
    updatedId
  };
}
/**
 * Action that marks the last block change explicitly as persistent.
 *
 * @return {Object} Action object.
 */

function __unstableMarkLastChangeAsPersistent() {
  return {
    type: 'MARK_LAST_CHANGE_AS_PERSISTENT'
  };
}
/**
 * Action that signals that the next block change should be marked explicitly as not persistent.
 *
 * @return {Object} Action object.
 */

function __unstableMarkNextChangeAsNotPersistent() {
  return {
    type: 'MARK_NEXT_CHANGE_AS_NOT_PERSISTENT'
  };
}
/**
 * Action that marks the last block change as an automatic change, meaning it was not
 * performed by the user, and can be undone using the `Escape` and `Backspace` keys.
 * This action must be called after the change was made, and any actions that are a
 * consequence of it, so it is recommended to be called at the next idle period to ensure all
 * selection changes have been recorded.
 */

const __unstableMarkAutomaticChange = () => ({
  dispatch
}) => {
  dispatch({
    type: 'MARK_AUTOMATIC_CHANGE'
  });
  const {
    requestIdleCallback = cb => setTimeout(cb, 100)
  } = window;
  requestIdleCallback(() => {
    dispatch({
      type: 'MARK_AUTOMATIC_CHANGE_FINAL'
    });
  });
};
/**
 * Action that enables or disables the navigation mode.
 *
 * @param {boolean} isNavigationMode Enable/Disable navigation mode.
 */

const setNavigationMode = (isNavigationMode = true) => ({
  dispatch
}) => {
  dispatch.__unstableSetEditorMode(isNavigationMode ? 'navigation' : 'edit');
};
/**
 * Action that sets the editor mode
 *
 * @param {string} mode Editor mode
 */

const __unstableSetEditorMode = mode => ({
  dispatch,
  select
}) => {
  // When switching to zoom-out mode, we need to select the root block
  if (mode === 'zoom-out') {
    const firstSelectedClientId = select.getBlockSelectionStart();

    if (firstSelectedClientId) {
      dispatch.selectBlock(select.getBlockHierarchyRootClientId(firstSelectedClientId));
    }
  }

  dispatch({
    type: 'SET_EDITOR_MODE',
    mode
  });

  if (mode === 'navigation') {
    (0,external_wp_a11y_namespaceObject.speak)((0,external_wp_i18n_namespaceObject.__)('You are currently in navigation mode. Navigate blocks using the Tab key and Arrow keys. Use Left and Right Arrow keys to move between nesting levels. To exit navigation mode and edit the selected block, press Enter.'));
  } else if (mode === 'edit') {
    (0,external_wp_a11y_namespaceObject.speak)((0,external_wp_i18n_namespaceObject.__)('You are currently in edit mode. To return to the navigation mode, press Escape.'));
  } else if (mode === 'zoom-out') {
    (0,external_wp_a11y_namespaceObject.speak)((0,external_wp_i18n_namespaceObject.__)('You are currently in zoom-out mode.'));
  }
};
/**
 * Action that enables or disables the block moving mode.
 *
 * @param {string|null} hasBlockMovingClientId Enable/Disable block moving mode.
 */

const setBlockMovingClientId = (hasBlockMovingClientId = null) => ({
  dispatch
}) => {
  dispatch({
    type: 'SET_BLOCK_MOVING_MODE',
    hasBlockMovingClientId
  });

  if (hasBlockMovingClientId) {
    (0,external_wp_a11y_namespaceObject.speak)((0,external_wp_i18n_namespaceObject.__)('Use the Tab key and Arrow keys to choose new block location. Use Left and Right Arrow keys to move between nesting levels. Once location is selected press Enter or Space to move the block.'));
  }
};
/**
 * Action that duplicates a list of blocks.
 *
 * @param {string[]} clientIds
 * @param {boolean}  updateSelection
 */

const duplicateBlocks = (clientIds, updateSelection = true) => ({
  select,
  dispatch
}) => {
  if (!clientIds || !clientIds.length) {
    return;
  } // Return early if blocks don't exist.


  const blocks = select.getBlocksByClientId(clientIds);

  if (blocks.some(block => !block)) {
    return;
  } // Return early if blocks don't support multiple usage.


  const blockNames = blocks.map(block => block.name);

  if (blockNames.some(blockName => !(0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockName, 'multiple', true))) {
    return;
  }

  const rootClientId = select.getBlockRootClientId(clientIds[0]);
  const clientIdsArray = actions_castArray(clientIds);
  const lastSelectedIndex = select.getBlockIndex(clientIdsArray[clientIdsArray.length - 1]);
  const clonedBlocks = blocks.map(block => (0,external_wp_blocks_namespaceObject.__experimentalCloneSanitizedBlock)(block));
  dispatch.insertBlocks(clonedBlocks, lastSelectedIndex + 1, rootClientId, updateSelection);

  if (clonedBlocks.length > 1 && updateSelection) {
    dispatch.multiSelect(clonedBlocks[0].clientId, clonedBlocks[clonedBlocks.length - 1].clientId);
  }

  return clonedBlocks.map(block => block.clientId);
};
/**
 * Action that inserts an empty block before a given block.
 *
 * @param {string} clientId
 */

const insertBeforeBlock = clientId => ({
  select,
  dispatch
}) => {
  if (!clientId) {
    return;
  }

  const rootClientId = select.getBlockRootClientId(clientId);
  const isLocked = select.getTemplateLock(rootClientId);

  if (isLocked) {
    return;
  }

  const firstSelectedIndex = select.getBlockIndex(clientId);
  return dispatch.insertDefaultBlock({}, rootClientId, firstSelectedIndex);
};
/**
 * Action that inserts an empty block after a given block.
 *
 * @param {string} clientId
 */

const insertAfterBlock = clientId => ({
  select,
  dispatch
}) => {
  if (!clientId) {
    return;
  }

  const rootClientId = select.getBlockRootClientId(clientId);
  const isLocked = select.getTemplateLock(rootClientId);

  if (isLocked) {
    return;
  }

  const firstSelectedIndex = select.getBlockIndex(clientId);
  return dispatch.insertDefaultBlock({}, rootClientId, firstSelectedIndex + 1);
};
/**
 * Action that toggles the highlighted block state.
 *
 * @param {string}  clientId      The block's clientId.
 * @param {boolean} isHighlighted The highlight state.
 */

function toggleBlockHighlight(clientId, isHighlighted) {
  return {
    type: 'TOGGLE_BLOCK_HIGHLIGHT',
    clientId,
    isHighlighted
  };
}
/**
 * Action that "flashes" the block with a given `clientId` by rhythmically highlighting it.
 *
 * @param {string} clientId Target block client ID.
 */

const flashBlock = clientId => async ({
  dispatch
}) => {
  dispatch(toggleBlockHighlight(clientId, true));
  await new Promise(resolve => setTimeout(resolve, 150));
  dispatch(toggleBlockHighlight(clientId, false));
};
/**
 * Action that sets whether a block has controlled inner blocks.
 *
 * @param {string}  clientId                 The block's clientId.
 * @param {boolean} hasControlledInnerBlocks True if the block's inner blocks are controlled.
 */

function setHasControlledInnerBlocks(clientId, hasControlledInnerBlocks) {
  return {
    type: 'SET_HAS_CONTROLLED_INNER_BLOCKS',
    hasControlledInnerBlocks,
    clientId
  };
}
/**
 * Action that sets whether given blocks are visible on the canvas.
 *
 * @param {Record<string,boolean>} updates For each block's clientId, its new visibility setting.
 */

function setBlockVisibility(updates) {
  return {
    type: 'SET_BLOCK_VISIBILITY',
    updates
  };
}
/**
 * Action that sets whether a block is being temporaritly edited as blocks.
 *
 * DO-NOT-USE in production.
 * This action is created for internal/experimental only usage and may be
 * removed anytime without any warning, causing breakage on any plugin or theme invoking it.
 *
 * @param {?string} temporarilyEditingAsBlocks The block's clientId being temporaritly edited as blocks.
 */

function __unstableSetTemporarilyEditingAsBlocks(temporarilyEditingAsBlocks) {
  return {
    type: 'SET_TEMPORARILY_EDITING_AS_BLOCKS',
    temporarilyEditingAsBlocks
  };
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/store/constants.js
const STORE_NAME = 'core/block-editor';

;// CONCATENATED MODULE: external ["wp","privateApis"]
var external_wp_privateApis_namespaceObject = window["wp"]["privateApis"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/lock-unlock.js
/**
 * WordPress dependencies
 */

const {
  lock,
  unlock
} = (0,external_wp_privateApis_namespaceObject.__dangerousOptInToUnstableAPIsOnlyForCoreModules)('I know using unstable features means my plugin or theme will inevitably break on the next WordPress release.', '@wordpress/block-editor');

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/store/index.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */








/**
 * Block editor data store configuration.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#registerStore
 */

const storeConfig = {
  reducer: reducer,
  selectors: selectors_namespaceObject,
  actions: actions_namespaceObject
};
/**
 * Store definition for the block editor namespace.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore
 */

const store = (0,external_wp_data_namespaceObject.createReduxStore)(STORE_NAME, { ...storeConfig,
  persist: ['preferences']
}); // We will be able to use the `register` function once we switch
// the "preferences" persistence to use the new preferences package.

const registeredStore = (0,external_wp_data_namespaceObject.registerStore)(STORE_NAME, { ...storeConfig,
  persist: ['preferences']
});
unlock(registeredStore).registerPrivateActions(private_actions_namespaceObject);
unlock(registeredStore).registerPrivateSelectors(private_selectors_namespaceObject); // TODO: Remove once we switch to the `register` function (see above).
//
// Until then, private functions also need to be attached to the original
// `store` descriptor in order to avoid unit tests failing, which could happen
// when tests create new registries in which they register stores.
//
// @see https://github.com/WordPress/gutenberg/pull/51145#discussion_r1239999590

unlock(store).registerPrivateActions(private_actions_namespaceObject);
unlock(store).registerPrivateSelectors(private_selectors_namespaceObject);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-edit/context.js
/**
 * WordPress dependencies
 */

const DEFAULT_BLOCK_EDIT_CONTEXT = {
  name: '',
  isSelected: false
};
const Context = (0,external_wp_element_namespaceObject.createContext)(DEFAULT_BLOCK_EDIT_CONTEXT);
const {
  Provider
} = Context;

/**
 * A hook that returns the block edit context.
 *
 * @return {Object} Block edit context
 */

function useBlockEditContext() {
  return (0,external_wp_element_namespaceObject.useContext)(Context);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/use-display-block-controls/index.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



function useDisplayBlockControls() {
  const {
    isSelected,
    clientId,
    name
  } = useBlockEditContext();
  return (0,external_wp_data_namespaceObject.useSelect)(select => {
    if (isSelected) {
      return true;
    }

    const {
      getBlockName,
      isFirstMultiSelectedBlock,
      getMultiSelectedBlockClientIds
    } = select(store);

    if (isFirstMultiSelectedBlock(clientId)) {
      return getMultiSelectedBlockClientIds().every(id => getBlockName(id) === name);
    }

    return false;
  }, [clientId, isSelected, name]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-controls/hook.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





function useBlockControlsFill(group, shareWithChildBlocks) {
  const isDisplayed = useDisplayBlockControls();
  const {
    clientId
  } = useBlockEditContext();
  const isParentDisplayed = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockName,
      hasSelectedInnerBlock
    } = select(store);
    const {
      hasBlockSupport
    } = select(external_wp_blocks_namespaceObject.store);
    return shareWithChildBlocks && hasBlockSupport(getBlockName(clientId), '__experimentalExposeControlsToChildren', false) && hasSelectedInnerBlock(clientId);
  }, [shareWithChildBlocks, clientId]);

  if (isDisplayed) {
    return block_controls_groups[group]?.Fill;
  }

  if (isParentDisplayed) {
    return block_controls_groups.parent.Fill;
  }

  return null;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-controls/fill.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


function BlockControlsFill({
  group = 'default',
  controls,
  children,
  __experimentalShareWithChildBlocks = false
}) {
  const Fill = useBlockControlsFill(group, __experimentalShareWithChildBlocks);

  if (!Fill) {
    return null;
  }

  const innerMarkup = (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, group === 'default' && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarGroup, {
    controls: controls
  }), children);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalStyleProvider, {
    document: document
  }, (0,external_wp_element_namespaceObject.createElement)(Fill, null, fillProps => {
    // `fillProps.forwardedContext` is an array of context provider entries, provided by slot,
    // that should wrap the fill markup.
    const {
      forwardedContext = []
    } = fillProps;
    return forwardedContext.reduce((inner, [Provider, props]) => (0,external_wp_element_namespaceObject.createElement)(Provider, { ...props
    }, inner), innerMarkup);
  }));
}

;// CONCATENATED MODULE: external ["wp","warning"]
var external_wp_warning_namespaceObject = window["wp"]["warning"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-controls/slot.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



const {
  ComponentsContext
} = unlock(external_wp_components_namespaceObject.privateApis);
function BlockControlsSlot({
  group = 'default',
  ...props
}) {
  const toolbarState = (0,external_wp_element_namespaceObject.useContext)(external_wp_components_namespaceObject.__experimentalToolbarContext);
  const contextState = (0,external_wp_element_namespaceObject.useContext)(ComponentsContext);
  const fillProps = (0,external_wp_element_namespaceObject.useMemo)(() => ({
    forwardedContext: [[external_wp_components_namespaceObject.__experimentalToolbarContext.Provider, {
      value: toolbarState
    }], [ComponentsContext.Provider, {
      value: contextState
    }]]
  }), [toolbarState, contextState]);
  const Slot = block_controls_groups[group]?.Slot;
  const fills = (0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(Slot?.__unstableName);

  if (!Slot) {
    typeof process !== "undefined" && process.env && "production" !== "production" ? 0 : void 0;
    return null;
  }

  if (!fills?.length) {
    return null;
  }

  const slot = (0,external_wp_element_namespaceObject.createElement)(Slot, { ...props,
    bubblesVirtually: true,
    fillProps: fillProps
  });

  if (group === 'default') {
    return slot;
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarGroup, null, slot);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-controls/index.js


/**
 * Internal dependencies
 */


const BlockControls = BlockControlsFill;
BlockControls.Slot = BlockControlsSlot; // This is just here for backward compatibility.

const BlockFormatControls = props => {
  return (0,external_wp_element_namespaceObject.createElement)(BlockControlsFill, {
    group: "inline",
    ...props
  });
};

BlockFormatControls.Slot = props => {
  return (0,external_wp_element_namespaceObject.createElement)(BlockControlsSlot, {
    group: "inline",
    ...props
  });
};

/* harmony default export */ var block_controls = (BlockControls);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/justify-left.js


/**
 * WordPress dependencies
 */

const justifyLeft = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M9 9v6h11V9H9zM4 20h1.5V4H4v16z"
}));
/* harmony default export */ var justify_left = (justifyLeft);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/justify-center.js


/**
 * WordPress dependencies
 */

const justifyCenter = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M12.5 15v5H11v-5H4V9h7V4h1.5v5h7v6h-7Z"
}));
/* harmony default export */ var justify_center = (justifyCenter);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/justify-right.js


/**
 * WordPress dependencies
 */

const justifyRight = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M4 15h11V9H4v6zM18.5 4v16H20V4h-1.5z"
}));
/* harmony default export */ var justify_right = (justifyRight);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/justify-space-between.js


/**
 * WordPress dependencies
 */

const justifySpaceBetween = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M9 15h6V9H9v6zm-5 5h1.5V4H4v16zM18.5 4v16H20V4h-1.5z"
}));
/* harmony default export */ var justify_space_between = (justifySpaceBetween);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/justify-stretch.js


/**
 * WordPress dependencies
 */

const justifyStretch = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M4 4H5.5V20H4V4ZM7 10L17 10V14L7 14V10ZM20 4H18.5V20H20V4Z"
}));
/* harmony default export */ var justify_stretch = (justifyStretch);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/arrow-right.js


/**
 * WordPress dependencies
 */

const arrowRight = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "m14.5 6.5-1 1 3.7 3.7H4v1.6h13.2l-3.7 3.7 1 1 5.6-5.5z"
}));
/* harmony default export */ var arrow_right = (arrowRight);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/arrow-down.js


/**
 * WordPress dependencies
 */

const arrowDown = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "m16.5 13.5-3.7 3.7V4h-1.5v13.2l-3.8-3.7-1 1 5.5 5.6 5.5-5.6z"
}));
/* harmony default export */ var arrow_down = (arrowDown);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/layouts/definitions.js
// Layout definitions keyed by layout type.
// Provides a common definition of slugs, classnames, base styles, and spacing styles for each layout type.
// If making changes or additions to layout definitions, be sure to update the corresponding PHP definitions in
// `block-supports/layout.php` so that the server-side and client-side definitions match.
const LAYOUT_DEFINITIONS = {
  default: {
    name: 'default',
    slug: 'flow',
    className: 'is-layout-flow',
    baseStyles: [{
      selector: ' > .alignleft',
      rules: {
        float: 'left',
        'margin-inline-start': '0',
        'margin-inline-end': '2em'
      }
    }, {
      selector: ' > .alignright',
      rules: {
        float: 'right',
        'margin-inline-start': '2em',
        'margin-inline-end': '0'
      }
    }, {
      selector: ' > .aligncenter',
      rules: {
        'margin-left': 'auto !important',
        'margin-right': 'auto !important'
      }
    }],
    spacingStyles: [{
      selector: ' > :first-child:first-child',
      rules: {
        'margin-block-start': '0'
      }
    }, {
      selector: ' > :last-child:last-child',
      rules: {
        'margin-block-end': '0'
      }
    }, {
      selector: ' > *',
      rules: {
        'margin-block-start': null,
        'margin-block-end': '0'
      }
    }]
  },
  constrained: {
    name: 'constrained',
    slug: 'constrained',
    className: 'is-layout-constrained',
    baseStyles: [{
      selector: ' > .alignleft',
      rules: {
        float: 'left',
        'margin-inline-start': '0',
        'margin-inline-end': '2em'
      }
    }, {
      selector: ' > .alignright',
      rules: {
        float: 'right',
        'margin-inline-start': '2em',
        'margin-inline-end': '0'
      }
    }, {
      selector: ' > .aligncenter',
      rules: {
        'margin-left': 'auto !important',
        'margin-right': 'auto !important'
      }
    }, {
      selector: ' > :where(:not(.alignleft):not(.alignright):not(.alignfull))',
      rules: {
        'max-width': 'var(--wp--style--global--content-size)',
        'margin-left': 'auto !important',
        'margin-right': 'auto !important'
      }
    }, {
      selector: ' > .alignwide',
      rules: {
        'max-width': 'var(--wp--style--global--wide-size)'
      }
    }],
    spacingStyles: [{
      selector: ' > :first-child:first-child',
      rules: {
        'margin-block-start': '0'
      }
    }, {
      selector: ' > :last-child:last-child',
      rules: {
        'margin-block-end': '0'
      }
    }, {
      selector: ' > *',
      rules: {
        'margin-block-start': null,
        'margin-block-end': '0'
      }
    }]
  },
  flex: {
    name: 'flex',
    slug: 'flex',
    className: 'is-layout-flex',
    displayMode: 'flex',
    baseStyles: [{
      selector: '',
      rules: {
        'flex-wrap': 'wrap',
        'align-items': 'center'
      }
    }, {
      selector: ' > *',
      rules: {
        margin: '0'
      }
    }],
    spacingStyles: [{
      selector: '',
      rules: {
        gap: null
      }
    }]
  },
  grid: {
    name: 'grid',
    slug: 'grid',
    className: 'is-layout-grid',
    displayMode: 'grid',
    baseStyles: [{
      selector: ' > *',
      rules: {
        margin: '0'
      }
    }],
    spacingStyles: [{
      selector: '',
      rules: {
        gap: null
      }
    }]
  }
};

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/layouts/utils.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Utility to generate the proper CSS selector for layout styles.
 *
 * @param {string} selectors CSS selector, also supports multiple comma-separated selectors.
 * @param {string} append    The string to append.
 *
 * @return {string} - CSS selector.
 */

function appendSelectors(selectors, append = '') {
  // Ideally we shouldn't need the `.editor-styles-wrapper` increased specificity here
  // The problem though is that we have a `.editor-styles-wrapper p { margin: reset; }` style
  // it's used to reset the default margin added by wp-admin to paragraphs
  // so we need this to be higher speficity otherwise, it won't be applied to paragraphs inside containers
  // When the post editor is fully iframed, this extra classname could be removed.
  return selectors.split(',').map(subselector => `.editor-styles-wrapper ${subselector}${append ? ` ${append}` : ''}`).join(',');
}
/**
 * Get generated blockGap CSS rules based on layout definitions provided in theme.json
 * Falsy values in the layout definition's spacingStyles rules will be swapped out
 * with the provided `blockGapValue`.
 *
 * @param {string} selector          The CSS selector to target for the generated rules.
 * @param {Object} layoutDefinitions Layout definitions object.
 * @param {string} layoutType        The layout type (e.g. `default` or `flex`).
 * @param {string} blockGapValue     The current blockGap value to be applied.
 * @return {string} The generated CSS rules.
 */

function getBlockGapCSS(selector, layoutDefinitions = LAYOUT_DEFINITIONS, layoutType, blockGapValue) {
  let output = '';

  if (layoutDefinitions?.[layoutType]?.spacingStyles?.length && blockGapValue) {
    layoutDefinitions[layoutType].spacingStyles.forEach(gapStyle => {
      output += `${appendSelectors(selector, gapStyle.selector.trim())} { `;
      output += Object.entries(gapStyle.rules).map(([cssProperty, value]) => `${cssProperty}: ${value ? value : blockGapValue}`).join('; ');
      output += '; }';
    });
  }

  return output;
}
/**
 * Helper method to assign contextual info to clarify
 * alignment settings.
 *
 * Besides checking if `contentSize` and `wideSize` have a
 * value, we now show this information only if their values
 * are not a `css var`. This needs to change when parsing
 * css variables land.
 *
 * @see https://github.com/WordPress/gutenberg/pull/34710#issuecomment-918000752
 *
 * @param {Object} layout The layout object.
 * @return {Object} An object with contextual info per alignment.
 */

function getAlignmentsInfo(layout) {
  const {
    contentSize,
    wideSize,
    type = 'default'
  } = layout;
  const alignmentInfo = {};
  const sizeRegex = /^(?!0)\d+(px|em|rem|vw|vh|%)?$/i;

  if (sizeRegex.test(contentSize) && type === 'constrained') {
    // translators: %s: container size (i.e. 600px etc)
    alignmentInfo.none = (0,external_wp_i18n_namespaceObject.sprintf)((0,external_wp_i18n_namespaceObject.__)('Max %s wide'), contentSize);
  }

  if (sizeRegex.test(wideSize)) {
    // translators: %s: container size (i.e. 600px etc)
    alignmentInfo.wide = (0,external_wp_i18n_namespaceObject.sprintf)((0,external_wp_i18n_namespaceObject.__)('Max %s wide'), wideSize);
  }

  return alignmentInfo;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/sides-all.js


/**
 * WordPress dependencies
 */

const sidesAll = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M3.5 17H5V7H3.5v10zM7 20.5h10V19H7v1.5zM19 7v10h1.5V7H19zM7 5h10V3.5H7V5z",
  style: {
    fill: '#1e1e1e'
  }
}));
/* harmony default export */ var sides_all = (sidesAll);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/sides-axial.js


/**
 * WordPress dependencies
 */

const sidesAxial = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M8.2 5.3h8V3.8h-8v1.5zm0 14.5h8v-1.5h-8v1.5zm3.5-6.5h1v-1h-1v1zm1-6.5h-1v.5h1v-.5zm-1 4.5h1v-1h-1v1zm0-2h1v-1h-1v1zm0 7.5h1v-.5h-1v.5zm1-2.5h-1v1h1v-1zm-8.5 1.5h1.5v-8H4.2v8zm14.5-8v8h1.5v-8h-1.5zm-5 4.5v-1h-1v1h1zm-6.5 0h.5v-1h-.5v1zm3.5-1v1h1v-1h-1zm6 1h.5v-1h-.5v1zm-8-1v1h1v-1h-1zm6 0v1h1v-1h-1z",
  style: {
    fill: '#1e1e1e',
    fillRule: 'evenodd',
    clipRule: 'evenodd'
  }
}));
/* harmony default export */ var sides_axial = (sidesAxial);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/sides-horizontal.js


/**
 * WordPress dependencies
 */

const sidesHorizontal = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M3.5 17H5V7H3.5v10zM19 7v10h1.5V7H19z",
  style: {
    fill: '#1e1e1e'
  }
}), (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M7 20.5h10V19H7v1.5zm0-17V5h10V3.5H7z",
  style: {
    fill: '#1e1e1e',
    opacity: 0.1
  }
}));
/* harmony default export */ var sides_horizontal = (sidesHorizontal);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/sides-vertical.js


/**
 * WordPress dependencies
 */

const sidesVertical = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M3.5 17H5V7H3.5v10zM19 7v10h1.5V7H19z",
  style: {
    fill: '#1e1e1e',
    opacity: 0.1
  }
}), (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M7 20.5h10V19H7v1.5zm0-17V5h10V3.5H7z",
  style: {
    fill: '#1e1e1e'
  }
}));
/* harmony default export */ var sides_vertical = (sidesVertical);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/sides-top.js


/**
 * WordPress dependencies
 */

const sidesTop = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M3.5 17H5V7H3.5v10zM7 20.5h10V19H7v1.5zM19 7v10h1.5V7H19z",
  style: {
    fill: '#1e1e1e',
    opacity: 0.1
  }
}), (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M7 5h10V3.5H7V5z",
  style: {
    fill: '#1e1e1e'
  }
}));
/* harmony default export */ var sides_top = (sidesTop);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/sides-right.js


/**
 * WordPress dependencies
 */

const sidesRight = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M20.5 7H19v10h1.5V7z",
  style: {
    fill: '#1e1e1e'
  }
}), (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M3.5 17H5V7H3.5v10zM7 20.5h10V19H7v1.5zm0-17V5h10V3.5H7z",
  style: {
    fill: '#1e1e1e',
    opacity: 0.1
  }
}));
/* harmony default export */ var sides_right = (sidesRight);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/sides-bottom.js


/**
 * WordPress dependencies
 */

const sidesBottom = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M7 20.5h10V19H7v1.5z",
  style: {
    fill: '#1e1e1e'
  }
}), (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M3.5 17H5V7H3.5v10zM19 7v10h1.5V7H19zM7 5h10V3.5H7V5z",
  style: {
    fill: '#1e1e1e',
    opacity: 0.1
  }
}));
/* harmony default export */ var sides_bottom = (sidesBottom);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/sides-left.js


/**
 * WordPress dependencies
 */

const sidesLeft = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M5 17H3.5V7H5v10z",
  style: {
    fill: '#1e1e1e'
  }
}), (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M7 20.5h10V19H7v1.5zM19 7v10h1.5V7H19zM7 5h10V3.5H7V5z",
  style: {
    fill: '#1e1e1e',
    opacity: 0.1
  }
}));
/* harmony default export */ var sides_left = (sidesLeft);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/utils.js
/**
 * WordPress dependencies
 */


const ALL_SIDES = ['top', 'right', 'bottom', 'left'];
const DEFAULT_VALUES = {
  top: undefined,
  right: undefined,
  bottom: undefined,
  left: undefined
};
const ICONS = {
  custom: sides_all,
  axial: sides_axial,
  horizontal: sides_horizontal,
  vertical: sides_vertical,
  top: sides_top,
  right: sides_right,
  bottom: sides_bottom,
  left: sides_left
};
const LABELS = {
  default: (0,external_wp_i18n_namespaceObject.__)('Spacing control'),
  top: (0,external_wp_i18n_namespaceObject.__)('Top'),
  bottom: (0,external_wp_i18n_namespaceObject.__)('Bottom'),
  left: (0,external_wp_i18n_namespaceObject.__)('Left'),
  right: (0,external_wp_i18n_namespaceObject.__)('Right'),
  mixed: (0,external_wp_i18n_namespaceObject.__)('Mixed'),
  vertical: (0,external_wp_i18n_namespaceObject.__)('Vertical'),
  horizontal: (0,external_wp_i18n_namespaceObject.__)('Horizontal'),
  axial: (0,external_wp_i18n_namespaceObject.__)('Horizontal & vertical'),
  custom: (0,external_wp_i18n_namespaceObject.__)('Custom')
};
const VIEWS = {
  axial: 'axial',
  top: 'top',
  right: 'right',
  bottom: 'bottom',
  left: 'left',
  custom: 'custom'
};
/**
 * Checks is given value is a spacing preset.
 *
 * @param {string} value Value to check
 *
 * @return {boolean} Return true if value is string in format var:preset|spacing|.
 */

function isValueSpacingPreset(value) {
  if (!value?.includes) {
    return false;
  }

  return value === '0' || value.includes('var:preset|spacing|');
}
/**
 * Converts a spacing preset into a custom value.
 *
 * @param {string} value        Value to convert
 * @param {Array}  spacingSizes Array of the current spacing preset objects
 *
 * @return {string} Mapping of the spacing preset to its equivalent custom value.
 */

function getCustomValueFromPreset(value, spacingSizes) {
  if (!isValueSpacingPreset(value)) {
    return value;
  }

  const slug = getSpacingPresetSlug(value);
  const spacingSize = spacingSizes.find(size => String(size.slug) === slug);
  return spacingSize?.size;
}
/**
 * Converts a custom value to preset value if one can be found.
 *
 * Returns value as-is if no match is found.
 *
 * @param {string} value        Value to convert
 * @param {Array}  spacingSizes Array of the current spacing preset objects
 *
 * @return {string} The preset value if it can be found.
 */

function getPresetValueFromCustomValue(value, spacingSizes) {
  // Return value as-is if it is undefined or is already a preset, or '0';
  if (!value || isValueSpacingPreset(value) || value === '0') {
    return value;
  }

  const spacingMatch = spacingSizes.find(size => String(size.size) === String(value));

  if (spacingMatch?.slug) {
    return `var:preset|spacing|${spacingMatch.slug}`;
  }

  return value;
}
/**
 * Converts a spacing preset into a custom value.
 *
 * @param {string} value Value to convert.
 *
 * @return {string | undefined} CSS var string for given spacing preset value.
 */

function getSpacingPresetCssVar(value) {
  if (!value) {
    return;
  }

  const slug = value.match(/var:preset\|spacing\|(.+)/);

  if (!slug) {
    return value;
  }

  return `var(--wp--preset--spacing--${slug[1]})`;
}
/**
 * Returns the slug section of the given spacing preset string.
 *
 * @param {string} value Value to extract slug from.
 *
 * @return {string|undefined} The int value of the slug from given spacing preset.
 */

function getSpacingPresetSlug(value) {
  if (!value) {
    return;
  }

  if (value === '0' || value === 'default') {
    return value;
  }

  const slug = value.match(/var:preset\|spacing\|(.+)/);
  return slug ? slug[1] : undefined;
}
/**
 * Converts spacing preset value into a Range component value .
 *
 * @param {string} presetValue  Value to convert to Range value.
 * @param {Array}  spacingSizes Array of current spacing preset value objects.
 *
 * @return {number} The int value for use in Range control.
 */

function getSliderValueFromPreset(presetValue, spacingSizes) {
  if (presetValue === undefined) {
    return 0;
  }

  const slug = parseFloat(presetValue, 10) === 0 ? '0' : getSpacingPresetSlug(presetValue);
  const sliderValue = spacingSizes.findIndex(spacingSize => {
    return String(spacingSize.slug) === slug;
  }); // Returning NaN rather than undefined as undefined makes range control thumb sit in center

  return sliderValue !== -1 ? sliderValue : NaN;
}
/**
 * Gets an items with the most occurrence within an array
 * https://stackoverflow.com/a/20762713
 *
 * @param {Array<any>} arr Array of items to check.
 * @return {any} The item with the most occurrences.
 */

function mode(arr) {
  return arr.sort((a, b) => arr.filter(v => v === a).length - arr.filter(v => v === b).length).pop();
}
/**
 * Gets the 'all' input value from values data.
 *
 * @param {Object} values Box spacing values
 *
 * @return {string} The most common value from all sides of box.
 */


function getAllRawValue(values = {}) {
  return mode(Object.values(values));
}
/**
 * Checks to determine if values are mixed.
 *
 * @param {Object} values Box values.
 * @param {Array}  sides  Sides that values relate to.
 *
 * @return {boolean} Whether values are mixed.
 */

function isValuesMixed(values = {}, sides = ALL_SIDES) {
  return Object.values(values).length >= 1 && Object.values(values).length < sides.length || new Set(Object.values(values)).size > 1;
}
/**
 * Checks to determine if values are defined.
 *
 * @param {Object} values Box values.
 *
 * @return {boolean} Whether values are defined.
 */

function isValuesDefined(values) {
  if (values === undefined || values === null) {
    return false;
  }

  return Object.values(values).filter(value => !!value).length > 0;
}
/**
 * Determines whether a particular axis has support. If no axis is
 * specified, this function checks if either axis is supported.
 *
 * @param {Array}  sides Supported sides.
 * @param {string} axis  Which axis to check.
 *
 * @return {boolean} Whether there is support for the specified axis or both axes.
 */

function hasAxisSupport(sides, axis) {
  if (!sides || !sides.length) {
    return false;
  }

  const hasHorizontalSupport = sides.includes('horizontal') || sides.includes('left') && sides.includes('right');
  const hasVerticalSupport = sides.includes('vertical') || sides.includes('top') && sides.includes('bottom');

  if (axis === 'horizontal') {
    return hasHorizontalSupport;
  }

  if (axis === 'vertical') {
    return hasVerticalSupport;
  }

  return hasHorizontalSupport || hasVerticalSupport;
}
/**
 * Determines which menu options should be included in the SidePicker.
 *
 * @param {Array} sides Supported sides.
 *
 * @return {Object} Menu options with each option containing label & icon.
 */

function getSupportedMenuItems(sides) {
  if (!sides || !sides.length) {
    return {};
  }

  const menuItems = {}; // Determine the primary "side" menu options.

  const hasHorizontalSupport = hasAxisSupport(sides, 'horizontal');
  const hasVerticalSupport = hasAxisSupport(sides, 'vertical');

  if (hasHorizontalSupport && hasVerticalSupport) {
    menuItems.axial = {
      label: LABELS.axial,
      icon: ICONS.axial
    };
  } else if (hasHorizontalSupport) {
    menuItems.axial = {
      label: LABELS.horizontal,
      icon: ICONS.horizontal
    };
  } else if (hasVerticalSupport) {
    menuItems.axial = {
      label: LABELS.vertical,
      icon: ICONS.vertical
    };
  } // Track whether we have any individual sides so we can omit the custom
  // option if required.


  let numberOfIndividualSides = 0;
  ALL_SIDES.forEach(side => {
    if (sides.includes(side)) {
      numberOfIndividualSides += 1;
      menuItems[side] = {
        label: LABELS[side],
        icon: ICONS[side]
      };
    }
  }); // Add custom item if there are enough sides to warrant a separated view.

  if (numberOfIndividualSides > 1) {
    menuItems.custom = {
      label: LABELS.custom,
      icon: ICONS.custom
    };
  }

  return menuItems;
}
/**
 * Checks if the supported sides are balanced for each axis.
 * - Horizontal - both left and right sides are supported.
 * - Vertical - both top and bottom are supported.
 *
 * @param {Array} sides The supported sides which may be axes as well.
 *
 * @return {boolean} Whether or not the supported sides are balanced.
 */

function hasBalancedSidesSupport(sides = []) {
  const counts = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  sides.forEach(side => counts[side] += 1);
  return (counts.top + counts.bottom) % 2 === 0 && (counts.left + counts.right) % 2 === 0;
}
/**
 * Determines which view the SpacingSizesControl should default to on its
 * first render; Axial, Custom, or Single side.
 *
 * @param {Object} values Current side values.
 * @param {Array}  sides  Supported sides.
 *
 * @return {string} View to display.
 */

function getInitialView(values = {}, sides) {
  const {
    top,
    right,
    bottom,
    left
  } = values;
  const sideValues = [top, right, bottom, left].filter(Boolean); // Axial ( Horizontal & vertical ).
  // - Has axial side support
  // - Has axial side values which match
  // - Has no values and the supported sides are balanced

  const hasMatchingAxialValues = top === bottom && left === right && (!!top || !!left);
  const hasNoValuesAndBalancedSides = !sideValues.length && hasBalancedSidesSupport(sides);

  if (hasAxisSupport(sides) && (hasMatchingAxialValues || hasNoValuesAndBalancedSides)) {
    return VIEWS.axial;
  } // Single side.
  // - Ensure the side returned is the first side that has a value.


  if (sideValues.length === 1) {
    let side;
    Object.entries(values).some(([key, value]) => {
      side = key;
      return value !== undefined;
    });
    return side;
  } // Only single side supported and no value defined.


  if (sides?.length === 1 && !sideValues.length) {
    return sides[0];
  } // Default to the Custom (separated sides) view.


  return VIEWS.custom;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/gap.js
/**
 * Internal dependencies
 */

/**
 * Returns a BoxControl object value from a given blockGap style value.
 * The string check is for backwards compatibility before Gutenberg supported
 * split gap values (row and column) and the value was a string n + unit.
 *
 * @param {string? | Object?} blockGapValue A block gap string or axial object value, e.g., '10px' or { top: '10px', left: '10px'}.
 * @return {Object|null}                    A value to pass to the BoxControl component.
 */

function getGapBoxControlValueFromStyle(blockGapValue) {
  if (!blockGapValue) {
    return null;
  }

  const isValueString = typeof blockGapValue === 'string';
  return {
    top: isValueString ? blockGapValue : blockGapValue?.top,
    left: isValueString ? blockGapValue : blockGapValue?.left
  };
}
/**
 * Returns a CSS value for the `gap` property from a given blockGap style.
 *
 * @param {string? | Object?} blockGapValue A block gap string or axial object value, e.g., '10px' or { top: '10px', left: '10px'}.
 * @param {string?}           defaultValue  A default gap value.
 * @return {string|null}                    The concatenated gap value (row and column).
 */

function getGapCSSValue(blockGapValue, defaultValue = '0') {
  const blockGapBoxControlValue = getGapBoxControlValueFromStyle(blockGapValue);

  if (!blockGapBoxControlValue) {
    return null;
  }

  const row = getSpacingPresetCssVar(blockGapBoxControlValue?.top) || defaultValue;
  const column = getSpacingPresetCssVar(blockGapBoxControlValue?.left) || defaultValue;
  return row === column ? row : `${row} ${column}`;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-vertical-alignment-control/icons.js


/**
 * WordPress dependencies
 */

const alignBottom = (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Path, {
  d: "M15 4H9v11h6V4zM4 18.5V20h16v-1.5H4z"
}));
const alignCenter = (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Path, {
  d: "M20 11h-5V4H9v7H4v1.5h5V20h6v-7.5h5z"
}));
const alignTop = (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Path, {
  d: "M9 20h6V9H9v11zM4 4v1.5h16V4H4z"
}));
const alignStretch = (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Path, {
  d: "M4 4L20 4L20 5.5L4 5.5L4 4ZM10 7L14 7L14 17L10 17L10 7ZM20 18.5L4 18.5L4 20L20 20L20 18.5Z"
}));
const spaceBetween = (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Path, {
  d: "M7 4H17V8L7 8V4ZM7 16L17 16V20L7 20V16ZM20 11.25H4V12.75H20V11.25Z"
}));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-vertical-alignment-control/ui.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


const BLOCK_ALIGNMENTS_CONTROLS = {
  top: {
    icon: alignTop,
    title: (0,external_wp_i18n_namespaceObject._x)('Align top', 'Block vertical alignment setting')
  },
  center: {
    icon: alignCenter,
    title: (0,external_wp_i18n_namespaceObject._x)('Align middle', 'Block vertical alignment setting')
  },
  bottom: {
    icon: alignBottom,
    title: (0,external_wp_i18n_namespaceObject._x)('Align bottom', 'Block vertical alignment setting')
  },
  stretch: {
    icon: alignStretch,
    title: (0,external_wp_i18n_namespaceObject._x)('Stretch to fill', 'Block vertical alignment setting')
  },
  'space-between': {
    icon: spaceBetween,
    title: (0,external_wp_i18n_namespaceObject._x)('Space between', 'Block vertical alignment setting')
  }
};
const DEFAULT_CONTROLS = ['top', 'center', 'bottom'];
const DEFAULT_CONTROL = 'top';

function BlockVerticalAlignmentUI({
  value,
  onChange,
  controls = DEFAULT_CONTROLS,
  isCollapsed = true,
  isToolbar
}) {
  function applyOrUnset(align) {
    return () => onChange(value === align ? undefined : align);
  }

  const activeAlignment = BLOCK_ALIGNMENTS_CONTROLS[value];
  const defaultAlignmentControl = BLOCK_ALIGNMENTS_CONTROLS[DEFAULT_CONTROL];
  const UIComponent = isToolbar ? external_wp_components_namespaceObject.ToolbarGroup : external_wp_components_namespaceObject.ToolbarDropdownMenu;
  const extraProps = isToolbar ? {
    isCollapsed
  } : {};
  return (0,external_wp_element_namespaceObject.createElement)(UIComponent, {
    icon: activeAlignment ? activeAlignment.icon : defaultAlignmentControl.icon,
    label: (0,external_wp_i18n_namespaceObject._x)('Change vertical alignment', 'Block vertical alignment setting label'),
    controls: controls.map(control => {
      return { ...BLOCK_ALIGNMENTS_CONTROLS[control],
        isActive: value === control,
        role: isCollapsed ? 'menuitemradio' : undefined,
        onClick: applyOrUnset(control)
      };
    }),
    ...extraProps
  });
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-vertical-alignment-toolbar/README.md
 */


/* harmony default export */ var ui = (BlockVerticalAlignmentUI);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-vertical-alignment-control/index.js


/**
 * Internal dependencies
 */


const BlockVerticalAlignmentControl = props => {
  return (0,external_wp_element_namespaceObject.createElement)(ui, { ...props,
    isToolbar: false
  });
};

const BlockVerticalAlignmentToolbar = props => {
  return (0,external_wp_element_namespaceObject.createElement)(ui, { ...props,
    isToolbar: true
  });
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-vertical-alignment-control/README.md
 */




;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/justify-content-control/ui.js


/**
 * WordPress dependencies
 */



const icons = {
  left: justify_left,
  center: justify_center,
  right: justify_right,
  'space-between': justify_space_between,
  stretch: justify_stretch
};

function JustifyContentUI({
  allowedControls = ['left', 'center', 'right', 'space-between'],
  isCollapsed = true,
  onChange,
  value,
  popoverProps,
  isToolbar
}) {
  // If the control is already selected we want a click
  // again on the control to deselect the item, so we
  // call onChange( undefined )
  const handleClick = next => {
    if (next === value) {
      onChange(undefined);
    } else {
      onChange(next);
    }
  };

  const icon = value ? icons[value] : icons.left;
  const allControls = [{
    name: 'left',
    icon: justify_left,
    title: (0,external_wp_i18n_namespaceObject.__)('Justify items left'),
    isActive: 'left' === value,
    onClick: () => handleClick('left')
  }, {
    name: 'center',
    icon: justify_center,
    title: (0,external_wp_i18n_namespaceObject.__)('Justify items center'),
    isActive: 'center' === value,
    onClick: () => handleClick('center')
  }, {
    name: 'right',
    icon: justify_right,
    title: (0,external_wp_i18n_namespaceObject.__)('Justify items right'),
    isActive: 'right' === value,
    onClick: () => handleClick('right')
  }, {
    name: 'space-between',
    icon: justify_space_between,
    title: (0,external_wp_i18n_namespaceObject.__)('Space between items'),
    isActive: 'space-between' === value,
    onClick: () => handleClick('space-between')
  }, {
    name: 'stretch',
    icon: justify_stretch,
    title: (0,external_wp_i18n_namespaceObject.__)('Stretch items'),
    isActive: 'stretch' === value,
    onClick: () => handleClick('stretch')
  }];
  const UIComponent = isToolbar ? external_wp_components_namespaceObject.ToolbarGroup : external_wp_components_namespaceObject.ToolbarDropdownMenu;
  const extraProps = isToolbar ? {
    isCollapsed
  } : {};
  return (0,external_wp_element_namespaceObject.createElement)(UIComponent, {
    icon: icon,
    popoverProps: popoverProps,
    label: (0,external_wp_i18n_namespaceObject.__)('Change items justification'),
    controls: allControls.filter(elem => allowedControls.includes(elem.name)),
    ...extraProps
  });
}

/* harmony default export */ var justify_content_control_ui = (JustifyContentUI);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/justify-content-control/index.js


/**
 * Internal dependencies
 */


const JustifyContentControl = props => {
  return (0,external_wp_element_namespaceObject.createElement)(justify_content_control_ui, { ...props,
    isToolbar: false
  });
};

const JustifyToolbar = props => {
  return (0,external_wp_element_namespaceObject.createElement)(justify_content_control_ui, { ...props,
    isToolbar: true
  });
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/justify-content-control/README.md
 */




;// CONCATENATED MODULE: external "lodash"
var external_lodash_namespaceObject = window["lodash"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/use-setting/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



const blockedPaths = ['color', 'border', 'dimensions', 'typography', 'spacing'];
const deprecatedFlags = {
  'color.palette': settings => settings.colors,
  'color.gradients': settings => settings.gradients,
  'color.custom': settings => settings.disableCustomColors === undefined ? undefined : !settings.disableCustomColors,
  'color.customGradient': settings => settings.disableCustomGradients === undefined ? undefined : !settings.disableCustomGradients,
  'typography.fontSizes': settings => settings.fontSizes,
  'typography.customFontSize': settings => settings.disableCustomFontSizes === undefined ? undefined : !settings.disableCustomFontSizes,
  'typography.lineHeight': settings => settings.enableCustomLineHeight,
  'spacing.units': settings => {
    if (settings.enableCustomUnits === undefined) {
      return;
    }

    if (settings.enableCustomUnits === true) {
      return ['px', 'em', 'rem', 'vh', 'vw', '%'];
    }

    return settings.enableCustomUnits;
  },
  'spacing.padding': settings => settings.enableCustomSpacing
};
const prefixedFlags = {
  /*
   * These were only available in the plugin
   * and can be removed when the minimum WordPress version
   * for the plugin is 5.9.
   */
  'border.customColor': 'border.color',
  'border.customStyle': 'border.style',
  'border.customWidth': 'border.width',
  'typography.customFontStyle': 'typography.fontStyle',
  'typography.customFontWeight': 'typography.fontWeight',
  'typography.customLetterSpacing': 'typography.letterSpacing',
  'typography.customTextDecorations': 'typography.textDecoration',
  'typography.customTextTransforms': 'typography.textTransform',

  /*
   * These were part of WordPress 5.8 and we need to keep them.
   */
  'border.customRadius': 'border.radius',
  'spacing.customMargin': 'spacing.margin',
  'spacing.customPadding': 'spacing.padding',
  'typography.customLineHeight': 'typography.lineHeight'
};
/**
 * Remove `custom` prefixes for flags that did not land in 5.8.
 *
 * This provides continued support for `custom` prefixed properties. It will
 * be removed once third party devs have had sufficient time to update themes,
 * plugins, etc.
 *
 * @see https://github.com/WordPress/gutenberg/pull/34485
 *
 * @param {string} path Path to desired value in settings.
 * @return {string}     The value for defined setting.
 */

const removeCustomPrefixes = path => {
  return prefixedFlags[path] || path;
};
/**
 * Hook that retrieves the given setting for the block instance in use.
 *
 * It looks up the settings first in the block instance hierarchy.
 * If none is found, it'll look it up in the block editor store.
 *
 * @param {string} path The path to the setting.
 * @return {any} Returns the value defined for the setting.
 * @example
 * ```js
 * const isEnabled = useSetting( 'typography.dropCap' );
 * ```
 */


function use_setting_useSetting(path) {
  const {
    name: blockName,
    clientId
  } = useBlockEditContext();
  return (0,external_wp_data_namespaceObject.useSelect)(select => {
    if (blockedPaths.includes(path)) {
      // eslint-disable-next-line no-console
      console.warn('Top level useSetting paths are disabled. Please use a subpath to query the information needed.');
      return undefined;
    } // 0. Allow third parties to filter the block's settings at runtime.


    let result = (0,external_wp_hooks_namespaceObject.applyFilters)('blockEditor.useSetting.before', undefined, path, clientId, blockName);

    if (undefined !== result) {
      return result;
    }

    const normalizedPath = removeCustomPrefixes(path); // 1. Take settings from the block instance or its ancestors.
    // Start from the current block and work our way up the ancestors.

    const candidates = [clientId, ...select(store).getBlockParents(clientId,
    /* ascending */
    true)];

    for (const candidateClientId of candidates) {
      const candidateBlockName = select(store).getBlockName(candidateClientId);

      if ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(candidateBlockName, '__experimentalSettings', false)) {
        var _get;

        const candidateAtts = select(store).getBlockAttributes(candidateClientId);
        result = (_get = (0,external_lodash_namespaceObject.get)(candidateAtts, `settings.blocks.${blockName}.${normalizedPath}`)) !== null && _get !== void 0 ? _get : (0,external_lodash_namespaceObject.get)(candidateAtts, `settings.${normalizedPath}`);

        if (result !== undefined) {
          // Stop the search for more distant ancestors and move on.
          break;
        }
      }
    } // 2. Fall back to the settings from the block editor store (__experimentalFeatures).


    const settings = select(store).getSettings();

    if (result === undefined) {
      var _get2;

      const defaultsPath = `__experimentalFeatures.${normalizedPath}`;
      const blockPath = `__experimentalFeatures.blocks.${blockName}.${normalizedPath}`;
      result = (_get2 = (0,external_lodash_namespaceObject.get)(settings, blockPath)) !== null && _get2 !== void 0 ? _get2 : (0,external_lodash_namespaceObject.get)(settings, defaultsPath);
    } // Return if the setting was found in either the block instance or the store.


    if (result !== undefined) {
      if (external_wp_blocks_namespaceObject.__EXPERIMENTAL_PATHS_WITH_MERGE[normalizedPath]) {
        var _ref, _result$custom;

        return (_ref = (_result$custom = result.custom) !== null && _result$custom !== void 0 ? _result$custom : result.theme) !== null && _ref !== void 0 ? _ref : result.default;
      }

      return result;
    } // 3. Otherwise, use deprecated settings.


    const deprecatedSettingsValue = deprecatedFlags[normalizedPath] ? deprecatedFlags[normalizedPath](settings) : undefined;

    if (deprecatedSettingsValue !== undefined) {
      return deprecatedSettingsValue;
    } // 4. Fallback for typography.dropCap:
    // This is only necessary to support typography.dropCap.
    // when __experimentalFeatures are not present (core without plugin).
    // To remove when __experimentalFeatures are ported to core.


    return normalizedPath === 'typography.dropCap' ? true : undefined;
  }, [blockName, clientId, path]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/font-sizes/fluid-utils.js
/**
 * The fluid utilities must match the backend equivalent.
 * See: gutenberg_get_typography_font_size_value() in lib/block-supports/typography.php
 * ---------------------------------------------------------------
 */
// Defaults.
const DEFAULT_MAXIMUM_VIEWPORT_WIDTH = '1600px';
const DEFAULT_MINIMUM_VIEWPORT_WIDTH = '320px';
const DEFAULT_SCALE_FACTOR = 1;
const DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MIN = 0.25;
const DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MAX = 0.75;
const DEFAULT_MINIMUM_FONT_SIZE_LIMIT = '14px';
/**
 * Computes a fluid font-size value that uses clamp(). A minimum and maximum
 * font size OR a single font size can be specified.
 *
 * If a single font size is specified, it is scaled up and down using a logarithmic scale.
 *
 * @example
 * ```js
 * // Calculate fluid font-size value from a minimum and maximum value.
 * const fontSize = getComputedFluidTypographyValue( {
 *     minimumFontSize: '20px',
 *     maximumFontSize: '45px'
 * } );
 * // Calculate fluid font-size value from a single font size.
 * const fontSize = getComputedFluidTypographyValue( {
 *     fontSize: '30px',
 * } );
 * ```
 *
 * @param {Object}        args
 * @param {?string}       args.minimumViewPortWidth Minimum viewport size from which type will have fluidity. Optional if fontSize is specified.
 * @param {?string}       args.maximumViewPortWidth Maximum size up to which type will have fluidity. Optional if fontSize is specified.
 * @param {string|number} [args.fontSize]           Size to derive maximumFontSize and minimumFontSize from, if necessary. Optional if minimumFontSize and maximumFontSize are specified.
 * @param {?string}       args.maximumFontSize      Maximum font size for any clamp() calculation. Optional.
 * @param {?string}       args.minimumFontSize      Minimum font size for any clamp() calculation. Optional.
 * @param {?number}       args.scaleFactor          A scale factor to determine how fast a font scales within boundaries. Optional.
 * @param {?string}       args.minimumFontSizeLimit The smallest a calculated font size may be. Optional.
 *
 * @return {string|null} A font-size value using clamp().
 */

function getComputedFluidTypographyValue({
  minimumFontSize,
  maximumFontSize,
  fontSize,
  minimumViewPortWidth = DEFAULT_MINIMUM_VIEWPORT_WIDTH,
  maximumViewPortWidth = DEFAULT_MAXIMUM_VIEWPORT_WIDTH,
  scaleFactor = DEFAULT_SCALE_FACTOR,
  minimumFontSizeLimit
}) {
  // Validate incoming settings and set defaults.
  minimumFontSizeLimit = !!getTypographyValueAndUnit(minimumFontSizeLimit) ? minimumFontSizeLimit : DEFAULT_MINIMUM_FONT_SIZE_LIMIT;
  /*
   * Calculates missing minimumFontSize and maximumFontSize from
   * defaultFontSize if provided.
   */

  if (fontSize) {
    // Parses default font size.
    const fontSizeParsed = getTypographyValueAndUnit(fontSize); // Protect against invalid units.

    if (!fontSizeParsed?.unit) {
      return null;
    } // Parses the minimum font size limit, so we can perform checks using it.


    const minimumFontSizeLimitParsed = getTypographyValueAndUnit(minimumFontSizeLimit, {
      coerceTo: fontSizeParsed.unit
    }); // Don't enforce minimum font size if a font size has explicitly set a min and max value.

    if (!!minimumFontSizeLimitParsed?.value && !minimumFontSize && !maximumFontSize) {
      /*
       * If a minimum size was not passed to this function
       * and the user-defined font size is lower than $minimum_font_size_limit,
       * do not calculate a fluid value.
       */
      if (fontSizeParsed?.value <= minimumFontSizeLimitParsed?.value) {
        return null;
      }
    } // If no fluid max font size is available use the incoming value.


    if (!maximumFontSize) {
      maximumFontSize = `${fontSizeParsed.value}${fontSizeParsed.unit}`;
    }
    /*
     * If no minimumFontSize is provided, create one using
     * the given font size multiplied by the min font size scale factor.
     */


    if (!minimumFontSize) {
      const fontSizeValueInPx = fontSizeParsed.unit === 'px' ? fontSizeParsed.value : fontSizeParsed.value * 16;
      /*
       * The scale factor is a multiplier that affects how quickly the curve will move towards the minimum,
       * that is, how quickly the size factor reaches 0 given increasing font size values.
       * For a - b * log2(), lower values of b will make the curve move towards the minimum faster.
       * The scale factor is constrained between min and max values.
       */

      const minimumFontSizeFactor = Math.min(Math.max(1 - 0.075 * Math.log2(fontSizeValueInPx), DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MIN), DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MAX); // Calculates the minimum font size.

      const calculatedMinimumFontSize = roundToPrecision(fontSizeParsed.value * minimumFontSizeFactor, 3); // Only use calculated min font size if it's > $minimum_font_size_limit value.

      if (!!minimumFontSizeLimitParsed?.value && calculatedMinimumFontSize < minimumFontSizeLimitParsed?.value) {
        minimumFontSize = `${minimumFontSizeLimitParsed.value}${minimumFontSizeLimitParsed.unit}`;
      } else {
        minimumFontSize = `${calculatedMinimumFontSize}${fontSizeParsed.unit}`;
      }
    }
  } // Grab the minimum font size and normalize it in order to use the value for calculations.


  const minimumFontSizeParsed = getTypographyValueAndUnit(minimumFontSize); // We get a 'preferred' unit to keep units consistent when calculating,
  // otherwise the result will not be accurate.

  const fontSizeUnit = minimumFontSizeParsed?.unit || 'rem'; // Grabs the maximum font size and normalize it in order to use the value for calculations.

  const maximumFontSizeParsed = getTypographyValueAndUnit(maximumFontSize, {
    coerceTo: fontSizeUnit
  }); // Checks for mandatory min and max sizes, and protects against unsupported units.

  if (!minimumFontSizeParsed || !maximumFontSizeParsed) {
    return null;
  } // Uses rem for accessible fluid target font scaling.


  const minimumFontSizeRem = getTypographyValueAndUnit(minimumFontSize, {
    coerceTo: 'rem'
  }); // Viewport widths defined for fluid typography. Normalize units

  const maximumViewPortWidthParsed = getTypographyValueAndUnit(maximumViewPortWidth, {
    coerceTo: fontSizeUnit
  });
  const minumumViewPortWidthParsed = getTypographyValueAndUnit(minimumViewPortWidth, {
    coerceTo: fontSizeUnit
  }); // Protect against unsupported units.

  if (!maximumViewPortWidthParsed || !minumumViewPortWidthParsed || !minimumFontSizeRem) {
    return null;
  } // Build CSS rule.
  // Borrowed from https://websemantics.uk/tools/responsive-font-calculator/.


  const minViewPortWidthOffsetValue = roundToPrecision(minumumViewPortWidthParsed.value / 100, 3);
  const viewPortWidthOffset = roundToPrecision(minViewPortWidthOffsetValue, 3) + fontSizeUnit;
  const linearFactor = 100 * ((maximumFontSizeParsed.value - minimumFontSizeParsed.value) / (maximumViewPortWidthParsed.value - minumumViewPortWidthParsed.value));
  const linearFactorScaled = roundToPrecision((linearFactor || 1) * scaleFactor, 3);
  const fluidTargetFontSize = `${minimumFontSizeRem.value}${minimumFontSizeRem.unit} + ((1vw - ${viewPortWidthOffset}) * ${linearFactorScaled})`;
  return `clamp(${minimumFontSize}, ${fluidTargetFontSize}, ${maximumFontSize})`;
}
/**
 * Internal method that checks a string for a unit and value and returns an array consisting of `'value'` and `'unit'`, e.g., [ '42', 'rem' ].
 * A raw font size of `value + unit` is expected. If the value is an integer, it will convert to `value + 'px'`.
 *
 * @param {string|number}    rawValue Raw size value from theme.json.
 * @param {Object|undefined} options  Calculation options.
 *
 * @return {{ unit: string, value: number }|null} An object consisting of `'value'` and `'unit'` properties.
 */

function getTypographyValueAndUnit(rawValue, options = {}) {
  if (typeof rawValue !== 'string' && typeof rawValue !== 'number') {
    return null;
  } // Converts numeric values to pixel values by default.


  if (isFinite(rawValue)) {
    rawValue = `${rawValue}px`;
  }

  const {
    coerceTo,
    rootSizeValue,
    acceptableUnits
  } = {
    coerceTo: '',
    // Default browser font size. Later we could inject some JS to compute this `getComputedStyle( document.querySelector( "html" ) ).fontSize`.
    rootSizeValue: 16,
    acceptableUnits: ['rem', 'px', 'em'],
    ...options
  };
  const acceptableUnitsGroup = acceptableUnits?.join('|');
  const regexUnits = new RegExp(`^(\\d*\\.?\\d+)(${acceptableUnitsGroup}){1,1}$`);
  const matches = rawValue.match(regexUnits); // We need a number value and a unit.

  if (!matches || matches.length < 3) {
    return null;
  }

  let [, value, unit] = matches;
  let returnValue = parseFloat(value);

  if ('px' === coerceTo && ('em' === unit || 'rem' === unit)) {
    returnValue = returnValue * rootSizeValue;
    unit = coerceTo;
  }

  if ('px' === unit && ('em' === coerceTo || 'rem' === coerceTo)) {
    returnValue = returnValue / rootSizeValue;
    unit = coerceTo;
  }
  /*
   * No calculation is required if swapping between em and rem yet,
   * since we assume a root size value. Later we might like to differentiate between
   * :root font size (rem) and parent element font size (em) relativity.
   */


  if (('em' === coerceTo || 'rem' === coerceTo) && ('em' === unit || 'rem' === unit)) {
    unit = coerceTo;
  }

  return {
    value: roundToPrecision(returnValue, 3),
    unit
  };
}
/**
 * Returns a value rounded to defined precision.
 * Returns `undefined` if the value is not a valid finite number.
 *
 * @param {number} value  Raw value.
 * @param {number} digits The number of digits to appear after the decimal point
 *
 * @return {number|undefined} Value rounded to standard precision.
 */

function roundToPrecision(value, digits = 3) {
  const base = Math.pow(10, digits);
  return Number.isFinite(value) ? parseFloat(Math.round(value * base) / base) : undefined;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/global-styles/typography-utils.js
/**
 * The fluid utilities must match the backend equivalent.
 * See: gutenberg_get_typography_font_size_value() in lib/block-supports/typography.php
 * ---------------------------------------------------------------
 */

/**
 * Internal dependencies
 */

/**
 * @typedef {Object} FluidPreset
 * @property {string|undefined}  max A maximum font size value.
 * @property {?string|undefined} min A minimum font size value.
 */

/**
 * @typedef {Object} Preset
 * @property {?string|?number}               size  A default font size.
 * @property {string}                        name  A font size name, displayed in the UI.
 * @property {string}                        slug  A font size slug
 * @property {boolean|FluidPreset|undefined} fluid Specifies the minimum and maximum font size value of a fluid font size.
 */

/**
 * @typedef {Object} TypographySettings
 * @property {?string} minViewPortWidth  Minimum viewport size from which type will have fluidity. Optional if size is specified.
 * @property {?string} maxViewPortWidth  Maximum size up to which type will have fluidity. Optional if size is specified.
 * @property {?number} scaleFactor       A scale factor to determine how fast a font scales within boundaries. Optional.
 * @property {?number} minFontSizeFactor How much to scale defaultFontSize by to derive minimumFontSize. Optional.
 * @property {?string} minFontSize       The smallest a calculated font size may be. Optional.
 */

/**
 * Returns a font-size value based on a given font-size preset.
 * Takes into account fluid typography parameters and attempts to return a css formula depending on available, valid values.
 *
 * @param {Preset}                     preset
 * @param {Object}                     typographyOptions
 * @param {boolean|TypographySettings} typographyOptions.fluid Whether fluid typography is enabled, and, optionally, fluid font size options.
 *
 * @return {string|*} A font-size value or the value of preset.size.
 */

function getTypographyFontSizeValue(preset, typographyOptions) {
  const {
    size: defaultSize
  } = preset;

  if (!isFluidTypographyEnabled(typographyOptions)) {
    return defaultSize;
  }
  /*
   * Checks whether a font size has explicitly bypassed fluid calculations.
   * Also catches falsy values and 0/'0'.
   * Fluid calculations cannot be performed on `0`.
   */


  if (!defaultSize || '0' === defaultSize || false === preset?.fluid) {
    return defaultSize;
  }

  const fluidTypographySettings = typeof typographyOptions?.fluid === 'object' ? typographyOptions?.fluid : {};
  const fluidFontSizeValue = getComputedFluidTypographyValue({
    minimumFontSize: preset?.fluid?.min,
    maximumFontSize: preset?.fluid?.max,
    fontSize: defaultSize,
    minimumFontSizeLimit: fluidTypographySettings?.minFontSize,
    maximumViewPortWidth: fluidTypographySettings?.maxViewPortWidth
  });

  if (!!fluidFontSizeValue) {
    return fluidFontSizeValue;
  }

  return defaultSize;
}

function isFluidTypographyEnabled(typographySettings) {
  const fluidSettings = typographySettings?.fluid;
  return true === fluidSettings || fluidSettings && typeof fluidSettings === 'object' && Object.keys(fluidSettings).length > 0;
}
/**
 * Returns fluid typography settings from theme.json setting object.
 *
 * @param {Object} settings            Theme.json settings
 * @param {Object} settings.typography Theme.json typography settings
 * @param {Object} settings.layout     Theme.json layout settings
 * @return {TypographySettings} Fluid typography settings
 */


function getFluidTypographyOptionsFromSettings(settings) {
  const typographySettings = settings?.typography;
  const layoutSettings = settings?.layout;
  const defaultMaxViewportWidth = getTypographyValueAndUnit(layoutSettings?.wideSize) ? layoutSettings?.wideSize : null;
  return isFluidTypographyEnabled(typographySettings) && defaultMaxViewportWidth ? {
    fluid: {
      maxViewPortWidth: defaultMaxViewportWidth,
      ...typographySettings.fluid
    }
  } : {
    fluid: typographySettings?.fluid
  };
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/global-styles/utils.js
/**
 * External dependencies
 */


/**
 * Internal dependencies
 */


/* Supporting data. */

const ROOT_BLOCK_NAME = 'root';
const ROOT_BLOCK_SELECTOR = 'body';
const ROOT_BLOCK_SUPPORTS = (/* unused pure expression or super */ null && (['background', 'backgroundColor', 'color', 'linkColor', 'captionColor', 'buttonColor', 'headingColor', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'lineHeight', 'textDecoration', 'textTransform', 'padding']));
const PRESET_METADATA = [{
  path: ['color', 'palette'],
  valueKey: 'color',
  cssVarInfix: 'color',
  classes: [{
    classSuffix: 'color',
    propertyName: 'color'
  }, {
    classSuffix: 'background-color',
    propertyName: 'background-color'
  }, {
    classSuffix: 'border-color',
    propertyName: 'border-color'
  }]
}, {
  path: ['color', 'gradients'],
  valueKey: 'gradient',
  cssVarInfix: 'gradient',
  classes: [{
    classSuffix: 'gradient-background',
    propertyName: 'background'
  }]
}, {
  path: ['color', 'duotone'],
  valueKey: 'colors',
  cssVarInfix: 'duotone',
  valueFunc: ({
    slug
  }) => `url( '#wp-duotone-${slug}' )`,
  classes: []
}, {
  path: ['shadow', 'presets'],
  valueKey: 'shadow',
  cssVarInfix: 'shadow',
  classes: []
}, {
  path: ['typography', 'fontSizes'],
  valueFunc: (preset, settings) => getTypographyFontSizeValue(preset, getFluidTypographyOptionsFromSettings(settings)),
  valueKey: 'size',
  cssVarInfix: 'font-size',
  classes: [{
    classSuffix: 'font-size',
    propertyName: 'font-size'
  }]
}, {
  path: ['typography', 'fontFamilies'],
  valueKey: 'fontFamily',
  cssVarInfix: 'font-family',
  classes: [{
    classSuffix: 'font-family',
    propertyName: 'font-family'
  }]
}, {
  path: ['spacing', 'spacingSizes'],
  valueKey: 'size',
  cssVarInfix: 'spacing',
  valueFunc: ({
    size
  }) => size,
  classes: []
}];
const STYLE_PATH_TO_CSS_VAR_INFIX = {
  'color.background': 'color',
  'color.text': 'color',
  'filter.duotone': 'duotone',
  'elements.link.color.text': 'color',
  'elements.link.:hover.color.text': 'color',
  'elements.link.typography.fontFamily': 'font-family',
  'elements.link.typography.fontSize': 'font-size',
  'elements.button.color.text': 'color',
  'elements.button.color.background': 'color',
  'elements.caption.color.text': 'color',
  'elements.button.typography.fontFamily': 'font-family',
  'elements.button.typography.fontSize': 'font-size',
  'elements.heading.color': 'color',
  'elements.heading.color.background': 'color',
  'elements.heading.typography.fontFamily': 'font-family',
  'elements.heading.gradient': 'gradient',
  'elements.heading.color.gradient': 'gradient',
  'elements.h1.color': 'color',
  'elements.h1.color.background': 'color',
  'elements.h1.typography.fontFamily': 'font-family',
  'elements.h1.color.gradient': 'gradient',
  'elements.h2.color': 'color',
  'elements.h2.color.background': 'color',
  'elements.h2.typography.fontFamily': 'font-family',
  'elements.h2.color.gradient': 'gradient',
  'elements.h3.color': 'color',
  'elements.h3.color.background': 'color',
  'elements.h3.typography.fontFamily': 'font-family',
  'elements.h3.color.gradient': 'gradient',
  'elements.h4.color': 'color',
  'elements.h4.color.background': 'color',
  'elements.h4.typography.fontFamily': 'font-family',
  'elements.h4.color.gradient': 'gradient',
  'elements.h5.color': 'color',
  'elements.h5.color.background': 'color',
  'elements.h5.typography.fontFamily': 'font-family',
  'elements.h5.color.gradient': 'gradient',
  'elements.h6.color': 'color',
  'elements.h6.color.background': 'color',
  'elements.h6.typography.fontFamily': 'font-family',
  'elements.h6.color.gradient': 'gradient',
  'color.gradient': 'gradient',
  shadow: 'shadow',
  'typography.fontSize': 'font-size',
  'typography.fontFamily': 'font-family'
}; // A static list of block attributes that store global style preset slugs.

const STYLE_PATH_TO_PRESET_BLOCK_ATTRIBUTE = {
  'color.background': 'backgroundColor',
  'color.text': 'textColor',
  'color.gradient': 'gradient',
  'typography.fontSize': 'fontSize',
  'typography.fontFamily': 'fontFamily'
};

function findInPresetsBy(features, blockName, presetPath, presetProperty, presetValueValue) {
  // Block presets take priority above root level presets.
  const orderedPresetsByOrigin = [(0,external_lodash_namespaceObject.get)(features, ['blocks', blockName, ...presetPath]), (0,external_lodash_namespaceObject.get)(features, presetPath)];

  for (const presetByOrigin of orderedPresetsByOrigin) {
    if (presetByOrigin) {
      // Preset origins ordered by priority.
      const origins = ['custom', 'theme', 'default'];

      for (const origin of origins) {
        const presets = presetByOrigin[origin];

        if (presets) {
          const presetObject = presets.find(preset => preset[presetProperty] === presetValueValue);

          if (presetObject) {
            if (presetProperty === 'slug') {
              return presetObject;
            } // If there is a highest priority preset with the same slug but different value the preset we found was overwritten and should be ignored.


            const highestPresetObjectWithSameSlug = findInPresetsBy(features, blockName, presetPath, 'slug', presetObject.slug);

            if (highestPresetObjectWithSameSlug[presetProperty] === presetObject[presetProperty]) {
              return presetObject;
            }

            return undefined;
          }
        }
      }
    }
  }
}

function getPresetVariableFromValue(features, blockName, variableStylePath, presetPropertyValue) {
  if (!presetPropertyValue) {
    return presetPropertyValue;
  }

  const cssVarInfix = STYLE_PATH_TO_CSS_VAR_INFIX[variableStylePath];
  const metadata = PRESET_METADATA.find(data => data.cssVarInfix === cssVarInfix);

  if (!metadata) {
    // The property doesn't have preset data
    // so the value should be returned as it is.
    return presetPropertyValue;
  }

  const {
    valueKey,
    path
  } = metadata;
  const presetObject = findInPresetsBy(features, blockName, path, valueKey, presetPropertyValue);

  if (!presetObject) {
    // Value wasn't found in the presets,
    // so it must be a custom value.
    return presetPropertyValue;
  }

  return `var:preset|${cssVarInfix}|${presetObject.slug}`;
}

function getValueFromPresetVariable(features, blockName, variable, [presetType, slug]) {
  const metadata = PRESET_METADATA.find(data => data.cssVarInfix === presetType);

  if (!metadata) {
    return variable;
  }

  const presetObject = findInPresetsBy(features.settings, blockName, metadata.path, 'slug', slug);

  if (presetObject) {
    const {
      valueKey
    } = metadata;
    const result = presetObject[valueKey];
    return getValueFromVariable(features, blockName, result);
  }

  return variable;
}

function getValueFromCustomVariable(features, blockName, variable, path) {
  var _get;

  const result = (_get = (0,external_lodash_namespaceObject.get)(features.settings, ['blocks', blockName, 'custom', ...path])) !== null && _get !== void 0 ? _get : (0,external_lodash_namespaceObject.get)(features.settings, ['custom', ...path]);

  if (!result) {
    return variable;
  } // A variable may reference another variable so we need recursion until we find the value.


  return getValueFromVariable(features, blockName, result);
}
/**
 * Attempts to fetch the value of a theme.json CSS variable.
 *
 * @param {Object}   features  GlobalStylesContext config, e.g., user, base or merged. Represents the theme.json tree.
 * @param {string}   blockName The name of a block as represented in the styles property. E.g., 'root' for root-level, and 'core/${blockName}' for blocks.
 * @param {string|*} variable  An incoming style value. A CSS var value is expected, but it could be any value.
 * @return {string|*|{ref}} The value of the CSS var, if found. If not found, the passed variable argument.
 */


function getValueFromVariable(features, blockName, variable) {
  if (!variable || typeof variable !== 'string') {
    if (variable?.ref && typeof variable?.ref === 'string') {
      const refPath = variable.ref.split('.');
      variable = (0,external_lodash_namespaceObject.get)(features, refPath); // Presence of another ref indicates a reference to another dynamic value.
      // Pointing to another dynamic value is not supported.

      if (!variable || !!variable?.ref) {
        return variable;
      }
    } else {
      return variable;
    }
  }

  const USER_VALUE_PREFIX = 'var:';
  const THEME_VALUE_PREFIX = 'var(--wp--';
  const THEME_VALUE_SUFFIX = ')';
  let parsedVar;

  if (variable.startsWith(USER_VALUE_PREFIX)) {
    parsedVar = variable.slice(USER_VALUE_PREFIX.length).split('|');
  } else if (variable.startsWith(THEME_VALUE_PREFIX) && variable.endsWith(THEME_VALUE_SUFFIX)) {
    parsedVar = variable.slice(THEME_VALUE_PREFIX.length, -THEME_VALUE_SUFFIX.length).split('--');
  } else {
    // We don't know how to parse the value: either is raw of uses complex CSS such as `calc(1px * var(--wp--variable) )`
    return variable;
  }

  const [type, ...path] = parsedVar;

  if (type === 'preset') {
    return getValueFromPresetVariable(features, blockName, variable, path);
  }

  if (type === 'custom') {
    return getValueFromCustomVariable(features, blockName, variable, path);
  }

  return variable;
}
/**
 * Function that scopes a selector with another one. This works a bit like
 * SCSS nesting except the `&` operator isn't supported.
 *
 * @example
 * ```js
 * const scope = '.a, .b .c';
 * const selector = '> .x, .y';
 * const merged = scopeSelector( scope, selector );
 * // merged is '.a > .x, .a .y, .b .c > .x, .b .c .y'
 * ```
 *
 * @param {string} scope    Selector to scope to.
 * @param {string} selector Original selector.
 *
 * @return {string} Scoped selector.
 */

function scopeSelector(scope, selector) {
  const scopes = scope.split(',');
  const selectors = selector.split(',');
  const selectorsScoped = [];
  scopes.forEach(outer => {
    selectors.forEach(inner => {
      selectorsScoped.push(`${outer.trim()} ${inner.trim()}`);
    });
  });
  return selectorsScoped.join(', ');
}
/**
 * Compares global style variations according to their styles and settings properties.
 *
 * @example
 * ```js
 * const globalStyles = { styles: { typography: { fontSize: '10px' } }, settings: {} };
 * const variation = { styles: { typography: { fontSize: '10000px' } }, settings: {} };
 * const isEqual = areGlobalStyleConfigsEqual( globalStyles, variation );
 * // false
 * ```
 *
 * @param {Object} original  A global styles object.
 * @param {Object} variation A global styles object.
 *
 * @return {boolean} Whether `original` and `variation` match.
 */

function areGlobalStyleConfigsEqual(original, variation) {
  if (typeof original !== 'object' || typeof variation !== 'object') {
    return original === variation;
  }

  return es6_default()(original?.styles, variation?.styles) && es6_default()(original?.settings, variation?.settings);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/global-styles/context.js
/**
 * WordPress dependencies
 */

const DEFAULT_GLOBAL_STYLES_CONTEXT = {
  user: {},
  base: {},
  merged: {},
  setUserConfig: () => {}
};
const GlobalStylesContext = (0,external_wp_element_namespaceObject.createContext)(DEFAULT_GLOBAL_STYLES_CONTEXT);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/global-styles/hooks.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




const EMPTY_CONFIG = {
  settings: {},
  styles: {}
};
const VALID_SETTINGS = ['appearanceTools', 'useRootPaddingAwareAlignments', 'border.color', 'border.radius', 'border.style', 'border.width', 'shadow.presets', 'shadow.defaultPresets', 'color.background', 'color.button', 'color.caption', 'color.custom', 'color.customDuotone', 'color.customGradient', 'color.defaultDuotone', 'color.defaultGradients', 'color.defaultPalette', 'color.duotone', 'color.gradients', 'color.heading', 'color.link', 'color.palette', 'color.text', 'custom', 'dimensions.minHeight', 'layout.contentSize', 'layout.definitions', 'layout.wideSize', 'position.fixed', 'position.sticky', 'spacing.customSpacingSize', 'spacing.spacingSizes', 'spacing.spacingScale', 'spacing.blockGap', 'spacing.margin', 'spacing.padding', 'spacing.units', 'typography.fluid', 'typography.customFontSize', 'typography.dropCap', 'typography.fontFamilies', 'typography.fontSizes', 'typography.fontStyle', 'typography.fontWeight', 'typography.letterSpacing', 'typography.lineHeight', 'typography.textColumns', 'typography.textDecoration', 'typography.textTransform'];
const useGlobalStylesReset = () => {
  const {
    user: config,
    setUserConfig
  } = (0,external_wp_element_namespaceObject.useContext)(GlobalStylesContext);
  const canReset = !!config && !es6_default()(config, EMPTY_CONFIG);
  return [canReset, (0,external_wp_element_namespaceObject.useCallback)(() => setUserConfig(() => EMPTY_CONFIG), [setUserConfig])];
};
function useGlobalSetting(propertyPath, blockName, source = 'all') {
  const {
    setUserConfig,
    ...configs
  } = (0,external_wp_element_namespaceObject.useContext)(GlobalStylesContext);
  const appendedBlockPath = blockName ? '.blocks.' + blockName : '';
  const appendedPropertyPath = propertyPath ? '.' + propertyPath : '';
  const contextualPath = `settings${appendedBlockPath}${appendedPropertyPath}`;
  const globalPath = `settings${appendedPropertyPath}`;
  const sourceKey = source === 'all' ? 'merged' : source;
  const settingValue = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const configToUse = configs[sourceKey];

    if (!configToUse) {
      throw 'Unsupported source';
    }

    if (propertyPath) {
      var _get;

      return (_get = (0,external_lodash_namespaceObject.get)(configToUse, contextualPath)) !== null && _get !== void 0 ? _get : (0,external_lodash_namespaceObject.get)(configToUse, globalPath);
    }

    const result = {};
    VALID_SETTINGS.forEach(setting => {
      var _get2;

      const value = (_get2 = (0,external_lodash_namespaceObject.get)(configToUse, `settings${appendedBlockPath}.${setting}`)) !== null && _get2 !== void 0 ? _get2 : (0,external_lodash_namespaceObject.get)(configToUse, `settings.${setting}`);

      if (value) {
        (0,external_lodash_namespaceObject.set)(result, setting, value);
      }
    });
    return result;
  }, [configs, sourceKey, propertyPath, contextualPath, globalPath, appendedBlockPath]);

  const setSetting = newValue => {
    setUserConfig(currentConfig => {
      // Deep clone `currentConfig` to avoid mutating it later.
      const newUserConfig = JSON.parse(JSON.stringify(currentConfig));
      (0,external_lodash_namespaceObject.set)(newUserConfig, contextualPath, newValue);
      return newUserConfig;
    });
  };

  return [settingValue, setSetting];
}
function useGlobalStyle(path, blockName, source = 'all', {
  shouldDecodeEncode = true
} = {}) {
  const {
    merged: mergedConfig,
    base: baseConfig,
    user: userConfig,
    setUserConfig
  } = (0,external_wp_element_namespaceObject.useContext)(GlobalStylesContext);
  const appendedPath = path ? '.' + path : '';
  const finalPath = !blockName ? `styles${appendedPath}` : `styles.blocks.${blockName}${appendedPath}`;

  const setStyle = newValue => {
    setUserConfig(currentConfig => {
      // Deep clone `currentConfig` to avoid mutating it later.
      const newUserConfig = JSON.parse(JSON.stringify(currentConfig));
      (0,external_lodash_namespaceObject.set)(newUserConfig, finalPath, shouldDecodeEncode ? getPresetVariableFromValue(mergedConfig.settings, blockName, path, newValue) : newValue);
      return newUserConfig;
    });
  };

  let rawResult, result;

  switch (source) {
    case 'all':
      rawResult = (0,external_lodash_namespaceObject.get)(mergedConfig, finalPath);
      result = shouldDecodeEncode ? getValueFromVariable(mergedConfig, blockName, rawResult) : rawResult;
      break;

    case 'user':
      rawResult = (0,external_lodash_namespaceObject.get)(userConfig, finalPath);
      result = shouldDecodeEncode ? getValueFromVariable(mergedConfig, blockName, rawResult) : rawResult;
      break;

    case 'base':
      rawResult = (0,external_lodash_namespaceObject.get)(baseConfig, finalPath);
      result = shouldDecodeEncode ? getValueFromVariable(baseConfig, blockName, rawResult) : rawResult;
      break;

    default:
      throw 'Unsupported source';
  }

  return [result, setStyle];
}
/**
 * React hook that overrides a global settings object with block and element specific settings.
 *
 * @param {Object}     parentSettings Settings object.
 * @param {blockName?} blockName      Block name.
 * @param {element?}   element        Element name.
 *
 * @return {Object} Merge of settings and supports.
 */

function useSettingsForBlockElement(parentSettings, blockName, element) {
  const {
    supportedStyles,
    supports
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    return {
      supportedStyles: unlock(select(external_wp_blocks_namespaceObject.store)).getSupportedStyles(blockName, element),
      supports: select(external_wp_blocks_namespaceObject.store).getBlockType(blockName)?.supports
    };
  }, [blockName, element]);
  return (0,external_wp_element_namespaceObject.useMemo)(() => {
    const updatedSettings = { ...parentSettings
    };

    if (!supportedStyles.includes('fontSize')) {
      updatedSettings.typography = { ...updatedSettings.typography,
        fontSizes: {},
        customFontSize: false
      };
    }

    if (!supportedStyles.includes('fontFamily')) {
      updatedSettings.typography = { ...updatedSettings.typography,
        fontFamilies: {}
      };
    }

    updatedSettings.color = { ...updatedSettings.color,
      text: updatedSettings.color?.text && supportedStyles.includes('color'),
      background: updatedSettings.color?.background && (supportedStyles.includes('background') || supportedStyles.includes('backgroundColor')),
      button: updatedSettings.color?.button && supportedStyles.includes('buttonColor'),
      heading: updatedSettings.color?.heading && supportedStyles.includes('headingColor'),
      link: updatedSettings.color?.link && supportedStyles.includes('linkColor'),
      caption: updatedSettings.color?.caption && supportedStyles.includes('captionColor')
    }; // Some blocks can enable background colors but disable gradients.

    if (!supportedStyles.includes('background')) {
      updatedSettings.color.gradients = [];
      updatedSettings.color.customGradient = false;
    } // If filters are not supported by the block/element, disable duotone.


    if (!supportedStyles.includes('filter')) {
      updatedSettings.color.defaultDuotone = false;
      updatedSettings.color.customDuotone = false;
    }

    ['lineHeight', 'fontStyle', 'fontWeight', 'letterSpacing', 'textTransform', 'textDecoration'].forEach(key => {
      if (!supportedStyles.includes(key)) {
        updatedSettings.typography = { ...updatedSettings.typography,
          [key]: false
        };
      }
    }); // The column-count style is named text column to reduce confusion with
    // the columns block and manage expectations from the support.
    // See: https://github.com/WordPress/gutenberg/pull/33587

    if (!supportedStyles.includes('columnCount')) {
      updatedSettings.typography = { ...updatedSettings.typography,
        textColumns: false
      };
    }

    ['contentSize', 'wideSize'].forEach(key => {
      if (!supportedStyles.includes(key)) {
        updatedSettings.layout = { ...updatedSettings.layout,
          [key]: false
        };
      }
    });
    ['padding', 'margin', 'blockGap'].forEach(key => {
      if (!supportedStyles.includes(key)) {
        updatedSettings.spacing = { ...updatedSettings.spacing,
          [key]: false
        };
      }

      const sides = Array.isArray(supports?.spacing?.[key]) ? supports?.spacing?.[key] : supports?.spacing?.[key]?.sides; // Check if spacing type is supported before adding sides.

      if (sides?.length && updatedSettings.spacing?.[key]) {
        updatedSettings.spacing = { ...updatedSettings.spacing,
          [key]: { ...updatedSettings.spacing?.[key],
            sides
          }
        };
      }
    });

    if (!supportedStyles.includes('minHeight')) {
      updatedSettings.dimensions = { ...updatedSettings.dimensions,
        minHeight: false
      };
    }

    ['radius', 'color', 'style', 'width'].forEach(key => {
      if (!supportedStyles.includes('border' + key.charAt(0).toUpperCase() + key.slice(1))) {
        updatedSettings.border = { ...updatedSettings.border,
          [key]: false
        };
      }
    });
    updatedSettings.shadow = supportedStyles.includes('shadow') ? updatedSettings.shadow : false;
    return updatedSettings;
  }, [parentSettings, supportedStyles, supports]);
}
function useColorsPerOrigin(settings) {
  const customColors = settings?.color?.palette?.custom;
  const themeColors = settings?.color?.palette?.theme;
  const defaultColors = settings?.color?.palette?.default;
  const shouldDisplayDefaultColors = settings?.color?.defaultPalette;
  return (0,external_wp_element_namespaceObject.useMemo)(() => {
    const result = [];

    if (themeColors && themeColors.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)('Theme', 'Indicates this palette comes from the theme.'),
        colors: themeColors
      });
    }

    if (shouldDisplayDefaultColors && defaultColors && defaultColors.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)('Default', 'Indicates this palette comes from WordPress.'),
        colors: defaultColors
      });
    }

    if (customColors && customColors.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)('Custom', 'Indicates this palette is created by the user.'),
        colors: customColors
      });
    }

    return result;
  }, [customColors, themeColors, defaultColors, shouldDisplayDefaultColors]);
}
function useGradientsPerOrigin(settings) {
  const customGradients = settings?.color?.gradients?.custom;
  const themeGradients = settings?.color?.gradients?.theme;
  const defaultGradients = settings?.color?.gradients?.default;
  const shouldDisplayDefaultGradients = settings?.color?.defaultGradients;
  return (0,external_wp_element_namespaceObject.useMemo)(() => {
    const result = [];

    if (themeGradients && themeGradients.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)('Theme', 'Indicates this palette comes from the theme.'),
        gradients: themeGradients
      });
    }

    if (shouldDisplayDefaultGradients && defaultGradients && defaultGradients.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)('Default', 'Indicates this palette comes from WordPress.'),
        gradients: defaultGradients
      });
    }

    if (customGradients && customGradients.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)('Custom', 'Indicates this palette is created by the user.'),
        gradients: customGradients
      });
    }

    return result;
  }, [customGradients, themeGradients, defaultGradients, shouldDisplayDefaultGradients]);
}

;// CONCATENATED MODULE: ./node_modules/tslib/tslib.es6.mjs
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object") throw new TypeError("Object expected.");
    var dispose;
    if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  function next() {
    while (env.stack.length) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
      }
      catch (e) {
          fail(e);
      }
    }
    if (env.hasError) throw env.error;
  }
  return next();
}

/* harmony default export */ var tslib_es6 = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
});

;// CONCATENATED MODULE: ./node_modules/lower-case/dist.es2015/index.js
/**
 * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
 */
var SUPPORTED_LOCALE = {
    tr: {
        regexp: /\u0130|\u0049|\u0049\u0307/g,
        map: {
            İ: "\u0069",
            I: "\u0131",
            İ: "\u0069",
        },
    },
    az: {
        regexp: /\u0130/g,
        map: {
            İ: "\u0069",
            I: "\u0131",
            İ: "\u0069",
        },
    },
    lt: {
        regexp: /\u0049|\u004A|\u012E|\u00CC|\u00CD|\u0128/g,
        map: {
            I: "\u0069\u0307",
            J: "\u006A\u0307",
            Į: "\u012F\u0307",
            Ì: "\u0069\u0307\u0300",
            Í: "\u0069\u0307\u0301",
            Ĩ: "\u0069\u0307\u0303",
        },
    },
};
/**
 * Localized lower case.
 */
function localeLowerCase(str, locale) {
    var lang = SUPPORTED_LOCALE[locale.toLowerCase()];
    if (lang)
        return lowerCase(str.replace(lang.regexp, function (m) { return lang.map[m]; }));
    return lowerCase(str);
}
/**
 * Lower case as a function.
 */
function lowerCase(str) {
    return str.toLowerCase();
}

;// CONCATENATED MODULE: ./node_modules/no-case/dist.es2015/index.js

// Support camel case ("camelCase" -> "camel Case" and "CAMELCase" -> "CAMEL Case").
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
// Remove all non-word characters.
var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
/**
 * Normalize the string into something other libraries can manipulate easier.
 */
function noCase(input, options) {
    if (options === void 0) { options = {}; }
    var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
    var result = dist_es2015_replace(dist_es2015_replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
    var start = 0;
    var end = result.length;
    // Trim the delimiter from around the output string.
    while (result.charAt(start) === "\0")
        start++;
    while (result.charAt(end - 1) === "\0")
        end--;
    // Transform each token independently.
    return result.slice(start, end).split("\0").map(transform).join(delimiter);
}
/**
 * Replace `re` in the input string with the replacement value.
 */
function dist_es2015_replace(input, re, value) {
    if (re instanceof RegExp)
        return input.replace(re, value);
    return re.reduce(function (input, re) { return input.replace(re, value); }, input);
}

;// CONCATENATED MODULE: ./node_modules/dot-case/dist.es2015/index.js


function dotCase(input, options) {
    if (options === void 0) { options = {}; }
    return noCase(input, __assign({ delimiter: "." }, options));
}

;// CONCATENATED MODULE: ./node_modules/param-case/dist.es2015/index.js


function paramCase(input, options) {
    if (options === void 0) { options = {}; }
    return dotCase(input, __assign({ delimiter: "-" }, options));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/object.js
/**
 * External dependencies
 */

/**
 * Converts a path to an array of its fragments.
 * Supports strings, numbers and arrays:
 *
 * 'foo' => [ 'foo' ]
 * 2 => [ '2' ]
 * [ 'foo', 'bar' ] => [ 'foo', 'bar' ]
 *
 * @param {string|number|Array} path Path
 * @return {Array} Normalized path.
 */

function normalizePath(path) {
  if (Array.isArray(path)) {
    return path;
  } else if (typeof path === 'number') {
    return [path.toString()];
  }

  return [path];
}
/**
 * Converts any string to kebab case.
 * Backwards compatible with Lodash's `_.kebabCase()`.
 * Backwards compatible with `_wp_to_kebab_case()`.
 *
 * @see https://lodash.com/docs/4.17.15#kebabCase
 * @see https://developer.wordpress.org/reference/functions/_wp_to_kebab_case/
 *
 * @param {string} str String to convert.
 * @return {string} Kebab-cased string
 */


function kebabCase(str) {
  let input = str;

  if (typeof str !== 'string') {
    var _str$toString;

    input = (_str$toString = str?.toString?.()) !== null && _str$toString !== void 0 ? _str$toString : '';
  } // See https://github.com/lodash/lodash/blob/b185fcee26b2133bd071f4aaca14b455c2ed1008/lodash.js#L4970


  input = input.replace(/['\u2019]/, '');
  return paramCase(input, {
    splitRegexp: [/(?!(?:1ST|2ND|3RD|[4-9]TH)(?![a-z]))([a-z0-9])([A-Z])/g, // fooBar => foo-bar, 3Bar => 3-bar
    /(?!(?:1st|2nd|3rd|[4-9]th)(?![a-z]))([0-9])([a-z])/g, // 3bar => 3-bar
    /([A-Za-z])([0-9])/g, // Foo3 => foo-3, foo3 => foo-3
    /([A-Z])([A-Z][a-z])/g // FOOBar => foo-bar
    ]
  });
}
/**
 * Clones an object.
 * Non-object values are returned unchanged.
 *
 * @param {*} object Object to clone.
 * @return {*} Cloned object, or original literal non-object value.
 */

function cloneObject(object) {
  if (object && typeof object === 'object') {
    return { ...Object.fromEntries(Object.entries(object).map(([key, value]) => [key, cloneObject(value)]))
    };
  }

  return object;
}
/**
 * Immutably sets a value inside an object. Like `lodash#set`, but returning a
 * new object. Treats nullish initial values as empty objects. Clones any
 * nested objects.
 *
 * @param {Object}              object Object to set a value in.
 * @param {number|string|Array} path   Path in the object to modify.
 * @param {*}                   value  New value to set.
 * @return {Object} Cloned object with the new value set.
 */


function setImmutably(object, path, value) {
  const normalizedPath = normalizePath(path);
  const newObject = object ? cloneObject(object) : {};
  normalizedPath.reduce((acc, key, i) => {
    if (acc[key] === undefined) {
      acc[key] = {};
    }

    if (i === normalizedPath.length - 1) {
      acc[key] = value;
    }

    return acc[key];
  }, newObject);
  return newObject;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/utils.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




/**
 * Removed falsy values from nested object.
 *
 * @param {*} object
 * @return {*} Object cleaned from falsy values
 */

const utils_cleanEmptyObject = object => {
  if (object === null || typeof object !== 'object' || Array.isArray(object)) {
    return object;
  }

  const cleanedNestedObjects = Object.entries(object).map(([key, value]) => [key, utils_cleanEmptyObject(value)]).filter(([, value]) => value !== undefined);
  return !cleanedNestedObjects.length ? undefined : Object.fromEntries(cleanedNestedObjects);
};
function transformStyles(activeSupports, migrationPaths, result, source, index, results) {
  // If there are no active supports return early.
  if (Object.values(activeSupports !== null && activeSupports !== void 0 ? activeSupports : {}).every(isActive => !isActive)) {
    return result;
  } // If the condition verifies we are probably in the presence of a wrapping transform
  // e.g: nesting paragraphs in a group or columns and in that case the styles should not be transformed.


  if (results.length === 1 && result.innerBlocks.length === source.length) {
    return result;
  } // For cases where we have a transform from one block to multiple blocks
  // or multiple blocks to one block we apply the styles of the first source block
  // to the result(s).


  let referenceBlockAttributes = source[0]?.attributes; // If we are in presence of transform between more than one block in the source
  // that has more than one block in the result
  // we apply the styles on source N to the result N,
  // if source N does not exists we do nothing.

  if (results.length > 1 && source.length > 1) {
    if (source[index]) {
      referenceBlockAttributes = source[index]?.attributes;
    } else {
      return result;
    }
  }

  let returnBlock = result;
  Object.entries(activeSupports).forEach(([support, isActive]) => {
    if (isActive) {
      migrationPaths[support].forEach(path => {
        const styleValue = (0,external_lodash_namespaceObject.get)(referenceBlockAttributes, path);

        if (styleValue) {
          returnBlock = { ...returnBlock,
            attributes: setImmutably(returnBlock.attributes, path, styleValue)
          };
        }
      });
    }
  });
  return returnBlock;
}
/**
 * Check whether serialization of specific block support feature or set should
 * be skipped.
 *
 * @param {string|Object} blockType  Block name or block type object.
 * @param {string}        featureSet Name of block support feature set.
 * @param {string}        feature    Name of the individual feature to check.
 *
 * @return {boolean} Whether serialization should occur.
 */

function shouldSkipSerialization(blockType, featureSet, feature) {
  const support = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, featureSet);
  const skipSerialization = support?.__experimentalSkipSerialization;

  if (Array.isArray(skipSerialization)) {
    return skipSerialization.includes(feature);
  }

  return skipSerialization;
}
/**
 * Based on the block and its context, returns an object of all the block settings.
 * This object can be passed as a prop to all the Styles UI components
 * (TypographyPanel, DimensionsPanel...).
 *
 * @param {string} name         Block name.
 * @param {*}      parentLayout Parent layout.
 *
 * @return {Object} Settings object.
 */

function useBlockSettings(name, parentLayout) {
  const fontFamilies = use_setting_useSetting('typography.fontFamilies');
  const fontSizes = use_setting_useSetting('typography.fontSizes');
  const customFontSize = use_setting_useSetting('typography.customFontSize');
  const fontStyle = use_setting_useSetting('typography.fontStyle');
  const fontWeight = use_setting_useSetting('typography.fontWeight');
  const lineHeight = use_setting_useSetting('typography.lineHeight');
  const textColumns = use_setting_useSetting('typography.textColumns');
  const textDecoration = use_setting_useSetting('typography.textDecoration');
  const textTransform = use_setting_useSetting('typography.textTransform');
  const letterSpacing = use_setting_useSetting('typography.letterSpacing');
  const padding = use_setting_useSetting('spacing.padding');
  const margin = use_setting_useSetting('spacing.margin');
  const blockGap = use_setting_useSetting('spacing.blockGap');
  const spacingSizes = use_setting_useSetting('spacing.spacingSizes');
  const units = use_setting_useSetting('spacing.units');
  const minHeight = use_setting_useSetting('dimensions.minHeight');
  const layout = use_setting_useSetting('layout');
  const borderColor = use_setting_useSetting('border.color');
  const borderRadius = use_setting_useSetting('border.radius');
  const borderStyle = use_setting_useSetting('border.style');
  const borderWidth = use_setting_useSetting('border.width');
  const customColorsEnabled = use_setting_useSetting('color.custom');
  const customColors = use_setting_useSetting('color.palette.custom');
  const customDuotone = use_setting_useSetting('color.customDuotone');
  const themeColors = use_setting_useSetting('color.palette.theme');
  const defaultColors = use_setting_useSetting('color.palette.default');
  const defaultPalette = use_setting_useSetting('color.defaultPalette');
  const defaultDuotone = use_setting_useSetting('color.defaultDuotone');
  const userDuotonePalette = use_setting_useSetting('color.duotone.custom');
  const themeDuotonePalette = use_setting_useSetting('color.duotone.theme');
  const defaultDuotonePalette = use_setting_useSetting('color.duotone.default');
  const userGradientPalette = use_setting_useSetting('color.gradients.custom');
  const themeGradientPalette = use_setting_useSetting('color.gradients.theme');
  const defaultGradientPalette = use_setting_useSetting('color.gradients.default');
  const defaultGradients = use_setting_useSetting('color.defaultGradients');
  const areCustomGradientsEnabled = use_setting_useSetting('color.customGradient');
  const isBackgroundEnabled = use_setting_useSetting('color.background');
  const isLinkEnabled = use_setting_useSetting('color.link');
  const isTextEnabled = use_setting_useSetting('color.text');
  const rawSettings = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return {
      color: {
        palette: {
          custom: customColors,
          theme: themeColors,
          default: defaultColors
        },
        gradients: {
          custom: userGradientPalette,
          theme: themeGradientPalette,
          default: defaultGradientPalette
        },
        duotone: {
          custom: userDuotonePalette,
          theme: themeDuotonePalette,
          default: defaultDuotonePalette
        },
        defaultGradients,
        defaultPalette,
        defaultDuotone,
        custom: customColorsEnabled,
        customGradient: areCustomGradientsEnabled,
        customDuotone,
        background: isBackgroundEnabled,
        link: isLinkEnabled,
        text: isTextEnabled
      },
      typography: {
        fontFamilies: {
          custom: fontFamilies
        },
        fontSizes: {
          custom: fontSizes
        },
        customFontSize,
        fontStyle,
        fontWeight,
        lineHeight,
        textColumns,
        textDecoration,
        textTransform,
        letterSpacing
      },
      spacing: {
        spacingSizes: {
          custom: spacingSizes
        },
        padding,
        margin,
        blockGap,
        units
      },
      border: {
        color: borderColor,
        radius: borderRadius,
        style: borderStyle,
        width: borderWidth
      },
      dimensions: {
        minHeight
      },
      layout,
      parentLayout
    };
  }, [fontFamilies, fontSizes, customFontSize, fontStyle, fontWeight, lineHeight, textColumns, textDecoration, textTransform, letterSpacing, padding, margin, blockGap, spacingSizes, units, minHeight, layout, parentLayout, borderColor, borderRadius, borderStyle, borderWidth, customColorsEnabled, customColors, customDuotone, themeColors, defaultColors, defaultPalette, defaultDuotone, userDuotonePalette, themeDuotonePalette, defaultDuotonePalette, userGradientPalette, themeGradientPalette, defaultGradientPalette, defaultGradients, areCustomGradientsEnabled, isBackgroundEnabled, isLinkEnabled, isTextEnabled]);
  return useSettingsForBlockElement(rawSettings, name);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/layouts/flex.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */





 // Used with the default, horizontal flex orientation.

const justifyContentMap = {
  left: 'flex-start',
  right: 'flex-end',
  center: 'center',
  'space-between': 'space-between'
}; // Used with the vertical (column) flex orientation.

const alignItemsMap = {
  left: 'flex-start',
  right: 'flex-end',
  center: 'center',
  stretch: 'stretch'
};
const verticalAlignmentMap = {
  top: 'flex-start',
  center: 'center',
  bottom: 'flex-end',
  stretch: 'stretch',
  'space-between': 'space-between'
};
const flexWrapOptions = ['wrap', 'nowrap'];
/* harmony default export */ var flex = ({
  name: 'flex',
  label: (0,external_wp_i18n_namespaceObject.__)('Flex'),
  inspectorControls: function FlexLayoutInspectorControls({
    layout = {},
    onChange,
    layoutBlockSupport = {}
  }) {
    const {
      allowOrientation = true
    } = layoutBlockSupport;
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Flex, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, null, (0,external_wp_element_namespaceObject.createElement)(FlexLayoutJustifyContentControl, {
      layout: layout,
      onChange: onChange
    })), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, null, allowOrientation && (0,external_wp_element_namespaceObject.createElement)(OrientationControl, {
      layout: layout,
      onChange: onChange
    }))), (0,external_wp_element_namespaceObject.createElement)(FlexWrapControl, {
      layout: layout,
      onChange: onChange
    }));
  },
  toolBarControls: function FlexLayoutToolbarControls({
    layout = {},
    onChange,
    layoutBlockSupport
  }) {
    if (layoutBlockSupport?.allowSwitching) {
      return null;
    }

    const {
      allowVerticalAlignment = true
    } = layoutBlockSupport;
    return (0,external_wp_element_namespaceObject.createElement)(block_controls, {
      group: "block",
      __experimentalShareWithChildBlocks: true
    }, (0,external_wp_element_namespaceObject.createElement)(FlexLayoutJustifyContentControl, {
      layout: layout,
      onChange: onChange,
      isToolbar: true
    }), allowVerticalAlignment && (0,external_wp_element_namespaceObject.createElement)(FlexLayoutVerticalAlignmentControl, {
      layout: layout,
      onChange: onChange,
      isToolbar: true
    }));
  },
  getLayoutStyle: function getLayoutStyle({
    selector,
    layout,
    style,
    blockName,
    hasBlockGapSupport,
    layoutDefinitions = LAYOUT_DEFINITIONS
  }) {
    const {
      orientation = 'horizontal'
    } = layout; // If a block's block.json skips serialization for spacing or spacing.blockGap,
    // don't apply the user-defined value to the styles.

    const blockGapValue = style?.spacing?.blockGap && !shouldSkipSerialization(blockName, 'spacing', 'blockGap') ? getGapCSSValue(style?.spacing?.blockGap, '0.5em') : undefined;
    const justifyContent = justifyContentMap[layout.justifyContent];
    const flexWrap = flexWrapOptions.includes(layout.flexWrap) ? layout.flexWrap : 'wrap';
    const verticalAlignment = verticalAlignmentMap[layout.verticalAlignment];
    const alignItems = alignItemsMap[layout.justifyContent] || alignItemsMap.left;
    let output = '';
    const rules = [];

    if (flexWrap && flexWrap !== 'wrap') {
      rules.push(`flex-wrap: ${flexWrap}`);
    }

    if (orientation === 'horizontal') {
      if (verticalAlignment) {
        rules.push(`align-items: ${verticalAlignment}`);
      }

      if (justifyContent) {
        rules.push(`justify-content: ${justifyContent}`);
      }
    } else {
      if (verticalAlignment) {
        rules.push(`justify-content: ${verticalAlignment}`);
      }

      rules.push('flex-direction: column');
      rules.push(`align-items: ${alignItems}`);
    }

    if (rules.length) {
      output = `${appendSelectors(selector)} {
				${rules.join('; ')};
			}`;
    } // Output blockGap styles based on rules contained in layout definitions in theme.json.


    if (hasBlockGapSupport && blockGapValue) {
      output += getBlockGapCSS(selector, layoutDefinitions, 'flex', blockGapValue);
    }

    return output;
  },

  getOrientation(layout) {
    const {
      orientation = 'horizontal'
    } = layout;
    return orientation;
  },

  getAlignments() {
    return [];
  }

});

function FlexLayoutVerticalAlignmentControl({
  layout,
  onChange,
  isToolbar = false
}) {
  const {
    orientation = 'horizontal'
  } = layout;
  const defaultVerticalAlignment = orientation === 'horizontal' ? verticalAlignmentMap.center : verticalAlignmentMap.top;
  const {
    verticalAlignment = defaultVerticalAlignment
  } = layout;

  const onVerticalAlignmentChange = value => {
    onChange({ ...layout,
      verticalAlignment: value
    });
  };

  if (isToolbar) {
    return (0,external_wp_element_namespaceObject.createElement)(BlockVerticalAlignmentControl, {
      onChange: onVerticalAlignmentChange,
      value: verticalAlignment,
      controls: orientation === 'horizontal' ? ['top', 'center', 'bottom', 'stretch'] : ['top', 'center', 'bottom', 'space-between']
    });
  }

  const verticalAlignmentOptions = [{
    value: 'flex-start',
    label: (0,external_wp_i18n_namespaceObject.__)('Align items top')
  }, {
    value: 'center',
    label: (0,external_wp_i18n_namespaceObject.__)('Align items center')
  }, {
    value: 'flex-end',
    label: (0,external_wp_i18n_namespaceObject.__)('Align items bottom')
  }];
  return (0,external_wp_element_namespaceObject.createElement)("fieldset", {
    className: "block-editor-hooks__flex-layout-vertical-alignment-control"
  }, (0,external_wp_element_namespaceObject.createElement)("legend", null, (0,external_wp_i18n_namespaceObject.__)('Vertical alignment')), (0,external_wp_element_namespaceObject.createElement)("div", null, verticalAlignmentOptions.map((value, icon, label) => {
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
      key: value,
      label: label,
      icon: icon,
      isPressed: verticalAlignment === value,
      onClick: () => onVerticalAlignmentChange(value)
    });
  })));
}

const POPOVER_PROPS = {
  placement: 'bottom-start'
};

function FlexLayoutJustifyContentControl({
  layout,
  onChange,
  isToolbar = false
}) {
  const {
    justifyContent = 'left',
    orientation = 'horizontal'
  } = layout;

  const onJustificationChange = value => {
    onChange({ ...layout,
      justifyContent: value
    });
  };

  const allowedControls = ['left', 'center', 'right'];

  if (orientation === 'horizontal') {
    allowedControls.push('space-between');
  } else {
    allowedControls.push('stretch');
  }

  if (isToolbar) {
    return (0,external_wp_element_namespaceObject.createElement)(JustifyContentControl, {
      allowedControls: allowedControls,
      value: justifyContent,
      onChange: onJustificationChange,
      popoverProps: POPOVER_PROPS
    });
  }

  const justificationOptions = [{
    value: 'left',
    icon: justify_left,
    label: (0,external_wp_i18n_namespaceObject.__)('Justify items left')
  }, {
    value: 'center',
    icon: justify_center,
    label: (0,external_wp_i18n_namespaceObject.__)('Justify items center')
  }, {
    value: 'right',
    icon: justify_right,
    label: (0,external_wp_i18n_namespaceObject.__)('Justify items right')
  }];

  if (orientation === 'horizontal') {
    justificationOptions.push({
      value: 'space-between',
      icon: justify_space_between,
      label: (0,external_wp_i18n_namespaceObject.__)('Space between items')
    });
  } else {
    justificationOptions.push({
      value: 'stretch',
      icon: justify_stretch,
      label: (0,external_wp_i18n_namespaceObject.__)('Stretch items')
    });
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToggleGroupControl, {
    __nextHasNoMarginBottom: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Justification'),
    value: justifyContent,
    onChange: onJustificationChange,
    className: "block-editor-hooks__flex-layout-justification-controls"
  }, justificationOptions.map(({
    value,
    icon,
    label
  }) => {
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToggleGroupControlOptionIcon, {
      key: value,
      value: value,
      icon: icon,
      label: label
    });
  }));
}

function FlexWrapControl({
  layout,
  onChange
}) {
  const {
    flexWrap = 'wrap'
  } = layout;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToggleControl, {
    __nextHasNoMarginBottom: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Allow to wrap to multiple lines'),
    onChange: value => {
      onChange({ ...layout,
        flexWrap: value ? 'wrap' : 'nowrap'
      });
    },
    checked: flexWrap === 'wrap'
  });
}

function OrientationControl({
  layout,
  onChange
}) {
  const {
    orientation = 'horizontal',
    verticalAlignment,
    justifyContent
  } = layout;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToggleGroupControl, {
    __nextHasNoMarginBottom: true,
    className: "block-editor-hooks__flex-layout-orientation-controls",
    label: (0,external_wp_i18n_namespaceObject.__)('Orientation'),
    value: orientation,
    onChange: value => {
      // Make sure the vertical alignment and justification are compatible with the new orientation.
      let newVerticalAlignment = verticalAlignment;
      let newJustification = justifyContent;

      if (value === 'horizontal') {
        if (verticalAlignment === 'space-between') {
          newVerticalAlignment = 'center';
        }

        if (justifyContent === 'stretch') {
          newJustification = 'left';
        }
      } else {
        if (verticalAlignment === 'stretch') {
          newVerticalAlignment = 'top';
        }

        if (justifyContent === 'space-between') {
          newJustification = 'left';
        }
      }

      return onChange({ ...layout,
        orientation: value,
        verticalAlignment: newVerticalAlignment,
        justifyContent: newJustification
      });
    }
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToggleGroupControlOptionIcon, {
    icon: arrow_right,
    value: 'horizontal',
    label: (0,external_wp_i18n_namespaceObject.__)('Horizontal')
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToggleGroupControlOptionIcon, {
    icon: arrow_down,
    value: 'vertical',
    label: (0,external_wp_i18n_namespaceObject.__)('Vertical')
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/layouts/flow.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */





/* harmony default export */ var flow = ({
  name: 'default',
  label: (0,external_wp_i18n_namespaceObject.__)('Flow'),
  inspectorControls: function DefaultLayoutInspectorControls() {
    return null;
  },
  toolBarControls: function DefaultLayoutToolbarControls() {
    return null;
  },
  getLayoutStyle: function getLayoutStyle({
    selector,
    style,
    blockName,
    hasBlockGapSupport,
    layoutDefinitions = LAYOUT_DEFINITIONS
  }) {
    const blockGapStyleValue = getGapCSSValue(style?.spacing?.blockGap); // If a block's block.json skips serialization for spacing or
    // spacing.blockGap, don't apply the user-defined value to the styles.

    let blockGapValue = '';

    if (!shouldSkipSerialization(blockName, 'spacing', 'blockGap')) {
      // If an object is provided only use the 'top' value for this kind of gap.
      if (blockGapStyleValue?.top) {
        blockGapValue = getGapCSSValue(blockGapStyleValue?.top);
      } else if (typeof blockGapStyleValue === 'string') {
        blockGapValue = getGapCSSValue(blockGapStyleValue);
      }
    }

    let output = ''; // Output blockGap styles based on rules contained in layout definitions in theme.json.

    if (hasBlockGapSupport && blockGapValue) {
      output += getBlockGapCSS(selector, layoutDefinitions, 'default', blockGapValue);
    }

    return output;
  },

  getOrientation() {
    return 'vertical';
  },

  getAlignments(layout, isBlockBasedTheme) {
    const alignmentInfo = getAlignmentsInfo(layout);

    if (layout.alignments !== undefined) {
      if (!layout.alignments.includes('none')) {
        layout.alignments.unshift('none');
      }

      return layout.alignments.map(alignment => ({
        name: alignment,
        info: alignmentInfo[alignment]
      }));
    }

    const alignments = [{
      name: 'left'
    }, {
      name: 'center'
    }, {
      name: 'right'
    }]; // This is for backwards compatibility with hybrid themes.

    if (!isBlockBasedTheme) {
      const {
        contentSize,
        wideSize
      } = layout;

      if (contentSize) {
        alignments.unshift({
          name: 'full'
        });
      }

      if (wideSize) {
        alignments.unshift({
          name: 'wide',
          info: alignmentInfo.wide
        });
      }
    }

    alignments.unshift({
      name: 'none',
      info: alignmentInfo.none
    });
    return alignments;
  }

});

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/icon/index.js
/**
 * WordPress dependencies
 */

/** @typedef {{icon: JSX.Element, size?: number} & import('@wordpress/primitives').SVGProps} IconProps */

/**
 * Return an SVG icon.
 *
 * @param {IconProps} props icon is the SVG component to render
 *                          size is a number specifiying the icon size in pixels
 *                          Other props will be passed to wrapped SVG component
 *
 * @return {JSX.Element}  Icon component
 */

function Icon({
  icon,
  size = 24,
  ...props
}) {
  return (0,external_wp_element_namespaceObject.cloneElement)(icon, {
    width: size,
    height: size,
    ...props
  });
}

/* harmony default export */ var build_module_icon = (Icon);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/position-center.js


/**
 * WordPress dependencies
 */

const positionCenter = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M19 5.5H5V4h14v1.5ZM19 20H5v-1.5h14V20ZM7 9h10v6H7V9Z"
}));
/* harmony default export */ var position_center = (positionCenter);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/stretch-wide.js


/**
 * WordPress dependencies
 */

const stretchWide = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M16 5.5H8V4h8v1.5ZM16 20H8v-1.5h8V20ZM5 9h14v6H5V9Z"
}));
/* harmony default export */ var stretch_wide = (stretchWide);

;// CONCATENATED MODULE: external ["wp","styleEngine"]
var external_wp_styleEngine_namespaceObject = window["wp"]["styleEngine"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/layouts/constrained.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */






/* harmony default export */ var constrained = ({
  name: 'constrained',
  label: (0,external_wp_i18n_namespaceObject.__)('Constrained'),
  inspectorControls: function DefaultLayoutInspectorControls({
    layout,
    onChange,
    layoutBlockSupport = {}
  }) {
    const {
      wideSize,
      contentSize,
      justifyContent = 'center'
    } = layout;
    const {
      allowJustification = true
    } = layoutBlockSupport;

    const onJustificationChange = value => {
      onChange({ ...layout,
        justifyContent: value
      });
    };

    const justificationOptions = [{
      value: 'left',
      icon: justify_left,
      label: (0,external_wp_i18n_namespaceObject.__)('Justify items left')
    }, {
      value: 'center',
      icon: justify_center,
      label: (0,external_wp_i18n_namespaceObject.__)('Justify items center')
    }, {
      value: 'right',
      icon: justify_right,
      label: (0,external_wp_i18n_namespaceObject.__)('Justify items right')
    }];
    const units = (0,external_wp_components_namespaceObject.__experimentalUseCustomUnits)({
      availableUnits: use_setting_useSetting('spacing.units') || ['%', 'px', 'em', 'rem', 'vw']
    });
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)("div", {
      className: "block-editor-hooks__layout-controls"
    }, (0,external_wp_element_namespaceObject.createElement)("div", {
      className: "block-editor-hooks__layout-controls-unit"
    }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalUnitControl, {
      className: "block-editor-hooks__layout-controls-unit-input",
      label: (0,external_wp_i18n_namespaceObject.__)('Content'),
      labelPosition: "top",
      __unstableInputWidth: "80px",
      value: contentSize || wideSize || '',
      onChange: nextWidth => {
        nextWidth = 0 > parseFloat(nextWidth) ? '0' : nextWidth;
        onChange({ ...layout,
          contentSize: nextWidth
        });
      },
      units: units
    }), (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
      icon: position_center
    })), (0,external_wp_element_namespaceObject.createElement)("div", {
      className: "block-editor-hooks__layout-controls-unit"
    }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalUnitControl, {
      className: "block-editor-hooks__layout-controls-unit-input",
      label: (0,external_wp_i18n_namespaceObject.__)('Wide'),
      labelPosition: "top",
      __unstableInputWidth: "80px",
      value: wideSize || contentSize || '',
      onChange: nextWidth => {
        nextWidth = 0 > parseFloat(nextWidth) ? '0' : nextWidth;
        onChange({ ...layout,
          wideSize: nextWidth
        });
      },
      units: units
    }), (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
      icon: stretch_wide
    }))), (0,external_wp_element_namespaceObject.createElement)("p", {
      className: "block-editor-hooks__layout-controls-helptext"
    }, (0,external_wp_i18n_namespaceObject.__)('Customize the width for all elements that are assigned to the center or wide columns.')), allowJustification && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToggleGroupControl, {
      __nextHasNoMarginBottom: true,
      label: (0,external_wp_i18n_namespaceObject.__)('Justification'),
      value: justifyContent,
      onChange: onJustificationChange
    }, justificationOptions.map(({
      value,
      icon,
      label
    }) => {
      return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToggleGroupControlOptionIcon, {
        key: value,
        value: value,
        icon: icon,
        label: label
      });
    })));
  },
  toolBarControls: function DefaultLayoutToolbarControls() {
    return null;
  },
  getLayoutStyle: function getLayoutStyle({
    selector,
    layout = {},
    style,
    blockName,
    hasBlockGapSupport,
    layoutDefinitions = LAYOUT_DEFINITIONS
  }) {
    const {
      contentSize,
      wideSize,
      justifyContent
    } = layout;
    const blockGapStyleValue = getGapCSSValue(style?.spacing?.blockGap); // If a block's block.json skips serialization for spacing or
    // spacing.blockGap, don't apply the user-defined value to the styles.

    let blockGapValue = '';

    if (!shouldSkipSerialization(blockName, 'spacing', 'blockGap')) {
      // If an object is provided only use the 'top' value for this kind of gap.
      if (blockGapStyleValue?.top) {
        blockGapValue = getGapCSSValue(blockGapStyleValue?.top);
      } else if (typeof blockGapStyleValue === 'string') {
        blockGapValue = getGapCSSValue(blockGapStyleValue);
      }
    }

    const marginLeft = justifyContent === 'left' ? '0 !important' : 'auto !important';
    const marginRight = justifyContent === 'right' ? '0 !important' : 'auto !important';
    let output = !!contentSize || !!wideSize ? `
					${appendSelectors(selector, '> :where(:not(.alignleft):not(.alignright):not(.alignfull))')} {
						max-width: ${contentSize !== null && contentSize !== void 0 ? contentSize : wideSize};
						margin-left: ${marginLeft};
						margin-right: ${marginRight};
					}
					${appendSelectors(selector, '> .alignwide')}  {
						max-width: ${wideSize !== null && wideSize !== void 0 ? wideSize : contentSize};
					}
					${appendSelectors(selector, '> .alignfull')} {
						max-width: none;
					}
				` : '';

    if (justifyContent === 'left') {
      output += `${appendSelectors(selector, '> :where(:not(.alignleft):not(.alignright):not(.alignfull))')}
			{ margin-left: ${marginLeft}; }`;
    } else if (justifyContent === 'right') {
      output += `${appendSelectors(selector, '> :where(:not(.alignleft):not(.alignright):not(.alignfull))')}
			{ margin-right: ${marginRight}; }`;
    } // If there is custom padding, add negative margins for alignfull blocks.


    if (style?.spacing?.padding) {
      // The style object might be storing a preset so we need to make sure we get a usable value.
      const paddingValues = (0,external_wp_styleEngine_namespaceObject.getCSSRules)(style);
      paddingValues.forEach(rule => {
        if (rule.key === 'paddingRight') {
          output += `
					${appendSelectors(selector, '> .alignfull')} {
						margin-right: calc(${rule.value} * -1);
					}
					`;
        } else if (rule.key === 'paddingLeft') {
          output += `
					${appendSelectors(selector, '> .alignfull')} {
						margin-left: calc(${rule.value} * -1);
					}
					`;
        }
      });
    } // Output blockGap styles based on rules contained in layout definitions in theme.json.


    if (hasBlockGapSupport && blockGapValue) {
      output += getBlockGapCSS(selector, layoutDefinitions, 'constrained', blockGapValue);
    }

    return output;
  },

  getOrientation() {
    return 'vertical';
  },

  getAlignments(layout) {
    const alignmentInfo = getAlignmentsInfo(layout);

    if (layout.alignments !== undefined) {
      if (!layout.alignments.includes('none')) {
        layout.alignments.unshift('none');
      }

      return layout.alignments.map(alignment => ({
        name: alignment,
        info: alignmentInfo[alignment]
      }));
    }

    const {
      contentSize,
      wideSize
    } = layout;
    const alignments = [{
      name: 'left'
    }, {
      name: 'center'
    }, {
      name: 'right'
    }];

    if (contentSize) {
      alignments.unshift({
        name: 'full'
      });
    }

    if (wideSize) {
      alignments.unshift({
        name: 'wide',
        info: alignmentInfo.wide
      });
    }

    alignments.unshift({
      name: 'none',
      info: alignmentInfo.none
    });
    return alignments;
  }

});

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/layouts/grid.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





const RANGE_CONTROL_MAX_VALUES = {
  px: 600,
  '%': 100,
  vw: 100,
  vh: 100,
  em: 38,
  rem: 38
};
/* harmony default export */ var grid = ({
  name: 'grid',
  label: (0,external_wp_i18n_namespaceObject.__)('Grid'),
  inspectorControls: function GridLayoutInspectorControls({
    layout = {},
    onChange
  }) {
    return layout?.columnCount ? (0,external_wp_element_namespaceObject.createElement)(GridLayoutColumnsControl, {
      layout: layout,
      onChange: onChange
    }) : (0,external_wp_element_namespaceObject.createElement)(GridLayoutMinimumWidthControl, {
      layout: layout,
      onChange: onChange
    });
  },
  toolBarControls: function DefaultLayoutToolbarControls() {
    return null;
  },
  getLayoutStyle: function getLayoutStyle({
    selector,
    layout,
    style,
    blockName,
    hasBlockGapSupport,
    layoutDefinitions = LAYOUT_DEFINITIONS
  }) {
    const {
      minimumColumnWidth = '12rem',
      columnCount = null
    } = layout; // If a block's block.json skips serialization for spacing or spacing.blockGap,
    // don't apply the user-defined value to the styles.

    const blockGapValue = style?.spacing?.blockGap && !shouldSkipSerialization(blockName, 'spacing', 'blockGap') ? getGapCSSValue(style?.spacing?.blockGap, '0.5em') : undefined;
    let output = '';
    const rules = [];

    if (columnCount) {
      rules.push(`grid-template-columns: repeat(${columnCount}, minmax(0, 1fr))`);
    } else if (minimumColumnWidth) {
      rules.push(`grid-template-columns: repeat(auto-fill, minmax(min(${minimumColumnWidth}, 100%), 1fr))`);
    }

    if (rules.length) {
      // Reason to disable: the extra line breaks added by prettier mess with the unit tests.
      // eslint-disable-next-line prettier/prettier
      output = `${appendSelectors(selector)} { ${rules.join('; ')}; }`;
    } // Output blockGap styles based on rules contained in layout definitions in theme.json.


    if (hasBlockGapSupport && blockGapValue) {
      output += getBlockGapCSS(selector, layoutDefinitions, 'grid', blockGapValue);
    }

    return output;
  },

  getOrientation() {
    return 'horizontal';
  },

  getAlignments() {
    return [];
  }

}); // Enables setting minimum width of grid items.

function GridLayoutMinimumWidthControl({
  layout,
  onChange
}) {
  const {
    minimumColumnWidth: value = '12rem'
  } = layout;
  const [quantity, unit] = (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(value);

  const handleSliderChange = next => {
    onChange({ ...layout,
      minimumColumnWidth: [next, unit].join('')
    });
  }; // Mostly copied from HeightControl.


  const handleUnitChange = newUnit => {
    // Attempt to smooth over differences between currentUnit and newUnit.
    // This should slightly improve the experience of switching between unit types.
    let newValue;

    if (['em', 'rem'].includes(newUnit) && unit === 'px') {
      // Convert pixel value to an approximate of the new unit, assuming a root size of 16px.
      newValue = (quantity / 16).toFixed(2) + newUnit;
    } else if (['em', 'rem'].includes(unit) && newUnit === 'px') {
      // Convert to pixel value assuming a root size of 16px.
      newValue = Math.round(quantity * 16) + newUnit;
    } else if (['vh', 'vw', '%'].includes(newUnit) && quantity > 100) {
      // When converting to `vh`, `vw`, or `%` units, cap the new value at 100.
      newValue = 100 + newUnit;
    }

    onChange({ ...layout,
      minimumColumnWidth: newValue
    });
  };

  return (0,external_wp_element_namespaceObject.createElement)("fieldset", null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.BaseControl.VisualLabel, {
    as: "legend"
  }, (0,external_wp_i18n_namespaceObject.__)('Minimum column width')), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Flex, {
    gap: 4
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, {
    isBlock: true
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalUnitControl, {
    size: '__unstable-large',
    onChange: newValue => {
      onChange({ ...layout,
        minimumColumnWidth: newValue
      });
    },
    onUnitChange: handleUnitChange,
    value: value,
    min: 0
  })), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, {
    isBlock: true
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.RangeControl, {
    onChange: handleSliderChange,
    value: quantity,
    min: 0,
    max: RANGE_CONTROL_MAX_VALUES[unit] || 600,
    withInputField: false
  }))));
} // Enables setting number of grid columns


function GridLayoutColumnsControl({
  layout,
  onChange
}) {
  const {
    columnCount = 3
  } = layout;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.RangeControl, {
    label: (0,external_wp_i18n_namespaceObject.__)('Columns'),
    value: columnCount,
    onChange: value => onChange({ ...layout,
      columnCount: value
    }),
    min: 1,
    max: 6
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/layouts/index.js
/**
 * Internal dependencies
 */




const layoutTypes = [flow, flex, constrained, grid];
/**
 * Retrieves a layout type by name.
 *
 * @param {string} name - The name of the layout type.
 * @return {Object} Layout type.
 */

function getLayoutType(name = 'default') {
  return layoutTypes.find(layoutType => layoutType.name === name);
}
/**
 * Retrieves the available layout types.
 *
 * @return {Array} Layout types.
 */

function getLayoutTypes() {
  return layoutTypes;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/layout.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



const defaultLayout = {
  type: 'default'
};
const Layout = (0,external_wp_element_namespaceObject.createContext)(defaultLayout);
/**
 * Allows to define the layout.
 */

const LayoutProvider = Layout.Provider;
/**
 * React hook used to retrieve the layout config.
 */

function useLayout() {
  return (0,external_wp_element_namespaceObject.useContext)(Layout);
}
function LayoutStyle({
  layout = {},
  css,
  ...props
}) {
  const layoutType = getLayoutType(layout.type);
  const blockGapSupport = use_setting_useSetting('spacing.blockGap');
  const hasBlockGapSupport = blockGapSupport !== null;

  if (layoutType) {
    if (css) {
      return (0,external_wp_element_namespaceObject.createElement)("style", null, css);
    }

    const layoutStyle = layoutType.getLayoutStyle?.({
      hasBlockGapSupport,
      layout,
      ...props
    });

    if (layoutStyle) {
      return (0,external_wp_element_namespaceObject.createElement)("style", null, layoutStyle);
    }
  }

  return null;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-alignment-control/use-available-alignments.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




const use_available_alignments_EMPTY_ARRAY = [];
const use_available_alignments_DEFAULT_CONTROLS = ['none', 'left', 'center', 'right', 'wide', 'full'];
const WIDE_CONTROLS = ['wide', 'full'];
function useAvailableAlignments(controls = use_available_alignments_DEFAULT_CONTROLS) {
  // Always add the `none` option if not exists.
  if (!controls.includes('none')) {
    controls = ['none', ...controls];
  }

  const {
    wideControlsEnabled = false,
    themeSupportsLayout,
    isBlockBasedTheme
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getSettings
    } = select(store);
    const settings = getSettings();
    return {
      wideControlsEnabled: settings.alignWide,
      themeSupportsLayout: settings.supportsLayout,
      isBlockBasedTheme: settings.__unstableIsBlockBasedTheme
    };
  }, []);
  const layout = useLayout();
  const layoutType = getLayoutType(layout?.type);
  const layoutAlignments = layoutType.getAlignments(layout, isBlockBasedTheme);

  if (themeSupportsLayout) {
    const alignments = layoutAlignments.filter(({
      name: alignmentName
    }) => controls.includes(alignmentName)); // While we treat `none` as an alignment, we shouldn't return it if no
    // other alignments exist.

    if (alignments.length === 1 && alignments[0].name === 'none') {
      return use_available_alignments_EMPTY_ARRAY;
    }

    return alignments;
  } // Starting here, it's the fallback for themes not supporting the layout config.


  if (layoutType.name !== 'default' && layoutType.name !== 'constrained') {
    return use_available_alignments_EMPTY_ARRAY;
  }

  const {
    alignments: availableAlignments = use_available_alignments_DEFAULT_CONTROLS
  } = layout;
  const enabledControls = controls.filter(control => (layout.alignments || // Ignore the global wideAlignment check if the layout explicitely defines alignments.
  wideControlsEnabled || !WIDE_CONTROLS.includes(control)) && availableAlignments.includes(control)).map(enabledControl => ({
    name: enabledControl
  })); // While we treat `none` as an alignment, we shouldn't return it if no
  // other alignments exist.

  if (enabledControls.length === 1 && enabledControls[0].name === 'none') {
    return use_available_alignments_EMPTY_ARRAY;
  }

  return enabledControls;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/align-none.js


/**
 * WordPress dependencies
 */

const alignNone = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M19 5.5H5V4h14v1.5ZM19 20H5v-1.5h14V20ZM5 9h14v6H5V9Z"
}));
/* harmony default export */ var align_none = (alignNone);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/position-left.js


/**
 * WordPress dependencies
 */

const positionLeft = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M5 5.5h8V4H5v1.5ZM5 20h8v-1.5H5V20ZM19 9H5v6h14V9Z"
}));
/* harmony default export */ var position_left = (positionLeft);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/position-right.js


/**
 * WordPress dependencies
 */

const positionRight = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M19 5.5h-8V4h8v1.5ZM19 20h-8v-1.5h8V20ZM5 9h14v6H5V9Z"
}));
/* harmony default export */ var position_right = (positionRight);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/stretch-full-width.js


/**
 * WordPress dependencies
 */

const stretchFullWidth = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M5 4h14v11H5V4Zm11 16H8v-1.5h8V20Z"
}));
/* harmony default export */ var stretch_full_width = (stretchFullWidth);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-alignment-control/constants.js
/**
 * WordPress dependencies
 */


const constants_BLOCK_ALIGNMENTS_CONTROLS = {
  none: {
    icon: align_none,
    title: (0,external_wp_i18n_namespaceObject._x)('None', 'Alignment option')
  },
  left: {
    icon: position_left,
    title: (0,external_wp_i18n_namespaceObject.__)('Align left')
  },
  center: {
    icon: position_center,
    title: (0,external_wp_i18n_namespaceObject.__)('Align center')
  },
  right: {
    icon: position_right,
    title: (0,external_wp_i18n_namespaceObject.__)('Align right')
  },
  wide: {
    icon: stretch_wide,
    title: (0,external_wp_i18n_namespaceObject.__)('Wide width')
  },
  full: {
    icon: stretch_full_width,
    title: (0,external_wp_i18n_namespaceObject.__)('Full width')
  }
};
const constants_DEFAULT_CONTROL = 'none';

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-alignment-control/ui.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




function BlockAlignmentUI({
  value,
  onChange,
  controls,
  isToolbar,
  isCollapsed = true
}) {
  const enabledControls = useAvailableAlignments(controls);
  const hasEnabledControls = !!enabledControls.length;

  if (!hasEnabledControls) {
    return null;
  }

  function onChangeAlignment(align) {
    onChange([value, 'none'].includes(align) ? undefined : align);
  }

  const activeAlignmentControl = constants_BLOCK_ALIGNMENTS_CONTROLS[value];
  const defaultAlignmentControl = constants_BLOCK_ALIGNMENTS_CONTROLS[constants_DEFAULT_CONTROL];
  const UIComponent = isToolbar ? external_wp_components_namespaceObject.ToolbarGroup : external_wp_components_namespaceObject.ToolbarDropdownMenu;
  const commonProps = {
    icon: activeAlignmentControl ? activeAlignmentControl.icon : defaultAlignmentControl.icon,
    label: (0,external_wp_i18n_namespaceObject.__)('Align')
  };
  const extraProps = isToolbar ? {
    isCollapsed,
    controls: enabledControls.map(({
      name: controlName
    }) => {
      return { ...constants_BLOCK_ALIGNMENTS_CONTROLS[controlName],
        isActive: value === controlName || !value && controlName === 'none',
        role: isCollapsed ? 'menuitemradio' : undefined,
        onClick: () => onChangeAlignment(controlName)
      };
    })
  } : {
    toggleProps: {
      describedBy: (0,external_wp_i18n_namespaceObject.__)('Change alignment')
    },
    children: ({
      onClose
    }) => {
      return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuGroup, {
        className: "block-editor-block-alignment-control__menu-group"
      }, enabledControls.map(({
        name: controlName,
        info
      }) => {
        const {
          icon,
          title
        } = constants_BLOCK_ALIGNMENTS_CONTROLS[controlName]; // If no value is provided, mark as selected the `none` option.

        const isSelected = controlName === value || !value && controlName === 'none';
        return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
          key: controlName,
          icon: icon,
          iconPosition: "left",
          className: classnames_default()('components-dropdown-menu__menu-item', {
            'is-active': isSelected
          }),
          isSelected: isSelected,
          onClick: () => {
            onChangeAlignment(controlName);
            onClose();
          },
          role: "menuitemradio",
          info: info
        }, title);
      })));
    }
  };
  return (0,external_wp_element_namespaceObject.createElement)(UIComponent, { ...commonProps,
    ...extraProps
  });
}

/* harmony default export */ var block_alignment_control_ui = (BlockAlignmentUI);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-alignment-control/index.js


/**
 * Internal dependencies
 */


const BlockAlignmentControl = props => {
  return (0,external_wp_element_namespaceObject.createElement)(block_alignment_control_ui, { ...props,
    isToolbar: false
  });
};

const BlockAlignmentToolbar = props => {
  return (0,external_wp_element_namespaceObject.createElement)(block_alignment_control_ui, { ...props,
    isToolbar: true
  });
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-alignment-control/README.md
 */




;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/block-list-block-context.js
/**
 * WordPress dependencies
 */

const BlockListBlockContext = (0,external_wp_element_namespaceObject.createContext)(null);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-editing-mode/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




/**
 * @typedef {'disabled'|'contentOnly'|'default'} BlockEditingMode
 */

/**
 * Allows a block to restrict the user interface that is displayed for editing
 * that block and its inner blocks.
 *
 * @example
 * ```js
 * function MyBlock( { attributes, setAttributes } ) {
 *     useBlockEditingMode( 'disabled' );
 *     return <div { ...useBlockProps() }></div>;
 * }
 * ```
 *
 * `mode` can be one of three options:
 *
 * - `'disabled'`: Prevents editing the block entirely, i.e. it cannot be
 *   selected.
 * - `'contentOnly'`: Hides all non-content UI, e.g. auxiliary controls in the
 *   toolbar, the block movers, block settings.
 * - `'default'`: Allows editing the block as normal.
 *
 * The mode is inherited by all of the block's inner blocks, unless they have
 * their own mode.
 *
 * If called outside of a block context, the mode is applied to all blocks.
 *
 * @param {?BlockEditingMode} mode The editing mode to apply. If undefined, the
 *                                 current editing mode is not changed.
 *
 * @return {BlockEditingMode} The current editing mode.
 */

function useBlockEditingMode(mode) {
  var _useContext;

  const {
    clientId = ''
  } = (_useContext = (0,external_wp_element_namespaceObject.useContext)(BlockListBlockContext)) !== null && _useContext !== void 0 ? _useContext : {};
  const blockEditingMode = (0,external_wp_data_namespaceObject.useSelect)(select => unlock(select(store)).getBlockEditingMode(clientId), [clientId]);
  const {
    setBlockEditingMode,
    unsetBlockEditingMode
  } = unlock((0,external_wp_data_namespaceObject.useDispatch)(store));
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (mode) {
      setBlockEditingMode(clientId, mode);
    }

    return () => {
      if (mode) {
        unsetBlockEditingMode(clientId);
      }
    };
  }, [clientId, mode]);
  return blockEditingMode;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/align.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




/**
 * An array which includes all possible valid alignments,
 * used to validate if an alignment is valid or not.
 *
 * @constant
 * @type {string[]}
 */

const ALL_ALIGNMENTS = ['left', 'center', 'right', 'wide', 'full'];
/**
 * An array which includes all wide alignments.
 * In order for this alignments to be valid they need to be supported by the block,
 * and by the theme.
 *
 * @constant
 * @type {string[]}
 */

const WIDE_ALIGNMENTS = ['wide', 'full'];
/**
 * Returns the valid alignments.
 * Takes into consideration the aligns supported by a block, if the block supports wide controls or not and if theme supports wide controls or not.
 * Exported just for testing purposes, not exported outside the module.
 *
 * @param {?boolean|string[]} blockAlign          Aligns supported by the block.
 * @param {?boolean}          hasWideBlockSupport True if block supports wide alignments. And False otherwise.
 * @param {?boolean}          hasWideEnabled      True if theme supports wide alignments. And False otherwise.
 *
 * @return {string[]} Valid alignments.
 */

function getValidAlignments(blockAlign, hasWideBlockSupport = true, hasWideEnabled = true) {
  let validAlignments;

  if (Array.isArray(blockAlign)) {
    validAlignments = ALL_ALIGNMENTS.filter(value => blockAlign.includes(value));
  } else if (blockAlign === true) {
    // `true` includes all alignments...
    validAlignments = [...ALL_ALIGNMENTS];
  } else {
    validAlignments = [];
  }

  if (!hasWideEnabled || blockAlign === true && !hasWideBlockSupport) {
    return validAlignments.filter(alignment => !WIDE_ALIGNMENTS.includes(alignment));
  }

  return validAlignments;
}
/**
 * Filters registered block settings, extending attributes to include `align`.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function addAttribute(settings) {
  var _settings$attributes$;

  // Allow blocks to specify their own attribute definition with default values if needed.
  if ('type' in ((_settings$attributes$ = settings.attributes?.align) !== null && _settings$attributes$ !== void 0 ? _settings$attributes$ : {})) {
    return settings;
  }

  if ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, 'align')) {
    // Gracefully handle if settings.attributes is undefined.
    settings.attributes = { ...settings.attributes,
      align: {
        type: 'string',
        // Allow for '' since it is used by updateAlignment function
        // in withToolbarControls for special cases with defined default values.
        enum: [...ALL_ALIGNMENTS, '']
      }
    };
  }

  return settings;
}
/**
 * Override the default edit UI to include new toolbar controls for block
 * alignment, if block defines support.
 *
 * @param {Function} BlockEdit Original component.
 *
 * @return {Function} Wrapped component.
 */

const withToolbarControls = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(BlockEdit => props => {
  const blockEdit = (0,external_wp_element_namespaceObject.createElement)(BlockEdit, {
    key: "edit",
    ...props
  });
  const {
    name: blockName
  } = props; // Compute the block valid alignments by taking into account,
  // if the theme supports wide alignments or not and the layout's
  // availble alignments. We do that for conditionally rendering
  // Slot.

  const blockAllowedAlignments = getValidAlignments((0,external_wp_blocks_namespaceObject.getBlockSupport)(blockName, 'align'), (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockName, 'alignWide', true));
  const validAlignments = useAvailableAlignments(blockAllowedAlignments).map(({
    name
  }) => name);
  const blockEditingMode = useBlockEditingMode();

  if (!validAlignments.length || blockEditingMode !== 'default') {
    return blockEdit;
  }

  const updateAlignment = nextAlign => {
    if (!nextAlign) {
      const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(props.name);
      const blockDefaultAlign = blockType?.attributes?.align?.default;

      if (blockDefaultAlign) {
        nextAlign = '';
      }
    }

    props.setAttributes({
      align: nextAlign
    });
  };

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(block_controls, {
    group: "block",
    __experimentalShareWithChildBlocks: true
  }, (0,external_wp_element_namespaceObject.createElement)(BlockAlignmentControl, {
    value: props.attributes.align,
    onChange: updateAlignment,
    controls: validAlignments
  })), blockEdit);
}, 'withToolbarControls');
/**
 * Override the default block element to add alignment wrapper props.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */

const withDataAlign = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(BlockListBlock => props => {
  const {
    name,
    attributes
  } = props;
  const {
    align
  } = attributes;
  const blockAllowedAlignments = getValidAlignments((0,external_wp_blocks_namespaceObject.getBlockSupport)(name, 'align'), (0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, 'alignWide', true));
  const validAlignments = useAvailableAlignments(blockAllowedAlignments); // If an alignment is not assigned, there's no need to go through the
  // effort to validate or assign its value.

  if (align === undefined) {
    return (0,external_wp_element_namespaceObject.createElement)(BlockListBlock, { ...props
    });
  }

  let wrapperProps = props.wrapperProps;

  if (validAlignments.some(alignment => alignment.name === align)) {
    wrapperProps = { ...wrapperProps,
      'data-align': align
    };
  }

  return (0,external_wp_element_namespaceObject.createElement)(BlockListBlock, { ...props,
    wrapperProps: wrapperProps
  });
}, 'withDataAlign');
/**
 * Override props assigned to save component to inject alignment class name if
 * block supports it.
 *
 * @param {Object} props      Additional props applied to save element.
 * @param {Object} blockType  Block type.
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */

function addAssignedAlign(props, blockType, attributes) {
  const {
    align
  } = attributes;
  const blockAlign = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, 'align');
  const hasWideBlockSupport = (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, 'alignWide', true); // Compute valid alignments without taking into account if
  // the theme supports wide alignments or not.
  // This way changing themes does not impact the block save.

  const isAlignValid = getValidAlignments(blockAlign, hasWideBlockSupport).includes(align);

  if (isAlignValid) {
    props.className = classnames_default()(`align${align}`, props.className);
  }

  return props;
}
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/align/addAttribute', addAttribute);
(0,external_wp_hooks_namespaceObject.addFilter)('editor.BlockListBlock', 'core/editor/align/with-data-align', withDataAlign);
(0,external_wp_hooks_namespaceObject.addFilter)('editor.BlockEdit', 'core/editor/align/with-toolbar-controls', withToolbarControls);
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.getSaveContent.extraProps', 'core/align/addAssignedAlign', addAssignedAlign);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/lock.js
/**
 * WordPress dependencies
 */

/**
 * Filters registered block settings, extending attributes to include `lock`.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function lock_addAttribute(settings) {
  var _settings$attributes$;

  // Allow blocks to specify their own attribute definition with default values if needed.
  if ('type' in ((_settings$attributes$ = settings.attributes?.lock) !== null && _settings$attributes$ !== void 0 ? _settings$attributes$ : {})) {
    return settings;
  } // Gracefully handle if settings.attributes is undefined.


  settings.attributes = { ...settings.attributes,
    lock: {
      type: 'object'
    }
  };
  return settings;
}
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/lock/addAttribute', lock_addAttribute);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls/groups.js
/**
 * WordPress dependencies
 */

const InspectorControlsDefault = (0,external_wp_components_namespaceObject.createSlotFill)('InspectorControls');
const InspectorControlsAdvanced = (0,external_wp_components_namespaceObject.createSlotFill)('InspectorAdvancedControls');
const InspectorControlsBorder = (0,external_wp_components_namespaceObject.createSlotFill)('InspectorControlsBorder');
const InspectorControlsColor = (0,external_wp_components_namespaceObject.createSlotFill)('InspectorControlsColor');
const InspectorControlsFilter = (0,external_wp_components_namespaceObject.createSlotFill)('InspectorControlsFilter');
const InspectorControlsDimensions = (0,external_wp_components_namespaceObject.createSlotFill)('InspectorControlsDimensions');
const InspectorControlsPosition = (0,external_wp_components_namespaceObject.createSlotFill)('InspectorControlsPosition');
const InspectorControlsTypography = (0,external_wp_components_namespaceObject.createSlotFill)('InspectorControlsTypography');
const InspectorControlsListView = (0,external_wp_components_namespaceObject.createSlotFill)('InspectorControlsListView');
const InspectorControlsStyles = (0,external_wp_components_namespaceObject.createSlotFill)('InspectorControlsStyles');
const groups_groups = {
  default: InspectorControlsDefault,
  advanced: InspectorControlsAdvanced,
  border: InspectorControlsBorder,
  color: InspectorControlsColor,
  filter: InspectorControlsFilter,
  dimensions: InspectorControlsDimensions,
  list: InspectorControlsListView,
  settings: InspectorControlsDefault,
  // Alias for default.
  styles: InspectorControlsStyles,
  typography: InspectorControlsTypography,
  position: InspectorControlsPosition
};
/* harmony default export */ var inspector_controls_groups = (groups_groups);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls/fill.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



function InspectorControlsFill({
  children,
  group = 'default',
  __experimentalGroup,
  resetAllFilter
}) {
  if (__experimentalGroup) {
    external_wp_deprecated_default()('`__experimentalGroup` property in `InspectorControlsFill`', {
      since: '6.2',
      version: '6.4',
      alternative: '`group`'
    });
    group = __experimentalGroup;
  }

  const isDisplayed = useDisplayBlockControls();
  const Fill = inspector_controls_groups[group]?.Fill;

  if (!Fill) {
    typeof process !== "undefined" && process.env && "production" !== "production" ? 0 : void 0;
    return null;
  }

  if (!isDisplayed) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalStyleProvider, {
    document: document
  }, (0,external_wp_element_namespaceObject.createElement)(Fill, null, fillProps => {
    return (0,external_wp_element_namespaceObject.createElement)(ToolsPanelInspectorControl, {
      fillProps: fillProps,
      children: children,
      resetAllFilter: resetAllFilter
    });
  }));
}

function ToolsPanelInspectorControl({
  children,
  resetAllFilter,
  fillProps
}) {
  const {
    registerResetAllFilter,
    deregisterResetAllFilter
  } = fillProps;
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (resetAllFilter && registerResetAllFilter) {
      registerResetAllFilter(resetAllFilter);
    }

    return () => {
      if (resetAllFilter && deregisterResetAllFilter) {
        deregisterResetAllFilter(resetAllFilter);
      }
    };
  }, [resetAllFilter, registerResetAllFilter, deregisterResetAllFilter]); // Children passed to InspectorControlsFill will not have
  // access to any React Context whose Provider is part of
  // the InspectorControlsSlot tree. So we re-create the
  // Provider in this subtree.

  const value = fillProps && Object.keys(fillProps).length > 0 ? fillProps : null;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelContext.Provider, {
    value: value
  }, children);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls/block-support-tools-panel.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function BlockSupportToolsPanel({
  children,
  group,
  label
}) {
  const {
    updateBlockAttributes
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const {
    getBlockAttributes,
    getMultiSelectedBlockClientIds,
    getSelectedBlockClientId,
    hasMultiSelection
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const panelId = getSelectedBlockClientId();
  const resetAll = (0,external_wp_element_namespaceObject.useCallback)((resetFilters = []) => {
    const newAttributes = {};
    const clientIds = hasMultiSelection() ? getMultiSelectedBlockClientIds() : [panelId];
    clientIds.forEach(clientId => {
      const {
        style
      } = getBlockAttributes(clientId);
      let newBlockAttributes = {
        style
      };
      resetFilters.forEach(resetFilter => {
        newBlockAttributes = { ...newBlockAttributes,
          ...resetFilter(newBlockAttributes)
        };
      }); // Enforce a cleaned style object.

      newBlockAttributes = { ...newBlockAttributes,
        style: utils_cleanEmptyObject(newBlockAttributes.style)
      };
      newAttributes[clientId] = newBlockAttributes;
    });
    updateBlockAttributes(clientIds, newAttributes, true);
  }, [getBlockAttributes, getMultiSelectedBlockClientIds, hasMultiSelection, panelId, updateBlockAttributes]);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanel, {
    className: `${group}-block-support-panel`,
    label: label,
    resetAll: resetAll,
    key: panelId,
    panelId: panelId,
    hasInnerWrapper: true,
    shouldRenderPlaceholderItems: true // Required to maintain fills ordering.
    ,
    __experimentalFirstVisibleItemClass: "first",
    __experimentalLastVisibleItemClass: "last"
  }, children);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls/block-support-slot-container.js


/**
 * WordPress dependencies
 */


function BlockSupportSlotContainer({
  Slot,
  ...props
}) {
  const toolsPanelContext = (0,external_wp_element_namespaceObject.useContext)(external_wp_components_namespaceObject.__experimentalToolsPanelContext);
  return (0,external_wp_element_namespaceObject.createElement)(Slot, { ...props,
    fillProps: toolsPanelContext,
    bubblesVirtually: true
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls/slot.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




function InspectorControlsSlot({
  __experimentalGroup,
  group = 'default',
  label,
  ...props
}) {
  if (__experimentalGroup) {
    external_wp_deprecated_default()('`__experimentalGroup` property in `InspectorControlsSlot`', {
      since: '6.2',
      version: '6.4',
      alternative: '`group`'
    });
    group = __experimentalGroup;
  }

  const Slot = inspector_controls_groups[group]?.Slot;
  const fills = (0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(Slot?.__unstableName);

  if (!Slot) {
    typeof process !== "undefined" && process.env && "production" !== "production" ? 0 : void 0;
    return null;
  }

  if (!fills?.length) {
    return null;
  }

  if (label) {
    return (0,external_wp_element_namespaceObject.createElement)(BlockSupportToolsPanel, {
      group: group,
      label: label
    }, (0,external_wp_element_namespaceObject.createElement)(BlockSupportSlotContainer, { ...props,
      Slot: Slot
    }));
  }

  return (0,external_wp_element_namespaceObject.createElement)(Slot, { ...props,
    bubblesVirtually: true
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls/index.js


/**
 * Internal dependencies
 */


const InspectorControls = InspectorControlsFill;
InspectorControls.Slot = InspectorControlsSlot; // This is just here for backward compatibility.

const InspectorAdvancedControls = props => {
  return (0,external_wp_element_namespaceObject.createElement)(InspectorControlsFill, { ...props,
    group: "advanced"
  });
};

InspectorAdvancedControls.Slot = props => {
  return (0,external_wp_element_namespaceObject.createElement)(InspectorControlsSlot, { ...props,
    group: "advanced"
  });
};

InspectorAdvancedControls.slotName = 'InspectorAdvancedControls';
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/inspector-controls/README.md
 */

/* harmony default export */ var inspector_controls = (InspectorControls);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/anchor.js


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */



/**
 * Regular expression matching invalid anchor characters for replacement.
 *
 * @type {RegExp}
 */

const ANCHOR_REGEX = /[\s#]/g;
const ANCHOR_SCHEMA = {
  type: 'string',
  source: 'attribute',
  attribute: 'id',
  selector: '*'
};
/**
 * Filters registered block settings, extending attributes with anchor using ID
 * of the first node.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function anchor_addAttribute(settings) {
  var _settings$attributes$;

  // Allow blocks to specify their own attribute definition with default values if needed.
  if ('type' in ((_settings$attributes$ = settings.attributes?.anchor) !== null && _settings$attributes$ !== void 0 ? _settings$attributes$ : {})) {
    return settings;
  }

  if ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, 'anchor')) {
    // Gracefully handle if settings.attributes is undefined.
    settings.attributes = { ...settings.attributes,
      anchor: ANCHOR_SCHEMA
    };
  }

  return settings;
}
/**
 * Override the default edit UI to include a new block inspector control for
 * assigning the anchor ID, if block supports anchor.
 *
 * @param {WPComponent} BlockEdit Original component.
 *
 * @return {WPComponent} Wrapped component.
 */

const withInspectorControl = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(BlockEdit => {
  return props => {
    const hasAnchor = (0,external_wp_blocks_namespaceObject.hasBlockSupport)(props.name, 'anchor');
    const blockEditingMode = useBlockEditingMode();

    if (hasAnchor && props.isSelected) {
      const isWeb = external_wp_element_namespaceObject.Platform.OS === 'web';
      const textControl = (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.TextControl, {
        __nextHasNoMarginBottom: true,
        className: "html-anchor-control",
        label: (0,external_wp_i18n_namespaceObject.__)('HTML anchor'),
        help: (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_i18n_namespaceObject.__)('Enter a word or two — without spaces — to make a unique web address just for this block, called an “anchor.” Then, you’ll be able to link directly to this section of your page.'), isWeb && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ExternalLink, {
          href: (0,external_wp_i18n_namespaceObject.__)('https://wordpress.org/documentation/article/page-jumps/')
        }, (0,external_wp_i18n_namespaceObject.__)('Learn more about anchors'))),
        value: props.attributes.anchor || '',
        placeholder: !isWeb ? (0,external_wp_i18n_namespaceObject.__)('Add an anchor') : null,
        onChange: nextValue => {
          nextValue = nextValue.replace(ANCHOR_REGEX, '-');
          props.setAttributes({
            anchor: nextValue
          });
        },
        autoCapitalize: "none",
        autoComplete: "off"
      });
      return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(BlockEdit, { ...props
      }), isWeb && blockEditingMode === 'default' && (0,external_wp_element_namespaceObject.createElement)(inspector_controls, {
        group: "advanced"
      }, textControl), !isWeb && props.name === 'core/heading' && (0,external_wp_element_namespaceObject.createElement)(inspector_controls, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.PanelBody, {
        title: (0,external_wp_i18n_namespaceObject.__)('Heading settings')
      }, textControl)));
    }

    return (0,external_wp_element_namespaceObject.createElement)(BlockEdit, { ...props
    });
  };
}, 'withInspectorControl');
/**
 * Override props assigned to save component to inject anchor ID, if block
 * supports anchor. This is only applied if the block's save result is an
 * element and not a markup string.
 *
 * @param {Object} extraProps Additional props applied to save element.
 * @param {Object} blockType  Block type.
 * @param {Object} attributes Current block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */

function addSaveProps(extraProps, blockType, attributes) {
  if ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, 'anchor')) {
    extraProps.id = attributes.anchor === '' ? null : attributes.anchor;
  }

  return extraProps;
}
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/anchor/attribute', anchor_addAttribute);
(0,external_wp_hooks_namespaceObject.addFilter)('editor.BlockEdit', 'core/editor/anchor/with-inspector-control', withInspectorControl);
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.getSaveContent.extraProps', 'core/anchor/save-props', addSaveProps);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/aria-label.js
/**
 * WordPress dependencies
 */


const ARIA_LABEL_SCHEMA = {
  type: 'string',
  source: 'attribute',
  attribute: 'aria-label',
  selector: '*'
};
/**
 * Filters registered block settings, extending attributes with ariaLabel using aria-label
 * of the first node.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function aria_label_addAttribute(settings) {
  // Allow blocks to specify their own attribute definition with default values if needed.
  if (settings?.attributes?.ariaLabel?.type) {
    return settings;
  }

  if ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, 'ariaLabel')) {
    // Gracefully handle if settings.attributes is undefined.
    settings.attributes = { ...settings.attributes,
      ariaLabel: ARIA_LABEL_SCHEMA
    };
  }

  return settings;
}
/**
 * Override props assigned to save component to inject aria-label, if block
 * supports ariaLabel. This is only applied if the block's save result is an
 * element and not a markup string.
 *
 * @param {Object} extraProps Additional props applied to save element.
 * @param {Object} blockType  Block type.
 * @param {Object} attributes Current block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */

function aria_label_addSaveProps(extraProps, blockType, attributes) {
  if ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, 'ariaLabel')) {
    extraProps['aria-label'] = attributes.ariaLabel === '' ? null : attributes.ariaLabel;
  }

  return extraProps;
}
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/ariaLabel/attribute', aria_label_addAttribute);
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.getSaveContent.extraProps', 'core/ariaLabel/save-props', aria_label_addSaveProps);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/custom-class-name.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */



/**
 * Filters registered block settings, extending attributes to include `className`.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function custom_class_name_addAttribute(settings) {
  if ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, 'customClassName', true)) {
    // Gracefully handle if settings.attributes is undefined.
    settings.attributes = { ...settings.attributes,
      className: {
        type: 'string'
      }
    };
  }

  return settings;
}
/**
 * Override the default edit UI to include a new block inspector control for
 * assigning the custom class name, if block supports custom class name.
 * The control is displayed within the Advanced panel in the block inspector.
 *
 * @param {WPComponent} BlockEdit Original component.
 *
 * @return {WPComponent} Wrapped component.
 */

const custom_class_name_withInspectorControl = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(BlockEdit => {
  return props => {
    const blockEditingMode = useBlockEditingMode();
    const hasCustomClassName = (0,external_wp_blocks_namespaceObject.hasBlockSupport)(props.name, 'customClassName', true);

    if (hasCustomClassName && props.isSelected) {
      return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(BlockEdit, { ...props
      }), blockEditingMode === 'default' && (0,external_wp_element_namespaceObject.createElement)(inspector_controls, {
        group: "advanced"
      }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.TextControl, {
        __nextHasNoMarginBottom: true,
        autoComplete: "off",
        label: (0,external_wp_i18n_namespaceObject.__)('Additional CSS class(es)'),
        value: props.attributes.className || '',
        onChange: nextValue => {
          props.setAttributes({
            className: nextValue !== '' ? nextValue : undefined
          });
        },
        help: (0,external_wp_i18n_namespaceObject.__)('Separate multiple classes with spaces.')
      })));
    }

    return (0,external_wp_element_namespaceObject.createElement)(BlockEdit, { ...props
    });
  };
}, 'withInspectorControl');
/**
 * Override props assigned to save component to inject the className, if block
 * supports customClassName. This is only applied if the block's save result is an
 * element and not a markup string.
 *
 * @param {Object} extraProps Additional props applied to save element.
 * @param {Object} blockType  Block type.
 * @param {Object} attributes Current block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */

function custom_class_name_addSaveProps(extraProps, blockType, attributes) {
  if ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, 'customClassName', true) && attributes.className) {
    extraProps.className = classnames_default()(extraProps.className, attributes.className);
  }

  return extraProps;
}
function addTransforms(result, source, index, results) {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(result.name, 'customClassName', true)) {
    return result;
  } // If the condition verifies we are probably in the presence of a wrapping transform
  // e.g: nesting paragraphs in a group or columns and in that case the class should not be kept.


  if (results.length === 1 && result.innerBlocks.length === source.length) {
    return result;
  } // If we are transforming one block to multiple blocks or multiple blocks to one block,
  // we ignore the class during the transform.


  if (results.length === 1 && source.length > 1 || results.length > 1 && source.length === 1) {
    return result;
  } // If we are in presence of transform between one or more block in the source
  // that have one or more blocks in the result
  // we apply the class on source N to the result N,
  // if source N does not exists we do nothing.


  if (source[index]) {
    const originClassName = source[index]?.attributes.className;

    if (originClassName) {
      return { ...result,
        attributes: { ...result.attributes,
          className: originClassName
        }
      };
    }
  }

  return result;
}
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/custom-class-name/attribute', custom_class_name_addAttribute);
(0,external_wp_hooks_namespaceObject.addFilter)('editor.BlockEdit', 'core/editor/custom-class-name/with-inspector-control', custom_class_name_withInspectorControl);
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.getSaveContent.extraProps', 'core/custom-class-name/save-props', custom_class_name_addSaveProps);
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.switchToBlockType.transformedBlock', 'core/color/addTransforms', addTransforms);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/generated-class-name.js
/**
 * WordPress dependencies
 */


/**
 * Override props assigned to save component to inject generated className if
 * block supports it. This is only applied if the block's save result is an
 * element and not a markup string.
 *
 * @param {Object} extraProps Additional props applied to save element.
 * @param {Object} blockType  Block type.
 *
 * @return {Object} Filtered props applied to save element.
 */

function addGeneratedClassName(extraProps, blockType) {
  // Adding the generated className.
  if ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, 'className', true)) {
    if (typeof extraProps.className === 'string') {
      // We have some extra classes and want to add the default classname
      // We use uniq to prevent duplicate classnames.
      extraProps.className = [...new Set([(0,external_wp_blocks_namespaceObject.getBlockDefaultClassName)(blockType.name), ...extraProps.className.split(' ')])].join(' ').trim();
    } else {
      // There is no string in the className variable,
      // so we just dump the default name in there.
      extraProps.className = (0,external_wp_blocks_namespaceObject.getBlockDefaultClassName)(blockType.name);
    }
  }

  return extraProps;
}
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.getSaveContent.extraProps', 'core/generated-class-name/save-props', addGeneratedClassName);

;// CONCATENATED MODULE: external ["wp","dom"]
var external_wp_dom_namespaceObject = window["wp"]["dom"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-context/index.js


/**
 * WordPress dependencies
 */

/** @typedef {import('react').ReactNode} ReactNode */

/**
 * @typedef BlockContextProviderProps
 *
 * @property {Record<string,*>} value    Context value to merge with current
 *                                       value.
 * @property {ReactNode}        children Component children.
 */

/** @type {import('react').Context<Record<string,*>>} */

const block_context_Context = (0,external_wp_element_namespaceObject.createContext)({});
/**
 * Component which merges passed value with current consumed block context.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-context/README.md
 *
 * @param {BlockContextProviderProps} props
 */

function BlockContextProvider({
  value,
  children
}) {
  const context = (0,external_wp_element_namespaceObject.useContext)(block_context_Context);
  const nextValue = (0,external_wp_element_namespaceObject.useMemo)(() => ({ ...context,
    ...value
  }), [context, value]);
  return (0,external_wp_element_namespaceObject.createElement)(block_context_Context.Provider, {
    value: nextValue,
    children: children
  });
}
/* harmony default export */ var block_context = (block_context_Context);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-edit/edit.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/**
 * Default value used for blocks which do not define their own context needs,
 * used to guarantee that a block's `context` prop will always be an object. It
 * is assigned as a constant since it is always expected to be an empty object,
 * and in order to avoid unnecessary React reconciliations of a changing object.
 *
 * @type {{}}
 */

const DEFAULT_BLOCK_CONTEXT = {};

const Edit = props => {
  const {
    name
  } = props;
  const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(name);

  if (!blockType) {
    return null;
  } // `edit` and `save` are functions or components describing the markup
  // with which a block is displayed. If `blockType` is valid, assign
  // them preferentially as the render value for the block.


  const Component = blockType.edit || blockType.save;
  return (0,external_wp_element_namespaceObject.createElement)(Component, { ...props
  });
};

const EditWithFilters = (0,external_wp_components_namespaceObject.withFilters)('editor.BlockEdit')(Edit);

const EditWithGeneratedProps = props => {
  const {
    attributes = {},
    name
  } = props;
  const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(name);
  const blockContext = (0,external_wp_element_namespaceObject.useContext)(block_context); // Assign context values using the block type's declared context needs.

  const context = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return blockType && blockType.usesContext ? Object.fromEntries(Object.entries(blockContext).filter(([key]) => blockType.usesContext.includes(key))) : DEFAULT_BLOCK_CONTEXT;
  }, [blockType, blockContext]);

  if (!blockType) {
    return null;
  }

  if (blockType.apiVersion > 1) {
    return (0,external_wp_element_namespaceObject.createElement)(EditWithFilters, { ...props,
      context: context
    });
  } // Generate a class name for the block's editable form.


  const generatedClassName = (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, 'className', true) ? (0,external_wp_blocks_namespaceObject.getBlockDefaultClassName)(name) : null;
  const className = classnames_default()(generatedClassName, attributes.className, props.className);
  return (0,external_wp_element_namespaceObject.createElement)(EditWithFilters, { ...props,
    context: context,
    className: className
  });
};

/* harmony default export */ var edit = (EditWithGeneratedProps);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-edit/index.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/**
 * The `useBlockEditContext` hook provides information about the block this hook is being used in.
 * It returns an object with the `name`, `isSelected` state, and the `clientId` of the block.
 * It is useful if you want to create custom hooks that need access to the current blocks clientId
 * but don't want to rely on the data getting passed in as a parameter.
 *
 * @return {Object} Block edit context
 */


function BlockEdit(props) {
  const {
    name,
    isSelected,
    clientId,
    attributes = {},
    __unstableLayoutClassNames
  } = props;
  const {
    layout = null
  } = attributes;
  const layoutSupport = (0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, 'layout', false) || (0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, '__experimentalLayout', false);
  const context = {
    name,
    isSelected,
    clientId,
    layout: layoutSupport ? layout : null,
    __unstableLayoutClassNames
  };
  return (0,external_wp_element_namespaceObject.createElement)(Provider // It is important to return the same object if props haven't
  // changed to avoid  unnecessary rerenders.
  // See https://reactjs.org/docs/context.html#caveats.
  , {
    value: (0,external_wp_element_namespaceObject.useMemo)(() => context, Object.values(context))
  }, (0,external_wp_element_namespaceObject.createElement)(edit, { ...props
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/more-horizontal.js


/**
 * WordPress dependencies
 */

const moreHorizontal = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M11 13h2v-2h-2v2zm-6 0h2v-2H5v2zm12-2v2h2v-2h-2z"
}));
/* harmony default export */ var more_horizontal = (moreHorizontal);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/warning/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






function Warning({
  className,
  actions,
  children,
  secondaryActions
}) {
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    style: {
      display: 'contents',
      all: 'initial'
    }
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: classnames_default()(className, 'block-editor-warning')
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-warning__contents"
  }, (0,external_wp_element_namespaceObject.createElement)("p", {
    className: "block-editor-warning__message"
  }, children), (external_wp_element_namespaceObject.Children.count(actions) > 0 || secondaryActions) && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-warning__actions"
  }, external_wp_element_namespaceObject.Children.count(actions) > 0 && external_wp_element_namespaceObject.Children.map(actions, (action, i) => (0,external_wp_element_namespaceObject.createElement)("span", {
    key: i,
    className: "block-editor-warning__action"
  }, action)), secondaryActions && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.DropdownMenu, {
    className: "block-editor-warning__secondary",
    icon: more_horizontal,
    label: (0,external_wp_i18n_namespaceObject.__)('More options'),
    popoverProps: {
      position: 'bottom left',
      className: 'block-editor-warning__dropdown'
    },
    noIcons: true
  }, () => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuGroup, null, secondaryActions.map((item, pos) => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    onClick: item.onClick,
    key: pos
  }, item.title))))))));
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/warning/README.md
 */


/* harmony default export */ var warning = (Warning);

// EXTERNAL MODULE: ./node_modules/diff/lib/diff/character.js
var character = __webpack_require__(1973);
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-compare/block-view.js


/**
 * WordPress dependencies
 */



function BlockView({
  title,
  rawContent,
  renderedContent,
  action,
  actionText,
  className
}) {
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: className
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-compare__content"
  }, (0,external_wp_element_namespaceObject.createElement)("h2", {
    className: "block-editor-block-compare__heading"
  }, title), (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-compare__html"
  }, rawContent), (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-compare__preview edit-post-visual-editor"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.RawHTML, null, (0,external_wp_dom_namespaceObject.safeHTML)(renderedContent)))), (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-compare__action"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    variant: "secondary",
    tabIndex: "0",
    onClick: action
  }, actionText)));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-compare/index.js


/**
 * External dependencies
 */
 // diff doesn't tree-shake correctly, so we import from the individual
// module here, to avoid including too much of the library


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function BlockCompare({
  block,
  onKeep,
  onConvert,
  convertor,
  convertButtonText
}) {
  function getDifference(originalContent, newContent) {
    const difference = (0,character/* diffChars */.Kx)(originalContent, newContent);
    return difference.map((item, pos) => {
      const classes = classnames_default()({
        'block-editor-block-compare__added': item.added,
        'block-editor-block-compare__removed': item.removed
      });
      return (0,external_wp_element_namespaceObject.createElement)("span", {
        key: pos,
        className: classes
      }, item.value);
    });
  }

  function getConvertedContent(convertedBlock) {
    // The convertor may return an array of items or a single item.
    const newBlocks = Array.isArray(convertedBlock) ? convertedBlock : [convertedBlock]; // Get converted block details.

    const newContent = newBlocks.map(item => (0,external_wp_blocks_namespaceObject.getSaveContent)(item.name, item.attributes, item.innerBlocks));
    return newContent.join('');
  }

  const converted = getConvertedContent(convertor(block));
  const difference = getDifference(block.originalContent, converted);
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-compare__wrapper"
  }, (0,external_wp_element_namespaceObject.createElement)(BlockView, {
    title: (0,external_wp_i18n_namespaceObject.__)('Current'),
    className: "block-editor-block-compare__current",
    action: onKeep,
    actionText: (0,external_wp_i18n_namespaceObject.__)('Convert to HTML'),
    rawContent: block.originalContent,
    renderedContent: block.originalContent
  }), (0,external_wp_element_namespaceObject.createElement)(BlockView, {
    title: (0,external_wp_i18n_namespaceObject.__)('After Conversion'),
    className: "block-editor-block-compare__converted",
    action: onConvert,
    actionText: convertButtonText,
    rawContent: difference,
    renderedContent: converted
  }));
}

/* harmony default export */ var block_compare = (BlockCompare);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/block-invalid-warning.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */





const blockToBlocks = block => (0,external_wp_blocks_namespaceObject.rawHandler)({
  HTML: block.originalContent
});

function BlockInvalidWarning({
  clientId
}) {
  const {
    block,
    canInsertHTMLBlock,
    canInsertClassicBlock
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      canInsertBlockType,
      getBlock,
      getBlockRootClientId
    } = select(store);
    const rootClientId = getBlockRootClientId(clientId);
    return {
      block: getBlock(clientId),
      canInsertHTMLBlock: canInsertBlockType('core/html', rootClientId),
      canInsertClassicBlock: canInsertBlockType('core/freeform', rootClientId)
    };
  }, [clientId]);
  const {
    replaceBlock
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const [compare, setCompare] = (0,external_wp_element_namespaceObject.useState)(false);
  const onCompareClose = (0,external_wp_element_namespaceObject.useCallback)(() => setCompare(false), []);
  const convert = (0,external_wp_element_namespaceObject.useMemo)(() => ({
    toClassic() {
      const classicBlock = (0,external_wp_blocks_namespaceObject.createBlock)('core/freeform', {
        content: block.originalContent
      });
      return replaceBlock(block.clientId, classicBlock);
    },

    toHTML() {
      const htmlBlock = (0,external_wp_blocks_namespaceObject.createBlock)('core/html', {
        content: block.originalContent
      });
      return replaceBlock(block.clientId, htmlBlock);
    },

    toBlocks() {
      const newBlocks = blockToBlocks(block);
      return replaceBlock(block.clientId, newBlocks);
    },

    toRecoveredBlock() {
      const recoveredBlock = (0,external_wp_blocks_namespaceObject.createBlock)(block.name, block.attributes, block.innerBlocks);
      return replaceBlock(block.clientId, recoveredBlock);
    }

  }), [block, replaceBlock]);
  const secondaryActions = (0,external_wp_element_namespaceObject.useMemo)(() => [{
    // translators: Button to fix block content
    title: (0,external_wp_i18n_namespaceObject._x)('Resolve', 'imperative verb'),
    onClick: () => setCompare(true)
  }, canInsertHTMLBlock && {
    title: (0,external_wp_i18n_namespaceObject.__)('Convert to HTML'),
    onClick: convert.toHTML
  }, canInsertClassicBlock && {
    title: (0,external_wp_i18n_namespaceObject.__)('Convert to Classic Block'),
    onClick: convert.toClassic
  }].filter(Boolean), [canInsertHTMLBlock, canInsertClassicBlock, convert]);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(warning, {
    actions: [(0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
      key: "recover",
      onClick: convert.toRecoveredBlock,
      variant: "primary"
    }, (0,external_wp_i18n_namespaceObject.__)('Attempt Block Recovery'))],
    secondaryActions: secondaryActions
  }, (0,external_wp_i18n_namespaceObject.__)('This block contains unexpected or invalid content.')), compare && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Modal, {
    title: // translators: Dialog title to fix block content
    (0,external_wp_i18n_namespaceObject.__)('Resolve Block'),
    onRequestClose: onCompareClose,
    className: "block-editor-block-compare"
  }, (0,external_wp_element_namespaceObject.createElement)(block_compare, {
    block: block,
    onKeep: convert.toHTML,
    onConvert: convert.toBlocks,
    convertor: blockToBlocks,
    convertButtonText: (0,external_wp_i18n_namespaceObject.__)('Convert to Blocks')
  })));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/block-crash-warning.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


const block_crash_warning_warning = (0,external_wp_element_namespaceObject.createElement)(warning, {
  className: "block-editor-block-list__block-crash-warning"
}, (0,external_wp_i18n_namespaceObject.__)('This block has encountered an error and cannot be previewed.'));
/* harmony default export */ var block_crash_warning = (() => block_crash_warning_warning);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/block-crash-boundary.js
/**
 * WordPress dependencies
 */


class BlockCrashBoundary extends external_wp_element_namespaceObject.Component {
  constructor() {
    super(...arguments);
    this.state = {
      hasError: false
    };
  }

  componentDidCatch() {
    this.setState({
      hasError: true
    });
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }

    return this.props.children;
  }

}

/* harmony default export */ var block_crash_boundary = (BlockCrashBoundary);

// EXTERNAL MODULE: ./node_modules/react-autosize-textarea/lib/index.js
var lib = __webpack_require__(773);
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/block-html.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



function BlockHTML({
  clientId
}) {
  const [html, setHtml] = (0,external_wp_element_namespaceObject.useState)('');
  const block = (0,external_wp_data_namespaceObject.useSelect)(select => select(store).getBlock(clientId), [clientId]);
  const {
    updateBlock
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);

  const onChange = () => {
    const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(block.name);

    if (!blockType) {
      return;
    }

    const attributes = (0,external_wp_blocks_namespaceObject.getBlockAttributes)(blockType, html, block.attributes); // If html is empty  we reset the block to the default HTML and mark it as valid to avoid triggering an error

    const content = html ? html : (0,external_wp_blocks_namespaceObject.getSaveContent)(blockType, attributes);
    const [isValid] = html ? (0,external_wp_blocks_namespaceObject.validateBlock)({ ...block,
      attributes,
      originalContent: content
    }) : [true];
    updateBlock(clientId, {
      attributes,
      originalContent: content,
      isValid
    }); // Ensure the state is updated if we reset so it displays the default content.

    if (!html) {
      setHtml(content);
    }
  };

  (0,external_wp_element_namespaceObject.useEffect)(() => {
    setHtml((0,external_wp_blocks_namespaceObject.getBlockContent)(block));
  }, [block]);
  return (0,external_wp_element_namespaceObject.createElement)(lib/* default */.Z, {
    className: "block-editor-block-list__block-html-textarea",
    value: html,
    onBlur: onChange,
    onChange: event => setHtml(event.target.value)
  });
}

/* harmony default export */ var block_html = (BlockHTML);

// EXTERNAL MODULE: external "React"
var external_React_ = __webpack_require__(9196);
var external_React_default = /*#__PURE__*/__webpack_require__.n(external_React_);
;// CONCATENATED MODULE: ./node_modules/@react-spring/shared/dist/react-spring_shared.modern.mjs
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/globals.ts
var globals_exports = {};
__export(globals_exports, {
  assign: () => react_spring_shared_modern_assign,
  colors: () => colors,
  createStringInterpolator: () => createStringInterpolator,
  skipAnimation: () => skipAnimation,
  to: () => to,
  willAdvance: () => willAdvance
});

// ../rafz/dist/react-spring_rafz.modern.mjs
var updateQueue = makeQueue();
var raf = (fn) => schedule(fn, updateQueue);
var writeQueue = makeQueue();
raf.write = (fn) => schedule(fn, writeQueue);
var onStartQueue = makeQueue();
raf.onStart = (fn) => schedule(fn, onStartQueue);
var onFrameQueue = makeQueue();
raf.onFrame = (fn) => schedule(fn, onFrameQueue);
var onFinishQueue = makeQueue();
raf.onFinish = (fn) => schedule(fn, onFinishQueue);
var timeouts = [];
raf.setTimeout = (handler, ms) => {
  const time = raf.now() + ms;
  const cancel = () => {
    const i = timeouts.findIndex((t) => t.cancel == cancel);
    if (~i)
      timeouts.splice(i, 1);
    pendingCount -= ~i ? 1 : 0;
  };
  const timeout = { time, handler, cancel };
  timeouts.splice(findTimeout(time), 0, timeout);
  pendingCount += 1;
  start();
  return timeout;
};
var findTimeout = (time) => ~(~timeouts.findIndex((t) => t.time > time) || ~timeouts.length);
raf.cancel = (fn) => {
  onStartQueue.delete(fn);
  onFrameQueue.delete(fn);
  onFinishQueue.delete(fn);
  updateQueue.delete(fn);
  writeQueue.delete(fn);
};
raf.sync = (fn) => {
  sync = true;
  raf.batchedUpdates(fn);
  sync = false;
};
raf.throttle = (fn) => {
  let lastArgs;
  function queuedFn() {
    try {
      fn(...lastArgs);
    } finally {
      lastArgs = null;
    }
  }
  function throttled(...args) {
    lastArgs = args;
    raf.onStart(queuedFn);
  }
  throttled.handler = fn;
  throttled.cancel = () => {
    onStartQueue.delete(queuedFn);
    lastArgs = null;
  };
  return throttled;
};
var nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : (
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  () => {
  }
);
raf.use = (impl) => nativeRaf = impl;
raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
raf.batchedUpdates = (fn) => fn();
raf.catch = console.error;
raf.frameLoop = "always";
raf.advance = () => {
  if (raf.frameLoop !== "demand") {
    console.warn(
      "Cannot call the manual advancement of rafz whilst frameLoop is not set as demand"
    );
  } else {
    update();
  }
};
var ts = -1;
var pendingCount = 0;
var sync = false;
function schedule(fn, queue) {
  if (sync) {
    queue.delete(fn);
    fn(0);
  } else {
    queue.add(fn);
    start();
  }
}
function start() {
  if (ts < 0) {
    ts = 0;
    if (raf.frameLoop !== "demand") {
      nativeRaf(loop);
    }
  }
}
function stop() {
  ts = -1;
}
function loop() {
  if (~ts) {
    nativeRaf(loop);
    raf.batchedUpdates(update);
  }
}
function update() {
  const prevTs = ts;
  ts = raf.now();
  const count = findTimeout(ts);
  if (count) {
    eachSafely(timeouts.splice(0, count), (t) => t.handler());
    pendingCount -= count;
  }
  if (!pendingCount) {
    stop();
    return;
  }
  onStartQueue.flush();
  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
  onFrameQueue.flush();
  writeQueue.flush();
  onFinishQueue.flush();
}
function makeQueue() {
  let next = /* @__PURE__ */ new Set();
  let current = next;
  return {
    add(fn) {
      pendingCount += current == next && !next.has(fn) ? 1 : 0;
      next.add(fn);
    },
    delete(fn) {
      pendingCount -= current == next && next.has(fn) ? 1 : 0;
      return next.delete(fn);
    },
    flush(arg) {
      if (current.size) {
        next = /* @__PURE__ */ new Set();
        pendingCount -= current.size;
        eachSafely(current, (fn) => fn(arg) && next.add(fn));
        pendingCount += next.size;
        current = next;
      }
    }
  };
}
function eachSafely(values, each2) {
  values.forEach((value) => {
    try {
      each2(value);
    } catch (e) {
      raf.catch(e);
    }
  });
}

// src/helpers.ts
function noop() {
}
var defineHidden = (obj, key, value) => Object.defineProperty(obj, key, { value, writable: true, configurable: true });
var is = {
  arr: Array.isArray,
  obj: (a) => !!a && a.constructor.name === "Object",
  fun: (a) => typeof a === "function",
  str: (a) => typeof a === "string",
  num: (a) => typeof a === "number",
  und: (a) => a === void 0
};
function isEqual(a, b) {
  if (is.arr(a)) {
    if (!is.arr(b) || a.length !== b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }
  return a === b;
}
var react_spring_shared_modern_each = (obj, fn) => obj.forEach(fn);
function eachProp(obj, fn, ctx) {
  if (is.arr(obj)) {
    for (let i = 0; i < obj.length; i++) {
      fn.call(ctx, obj[i], `${i}`);
    }
    return;
  }
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      fn.call(ctx, obj[key], key);
    }
  }
}
var toArray = (a) => is.und(a) ? [] : is.arr(a) ? a : [a];
function flush(queue, iterator) {
  if (queue.size) {
    const items = Array.from(queue);
    queue.clear();
    react_spring_shared_modern_each(items, iterator);
  }
}
var flushCalls = (queue, ...args) => flush(queue, (fn) => fn(...args));
var isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);

// src/globals.ts
var createStringInterpolator;
var to;
var colors = null;
var skipAnimation = false;
var willAdvance = noop;
var react_spring_shared_modern_assign = (globals) => {
  if (globals.to)
    to = globals.to;
  if (globals.now)
    raf.now = globals.now;
  if (globals.colors !== void 0)
    colors = globals.colors;
  if (globals.skipAnimation != null)
    skipAnimation = globals.skipAnimation;
  if (globals.createStringInterpolator)
    createStringInterpolator = globals.createStringInterpolator;
  if (globals.requestAnimationFrame)
    raf.use(globals.requestAnimationFrame);
  if (globals.batchedUpdates)
    raf.batchedUpdates = globals.batchedUpdates;
  if (globals.willAdvance)
    willAdvance = globals.willAdvance;
  if (globals.frameLoop)
    raf.frameLoop = globals.frameLoop;
};

// src/FrameLoop.ts
var startQueue = /* @__PURE__ */ new Set();
var currentFrame = [];
var prevFrame = [];
var priority = 0;
var frameLoop = {
  get idle() {
    return !startQueue.size && !currentFrame.length;
  },
  /** Advance the given animation on every frame until idle. */
  start(animation) {
    if (priority > animation.priority) {
      startQueue.add(animation);
      raf.onStart(flushStartQueue);
    } else {
      startSafely(animation);
      raf(advance);
    }
  },
  /** Advance all animations by the given time. */
  advance,
  /** Call this when an animation's priority changes. */
  sort(animation) {
    if (priority) {
      raf.onFrame(() => frameLoop.sort(animation));
    } else {
      const prevIndex = currentFrame.indexOf(animation);
      if (~prevIndex) {
        currentFrame.splice(prevIndex, 1);
        startUnsafely(animation);
      }
    }
  },
  /**
   * Clear all animations. For testing purposes.
   *
   * ☠️ Never call this from within the frameloop.
   */
  clear() {
    currentFrame = [];
    startQueue.clear();
  }
};
function flushStartQueue() {
  startQueue.forEach(startSafely);
  startQueue.clear();
  raf(advance);
}
function startSafely(animation) {
  if (!currentFrame.includes(animation))
    startUnsafely(animation);
}
function startUnsafely(animation) {
  currentFrame.splice(
    findIndex(currentFrame, (other) => other.priority > animation.priority),
    0,
    animation
  );
}
function advance(dt) {
  const nextFrame = prevFrame;
  for (let i = 0; i < currentFrame.length; i++) {
    const animation = currentFrame[i];
    priority = animation.priority;
    if (!animation.idle) {
      willAdvance(animation);
      animation.advance(dt);
      if (!animation.idle) {
        nextFrame.push(animation);
      }
    }
  }
  priority = 0;
  prevFrame = currentFrame;
  prevFrame.length = 0;
  currentFrame = nextFrame;
  return currentFrame.length > 0;
}
function findIndex(arr, test) {
  const index = arr.findIndex(test);
  return index < 0 ? arr.length : index;
}

// src/clamp.ts
var clamp = (min, max, v) => Math.min(Math.max(v, min), max);

// src/colors.ts
var colors2 = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};

// src/colorMatchers.ts
var NUMBER = "[-+]?\\d*\\.?\\d+";
var PERCENTAGE = NUMBER + "%";
function call(...parts) {
  return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
}
var rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
var rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
var hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
var hsla = new RegExp(
  "hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)
);
var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex6 = /^#([0-9a-fA-F]{6})$/;
var hex8 = /^#([0-9a-fA-F]{8})$/;

// src/normalizeColor.ts
function normalizeColor(color) {
  let match;
  if (typeof color === "number") {
    return color >>> 0 === color && color >= 0 && color <= 4294967295 ? color : null;
  }
  if (match = hex6.exec(color))
    return parseInt(match[1] + "ff", 16) >>> 0;
  if (colors && colors[color] !== void 0) {
    return colors[color];
  }
  if (match = rgb.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    255) >>> // a
    0;
  }
  if (match = rgba.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    parse1(match[4])) >>> // a
    0;
  }
  if (match = hex3.exec(color)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      "ff",
      // a
      16
    ) >>> 0;
  }
  if (match = hex8.exec(color))
    return parseInt(match[1], 16) >>> 0;
  if (match = hex4.exec(color)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      match[4] + match[4],
      // a
      16
    ) >>> 0;
  }
  if (match = hsl.exec(color)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | 255) >>> // a
    0;
  }
  if (match = hsla.exec(color)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | parse1(match[4])) >>> // a
    0;
  }
  return null;
}
function hue2rgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
function hslToRgb(h, s, l) {
  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  const p = 2 * l - q;
  const r = hue2rgb(p, q, h + 1 / 3);
  const g = hue2rgb(p, q, h);
  const b = hue2rgb(p, q, h - 1 / 3);
  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
}
function parse255(str) {
  const int = parseInt(str, 10);
  if (int < 0)
    return 0;
  if (int > 255)
    return 255;
  return int;
}
function parse360(str) {
  const int = parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
  const num = parseFloat(str);
  if (num < 0)
    return 0;
  if (num > 1)
    return 255;
  return Math.round(num * 255);
}
function parsePercentage(str) {
  const int = parseFloat(str);
  if (int < 0)
    return 0;
  if (int > 100)
    return 1;
  return int / 100;
}

// src/colorToRgba.ts
function colorToRgba(input) {
  let int32Color = normalizeColor(input);
  if (int32Color === null)
    return input;
  int32Color = int32Color || 0;
  const r = (int32Color & 4278190080) >>> 24;
  const g = (int32Color & 16711680) >>> 16;
  const b = (int32Color & 65280) >>> 8;
  const a = (int32Color & 255) / 255;
  return `rgba(${r}, ${g}, ${b}, ${a})`;
}

// src/createInterpolator.ts
var createInterpolator = (range, output, extrapolate) => {
  if (is.fun(range)) {
    return range;
  }
  if (is.arr(range)) {
    return createInterpolator({
      range,
      output,
      extrapolate
    });
  }
  if (is.str(range.output[0])) {
    return createStringInterpolator(range);
  }
  const config = range;
  const outputRange = config.output;
  const inputRange = config.range || [0, 1];
  const extrapolateLeft = config.extrapolateLeft || config.extrapolate || "extend";
  const extrapolateRight = config.extrapolateRight || config.extrapolate || "extend";
  const easing = config.easing || ((t) => t);
  return (input) => {
    const range2 = findRange(input, inputRange);
    return interpolate(
      input,
      inputRange[range2],
      inputRange[range2 + 1],
      outputRange[range2],
      outputRange[range2 + 1],
      easing,
      extrapolateLeft,
      extrapolateRight,
      config.map
    );
  };
};
function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
  let result = map ? map(input) : input;
  if (result < inputMin) {
    if (extrapolateLeft === "identity")
      return result;
    else if (extrapolateLeft === "clamp")
      result = inputMin;
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity")
      return result;
    else if (extrapolateRight === "clamp")
      result = inputMax;
  }
  if (outputMin === outputMax)
    return outputMin;
  if (inputMin === inputMax)
    return input <= inputMin ? outputMin : outputMax;
  if (inputMin === -Infinity)
    result = -result;
  else if (inputMax === Infinity)
    result = result - inputMin;
  else
    result = (result - inputMin) / (inputMax - inputMin);
  result = easing(result);
  if (outputMin === -Infinity)
    result = -result;
  else if (outputMax === Infinity)
    result = result + outputMin;
  else
    result = result * (outputMax - outputMin) + outputMin;
  return result;
}
function findRange(input, inputRange) {
  for (var i = 1; i < inputRange.length - 1; ++i)
    if (inputRange[i] >= input)
      break;
  return i - 1;
}

// src/easings.ts
var steps = (steps2, direction = "end") => (progress2) => {
  progress2 = direction === "end" ? Math.min(progress2, 0.999) : Math.max(progress2, 1e-3);
  const expanded = progress2 * steps2;
  const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
  return clamp(0, 1, rounded / steps2);
};
var c1 = 1.70158;
var c2 = c1 * 1.525;
var c3 = c1 + 1;
var c4 = 2 * Math.PI / 3;
var c5 = 2 * Math.PI / 4.5;
var bounceOut = (x) => {
  const n1 = 7.5625;
  const d1 = 2.75;
  if (x < 1 / d1) {
    return n1 * x * x;
  } else if (x < 2 / d1) {
    return n1 * (x -= 1.5 / d1) * x + 0.75;
  } else if (x < 2.5 / d1) {
    return n1 * (x -= 2.25 / d1) * x + 0.9375;
  } else {
    return n1 * (x -= 2.625 / d1) * x + 0.984375;
  }
};
var easings = {
  linear: (x) => x,
  easeInQuad: (x) => x * x,
  easeOutQuad: (x) => 1 - (1 - x) * (1 - x),
  easeInOutQuad: (x) => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,
  easeInCubic: (x) => x * x * x,
  easeOutCubic: (x) => 1 - Math.pow(1 - x, 3),
  easeInOutCubic: (x) => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2,
  easeInQuart: (x) => x * x * x * x,
  easeOutQuart: (x) => 1 - Math.pow(1 - x, 4),
  easeInOutQuart: (x) => x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2,
  easeInQuint: (x) => x * x * x * x * x,
  easeOutQuint: (x) => 1 - Math.pow(1 - x, 5),
  easeInOutQuint: (x) => x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2,
  easeInSine: (x) => 1 - Math.cos(x * Math.PI / 2),
  easeOutSine: (x) => Math.sin(x * Math.PI / 2),
  easeInOutSine: (x) => -(Math.cos(Math.PI * x) - 1) / 2,
  easeInExpo: (x) => x === 0 ? 0 : Math.pow(2, 10 * x - 10),
  easeOutExpo: (x) => x === 1 ? 1 : 1 - Math.pow(2, -10 * x),
  easeInOutExpo: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2,
  easeInCirc: (x) => 1 - Math.sqrt(1 - Math.pow(x, 2)),
  easeOutCirc: (x) => Math.sqrt(1 - Math.pow(x - 1, 2)),
  easeInOutCirc: (x) => x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2,
  easeInBack: (x) => c3 * x * x * x - c1 * x * x,
  easeOutBack: (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2),
  easeInOutBack: (x) => x < 0.5 ? Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2,
  easeInElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4),
  easeOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1,
  easeInOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1,
  easeInBounce: (x) => 1 - bounceOut(1 - x),
  easeOutBounce: bounceOut,
  easeInOutBounce: (x) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2,
  steps
};

// src/fluids.ts
var $get = Symbol.for("FluidValue.get");
var $observers = Symbol.for("FluidValue.observers");
var hasFluidValue = (arg) => Boolean(arg && arg[$get]);
var getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
var getFluidObservers = (target) => target[$observers] || null;
function callFluidObserver(observer2, event) {
  if (observer2.eventObserved) {
    observer2.eventObserved(event);
  } else {
    observer2(event);
  }
}
function callFluidObservers(target, event) {
  const observers = target[$observers];
  if (observers) {
    observers.forEach((observer2) => {
      callFluidObserver(observer2, event);
    });
  }
}
var FluidValue = class {
  constructor(get) {
    if (!get && !(get = this.get)) {
      throw Error("Unknown getter");
    }
    setFluidGetter(this, get);
  }
};
$get, $observers;
var setFluidGetter = (target, get) => setHidden(target, $get, get);
function addFluidObserver(target, observer2) {
  if (target[$get]) {
    let observers = target[$observers];
    if (!observers) {
      setHidden(target, $observers, observers = /* @__PURE__ */ new Set());
    }
    if (!observers.has(observer2)) {
      observers.add(observer2);
      if (target.observerAdded) {
        target.observerAdded(observers.size, observer2);
      }
    }
  }
  return observer2;
}
function removeFluidObserver(target, observer2) {
  const observers = target[$observers];
  if (observers && observers.has(observer2)) {
    const count = observers.size - 1;
    if (count) {
      observers.delete(observer2);
    } else {
      target[$observers] = null;
    }
    if (target.observerRemoved) {
      target.observerRemoved(count, observer2);
    }
  }
}
var setHidden = (target, key, value) => Object.defineProperty(target, key, {
  value,
  writable: true,
  configurable: true
});

// src/regexs.ts
var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
var unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;

// src/variableToRgba.ts
var variableToRgba = (input) => {
  const [token, fallback] = parseCSSVariable(input);
  if (!token || isSSR()) {
    return input;
  }
  const value = window.getComputedStyle(document.documentElement).getPropertyValue(token);
  if (value) {
    return value.trim();
  } else if (fallback && fallback.startsWith("--")) {
    const value2 = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
    if (value2) {
      return value2;
    } else {
      return input;
    }
  } else if (fallback && cssVariableRegex.test(fallback)) {
    return variableToRgba(fallback);
  } else if (fallback) {
    return fallback;
  }
  return input;
};
var parseCSSVariable = (current) => {
  const match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  const [, token, fallback] = match;
  return [token, fallback];
};

// src/stringInterpolation.ts
var namedColorRegex;
var rgbaRound = (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;
var createStringInterpolator2 = (config) => {
  if (!namedColorRegex)
    namedColorRegex = colors ? (
      // match color names, ignore partial matches
      new RegExp(`(${Object.keys(colors).join("|")})(?!\\w)`, "g")
    ) : (
      // never match
      /^\b$/
    );
  const output = config.output.map((value) => {
    return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
  });
  const keyframes = output.map((value) => value.match(numberRegex).map(Number));
  const outputRanges = keyframes[0].map(
    (_, i) => keyframes.map((values) => {
      if (!(i in values)) {
        throw Error('The arity of each "output" value must be equal');
      }
      return values[i];
    })
  );
  const interpolators = outputRanges.map(
    (output2) => createInterpolator({ ...config, output: output2 })
  );
  return (input) => {
    const missingUnit = !unitRegex.test(output[0]) && output.find((value) => unitRegex.test(value))?.replace(numberRegex, "");
    let i = 0;
    return output[0].replace(
      numberRegex,
      () => `${interpolators[i++](input)}${missingUnit || ""}`
    ).replace(rgbaRegex, rgbaRound);
  };
};

// src/deprecations.ts
var react_spring_shared_modern_prefix = "react-spring: ";
var once = (fn) => {
  const func = fn;
  let called = false;
  if (typeof func != "function") {
    throw new TypeError(`${react_spring_shared_modern_prefix}once requires a function parameter`);
  }
  return (...args) => {
    if (!called) {
      func(...args);
      called = true;
    }
  };
};
var warnInterpolate = once(console.warn);
function deprecateInterpolate() {
  warnInterpolate(
    `${react_spring_shared_modern_prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`
  );
}
var warnDirectCall = once(console.warn);
function deprecateDirectCall() {
  warnDirectCall(
    `${react_spring_shared_modern_prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`
  );
}

// src/isAnimatedString.ts
function isAnimatedString(value) {
  return is.str(value) && (value[0] == "#" || /\d/.test(value) || // Do not identify a CSS variable as an AnimatedString if its SSR
  !isSSR() && cssVariableRegex.test(value) || value in (colors || {}));
}

// src/dom-events/resize/resizeElement.ts
var observer;
var resizeHandlers = /* @__PURE__ */ new WeakMap();
var handleObservation = (entries) => entries.forEach(({ target, contentRect }) => {
  return resizeHandlers.get(target)?.forEach((handler) => handler(contentRect));
});
function resizeElement(handler, target) {
  if (!observer) {
    if (typeof ResizeObserver !== "undefined") {
      observer = new ResizeObserver(handleObservation);
    }
  }
  let elementHandlers = resizeHandlers.get(target);
  if (!elementHandlers) {
    elementHandlers = /* @__PURE__ */ new Set();
    resizeHandlers.set(target, elementHandlers);
  }
  elementHandlers.add(handler);
  if (observer) {
    observer.observe(target);
  }
  return () => {
    const elementHandlers2 = resizeHandlers.get(target);
    if (!elementHandlers2)
      return;
    elementHandlers2.delete(handler);
    if (!elementHandlers2.size && observer) {
      observer.unobserve(target);
    }
  };
}

// src/dom-events/resize/resizeWindow.ts
var listeners = /* @__PURE__ */ new Set();
var cleanupWindowResizeHandler;
var createResizeHandler = () => {
  const handleResize = () => {
    listeners.forEach(
      (callback) => callback({
        width: window.innerWidth,
        height: window.innerHeight
      })
    );
  };
  window.addEventListener("resize", handleResize);
  return () => {
    window.removeEventListener("resize", handleResize);
  };
};
var resizeWindow = (callback) => {
  listeners.add(callback);
  if (!cleanupWindowResizeHandler) {
    cleanupWindowResizeHandler = createResizeHandler();
  }
  return () => {
    listeners.delete(callback);
    if (!listeners.size && cleanupWindowResizeHandler) {
      cleanupWindowResizeHandler();
      cleanupWindowResizeHandler = void 0;
    }
  };
};

// src/dom-events/resize/index.ts
var react_spring_shared_modern_onResize = (callback, { container = document.documentElement } = {}) => {
  if (container === document.documentElement) {
    return resizeWindow(callback);
  } else {
    return resizeElement(callback, container);
  }
};

// src/progress.ts
var progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);

// src/dom-events/scroll/ScrollHandler.ts
var SCROLL_KEYS = {
  x: {
    length: "Width",
    position: "Left"
  },
  y: {
    length: "Height",
    position: "Top"
  }
};
var ScrollHandler = class {
  constructor(callback, container) {
    this.createAxis = () => ({
      current: 0,
      progress: 0,
      scrollLength: 0
    });
    this.updateAxis = (axisName) => {
      const axis = this.info[axisName];
      const { length, position } = SCROLL_KEYS[axisName];
      axis.current = this.container[`scroll${position}`];
      axis.scrollLength = this.container["scroll" + length] - this.container["client" + length];
      axis.progress = progress(0, axis.scrollLength, axis.current);
    };
    this.update = () => {
      this.updateAxis("x");
      this.updateAxis("y");
    };
    this.sendEvent = () => {
      this.callback(this.info);
    };
    this.advance = () => {
      this.update();
      this.sendEvent();
    };
    this.callback = callback;
    this.container = container;
    this.info = {
      time: 0,
      x: this.createAxis(),
      y: this.createAxis()
    };
  }
};

// src/dom-events/scroll/index.ts
var scrollListeners = /* @__PURE__ */ new WeakMap();
var resizeListeners = /* @__PURE__ */ new WeakMap();
var onScrollHandlers = /* @__PURE__ */ new WeakMap();
var getTarget = (container) => container === document.documentElement ? window : container;
var react_spring_shared_modern_onScroll = (callback, { container = document.documentElement } = {}) => {
  let containerHandlers = onScrollHandlers.get(container);
  if (!containerHandlers) {
    containerHandlers = /* @__PURE__ */ new Set();
    onScrollHandlers.set(container, containerHandlers);
  }
  const containerHandler = new ScrollHandler(callback, container);
  containerHandlers.add(containerHandler);
  if (!scrollListeners.has(container)) {
    const listener = () => {
      containerHandlers?.forEach((handler) => handler.advance());
      return true;
    };
    scrollListeners.set(container, listener);
    const target = getTarget(container);
    window.addEventListener("resize", listener, { passive: true });
    if (container !== document.documentElement) {
      resizeListeners.set(container, react_spring_shared_modern_onResize(listener, { container }));
    }
    target.addEventListener("scroll", listener, { passive: true });
  }
  const animateScroll = scrollListeners.get(container);
  raf(animateScroll);
  return () => {
    raf.cancel(animateScroll);
    const containerHandlers2 = onScrollHandlers.get(container);
    if (!containerHandlers2)
      return;
    containerHandlers2.delete(containerHandler);
    if (containerHandlers2.size)
      return;
    const listener = scrollListeners.get(container);
    scrollListeners.delete(container);
    if (listener) {
      getTarget(container).removeEventListener("scroll", listener);
      window.removeEventListener("resize", listener);
      resizeListeners.get(container)?.();
    }
  };
};

// src/hooks/useConstant.ts

function react_spring_shared_modern_useConstant(init) {
  const ref = useRef(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}

// src/hooks/useForceUpdate.ts


// src/hooks/useIsMounted.ts


// src/hooks/useIsomorphicLayoutEffect.ts

var react_spring_shared_modern_useIsomorphicLayoutEffect = isSSR() ? external_React_.useEffect : external_React_.useLayoutEffect;

// src/hooks/useIsMounted.ts
var useIsMounted = () => {
  const isMounted = (0,external_React_.useRef)(false);
  react_spring_shared_modern_useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
};

// src/hooks/useForceUpdate.ts
function useForceUpdate() {
  const update2 = (0,external_React_.useState)()[1];
  const isMounted = useIsMounted();
  return () => {
    if (isMounted.current) {
      update2(Math.random());
    }
  };
}

// src/hooks/useMemoOne.ts

function useMemoOne(getResult, inputs) {
  const [initial] = (0,external_React_.useState)(
    () => ({
      inputs,
      result: getResult()
    })
  );
  const committed = (0,external_React_.useRef)();
  const prevCache = committed.current;
  let cache = prevCache;
  if (cache) {
    const useCache = Boolean(
      inputs && cache.inputs && areInputsEqual(inputs, cache.inputs)
    );
    if (!useCache) {
      cache = {
        inputs,
        result: getResult()
      };
    }
  } else {
    cache = initial;
  }
  (0,external_React_.useEffect)(() => {
    committed.current = cache;
    if (prevCache == initial) {
      initial.inputs = initial.result = void 0;
    }
  }, [cache]);
  return cache.result;
}
function areInputsEqual(next, prev) {
  if (next.length !== prev.length) {
    return false;
  }
  for (let i = 0; i < next.length; i++) {
    if (next[i] !== prev[i]) {
      return false;
    }
  }
  return true;
}

// src/hooks/useOnce.ts

var useOnce = (effect) => (0,external_React_.useEffect)(effect, emptyDeps);
var emptyDeps = [];

// src/hooks/usePrev.ts

function usePrev(value) {
  const prevRef = (0,external_React_.useRef)();
  (0,external_React_.useEffect)(() => {
    prevRef.current = value;
  });
  return prevRef.current;
}

// src/hooks/useReducedMotion.ts

var useReducedMotion = () => {
  const [reducedMotion, setReducedMotion] = useState3(null);
  react_spring_shared_modern_useIsomorphicLayoutEffect(() => {
    const mql = window.matchMedia("(prefers-reduced-motion)");
    const handleMediaChange = (e) => {
      setReducedMotion(e.matches);
      react_spring_shared_modern_assign({
        skipAnimation: e.matches
      });
    };
    handleMediaChange(mql);
    mql.addEventListener("change", handleMediaChange);
    return () => {
      mql.removeEventListener("change", handleMediaChange);
    };
  }, []);
  return reducedMotion;
};

;// CONCATENATED MODULE: ./node_modules/@react-spring/animated/dist/react-spring_animated.modern.mjs
// src/Animated.ts

var $node = Symbol.for("Animated:node");
var isAnimated = (value) => !!value && value[$node] === value;
var getAnimated = (owner) => owner && owner[$node];
var setAnimated = (owner, node) => defineHidden(owner, $node, node);
var getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
var Animated = class {
  constructor() {
    setAnimated(this, this);
  }
  /** Get every `AnimatedValue` used by this node. */
  getPayload() {
    return this.payload || [];
  }
};

// src/AnimatedValue.ts

var AnimatedValue = class extends Animated {
  constructor(_value) {
    super();
    this._value = _value;
    this.done = true;
    this.durationProgress = 0;
    if (is.num(this._value)) {
      this.lastPosition = this._value;
    }
  }
  /** @internal */
  static create(value) {
    return new AnimatedValue(value);
  }
  getPayload() {
    return [this];
  }
  getValue() {
    return this._value;
  }
  setValue(value, step) {
    if (is.num(value)) {
      this.lastPosition = value;
      if (step) {
        value = Math.round(value / step) * step;
        if (this.done) {
          this.lastPosition = value;
        }
      }
    }
    if (this._value === value) {
      return false;
    }
    this._value = value;
    return true;
  }
  reset() {
    const { done } = this;
    this.done = false;
    if (is.num(this._value)) {
      this.elapsedTime = 0;
      this.durationProgress = 0;
      this.lastPosition = this._value;
      if (done)
        this.lastVelocity = null;
      this.v0 = null;
    }
  }
};

// src/AnimatedString.ts

var AnimatedString = class extends AnimatedValue {
  constructor(value) {
    super(0);
    this._string = null;
    this._toString = createInterpolator({
      output: [value, value]
    });
  }
  /** @internal */
  static create(value) {
    return new AnimatedString(value);
  }
  getValue() {
    const value = this._string;
    return value == null ? this._string = this._toString(this._value) : value;
  }
  setValue(value) {
    if (is.str(value)) {
      if (value == this._string) {
        return false;
      }
      this._string = value;
      this._value = 1;
    } else if (super.setValue(value)) {
      this._string = null;
    } else {
      return false;
    }
    return true;
  }
  reset(goal) {
    if (goal) {
      this._toString = createInterpolator({
        output: [this.getValue(), goal]
      });
    }
    this._value = 0;
    super.reset();
  }
};

// src/AnimatedArray.ts


// src/AnimatedObject.ts


// src/context.ts
var TreeContext = { dependencies: null };

// src/AnimatedObject.ts
var AnimatedObject = class extends Animated {
  constructor(source) {
    super();
    this.source = source;
    this.setValue(source);
  }
  getValue(animated) {
    const values = {};
    eachProp(this.source, (source, key) => {
      if (isAnimated(source)) {
        values[key] = source.getValue(animated);
      } else if (hasFluidValue(source)) {
        values[key] = getFluidValue(source);
      } else if (!animated) {
        values[key] = source;
      }
    });
    return values;
  }
  /** Replace the raw object data */
  setValue(source) {
    this.source = source;
    this.payload = this._makePayload(source);
  }
  reset() {
    if (this.payload) {
      react_spring_shared_modern_each(this.payload, (node) => node.reset());
    }
  }
  /** Create a payload set. */
  _makePayload(source) {
    if (source) {
      const payload = /* @__PURE__ */ new Set();
      eachProp(source, this._addToPayload, payload);
      return Array.from(payload);
    }
  }
  /** Add to a payload set. */
  _addToPayload(source) {
    if (TreeContext.dependencies && hasFluidValue(source)) {
      TreeContext.dependencies.add(source);
    }
    const payload = getPayload(source);
    if (payload) {
      react_spring_shared_modern_each(payload, (node) => this.add(node));
    }
  }
};

// src/AnimatedArray.ts
var AnimatedArray = class extends AnimatedObject {
  constructor(source) {
    super(source);
  }
  /** @internal */
  static create(source) {
    return new AnimatedArray(source);
  }
  getValue() {
    return this.source.map((node) => node.getValue());
  }
  setValue(source) {
    const payload = this.getPayload();
    if (source.length == payload.length) {
      return payload.map((node, i) => node.setValue(source[i])).some(Boolean);
    }
    super.setValue(source.map(makeAnimated));
    return true;
  }
};
function makeAnimated(value) {
  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
  return nodeType.create(value);
}

// src/getAnimatedType.ts

function getAnimatedType(value) {
  const parentNode = getAnimated(value);
  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
}

// src/createHost.ts


// src/withAnimated.tsx



var withAnimated = (Component, host) => {
  const hasInstance = (
    // Function components must use "forwardRef" to avoid being
    // re-rendered on every animation frame.
    !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent
  );
  return (0,external_React_.forwardRef)((givenProps, givenRef) => {
    const instanceRef = (0,external_React_.useRef)(null);
    const ref = hasInstance && // eslint-disable-next-line react-hooks/rules-of-hooks
    (0,external_React_.useCallback)(
      (value) => {
        instanceRef.current = updateRef(givenRef, value);
      },
      [givenRef]
    );
    const [props, deps] = getAnimatedState(givenProps, host);
    const forceUpdate = useForceUpdate();
    const callback = () => {
      const instance = instanceRef.current;
      if (hasInstance && !instance) {
        return;
      }
      const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;
      if (didUpdate === false) {
        forceUpdate();
      }
    };
    const observer = new PropsObserver(callback, deps);
    const observerRef = (0,external_React_.useRef)();
    react_spring_shared_modern_useIsomorphicLayoutEffect(() => {
      observerRef.current = observer;
      react_spring_shared_modern_each(deps, (dep) => addFluidObserver(dep, observer));
      return () => {
        if (observerRef.current) {
          react_spring_shared_modern_each(
            observerRef.current.deps,
            (dep) => removeFluidObserver(dep, observerRef.current)
          );
          raf.cancel(observerRef.current.update);
        }
      };
    });
    (0,external_React_.useEffect)(callback, []);
    useOnce(() => () => {
      const observer2 = observerRef.current;
      react_spring_shared_modern_each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
    });
    const usedProps = host.getComponentProps(props.getValue());
    return /* @__PURE__ */ external_React_.createElement(Component, { ...usedProps, ref });
  });
};
var PropsObserver = class {
  constructor(update, deps) {
    this.update = update;
    this.deps = deps;
  }
  eventObserved(event) {
    if (event.type == "change") {
      raf.write(this.update);
    }
  }
};
function getAnimatedState(props, host) {
  const dependencies = /* @__PURE__ */ new Set();
  TreeContext.dependencies = dependencies;
  if (props.style)
    props = {
      ...props,
      style: host.createAnimatedStyle(props.style)
    };
  props = new AnimatedObject(props);
  TreeContext.dependencies = null;
  return [props, dependencies];
}
function updateRef(ref, value) {
  if (ref) {
    if (is.fun(ref))
      ref(value);
    else
      ref.current = value;
  }
  return value;
}

// src/createHost.ts
var cacheKey = Symbol.for("AnimatedComponent");
var createHost = (components, {
  applyAnimatedValues = () => false,
  createAnimatedStyle = (style) => new AnimatedObject(style),
  getComponentProps = (props) => props
} = {}) => {
  const hostConfig = {
    applyAnimatedValues,
    createAnimatedStyle,
    getComponentProps
  };
  const animated = (Component) => {
    const displayName = getDisplayName(Component) || "Anonymous";
    if (is.str(Component)) {
      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));
    } else {
      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
    }
    Component.displayName = `Animated(${displayName})`;
    return Component;
  };
  eachProp(components, (Component, key) => {
    if (is.arr(components)) {
      key = getDisplayName(Component);
    }
    animated[key] = animated(Component);
  });
  return {
    animated
  };
};
var getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;

;// CONCATENATED MODULE: ./node_modules/@react-spring/core/dist/react-spring_core.modern.mjs
// src/hooks/useChain.ts


// src/helpers.ts

function callProp(value, ...args) {
  return is.fun(value) ? value(...args) : value;
}
var matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));
var resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;
var getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
var noopTransform = (value) => value;
var getDefaultProps = (props, transform = noopTransform) => {
  let keys = DEFAULT_PROPS;
  if (props.default && props.default !== true) {
    props = props.default;
    keys = Object.keys(props);
  }
  const defaults2 = {};
  for (const key of keys) {
    const value = transform(props[key], key);
    if (!is.und(value)) {
      defaults2[key] = value;
    }
  }
  return defaults2;
};
var DEFAULT_PROPS = [
  "config",
  "onProps",
  "onStart",
  "onChange",
  "onPause",
  "onResume",
  "onRest"
];
var RESERVED_PROPS = {
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  loop: 1,
  reset: 1,
  pause: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  onProps: 1,
  onStart: 1,
  onChange: 1,
  onPause: 1,
  onResume: 1,
  onRest: 1,
  onResolve: 1,
  // Transition props
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  update: 1,
  leave: 1,
  children: 1,
  onDestroyed: 1,
  // Internal props
  keys: 1,
  callId: 1,
  parentId: 1
};
function getForwardProps(props) {
  const forward = {};
  let count = 0;
  eachProp(props, (value, prop) => {
    if (!RESERVED_PROPS[prop]) {
      forward[prop] = value;
      count++;
    }
  });
  if (count) {
    return forward;
  }
}
function inferTo(props) {
  const to2 = getForwardProps(props);
  if (to2) {
    const out = { to: to2 };
    eachProp(props, (val, key) => key in to2 || (out[key] = val));
    return out;
  }
  return { ...props };
}
function computeGoal(value) {
  value = getFluidValue(value);
  return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? globals_exports.createStringInterpolator({
    range: [0, 1],
    output: [value, value]
  })(1) : value;
}
function hasProps(props) {
  for (const _ in props)
    return true;
  return false;
}
function isAsyncTo(to2) {
  return is.fun(to2) || is.arr(to2) && is.obj(to2[0]);
}
function detachRefs(ctrl, ref) {
  ctrl.ref?.delete(ctrl);
  ref?.delete(ctrl);
}
function replaceRef(ctrl, ref) {
  if (ref && ctrl.ref !== ref) {
    ctrl.ref?.delete(ctrl);
    ref.add(ctrl);
    ctrl.ref = ref;
  }
}

// src/hooks/useChain.ts
function useChain(refs, timeSteps, timeFrame = 1e3) {
  useIsomorphicLayoutEffect(() => {
    if (timeSteps) {
      let prevDelay = 0;
      each(refs, (ref, i) => {
        const controllers = ref.current;
        if (controllers.length) {
          let delay = timeFrame * timeSteps[i];
          if (isNaN(delay))
            delay = prevDelay;
          else
            prevDelay = delay;
          each(controllers, (ctrl) => {
            each(ctrl.queue, (props) => {
              const memoizedDelayProp = props.delay;
              props.delay = (key) => delay + callProp(memoizedDelayProp || 0, key);
            });
          });
          ref.start();
        }
      });
    } else {
      let p = Promise.resolve();
      each(refs, (ref) => {
        const controllers = ref.current;
        if (controllers.length) {
          const queues = controllers.map((ctrl) => {
            const q = ctrl.queue;
            ctrl.queue = [];
            return q;
          });
          p = p.then(() => {
            each(
              controllers,
              (ctrl, i) => each(queues[i] || [], (update2) => ctrl.queue.push(update2))
            );
            return Promise.all(ref.start());
          });
        }
      });
    }
  });
}

// src/hooks/useSpring.ts


// src/hooks/useSprings.ts



// src/SpringValue.ts



// src/AnimationConfig.ts


// src/constants.ts
var config = {
  default: { tension: 170, friction: 26 },
  gentle: { tension: 120, friction: 14 },
  wobbly: { tension: 180, friction: 12 },
  stiff: { tension: 210, friction: 20 },
  slow: { tension: 280, friction: 60 },
  molasses: { tension: 280, friction: 120 }
};

// src/AnimationConfig.ts
var defaults = {
  ...config.default,
  mass: 1,
  damping: 1,
  easing: easings.linear,
  clamp: false
};
var AnimationConfig = class {
  constructor() {
    /**
     * The initial velocity of one or more values.
     *
     * @default 0
     */
    this.velocity = 0;
    Object.assign(this, defaults);
  }
};
function mergeConfig(config2, newConfig, defaultConfig) {
  if (defaultConfig) {
    defaultConfig = { ...defaultConfig };
    sanitizeConfig(defaultConfig, newConfig);
    newConfig = { ...defaultConfig, ...newConfig };
  }
  sanitizeConfig(config2, newConfig);
  Object.assign(config2, newConfig);
  for (const key in defaults) {
    if (config2[key] == null) {
      config2[key] = defaults[key];
    }
  }
  let { frequency, damping } = config2;
  const { mass } = config2;
  if (!is.und(frequency)) {
    if (frequency < 0.01)
      frequency = 0.01;
    if (damping < 0)
      damping = 0;
    config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
    config2.friction = 4 * Math.PI * damping * mass / frequency;
  }
  return config2;
}
function sanitizeConfig(config2, props) {
  if (!is.und(props.decay)) {
    config2.duration = void 0;
  } else {
    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
      config2.duration = void 0;
      config2.decay = void 0;
    }
    if (isTensionConfig) {
      config2.frequency = void 0;
    }
  }
}

// src/Animation.ts
var emptyArray = [];
var Animation = class {
  constructor() {
    this.changed = false;
    this.values = emptyArray;
    this.toValues = null;
    this.fromValues = emptyArray;
    this.config = new AnimationConfig();
    this.immediate = false;
  }
};

// src/scheduleProps.ts

function scheduleProps(callId, { key, props, defaultProps, state, actions }) {
  return new Promise((resolve, reject) => {
    let delay;
    let timeout;
    let cancel = matchProp(props.cancel ?? defaultProps?.cancel, key);
    if (cancel) {
      onStart();
    } else {
      if (!is.und(props.pause)) {
        state.paused = matchProp(props.pause, key);
      }
      let pause = defaultProps?.pause;
      if (pause !== true) {
        pause = state.paused || matchProp(pause, key);
      }
      delay = callProp(props.delay || 0, key);
      if (pause) {
        state.resumeQueue.add(onResume);
        actions.pause();
      } else {
        actions.resume();
        onResume();
      }
    }
    function onPause() {
      state.resumeQueue.add(onResume);
      state.timeouts.delete(timeout);
      timeout.cancel();
      delay = timeout.time - raf.now();
    }
    function onResume() {
      if (delay > 0 && !globals_exports.skipAnimation) {
        state.delayed = true;
        timeout = raf.setTimeout(onStart, delay);
        state.pauseQueue.add(onPause);
        state.timeouts.add(timeout);
      } else {
        onStart();
      }
    }
    function onStart() {
      if (state.delayed) {
        state.delayed = false;
      }
      state.pauseQueue.delete(onPause);
      state.timeouts.delete(timeout);
      if (callId <= (state.cancelId || 0)) {
        cancel = true;
      }
      try {
        actions.start({ ...props, callId, cancel }, resolve);
      } catch (err) {
        reject(err);
      }
    }
  });
}

// src/runAsync.ts


// src/AnimationResult.ts
var getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(
  target.get(),
  results.every((result) => result.finished)
);
var getNoopResult = (value) => ({
  value,
  noop: true,
  finished: true,
  cancelled: false
});
var getFinishedResult = (value, finished, cancelled = false) => ({
  value,
  finished,
  cancelled
});
var getCancelledResult = (value) => ({
  value,
  cancelled: true,
  finished: false
});

// src/runAsync.ts
function runAsync(to2, props, state, target) {
  const { callId, parentId, onRest } = props;
  const { asyncTo: prevTo, promise: prevPromise } = state;
  if (!parentId && to2 === prevTo && !props.reset) {
    return prevPromise;
  }
  return state.promise = (async () => {
    state.asyncId = callId;
    state.asyncTo = to2;
    const defaultProps = getDefaultProps(
      props,
      (value, key) => (
        // The `onRest` prop is only called when the `runAsync` promise is resolved.
        key === "onRest" ? void 0 : value
      )
    );
    let preventBail;
    let bail;
    const bailPromise = new Promise(
      (resolve, reject) => (preventBail = resolve, bail = reject)
    );
    const bailIfEnded = (bailSignal) => {
      const bailResult = (
        // The `cancel` prop or `stop` method was used.
        callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.
        callId !== state.asyncId && getFinishedResult(target, false)
      );
      if (bailResult) {
        bailSignal.result = bailResult;
        bail(bailSignal);
        throw bailSignal;
      }
    };
    const animate = (arg1, arg2) => {
      const bailSignal = new BailSignal();
      const skipAnimationSignal = new SkipAnimationSignal();
      return (async () => {
        if (globals_exports.skipAnimation) {
          stopAsync(state);
          skipAnimationSignal.result = getFinishedResult(target, false);
          bail(skipAnimationSignal);
          throw skipAnimationSignal;
        }
        bailIfEnded(bailSignal);
        const props2 = is.obj(arg1) ? { ...arg1 } : { ...arg2, to: arg1 };
        props2.parentId = callId;
        eachProp(defaultProps, (value, key) => {
          if (is.und(props2[key])) {
            props2[key] = value;
          }
        });
        const result2 = await target.start(props2);
        bailIfEnded(bailSignal);
        if (state.paused) {
          await new Promise((resume) => {
            state.resumeQueue.add(resume);
          });
        }
        return result2;
      })();
    };
    let result;
    if (globals_exports.skipAnimation) {
      stopAsync(state);
      return getFinishedResult(target, false);
    }
    try {
      let animating;
      if (is.arr(to2)) {
        animating = (async (queue) => {
          for (const props2 of queue) {
            await animate(props2);
          }
        })(to2);
      } else {
        animating = Promise.resolve(to2(animate, target.stop.bind(target)));
      }
      await Promise.all([animating.then(preventBail), bailPromise]);
      result = getFinishedResult(target.get(), true, false);
    } catch (err) {
      if (err instanceof BailSignal) {
        result = err.result;
      } else if (err instanceof SkipAnimationSignal) {
        result = err.result;
      } else {
        throw err;
      }
    } finally {
      if (callId == state.asyncId) {
        state.asyncId = parentId;
        state.asyncTo = parentId ? prevTo : void 0;
        state.promise = parentId ? prevPromise : void 0;
      }
    }
    if (is.fun(onRest)) {
      raf.batchedUpdates(() => {
        onRest(result, target, target.item);
      });
    }
    return result;
  })();
}
function stopAsync(state, cancelId) {
  flush(state.timeouts, (t) => t.cancel());
  state.pauseQueue.clear();
  state.resumeQueue.clear();
  state.asyncId = state.asyncTo = state.promise = void 0;
  if (cancelId)
    state.cancelId = cancelId;
}
var BailSignal = class extends Error {
  constructor() {
    super(
      "An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."
    );
  }
};
var SkipAnimationSignal = class extends Error {
  constructor() {
    super("SkipAnimationSignal");
  }
};

// src/FrameValue.ts


var isFrameValue = (value) => value instanceof FrameValue;
var nextId = 1;
var FrameValue = class extends FluidValue {
  constructor() {
    super(...arguments);
    this.id = nextId++;
    this._priority = 0;
  }
  get priority() {
    return this._priority;
  }
  set priority(priority) {
    if (this._priority != priority) {
      this._priority = priority;
      this._onPriorityChange(priority);
    }
  }
  /** Get the current value */
  get() {
    const node = getAnimated(this);
    return node && node.getValue();
  }
  /** Create a spring that maps our value to another value */
  to(...args) {
    return globals_exports.to(this, args);
  }
  /** @deprecated Use the `to` method instead. */
  interpolate(...args) {
    deprecateInterpolate();
    return globals_exports.to(this, args);
  }
  toJSON() {
    return this.get();
  }
  observerAdded(count) {
    if (count == 1)
      this._attach();
  }
  observerRemoved(count) {
    if (count == 0)
      this._detach();
  }
  /** Called when the first child is added. */
  _attach() {
  }
  /** Called when the last child is removed. */
  _detach() {
  }
  /** Tell our children about our new value */
  _onChange(value, idle = false) {
    callFluidObservers(this, {
      type: "change",
      parent: this,
      value,
      idle
    });
  }
  /** Tell our children about our new priority */
  _onPriorityChange(priority) {
    if (!this.idle) {
      frameLoop.sort(this);
    }
    callFluidObservers(this, {
      type: "priority",
      parent: this,
      priority
    });
  }
};

// src/SpringPhase.ts
var $P = Symbol.for("SpringPhase");
var HAS_ANIMATED = 1;
var IS_ANIMATING = 2;
var IS_PAUSED = 4;
var hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
var isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
var isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
var setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
var setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;

// src/SpringValue.ts
var SpringValue = class extends FrameValue {
  constructor(arg1, arg2) {
    super();
    /** The animation state */
    this.animation = new Animation();
    /** Some props have customizable default values */
    this.defaultProps = {};
    /** The state for `runAsync` calls */
    this._state = {
      paused: false,
      delayed: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    /** The promise resolvers of pending `start` calls */
    this._pendingCalls = /* @__PURE__ */ new Set();
    /** The counter for tracking `scheduleProps` calls */
    this._lastCallId = 0;
    /** The last `scheduleProps` call that changed the `to` prop */
    this._lastToId = 0;
    this._memoizedDuration = 0;
    if (!is.und(arg1) || !is.und(arg2)) {
      const props = is.obj(arg1) ? { ...arg1 } : { ...arg2, from: arg1 };
      if (is.und(props.default)) {
        props.default = true;
      }
      this.start(props);
    }
  }
  /** Equals true when not advancing on each frame. */
  get idle() {
    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
  }
  get goal() {
    return getFluidValue(this.animation.to);
  }
  get velocity() {
    const node = getAnimated(this);
    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);
  }
  /**
   * When true, this value has been animated at least once.
   */
  get hasAnimated() {
    return hasAnimated(this);
  }
  /**
   * When true, this value has an unfinished animation,
   * which is either active or paused.
   */
  get isAnimating() {
    return isAnimating(this);
  }
  /**
   * When true, all current and future animations are paused.
   */
  get isPaused() {
    return isPaused(this);
  }
  /**
   *
   *
   */
  get isDelayed() {
    return this._state.delayed;
  }
  /** Advance the current animation by a number of milliseconds */
  advance(dt) {
    let idle = true;
    let changed = false;
    const anim = this.animation;
    let { toValues } = anim;
    const { config: config2 } = anim;
    const payload = getPayload(anim.to);
    if (!payload && hasFluidValue(anim.to)) {
      toValues = toArray(getFluidValue(anim.to));
    }
    anim.values.forEach((node2, i) => {
      if (node2.done)
        return;
      const to2 = (
        // Animated strings always go from 0 to 1.
        node2.constructor == AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i]
      );
      let finished = anim.immediate;
      let position = to2;
      if (!finished) {
        position = node2.lastPosition;
        if (config2.tension <= 0) {
          node2.done = true;
          return;
        }
        let elapsed = node2.elapsedTime += dt;
        const from = anim.fromValues[i];
        const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config2.velocity) ? config2.velocity[i] : config2.velocity;
        let velocity;
        const precision = config2.precision || (from == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from) * 1e-3));
        if (!is.und(config2.duration)) {
          let p = 1;
          if (config2.duration > 0) {
            if (this._memoizedDuration !== config2.duration) {
              this._memoizedDuration = config2.duration;
              if (node2.durationProgress > 0) {
                node2.elapsedTime = config2.duration * node2.durationProgress;
                elapsed = node2.elapsedTime += dt;
              }
            }
            p = (config2.progress || 0) + elapsed / this._memoizedDuration;
            p = p > 1 ? 1 : p < 0 ? 0 : p;
            node2.durationProgress = p;
          }
          position = from + config2.easing(p) * (to2 - from);
          velocity = (position - node2.lastPosition) / dt;
          finished = p == 1;
        } else if (config2.decay) {
          const decay = config2.decay === true ? 0.998 : config2.decay;
          const e = Math.exp(-(1 - decay) * elapsed);
          position = from + v0 / (1 - decay) * (1 - e);
          finished = Math.abs(node2.lastPosition - position) <= precision;
          velocity = v0 * e;
        } else {
          velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;
          const restVelocity = config2.restVelocity || precision / 10;
          const bounceFactor = config2.clamp ? 0 : config2.bounce;
          const canBounce = !is.und(bounceFactor);
          const isGrowing = from == to2 ? node2.v0 > 0 : from < to2;
          let isMoving;
          let isBouncing = false;
          const step = 1;
          const numSteps = Math.ceil(dt / step);
          for (let n = 0; n < numSteps; ++n) {
            isMoving = Math.abs(velocity) > restVelocity;
            if (!isMoving) {
              finished = Math.abs(to2 - position) <= precision;
              if (finished) {
                break;
              }
            }
            if (canBounce) {
              isBouncing = position == to2 || position > to2 == isGrowing;
              if (isBouncing) {
                velocity = -velocity * bounceFactor;
                position = to2;
              }
            }
            const springForce = -config2.tension * 1e-6 * (position - to2);
            const dampingForce = -config2.friction * 1e-3 * velocity;
            const acceleration = (springForce + dampingForce) / config2.mass;
            velocity = velocity + acceleration * step;
            position = position + velocity * step;
          }
        }
        node2.lastVelocity = velocity;
        if (Number.isNaN(position)) {
          console.warn(`Got NaN while animating:`, this);
          finished = true;
        }
      }
      if (payload && !payload[i].done) {
        finished = false;
      }
      if (finished) {
        node2.done = true;
      } else {
        idle = false;
      }
      if (node2.setValue(position, config2.round)) {
        changed = true;
      }
    });
    const node = getAnimated(this);
    const currVal = node.getValue();
    if (idle) {
      const finalVal = getFluidValue(anim.to);
      if ((currVal !== finalVal || changed) && !config2.decay) {
        node.setValue(finalVal);
        this._onChange(finalVal);
      } else if (changed && config2.decay) {
        this._onChange(currVal);
      }
      this._stop();
    } else if (changed) {
      this._onChange(currVal);
    }
  }
  /** Set the current value, while stopping the current animation */
  set(value) {
    raf.batchedUpdates(() => {
      this._stop();
      this._focus(value);
      this._set(value);
    });
    return this;
  }
  /**
   * Freeze the active animation in time, as well as any updates merged
   * before `resume` is called.
   */
  pause() {
    this._update({ pause: true });
  }
  /** Resume the animation if paused. */
  resume() {
    this._update({ pause: false });
  }
  /** Skip to the end of the current animation. */
  finish() {
    if (isAnimating(this)) {
      const { to: to2, config: config2 } = this.animation;
      raf.batchedUpdates(() => {
        this._onStart();
        if (!config2.decay) {
          this._set(to2, false);
        }
        this._stop();
      });
    }
    return this;
  }
  /** Push props into the pending queue. */
  update(props) {
    const queue = this.queue || (this.queue = []);
    queue.push(props);
    return this;
  }
  start(to2, arg2) {
    let queue;
    if (!is.und(to2)) {
      queue = [is.obj(to2) ? to2 : { ...arg2, to: to2 }];
    } else {
      queue = this.queue || [];
      this.queue = [];
    }
    return Promise.all(
      queue.map((props) => {
        const up = this._update(props);
        return up;
      })
    ).then((results) => getCombinedResult(this, results));
  }
  /**
   * Stop the current animation, and cancel any delayed updates.
   *
   * Pass `true` to call `onRest` with `cancelled: true`.
   */
  stop(cancel) {
    const { to: to2 } = this.animation;
    this._focus(this.get());
    stopAsync(this._state, cancel && this._lastCallId);
    raf.batchedUpdates(() => this._stop(to2, cancel));
    return this;
  }
  /** Restart the animation. */
  reset() {
    this._update({ reset: true });
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      this._start();
    } else if (event.type == "priority") {
      this.priority = event.priority + 1;
    }
  }
  /**
   * Parse the `to` and `from` range from the given `props` object.
   *
   * This also ensures the initial value is available to animated components
   * during the render phase.
   */
  _prepareNode(props) {
    const key = this.key || "";
    let { to: to2, from } = props;
    to2 = is.obj(to2) ? to2[key] : to2;
    if (to2 == null || isAsyncTo(to2)) {
      to2 = void 0;
    }
    from = is.obj(from) ? from[key] : from;
    if (from == null) {
      from = void 0;
    }
    const range = { to: to2, from };
    if (!hasAnimated(this)) {
      if (props.reverse)
        [to2, from] = [from, to2];
      from = getFluidValue(from);
      if (!is.und(from)) {
        this._set(from);
      } else if (!getAnimated(this)) {
        this._set(to2);
      }
    }
    return range;
  }
  /** Every update is processed by this method before merging. */
  _update({ ...props }, isLoop) {
    const { key, defaultProps } = this;
    if (props.default)
      Object.assign(
        defaultProps,
        getDefaultProps(
          props,
          (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value
        )
      );
    mergeActiveFn(this, props, "onProps");
    sendEvent(this, "onProps", props, this);
    const range = this._prepareNode(props);
    if (Object.isFrozen(this)) {
      throw Error(
        "Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?"
      );
    }
    const state = this._state;
    return scheduleProps(++this._lastCallId, {
      key,
      props,
      defaultProps,
      state,
      actions: {
        pause: () => {
          if (!isPaused(this)) {
            setPausedBit(this, true);
            flushCalls(state.pauseQueue);
            sendEvent(
              this,
              "onPause",
              getFinishedResult(this, checkFinished(this, this.animation.to)),
              this
            );
          }
        },
        resume: () => {
          if (isPaused(this)) {
            setPausedBit(this, false);
            if (isAnimating(this)) {
              this._resume();
            }
            flushCalls(state.resumeQueue);
            sendEvent(
              this,
              "onResume",
              getFinishedResult(this, checkFinished(this, this.animation.to)),
              this
            );
          }
        },
        start: this._merge.bind(this, range)
      }
    }).then((result) => {
      if (props.loop && result.finished && !(isLoop && result.noop)) {
        const nextProps = createLoopUpdate(props);
        if (nextProps) {
          return this._update(nextProps, true);
        }
      }
      return result;
    });
  }
  /** Merge props into the current animation */
  _merge(range, props, resolve) {
    if (props.cancel) {
      this.stop(true);
      return resolve(getCancelledResult(this));
    }
    const hasToProp = !is.und(range.to);
    const hasFromProp = !is.und(range.from);
    if (hasToProp || hasFromProp) {
      if (props.callId > this._lastToId) {
        this._lastToId = props.callId;
      } else {
        return resolve(getCancelledResult(this));
      }
    }
    const { key, defaultProps, animation: anim } = this;
    const { to: prevTo, from: prevFrom } = anim;
    let { to: to2 = prevTo, from = prevFrom } = range;
    if (hasFromProp && !hasToProp && (!props.default || is.und(to2))) {
      to2 = from;
    }
    if (props.reverse)
      [to2, from] = [from, to2];
    const hasFromChanged = !isEqual(from, prevFrom);
    if (hasFromChanged) {
      anim.from = from;
    }
    from = getFluidValue(from);
    const hasToChanged = !isEqual(to2, prevTo);
    if (hasToChanged) {
      this._focus(to2);
    }
    const hasAsyncTo = isAsyncTo(props.to);
    const { config: config2 } = anim;
    const { decay, velocity } = config2;
    if (hasToProp || hasFromProp) {
      config2.velocity = 0;
    }
    if (props.config && !hasAsyncTo) {
      mergeConfig(
        config2,
        callProp(props.config, key),
        // Avoid calling the same "config" prop twice.
        props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0
      );
    }
    let node = getAnimated(this);
    if (!node || is.und(to2)) {
      return resolve(getFinishedResult(this, true));
    }
    const reset = (
      // When `reset` is undefined, the `from` prop implies `reset: true`,
      // except for declarative updates. When `reset` is defined, there
      // must exist a value to animate from.
      is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key)
    );
    const value = reset ? from : this.get();
    const goal = computeGoal(to2);
    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));
    if (hasToChanged) {
      const nodeType = getAnimatedType(to2);
      if (nodeType !== node.constructor) {
        if (immediate) {
          node = this._set(goal);
        } else
          throw Error(
            `Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`
          );
      }
    }
    const goalType = node.constructor;
    let started = hasFluidValue(to2);
    let finished = false;
    if (!started) {
      const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
      if (hasToChanged || hasValueChanged) {
        finished = isEqual(computeGoal(value), goal);
        started = !finished;
      }
      if (!isEqual(anim.immediate, immediate) && !immediate || !isEqual(config2.decay, decay) || !isEqual(config2.velocity, velocity)) {
        started = true;
      }
    }
    if (finished && isAnimating(this)) {
      if (anim.changed && !reset) {
        started = true;
      } else if (!started) {
        this._stop(prevTo);
      }
    }
    if (!hasAsyncTo) {
      if (started || hasFluidValue(prevTo)) {
        anim.values = node.getPayload();
        anim.toValues = hasFluidValue(to2) ? null : goalType == AnimatedString ? [1] : toArray(goal);
      }
      if (anim.immediate != immediate) {
        anim.immediate = immediate;
        if (!immediate && !reset) {
          this._set(prevTo);
        }
      }
      if (started) {
        const { onRest } = anim;
        react_spring_shared_modern_each(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
        const result = getFinishedResult(this, checkFinished(this, prevTo));
        flushCalls(this._pendingCalls, result);
        this._pendingCalls.add(resolve);
        if (anim.changed)
          raf.batchedUpdates(() => {
            anim.changed = !reset;
            onRest?.(result, this);
            if (reset) {
              callProp(defaultProps.onRest, result);
            } else {
              anim.onStart?.(result, this);
            }
          });
      }
    }
    if (reset) {
      this._set(value);
    }
    if (hasAsyncTo) {
      resolve(runAsync(props.to, props, this._state, this));
    } else if (started) {
      this._start();
    } else if (isAnimating(this) && !hasToChanged) {
      this._pendingCalls.add(resolve);
    } else {
      resolve(getNoopResult(value));
    }
  }
  /** Update the `animation.to` value, which might be a `FluidValue` */
  _focus(value) {
    const anim = this.animation;
    if (value !== anim.to) {
      if (getFluidObservers(this)) {
        this._detach();
      }
      anim.to = value;
      if (getFluidObservers(this)) {
        this._attach();
      }
    }
  }
  _attach() {
    let priority = 0;
    const { to: to2 } = this.animation;
    if (hasFluidValue(to2)) {
      addFluidObserver(to2, this);
      if (isFrameValue(to2)) {
        priority = to2.priority + 1;
      }
    }
    this.priority = priority;
  }
  _detach() {
    const { to: to2 } = this.animation;
    if (hasFluidValue(to2)) {
      removeFluidObserver(to2, this);
    }
  }
  /**
   * Update the current value from outside the frameloop,
   * and return the `Animated` node.
   */
  _set(arg, idle = true) {
    const value = getFluidValue(arg);
    if (!is.und(value)) {
      const oldNode = getAnimated(this);
      if (!oldNode || !isEqual(value, oldNode.getValue())) {
        const nodeType = getAnimatedType(value);
        if (!oldNode || oldNode.constructor != nodeType) {
          setAnimated(this, nodeType.create(value));
        } else {
          oldNode.setValue(value);
        }
        if (oldNode) {
          raf.batchedUpdates(() => {
            this._onChange(value, idle);
          });
        }
      }
    }
    return getAnimated(this);
  }
  _onStart() {
    const anim = this.animation;
    if (!anim.changed) {
      anim.changed = true;
      sendEvent(
        this,
        "onStart",
        getFinishedResult(this, checkFinished(this, anim.to)),
        this
      );
    }
  }
  _onChange(value, idle) {
    if (!idle) {
      this._onStart();
      callProp(this.animation.onChange, value, this);
    }
    callProp(this.defaultProps.onChange, value, this);
    super._onChange(value, idle);
  }
  // This method resets the animation state (even if already animating) to
  // ensure the latest from/to range is used, and it also ensures this spring
  // is added to the frameloop.
  _start() {
    const anim = this.animation;
    getAnimated(this).reset(getFluidValue(anim.to));
    if (!anim.immediate) {
      anim.fromValues = anim.values.map((node) => node.lastPosition);
    }
    if (!isAnimating(this)) {
      setActiveBit(this, true);
      if (!isPaused(this)) {
        this._resume();
      }
    }
  }
  _resume() {
    if (globals_exports.skipAnimation) {
      this.finish();
    } else {
      frameLoop.start(this);
    }
  }
  /**
   * Exit the frameloop and notify `onRest` listeners.
   *
   * Always wrap `_stop` calls with `batchedUpdates`.
   */
  _stop(goal, cancel) {
    if (isAnimating(this)) {
      setActiveBit(this, false);
      const anim = this.animation;
      react_spring_shared_modern_each(anim.values, (node) => {
        node.done = true;
      });
      if (anim.toValues) {
        anim.onChange = anim.onPause = anim.onResume = void 0;
      }
      callFluidObservers(this, {
        type: "idle",
        parent: this
      });
      const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal ?? anim.to));
      flushCalls(this._pendingCalls, result);
      if (anim.changed) {
        anim.changed = false;
        sendEvent(this, "onRest", result, this);
      }
    }
  }
};
function checkFinished(target, to2) {
  const goal = computeGoal(to2);
  const value = computeGoal(target.get());
  return isEqual(value, goal);
}
function createLoopUpdate(props, loop = props.loop, to2 = props.to) {
  const loopRet = callProp(loop);
  if (loopRet) {
    const overrides = loopRet !== true && inferTo(loopRet);
    const reverse = (overrides || props).reverse;
    const reset = !overrides || overrides.reset;
    return createUpdate({
      ...props,
      loop,
      // Avoid updating default props when looping.
      default: false,
      // Never loop the `pause` prop.
      pause: void 0,
      // For the "reverse" prop to loop as expected, the "to" prop
      // must be undefined. The "reverse" prop is ignored when the
      // "to" prop is an array or function.
      to: !reverse || isAsyncTo(to2) ? to2 : void 0,
      // Ignore the "from" prop except on reset.
      from: reset ? props.from : void 0,
      reset,
      // The "loop" prop can return a "useSpring" props object to
      // override any of the original props.
      ...overrides
    });
  }
}
function createUpdate(props) {
  const { to: to2, from } = props = inferTo(props);
  const keys = /* @__PURE__ */ new Set();
  if (is.obj(to2))
    findDefined(to2, keys);
  if (is.obj(from))
    findDefined(from, keys);
  props.keys = keys.size ? Array.from(keys) : null;
  return props;
}
function declareUpdate(props) {
  const update2 = createUpdate(props);
  if (is.und(update2.default)) {
    update2.default = getDefaultProps(update2);
  }
  return update2;
}
function findDefined(values, keys) {
  eachProp(values, (value, key) => value != null && keys.add(key));
}
var ACTIVE_EVENTS = [
  "onStart",
  "onRest",
  "onChange",
  "onPause",
  "onResume"
];
function mergeActiveFn(target, props, type) {
  target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;
}
function sendEvent(target, type, ...args) {
  target.animation[type]?.(...args);
  target.defaultProps[type]?.(...args);
}

// src/Controller.ts

var BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
var nextId2 = 1;
var Controller = class {
  constructor(props, flush3) {
    this.id = nextId2++;
    /** The animated values */
    this.springs = {};
    /** The queue of props passed to the `update` method. */
    this.queue = [];
    /** The counter for tracking `scheduleProps` calls */
    this._lastAsyncId = 0;
    /** The values currently being animated */
    this._active = /* @__PURE__ */ new Set();
    /** The values that changed recently */
    this._changed = /* @__PURE__ */ new Set();
    /** Equals false when `onStart` listeners can be called */
    this._started = false;
    /** State used by the `runAsync` function */
    this._state = {
      paused: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    /** The event queues that are flushed once per frame maximum */
    this._events = {
      onStart: /* @__PURE__ */ new Map(),
      onChange: /* @__PURE__ */ new Map(),
      onRest: /* @__PURE__ */ new Map()
    };
    this._onFrame = this._onFrame.bind(this);
    if (flush3) {
      this._flush = flush3;
    }
    if (props) {
      this.start({ default: true, ...props });
    }
  }
  /**
   * Equals `true` when no spring values are in the frameloop, and
   * no async animation is currently active.
   */
  get idle() {
    return !this._state.asyncTo && Object.values(this.springs).every((spring) => {
      return spring.idle && !spring.isDelayed && !spring.isPaused;
    });
  }
  get item() {
    return this._item;
  }
  set item(item) {
    this._item = item;
  }
  /** Get the current values of our springs */
  get() {
    const values = {};
    this.each((spring, key) => values[key] = spring.get());
    return values;
  }
  /** Set the current values without animating. */
  set(values) {
    for (const key in values) {
      const value = values[key];
      if (!is.und(value)) {
        this.springs[key].set(value);
      }
    }
  }
  /** Push an update onto the queue of each value. */
  update(props) {
    if (props) {
      this.queue.push(createUpdate(props));
    }
    return this;
  }
  /**
   * Start the queued animations for every spring, and resolve the returned
   * promise once all queued animations have finished or been cancelled.
   *
   * When you pass a queue (instead of nothing), that queue is used instead of
   * the queued animations added with the `update` method, which are left alone.
   */
  start(props) {
    let { queue } = this;
    if (props) {
      queue = toArray(props).map(createUpdate);
    } else {
      this.queue = [];
    }
    if (this._flush) {
      return this._flush(this, queue);
    }
    prepareKeys(this, queue);
    return flushUpdateQueue(this, queue);
  }
  /** @internal */
  stop(arg, keys) {
    if (arg !== !!arg) {
      keys = arg;
    }
    if (keys) {
      const springs = this.springs;
      react_spring_shared_modern_each(toArray(keys), (key) => springs[key].stop(!!arg));
    } else {
      stopAsync(this._state, this._lastAsyncId);
      this.each((spring) => spring.stop(!!arg));
    }
    return this;
  }
  /** Freeze the active animation in time */
  pause(keys) {
    if (is.und(keys)) {
      this.start({ pause: true });
    } else {
      const springs = this.springs;
      react_spring_shared_modern_each(toArray(keys), (key) => springs[key].pause());
    }
    return this;
  }
  /** Resume the animation if paused. */
  resume(keys) {
    if (is.und(keys)) {
      this.start({ pause: false });
    } else {
      const springs = this.springs;
      react_spring_shared_modern_each(toArray(keys), (key) => springs[key].resume());
    }
    return this;
  }
  /** Call a function once per spring value */
  each(iterator) {
    eachProp(this.springs, iterator);
  }
  /** @internal Called at the end of every animation frame */
  _onFrame() {
    const { onStart, onChange, onRest } = this._events;
    const active = this._active.size > 0;
    const changed = this._changed.size > 0;
    if (active && !this._started || changed && !this._started) {
      this._started = true;
      flush(onStart, ([onStart2, result]) => {
        result.value = this.get();
        onStart2(result, this, this._item);
      });
    }
    const idle = !active && this._started;
    const values = changed || idle && onRest.size ? this.get() : null;
    if (changed && onChange.size) {
      flush(onChange, ([onChange2, result]) => {
        result.value = values;
        onChange2(result, this, this._item);
      });
    }
    if (idle) {
      this._started = false;
      flush(onRest, ([onRest2, result]) => {
        result.value = values;
        onRest2(result, this, this._item);
      });
    }
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      this._changed.add(event.parent);
      if (!event.idle) {
        this._active.add(event.parent);
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else
      return;
    raf.onFrame(this._onFrame);
  }
};
function flushUpdateQueue(ctrl, queue) {
  return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then(
    (results) => getCombinedResult(ctrl, results)
  );
}
async function flushUpdate(ctrl, props, isLoop) {
  const { keys, to: to2, from, loop, onRest, onResolve } = props;
  const defaults2 = is.obj(props.default) && props.default;
  if (loop) {
    props.loop = false;
  }
  if (to2 === false)
    props.to = null;
  if (from === false)
    props.from = null;
  const asyncTo = is.arr(to2) || is.fun(to2) ? to2 : void 0;
  if (asyncTo) {
    props.to = void 0;
    props.onRest = void 0;
    if (defaults2) {
      defaults2.onRest = void 0;
    }
  } else {
    react_spring_shared_modern_each(BATCHED_EVENTS, (key) => {
      const handler = props[key];
      if (is.fun(handler)) {
        const queue = ctrl["_events"][key];
        props[key] = ({ finished, cancelled }) => {
          const result2 = queue.get(handler);
          if (result2) {
            if (!finished)
              result2.finished = false;
            if (cancelled)
              result2.cancelled = true;
          } else {
            queue.set(handler, {
              value: null,
              finished: finished || false,
              cancelled: cancelled || false
            });
          }
        };
        if (defaults2) {
          defaults2[key] = props[key];
        }
      }
    });
  }
  const state = ctrl["_state"];
  if (props.pause === !state.paused) {
    state.paused = props.pause;
    flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
  } else if (state.paused) {
    props.pause = true;
  }
  const promises = (keys || Object.keys(ctrl.springs)).map(
    (key) => ctrl.springs[key].start(props)
  );
  const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
  if (asyncTo || cancel && state.asyncId) {
    promises.push(
      scheduleProps(++ctrl["_lastAsyncId"], {
        props,
        state,
        actions: {
          pause: noop,
          resume: noop,
          start(props2, resolve) {
            if (cancel) {
              stopAsync(state, ctrl["_lastAsyncId"]);
              resolve(getCancelledResult(ctrl));
            } else {
              props2.onRest = onRest;
              resolve(
                runAsync(
                  asyncTo,
                  props2,
                  state,
                  ctrl
                )
              );
            }
          }
        }
      })
    );
  }
  if (state.paused) {
    await new Promise((resume) => {
      state.resumeQueue.add(resume);
    });
  }
  const result = getCombinedResult(ctrl, await Promise.all(promises));
  if (loop && result.finished && !(isLoop && result.noop)) {
    const nextProps = createLoopUpdate(props, loop, to2);
    if (nextProps) {
      prepareKeys(ctrl, [nextProps]);
      return flushUpdate(ctrl, nextProps, true);
    }
  }
  if (onResolve) {
    raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
  }
  return result;
}
function getSprings(ctrl, props) {
  const springs = { ...ctrl.springs };
  if (props) {
    react_spring_shared_modern_each(toArray(props), (props2) => {
      if (is.und(props2.keys)) {
        props2 = createUpdate(props2);
      }
      if (!is.obj(props2.to)) {
        props2 = { ...props2, to: void 0 };
      }
      prepareSprings(springs, props2, (key) => {
        return createSpring(key);
      });
    });
  }
  setSprings(ctrl, springs);
  return springs;
}
function setSprings(ctrl, springs) {
  eachProp(springs, (spring, key) => {
    if (!ctrl.springs[key]) {
      ctrl.springs[key] = spring;
      addFluidObserver(spring, ctrl);
    }
  });
}
function createSpring(key, observer) {
  const spring = new SpringValue();
  spring.key = key;
  if (observer) {
    addFluidObserver(spring, observer);
  }
  return spring;
}
function prepareSprings(springs, props, create) {
  if (props.keys) {
    react_spring_shared_modern_each(props.keys, (key) => {
      const spring = springs[key] || (springs[key] = create(key));
      spring["_prepareNode"](props);
    });
  }
}
function prepareKeys(ctrl, queue) {
  react_spring_shared_modern_each(queue, (props) => {
    prepareSprings(ctrl.springs, props, (key) => {
      return createSpring(key, ctrl);
    });
  });
}

// src/SpringContext.tsx



var SpringContext = ({
  children,
  ...props
}) => {
  const inherited = (0,external_React_.useContext)(ctx);
  const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
  props = useMemoOne(() => ({ pause, immediate }), [pause, immediate]);
  const { Provider } = ctx;
  return /* @__PURE__ */ external_React_.createElement(Provider, { value: props }, children);
};
var ctx = makeContext(SpringContext, {});
SpringContext.Provider = ctx.Provider;
SpringContext.Consumer = ctx.Consumer;
function makeContext(target, init) {
  Object.assign(target, external_React_.createContext(init));
  target.Provider._context = target;
  target.Consumer._context = target;
  return target;
}

// src/SpringRef.ts

var SpringRef = () => {
  const current = [];
  const SpringRef2 = function(props) {
    deprecateDirectCall();
    const results = [];
    react_spring_shared_modern_each(current, (ctrl, i) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update2 = _getProps(props, ctrl, i);
        if (update2) {
          results.push(ctrl.start(update2));
        }
      }
    });
    return results;
  };
  SpringRef2.current = current;
  SpringRef2.add = function(ctrl) {
    if (!current.includes(ctrl)) {
      current.push(ctrl);
    }
  };
  SpringRef2.delete = function(ctrl) {
    const i = current.indexOf(ctrl);
    if (~i)
      current.splice(i, 1);
  };
  SpringRef2.pause = function() {
    react_spring_shared_modern_each(current, (ctrl) => ctrl.pause(...arguments));
    return this;
  };
  SpringRef2.resume = function() {
    react_spring_shared_modern_each(current, (ctrl) => ctrl.resume(...arguments));
    return this;
  };
  SpringRef2.set = function(values) {
    react_spring_shared_modern_each(current, (ctrl, i) => {
      const update2 = is.fun(values) ? values(i, ctrl) : values;
      if (update2) {
        ctrl.set(update2);
      }
    });
  };
  SpringRef2.start = function(props) {
    const results = [];
    react_spring_shared_modern_each(current, (ctrl, i) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update2 = this._getProps(props, ctrl, i);
        if (update2) {
          results.push(ctrl.start(update2));
        }
      }
    });
    return results;
  };
  SpringRef2.stop = function() {
    react_spring_shared_modern_each(current, (ctrl) => ctrl.stop(...arguments));
    return this;
  };
  SpringRef2.update = function(props) {
    react_spring_shared_modern_each(current, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)));
    return this;
  };
  const _getProps = function(arg, ctrl, index) {
    return is.fun(arg) ? arg(index, ctrl) : arg;
  };
  SpringRef2._getProps = _getProps;
  return SpringRef2;
};

// src/hooks/useSprings.ts
function useSprings(length, props, deps) {
  const propsFn = is.fun(props) && props;
  if (propsFn && !deps)
    deps = [];
  const ref = (0,external_React_.useMemo)(
    () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
    []
  );
  const layoutId = (0,external_React_.useRef)(0);
  const forceUpdate = useForceUpdate();
  const state = (0,external_React_.useMemo)(
    () => ({
      ctrls: [],
      queue: [],
      flush(ctrl, updates2) {
        const springs2 = getSprings(ctrl, updates2);
        const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);
        return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {
          setSprings(ctrl, springs2);
          state.queue.push(() => {
            resolve(flushUpdateQueue(ctrl, updates2));
          });
          forceUpdate();
        });
      }
    }),
    []
  );
  const ctrls = (0,external_React_.useRef)([...state.ctrls]);
  const updates = [];
  const prevLength = usePrev(length) || 0;
  (0,external_React_.useMemo)(() => {
    react_spring_shared_modern_each(ctrls.current.slice(length, prevLength), (ctrl) => {
      detachRefs(ctrl, ref);
      ctrl.stop(true);
    });
    ctrls.current.length = length;
    declareUpdates(prevLength, length);
  }, [length]);
  (0,external_React_.useMemo)(() => {
    declareUpdates(0, Math.min(prevLength, length));
  }, deps);
  function declareUpdates(startIndex, endIndex) {
    for (let i = startIndex; i < endIndex; i++) {
      const ctrl = ctrls.current[i] || (ctrls.current[i] = new Controller(null, state.flush));
      const update2 = propsFn ? propsFn(i, ctrl) : props[i];
      if (update2) {
        updates[i] = declareUpdate(update2);
      }
    }
  }
  const springs = ctrls.current.map((ctrl, i) => getSprings(ctrl, updates[i]));
  const context = (0,external_React_.useContext)(SpringContext);
  const prevContext = usePrev(context);
  const hasContext = context !== prevContext && hasProps(context);
  react_spring_shared_modern_useIsomorphicLayoutEffect(() => {
    layoutId.current++;
    state.ctrls = ctrls.current;
    const { queue } = state;
    if (queue.length) {
      state.queue = [];
      react_spring_shared_modern_each(queue, (cb) => cb());
    }
    react_spring_shared_modern_each(ctrls.current, (ctrl, i) => {
      ref?.add(ctrl);
      if (hasContext) {
        ctrl.start({ default: context });
      }
      const update2 = updates[i];
      if (update2) {
        replaceRef(ctrl, update2.ref);
        if (ctrl.ref) {
          ctrl.queue.push(update2);
        } else {
          ctrl.start(update2);
        }
      }
    });
  });
  useOnce(() => () => {
    react_spring_shared_modern_each(state.ctrls, (ctrl) => ctrl.stop(true));
  });
  const values = springs.map((x) => ({ ...x }));
  return ref ? [values, ref] : values;
}

// src/hooks/useSpring.ts
function useSpring(props, deps) {
  const isFn = is.fun(props);
  const [[values], ref] = useSprings(
    1,
    isFn ? props : [props],
    isFn ? deps || [] : deps
  );
  return isFn || arguments.length == 2 ? [values, ref] : values;
}

// src/hooks/useSpringRef.ts

var initSpringRef = () => SpringRef();
var useSpringRef = () => useState(initSpringRef)[0];

// src/hooks/useSpringValue.ts

var useSpringValue = (initial, props) => {
  const springValue = useConstant(() => new SpringValue(initial, props));
  useOnce2(() => () => {
    springValue.stop();
  });
  return springValue;
};

// src/hooks/useTrail.ts

function useTrail(length, propsArg, deps) {
  const propsFn = is10.fun(propsArg) && propsArg;
  if (propsFn && !deps)
    deps = [];
  let reverse = true;
  let passedRef = void 0;
  const result = useSprings(
    length,
    (i, ctrl) => {
      const props = propsFn ? propsFn(i, ctrl) : propsArg;
      passedRef = props.ref;
      reverse = reverse && props.reverse;
      return props;
    },
    // Ensure the props function is called when no deps exist.
    // This works around the 3 argument rule.
    deps || [{}]
  );
  useIsomorphicLayoutEffect3(() => {
    each6(result[1].current, (ctrl, i) => {
      const parent = result[1].current[i + (reverse ? 1 : -1)];
      replaceRef(ctrl, passedRef);
      if (ctrl.ref) {
        if (parent) {
          ctrl.update({ to: parent.springs });
        }
        return;
      }
      if (parent) {
        ctrl.start({ to: parent.springs });
      } else {
        ctrl.start();
      }
    });
  }, deps);
  if (propsFn || arguments.length == 3) {
    const ref = passedRef ?? result[1];
    ref["_getProps"] = (propsArg2, ctrl, i) => {
      const props = is10.fun(propsArg2) ? propsArg2(i, ctrl) : propsArg2;
      if (props) {
        const parent = ref.current[i + (props.reverse ? 1 : -1)];
        if (parent)
          props.to = parent.springs;
        return props;
      }
    };
    return result;
  }
  return result[0];
}

// src/hooks/useTransition.tsx



function useTransition(data, props, deps) {
  const propsFn = is11.fun(props) && props;
  const {
    reset,
    sort,
    trail = 0,
    expires = true,
    exitBeforeEnter = false,
    onDestroyed,
    ref: propsRef,
    config: propsConfig
  } = propsFn ? propsFn() : props;
  const ref = useMemo2(
    () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
    []
  );
  const items = toArray4(data);
  const transitions = [];
  const usedTransitions = useRef2(null);
  const prevTransitions = reset ? null : usedTransitions.current;
  useIsomorphicLayoutEffect4(() => {
    usedTransitions.current = transitions;
  });
  useOnce3(() => {
    each7(transitions, (t) => {
      ref?.add(t.ctrl);
      t.ctrl.ref = ref;
    });
    return () => {
      each7(usedTransitions.current, (t) => {
        if (t.expired) {
          clearTimeout(t.expirationId);
        }
        detachRefs(t.ctrl, ref);
        t.ctrl.stop(true);
      });
    };
  });
  const keys = getKeys(items, propsFn ? propsFn() : props, prevTransitions);
  const expired = reset && usedTransitions.current || [];
  useIsomorphicLayoutEffect4(
    () => each7(expired, ({ ctrl, item, key }) => {
      detachRefs(ctrl, ref);
      callProp(onDestroyed, item, key);
    })
  );
  const reused = [];
  if (prevTransitions)
    each7(prevTransitions, (t, i) => {
      if (t.expired) {
        clearTimeout(t.expirationId);
        expired.push(t);
      } else {
        i = reused[i] = keys.indexOf(t.key);
        if (~i)
          transitions[i] = t;
      }
    });
  each7(items, (item, i) => {
    if (!transitions[i]) {
      transitions[i] = {
        key: keys[i],
        item,
        phase: "mount" /* MOUNT */,
        ctrl: new Controller()
      };
      transitions[i].ctrl.item = item;
    }
  });
  if (reused.length) {
    let i = -1;
    const { leave } = propsFn ? propsFn() : props;
    each7(reused, (keyIndex, prevIndex) => {
      const t = prevTransitions[prevIndex];
      if (~keyIndex) {
        i = transitions.indexOf(t);
        transitions[i] = { ...t, item: items[keyIndex] };
      } else if (leave) {
        transitions.splice(++i, 0, t);
      }
    });
  }
  if (is11.fun(sort)) {
    transitions.sort((a, b) => sort(a.item, b.item));
  }
  let delay = -trail;
  const forceUpdate = useForceUpdate2();
  const defaultProps = getDefaultProps(props);
  const changes = /* @__PURE__ */ new Map();
  const exitingTransitions = useRef2(/* @__PURE__ */ new Map());
  const forceChange = useRef2(false);
  each7(transitions, (t, i) => {
    const key = t.key;
    const prevPhase = t.phase;
    const p = propsFn ? propsFn() : props;
    let to2;
    let phase;
    const propsDelay = callProp(p.delay || 0, key);
    if (prevPhase == "mount" /* MOUNT */) {
      to2 = p.enter;
      phase = "enter" /* ENTER */;
    } else {
      const isLeave = keys.indexOf(key) < 0;
      if (prevPhase != "leave" /* LEAVE */) {
        if (isLeave) {
          to2 = p.leave;
          phase = "leave" /* LEAVE */;
        } else if (to2 = p.update) {
          phase = "update" /* UPDATE */;
        } else
          return;
      } else if (!isLeave) {
        to2 = p.enter;
        phase = "enter" /* ENTER */;
      } else
        return;
    }
    to2 = callProp(to2, t.item, i);
    to2 = is11.obj(to2) ? inferTo(to2) : { to: to2 };
    if (!to2.config) {
      const config2 = propsConfig || defaultProps.config;
      to2.config = callProp(config2, t.item, i, phase);
    }
    delay += trail;
    const payload = {
      ...defaultProps,
      // we need to add our props.delay value you here.
      delay: propsDelay + delay,
      ref: propsRef,
      immediate: p.immediate,
      // This prevents implied resets.
      reset: false,
      // Merge any phase-specific props.
      ...to2
    };
    if (phase == "enter" /* ENTER */ && is11.und(payload.from)) {
      const p2 = propsFn ? propsFn() : props;
      const from = is11.und(p2.initial) || prevTransitions ? p2.from : p2.initial;
      payload.from = callProp(from, t.item, i);
    }
    const { onResolve } = payload;
    payload.onResolve = (result) => {
      callProp(onResolve, result);
      const transitions2 = usedTransitions.current;
      const t2 = transitions2.find((t3) => t3.key === key);
      if (!t2)
        return;
      if (result.cancelled && t2.phase != "update" /* UPDATE */) {
        return;
      }
      if (t2.ctrl.idle) {
        const idle = transitions2.every((t3) => t3.ctrl.idle);
        if (t2.phase == "leave" /* LEAVE */) {
          const expiry = callProp(expires, t2.item);
          if (expiry !== false) {
            const expiryMs = expiry === true ? 0 : expiry;
            t2.expired = true;
            if (!idle && expiryMs > 0) {
              if (expiryMs <= 2147483647)
                t2.expirationId = setTimeout(forceUpdate, expiryMs);
              return;
            }
          }
        }
        if (idle && transitions2.some((t3) => t3.expired)) {
          exitingTransitions.current.delete(t2);
          if (exitBeforeEnter) {
            forceChange.current = true;
          }
          forceUpdate();
        }
      }
    };
    const springs = getSprings(t.ctrl, payload);
    if (phase === "leave" /* LEAVE */ && exitBeforeEnter) {
      exitingTransitions.current.set(t, { phase, springs, payload });
    } else {
      changes.set(t, { phase, springs, payload });
    }
  });
  const context = useContext3(SpringContext);
  const prevContext = usePrev2(context);
  const hasContext = context !== prevContext && hasProps(context);
  useIsomorphicLayoutEffect4(() => {
    if (hasContext) {
      each7(transitions, (t) => {
        t.ctrl.start({ default: context });
      });
    }
  }, [context]);
  each7(changes, (_, t) => {
    if (exitingTransitions.current.size) {
      const ind = transitions.findIndex((state) => state.key === t.key);
      transitions.splice(ind, 1);
    }
  });
  useIsomorphicLayoutEffect4(
    () => {
      each7(
        exitingTransitions.current.size ? exitingTransitions.current : changes,
        ({ phase, payload }, t) => {
          const { ctrl } = t;
          t.phase = phase;
          ref?.add(ctrl);
          if (hasContext && phase == "enter" /* ENTER */) {
            ctrl.start({ default: context });
          }
          if (payload) {
            replaceRef(ctrl, payload.ref);
            if ((ctrl.ref || ref) && !forceChange.current) {
              ctrl.update(payload);
            } else {
              ctrl.start(payload);
              if (forceChange.current) {
                forceChange.current = false;
              }
            }
          }
        }
      );
    },
    reset ? void 0 : deps
  );
  const renderTransitions = (render) => /* @__PURE__ */ React2.createElement(React2.Fragment, null, transitions.map((t, i) => {
    const { springs } = changes.get(t) || t.ctrl;
    const elem = render({ ...springs }, t.item, t, i);
    return elem && elem.type ? /* @__PURE__ */ React2.createElement(
      elem.type,
      {
        ...elem.props,
        key: is11.str(t.key) || is11.num(t.key) ? t.key : t.ctrl.id,
        ref: elem.ref
      }
    ) : elem;
  }));
  return ref ? [renderTransitions, ref] : renderTransitions;
}
var nextKey = 1;
function getKeys(items, { key, keys = key }, prevTransitions) {
  if (keys === null) {
    const reused = /* @__PURE__ */ new Set();
    return items.map((item) => {
      const t = prevTransitions && prevTransitions.find(
        (t2) => t2.item === item && t2.phase !== "leave" /* LEAVE */ && !reused.has(t2)
      );
      if (t) {
        reused.add(t);
        return t.key;
      }
      return nextKey++;
    });
  }
  return is11.und(keys) ? items : is11.fun(keys) ? items.map(keys) : toArray4(keys);
}

// src/hooks/useScroll.ts

var useScroll = ({
  container,
  ...springOptions
} = {}) => {
  const [scrollValues, api] = useSpring(
    () => ({
      scrollX: 0,
      scrollY: 0,
      scrollXProgress: 0,
      scrollYProgress: 0,
      ...springOptions
    }),
    []
  );
  useIsomorphicLayoutEffect5(() => {
    const cleanupScroll = onScroll(
      ({ x, y }) => {
        api.start({
          scrollX: x.current,
          scrollXProgress: x.progress,
          scrollY: y.current,
          scrollYProgress: y.progress
        });
      },
      { container: container?.current || void 0 }
    );
    return () => {
      each8(Object.values(scrollValues), (value) => value.stop());
      cleanupScroll();
    };
  }, []);
  return scrollValues;
};

// src/hooks/useResize.ts

var useResize = ({
  container,
  ...springOptions
}) => {
  const [sizeValues, api] = useSpring(
    () => ({
      width: 0,
      height: 0,
      ...springOptions
    }),
    []
  );
  useIsomorphicLayoutEffect6(() => {
    const cleanupScroll = onResize(
      ({ width, height }) => {
        api.start({
          width,
          height,
          immediate: sizeValues.width.get() === 0 || sizeValues.height.get() === 0
        });
      },
      { container: container?.current || void 0 }
    );
    return () => {
      each9(Object.values(sizeValues), (value) => value.stop());
      cleanupScroll();
    };
  }, []);
  return sizeValues;
};

// src/hooks/useInView.ts


var defaultThresholdOptions = {
  any: 0,
  all: 1
};
function useInView(props, args) {
  const [isInView, setIsInView] = useState2(false);
  const ref = useRef3();
  const propsFn = is12.fun(props) && props;
  const springsProps = propsFn ? propsFn() : {};
  const { to: to2 = {}, from = {}, ...restSpringProps } = springsProps;
  const intersectionArguments = propsFn ? args : props;
  const [springs, api] = useSpring(() => ({ from, ...restSpringProps }), []);
  useIsomorphicLayoutEffect7(() => {
    const element = ref.current;
    const {
      root,
      once,
      amount = "any",
      ...restArgs
    } = intersectionArguments ?? {};
    if (!element || once && isInView || typeof IntersectionObserver === "undefined")
      return;
    const activeIntersections = /* @__PURE__ */ new WeakMap();
    const onEnter = () => {
      if (to2) {
        api.start(to2);
      }
      setIsInView(true);
      const cleanup = () => {
        if (from) {
          api.start(from);
        }
        setIsInView(false);
      };
      return once ? void 0 : cleanup;
    };
    const handleIntersection = (entries) => {
      entries.forEach((entry) => {
        const onLeave = activeIntersections.get(entry.target);
        if (entry.isIntersecting === Boolean(onLeave)) {
          return;
        }
        if (entry.isIntersecting) {
          const newOnLeave = onEnter();
          if (is12.fun(newOnLeave)) {
            activeIntersections.set(entry.target, newOnLeave);
          } else {
            observer.unobserve(entry.target);
          }
        } else if (onLeave) {
          onLeave();
          activeIntersections.delete(entry.target);
        }
      });
    };
    const observer = new IntersectionObserver(handleIntersection, {
      root: root && root.current || void 0,
      threshold: typeof amount === "number" || Array.isArray(amount) ? amount : defaultThresholdOptions[amount],
      ...restArgs
    });
    observer.observe(element);
    return () => observer.unobserve(element);
  }, [intersectionArguments]);
  if (propsFn) {
    return [ref, springs];
  }
  return [ref, isInView];
}

// src/components/Spring.tsx
function Spring({ children, ...props }) {
  return children(useSpring(props));
}

// src/components/Trail.tsx

function Trail({
  items,
  children,
  ...props
}) {
  const trails = useTrail(items.length, props);
  return items.map((item, index) => {
    const result = children(item, index);
    return is13.fun(result) ? result(trails[index]) : result;
  });
}

// src/components/Transition.tsx
function Transition({
  items,
  children,
  ...props
}) {
  return useTransition(items, props)(children);
}

// src/interpolate.ts


// src/Interpolation.ts


var Interpolation = class extends FrameValue {
  constructor(source, args) {
    super();
    this.source = source;
    /** Equals false when in the frameloop */
    this.idle = true;
    /** The inputs which are currently animating */
    this._active = /* @__PURE__ */ new Set();
    this.calc = createInterpolator(...args);
    const value = this._get();
    const nodeType = getAnimatedType(value);
    setAnimated(this, nodeType.create(value));
  }
  advance(_dt) {
    const value = this._get();
    const oldValue = this.get();
    if (!isEqual(value, oldValue)) {
      getAnimated(this).setValue(value);
      this._onChange(value, this.idle);
    }
    if (!this.idle && checkIdle(this._active)) {
      becomeIdle(this);
    }
  }
  _get() {
    const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));
    return this.calc(...inputs);
  }
  _start() {
    if (this.idle && !checkIdle(this._active)) {
      this.idle = false;
      react_spring_shared_modern_each(getPayload(this), (node) => {
        node.done = false;
      });
      if (globals_exports.skipAnimation) {
        raf.batchedUpdates(() => this.advance());
        becomeIdle(this);
      } else {
        frameLoop.start(this);
      }
    }
  }
  // Observe our sources only when we're observed.
  _attach() {
    let priority = 1;
    react_spring_shared_modern_each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        addFluidObserver(source, this);
      }
      if (isFrameValue(source)) {
        if (!source.idle) {
          this._active.add(source);
        }
        priority = Math.max(priority, source.priority + 1);
      }
    });
    this.priority = priority;
    this._start();
  }
  // Stop observing our sources once we have no observers.
  _detach() {
    react_spring_shared_modern_each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        removeFluidObserver(source, this);
      }
    });
    this._active.clear();
    becomeIdle(this);
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      if (event.idle) {
        this.advance();
      } else {
        this._active.add(event.parent);
        this._start();
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else if (event.type == "priority") {
      this.priority = toArray(this.source).reduce(
        (highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1),
        0
      );
    }
  }
};
function isIdle(source) {
  return source.idle !== false;
}
function checkIdle(active) {
  return !active.size || Array.from(active).every(isIdle);
}
function becomeIdle(self) {
  if (!self.idle) {
    self.idle = true;
    react_spring_shared_modern_each(getPayload(self), (node) => {
      node.done = true;
    });
    callFluidObservers(self, {
      type: "idle",
      parent: self
    });
  }
}

// src/interpolate.ts
var react_spring_core_modern_to = (source, ...args) => new Interpolation(source, args);
var react_spring_core_modern_interpolate = (source, ...args) => (deprecateInterpolate2(), new Interpolation(source, args));

// src/globals.ts

globals_exports.assign({
  createStringInterpolator: createStringInterpolator2,
  to: (source, args) => new Interpolation(source, args)
});
var react_spring_core_modern_update = frameLoop.advance;

// src/index.ts



;// CONCATENATED MODULE: external "ReactDOM"
var external_ReactDOM_namespaceObject = window["ReactDOM"];
;// CONCATENATED MODULE: ./node_modules/@react-spring/web/dist/react-spring_web.modern.mjs
// src/index.ts





// src/applyAnimatedValues.ts
var isCustomPropRE = /^--/;
function dangerousStyleValue(name, value) {
  if (value == null || typeof value === "boolean" || value === "")
    return "";
  if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
    return value + "px";
  return ("" + value).trim();
}
var attributeCache = {};
function applyAnimatedValues(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }
  const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
  const { style, children, scrollTop, scrollLeft, viewBox, ...attributes } = props;
  const values = Object.values(attributes);
  const names = Object.keys(attributes).map(
    (name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(
      /([A-Z])/g,
      // Attributes are written in dash case
      (n) => "-" + n.toLowerCase()
    ))
  );
  if (children !== void 0) {
    instance.textContent = children;
  }
  for (const name in style) {
    if (style.hasOwnProperty(name)) {
      const value = dangerousStyleValue(name, style[name]);
      if (isCustomPropRE.test(name)) {
        instance.style.setProperty(name, value);
      } else {
        instance.style[name] = value;
      }
    }
  }
  names.forEach((name, i) => {
    instance.setAttribute(name, values[i]);
  });
  if (scrollTop !== void 0) {
    instance.scrollTop = scrollTop;
  }
  if (scrollLeft !== void 0) {
    instance.scrollLeft = scrollLeft;
  }
  if (viewBox !== void 0) {
    instance.setAttribute("viewBox", viewBox);
  }
}
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);
var prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix) => acc[prefixKey(prefix, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);

// src/AnimatedStyle.ts


var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
var pxTransforms = /^(translate)/;
var degTransforms = /^(rotate|skew)/;
var addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
var isValueIdentity = (value, id) => is.arr(value) ? value.every((v) => isValueIdentity(v, id)) : is.num(value) ? value === id : parseFloat(value) === id;
var AnimatedStyle = class extends AnimatedObject {
  constructor({ x, y, z, ...style }) {
    const inputs = [];
    const transforms = [];
    if (x || y || z) {
      inputs.push([x || 0, y || 0, z || 0]);
      transforms.push((xyz) => [
        `translate3d(${xyz.map((v) => addUnit(v, "px")).join(",")})`,
        // prettier-ignore
        isValueIdentity(xyz, 0)
      ]);
    }
    eachProp(style, (value, key) => {
      if (key === "transform") {
        inputs.push([value || ""]);
        transforms.push((transform) => [transform, transform === ""]);
      } else if (domTransforms.test(key)) {
        delete style[key];
        if (is.und(value))
          return;
        const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
        inputs.push(toArray(value));
        transforms.push(
          key === "rotate3d" ? ([x2, y2, z2, deg]) => [
            `rotate3d(${x2},${y2},${z2},${addUnit(deg, unit)})`,
            isValueIdentity(deg, 0)
          ] : (input) => [
            `${key}(${input.map((v) => addUnit(v, unit)).join(",")})`,
            isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
          ]
        );
      }
    });
    if (inputs.length) {
      style.transform = new FluidTransform(inputs, transforms);
    }
    super(style);
  }
};
var FluidTransform = class extends FluidValue {
  constructor(inputs, transforms) {
    super();
    this.inputs = inputs;
    this.transforms = transforms;
    this._value = null;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let transform = "";
    let identity = true;
    react_spring_shared_modern_each(this.inputs, (input, i) => {
      const arg1 = getFluidValue(input[0]);
      const [t, id] = this.transforms[i](
        is.arr(arg1) ? arg1 : input.map(getFluidValue)
      );
      transform += " " + t;
      identity = identity && id;
    });
    return identity ? "none" : transform;
  }
  // Start observing our inputs once we have an observer.
  observerAdded(count) {
    if (count == 1)
      react_spring_shared_modern_each(
        this.inputs,
        (input) => react_spring_shared_modern_each(
          input,
          (value) => hasFluidValue(value) && addFluidObserver(value, this)
        )
      );
  }
  // Stop observing our inputs once we have no observers.
  observerRemoved(count) {
    if (count == 0)
      react_spring_shared_modern_each(
        this.inputs,
        (input) => react_spring_shared_modern_each(
          input,
          (value) => hasFluidValue(value) && removeFluidObserver(value, this)
        )
      );
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._value = null;
    }
    callFluidObservers(this, event);
  }
};

// src/primitives.ts
var primitives = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];

// src/index.ts

globals_exports.assign({
  batchedUpdates: external_ReactDOM_namespaceObject.unstable_batchedUpdates,
  createStringInterpolator: createStringInterpolator2,
  colors: colors2
});
var host = createHost(primitives, {
  applyAnimatedValues,
  createAnimatedStyle: (style) => new AnimatedStyle(style),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getComponentProps: ({ scrollTop, scrollLeft, ...props }) => props
});
var animated = host.animated;

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/use-moving-animation/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Simple reducer used to increment a counter.
 *
 * @param {number} state Previous counter value.
 * @return {number} New state value.
 */

const counterReducer = state => state + 1;

const getAbsolutePosition = element => {
  return {
    top: element.offsetTop,
    left: element.offsetLeft
  };
};
/**
 * Hook used to compute the styles required to move a div into a new position.
 *
 * The way this animation works is the following:
 *  - It first renders the element as if there was no animation.
 *  - It takes a snapshot of the position of the block to use it
 *    as a destination point for the animation.
 *  - It restores the element to the previous position using a CSS transform
 *  - It uses the "resetAnimation" flag to reset the animation
 *    from the beginning in order to animate to the new destination point.
 *
 * @param {Object}  $1                          Options
 * @param {boolean} $1.isSelected               Whether it's the current block or not.
 * @param {boolean} $1.adjustScrolling          Adjust the scroll position to the current block.
 * @param {boolean} $1.enableAnimation          Enable/Disable animation.
 * @param {*}       $1.triggerAnimationOnChange Variable used to trigger the animation if it changes.
 */


function useMovingAnimation({
  isSelected,
  adjustScrolling,
  enableAnimation,
  triggerAnimationOnChange
}) {
  const ref = (0,external_wp_element_namespaceObject.useRef)();
  const prefersReducedMotion = (0,external_wp_compose_namespaceObject.useReducedMotion)() || !enableAnimation;
  const [triggeredAnimation, triggerAnimation] = (0,external_wp_element_namespaceObject.useReducer)(counterReducer, 0);
  const [finishedAnimation, endAnimation] = (0,external_wp_element_namespaceObject.useReducer)(counterReducer, 0);
  const [transform, setTransform] = (0,external_wp_element_namespaceObject.useState)({
    x: 0,
    y: 0
  });
  const previous = (0,external_wp_element_namespaceObject.useMemo)(() => ref.current ? getAbsolutePosition(ref.current) : null, [triggerAnimationOnChange]); // Calculate the previous position of the block relative to the viewport and
  // return a function to maintain that position by scrolling.

  const preserveScrollPosition = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (!adjustScrolling || !ref.current) {
      return () => {};
    }

    const scrollContainer = (0,external_wp_dom_namespaceObject.getScrollContainer)(ref.current);

    if (!scrollContainer) {
      return () => {};
    }

    const prevRect = ref.current.getBoundingClientRect();
    return () => {
      const blockRect = ref.current.getBoundingClientRect();
      const diff = blockRect.top - prevRect.top;

      if (diff) {
        scrollContainer.scrollTop += diff;
      }
    };
  }, [triggerAnimationOnChange, adjustScrolling]);
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    if (triggeredAnimation) {
      endAnimation();
    }
  }, [triggeredAnimation]);
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    if (!previous) {
      return;
    }

    if (prefersReducedMotion) {
      // If the animation is disabled and the scroll needs to be adjusted,
      // just move directly to the final scroll position.
      preserveScrollPosition();
      return;
    }

    ref.current.style.transform = undefined;
    const destination = getAbsolutePosition(ref.current);
    triggerAnimation();
    setTransform({
      x: Math.round(previous.left - destination.left),
      y: Math.round(previous.top - destination.top)
    });
  }, [triggerAnimationOnChange]);

  function onChange({
    value
  }) {
    if (!ref.current) {
      return;
    }

    let {
      x,
      y
    } = value;
    x = Math.round(x);
    y = Math.round(y);
    const finishedMoving = x === 0 && y === 0;
    ref.current.style.transformOrigin = 'center center';
    ref.current.style.transform = finishedMoving ? undefined : `translate3d(${x}px,${y}px,0)`;
    ref.current.style.zIndex = isSelected ? '1' : '';
    preserveScrollPosition();
  }

  useSpring({
    from: {
      x: transform.x,
      y: transform.y
    },
    to: {
      x: 0,
      y: 0
    },
    reset: triggeredAnimation !== finishedAnimation,
    config: {
      mass: 5,
      tension: 2000,
      friction: 200
    },
    immediate: prefersReducedMotion,
    onChange
  });
  return ref;
}

/* harmony default export */ var use_moving_animation = (useMovingAnimation);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/dom.js
const BLOCK_SELECTOR = '.block-editor-block-list__block';
const APPENDER_SELECTOR = '.block-list-appender';
const BLOCK_APPENDER_CLASS = '.block-editor-button-block-appender';
/**
 * Returns true if two elements are contained within the same block.
 *
 * @param {Element} a First element.
 * @param {Element} b Second element.
 *
 * @return {boolean} Whether elements are in the same block.
 */

function isInSameBlock(a, b) {
  return a.closest(BLOCK_SELECTOR) === b.closest(BLOCK_SELECTOR);
}
/**
 * Returns true if an element is considered part of the block and not its inner
 * blocks or appender.
 *
 * @param {Element} blockElement Block container element.
 * @param {Element} element      Element.
 *
 * @return {boolean} Whether an element is considered part of the block and not
 *                   its inner blocks or appender.
 */

function isInsideRootBlock(blockElement, element) {
  const parentBlock = element.closest([BLOCK_SELECTOR, APPENDER_SELECTOR, BLOCK_APPENDER_CLASS].join(','));
  return parentBlock === blockElement;
}
/**
 * Finds the block client ID given any DOM node inside the block.
 *
 * @param {Node?} node DOM node.
 *
 * @return {string|undefined} Client ID or undefined if the node is not part of
 *                            a block.
 */

function getBlockClientId(node) {
  while (node && node.nodeType !== node.ELEMENT_NODE) {
    node = node.parentNode;
  }

  if (!node) {
    return;
  }

  const elementNode =
  /** @type {Element} */
  node;
  const blockNode = elementNode.closest(BLOCK_SELECTOR);

  if (!blockNode) {
    return;
  }

  return blockNode.id.slice('block-'.length);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-focus-first-element.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/** @typedef {import('@wordpress/element').RefObject} RefObject */

/**
 * Returns the initial position if the block needs to be focussed, `undefined`
 * otherwise. The initial position is either 0 (start) or -1 (end).
 *
 * @param {string} clientId Block client ID.
 *
 * @return {number} The initial position, either 0 (start) or -1 (end).
 */

function useInitialPosition(clientId) {
  return (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getSelectedBlocksInitialCaretPosition,
      __unstableGetEditorMode,
      isBlockSelected
    } = select(store);

    if (!isBlockSelected(clientId)) {
      return;
    }

    if (__unstableGetEditorMode() !== 'edit') {
      return;
    } // If there's no initial position, return 0 to focus the start.


    return getSelectedBlocksInitialCaretPosition();
  }, [clientId]);
}
/**
 * Transitions focus to the block or inner tabbable when the block becomes
 * selected and an initial position is set.
 *
 * @param {string} clientId Block client ID.
 *
 * @return {RefObject} React ref with the block element.
 */


function useFocusFirstElement(clientId) {
  const ref = (0,external_wp_element_namespaceObject.useRef)();
  const initialPosition = useInitialPosition(clientId);
  const {
    isBlockSelected,
    isMultiSelecting
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    // Check if the block is still selected at the time this effect runs.
    if (!isBlockSelected(clientId) || isMultiSelecting()) {
      return;
    }

    if (initialPosition === undefined || initialPosition === null) {
      return;
    }

    if (!ref.current) {
      return;
    }

    const {
      ownerDocument
    } = ref.current; // Do not focus the block if it already contains the active element.

    if (isInsideRootBlock(ref.current, ownerDocument.activeElement)) {
      return;
    } // Find all tabbables within node.


    const textInputs = external_wp_dom_namespaceObject.focus.tabbable.find(ref.current).filter(node => (0,external_wp_dom_namespaceObject.isTextField)(node)); // If reversed (e.g. merge via backspace), use the last in the set of
    // tabbables.

    const isReverse = -1 === initialPosition;
    const target = textInputs[isReverse ? textInputs.length - 1 : 0] || ref.current;

    if (!isInsideRootBlock(ref.current, target)) {
      ref.current.focus();
      return;
    } // Check to see if element is focussable before a generic caret insert.


    if (!ref.current.getAttribute('contenteditable')) {
      const focusElement = external_wp_dom_namespaceObject.focus.tabbable.findNext(ref.current); // Make sure focusElement is valid, contained in the same block, and a form field.

      if (focusElement && isInsideRootBlock(ref.current, focusElement) && (0,external_wp_dom_namespaceObject.isFormElement)(focusElement)) {
        focusElement.focus();
        return;
      }
    }

    (0,external_wp_dom_namespaceObject.placeCaretAtHorizontalEdge)(target, isReverse);
  }, [initialPosition, clientId]);
  return ref;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-is-hovered.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function listener(event) {
  if (event.defaultPrevented) {
    return;
  }

  const action = event.type === 'mouseover' ? 'add' : 'remove';
  event.preventDefault();
  event.currentTarget.classList[action]('is-hovered');
}
/**
 * Adds `is-hovered` class when the block is hovered and in navigation or
 * outline mode.
 */


function useIsHovered() {
  const isEnabled = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getSettings
    } = select(store);
    return getSettings().outlineMode;
  }, []);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    if (isEnabled) {
      node.addEventListener('mouseout', listener);
      node.addEventListener('mouseover', listener);
      return () => {
        node.removeEventListener('mouseout', listener);
        node.removeEventListener('mouseover', listener); // Remove class in case it lingers.

        node.classList.remove('is-hovered');
      };
    }
  }, [isEnabled]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-class-names.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Returns the class names used for the different states of the block.
 *
 * @param {string} clientId The block client ID.
 *
 * @return {string} The class names.
 */

function useBlockClassNames(clientId) {
  return (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      isBlockBeingDragged,
      isBlockHighlighted,
      isBlockSelected,
      isBlockMultiSelected,
      getBlockName,
      getSettings,
      hasSelectedInnerBlock,
      isTyping,
      __unstableIsFullySelected,
      __unstableSelectionHasUnmergeableBlock
    } = select(store);
    const {
      outlineMode
    } = getSettings();
    const isDragging = isBlockBeingDragged(clientId);
    const isSelected = isBlockSelected(clientId);
    const name = getBlockName(clientId);
    const checkDeep = true; // "ancestor" is the more appropriate label due to "deep" check.

    const isAncestorOfSelectedBlock = hasSelectedInnerBlock(clientId, checkDeep);
    const isMultiSelected = isBlockMultiSelected(clientId);
    return classnames_default()({
      'is-selected': isSelected,
      'is-highlighted': isBlockHighlighted(clientId),
      'is-multi-selected': isMultiSelected,
      'is-partially-selected': isMultiSelected && !__unstableIsFullySelected() && !__unstableSelectionHasUnmergeableBlock(),
      'is-reusable': (0,external_wp_blocks_namespaceObject.isReusableBlock)((0,external_wp_blocks_namespaceObject.getBlockType)(name)),
      'is-dragging': isDragging,
      'has-child-selected': isAncestorOfSelectedBlock,
      'remove-outline': isSelected && outlineMode && isTyping()
    });
  }, [clientId]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-default-class-name.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Returns the default class name if the block is a light block and it supports
 * `className`.
 *
 * @param {string} clientId The block client ID.
 *
 * @return {string} The class name, e.g. `wp-block-paragraph`.
 */

function useBlockDefaultClassName(clientId) {
  return (0,external_wp_data_namespaceObject.useSelect)(select => {
    const name = select(store).getBlockName(clientId);
    const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(name);
    const hasLightBlockWrapper = blockType?.apiVersion > 1;

    if (!hasLightBlockWrapper) {
      return;
    }

    return (0,external_wp_blocks_namespaceObject.getBlockDefaultClassName)(name);
  }, [clientId]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-custom-class-name.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Returns the custom class name if the block is a light block.
 *
 * @param {string} clientId The block client ID.
 *
 * @return {string} The custom class name.
 */

function useBlockCustomClassName(clientId) {
  // It's good for this to be a separate selector because it will be executed
  // on every attribute change, while the other selectors are not re-evaluated
  // as much.
  return (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockName,
      getBlockAttributes
    } = select(store);
    const attributes = getBlockAttributes(clientId);

    if (!attributes?.className) {
      return;
    }

    const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(getBlockName(clientId));
    const hasLightBlockWrapper = blockType?.apiVersion > 1;

    if (!hasLightBlockWrapper) {
      return;
    }

    return attributes.className;
  }, [clientId]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-moving-mode-class-names.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Returns the class names used for block moving mode.
 *
 * @param {string} clientId The block client ID to insert above.
 *
 * @return {string} The class names.
 */

function useBlockMovingModeClassNames(clientId) {
  return (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      hasBlockMovingClientId,
      canInsertBlockType,
      getBlockName,
      getBlockRootClientId,
      isBlockSelected
    } = select(store); // The classes are only relevant for the selected block. Avoid
    // re-rendering all blocks!

    if (!isBlockSelected(clientId)) {
      return;
    }

    const movingClientId = hasBlockMovingClientId();

    if (!movingClientId) {
      return;
    }

    return classnames_default()('is-block-moving-mode', {
      'can-insert-moving-block': canInsertBlockType(getBlockName(movingClientId), getBlockRootClientId(clientId))
    });
  }, [clientId]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-focus-handler.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/**
 * Selects the block if it receives focus.
 *
 * @param {string} clientId Block client ID.
 */

function useFocusHandler(clientId) {
  const {
    isBlockSelected
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    selectBlock,
    selectionChange
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    /**
     * Marks the block as selected when focused and not already
     * selected. This specifically handles the case where block does not
     * set focus on its own (via `setFocus`), typically if there is no
     * focusable input in the block.
     *
     * @param {FocusEvent} event Focus event.
     */
    function onFocus(event) {
      // When the whole editor is editable, let writing flow handle
      // selection.
      if (node.parentElement.closest('[contenteditable="true"]')) {
        return;
      } // Check synchronously because a non-selected block might be
      // getting data through `useSelect` asynchronously.


      if (isBlockSelected(clientId)) {
        // Potentially change selection away from rich text.
        if (!event.target.isContentEditable) {
          selectionChange(clientId);
        }

        return;
      } // If an inner block is focussed, that block is resposible for
      // setting the selected block.


      if (!isInsideRootBlock(node, event.target)) {
        return;
      }

      selectBlock(clientId);
    }

    node.addEventListener('focusin', onFocus);
    return () => {
      node.removeEventListener('focusin', onFocus);
    };
  }, [isBlockSelected, selectBlock]);
}

;// CONCATENATED MODULE: external ["wp","keycodes"]
var external_wp_keycodes_namespaceObject = window["wp"]["keycodes"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-selected-block-event-handlers.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/**
 * Adds block behaviour:
 *   - Removes the block on BACKSPACE.
 *   - Inserts a default block on ENTER.
 *   - Disables dragging of block contents.
 *
 * @param {string} clientId Block client ID.
 */

function useEventHandlers(clientId) {
  const isSelected = (0,external_wp_data_namespaceObject.useSelect)(select => select(store).isBlockSelected(clientId), [clientId]);
  const {
    getBlockRootClientId,
    getBlockIndex
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    insertDefaultBlock,
    removeBlock
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    if (!isSelected) {
      return;
    }
    /**
     * Interprets keydown event intent to remove or insert after block if
     * key event occurs on wrapper node. This can occur when the block has
     * no text fields of its own, particularly after initial insertion, to
     * allow for easy deletion and continuous writing flow to add additional
     * content.
     *
     * @param {KeyboardEvent} event Keydown event.
     */


    function onKeyDown(event) {
      const {
        keyCode,
        target
      } = event;

      if (keyCode !== external_wp_keycodes_namespaceObject.ENTER && keyCode !== external_wp_keycodes_namespaceObject.BACKSPACE && keyCode !== external_wp_keycodes_namespaceObject.DELETE) {
        return;
      }

      if (target !== node || (0,external_wp_dom_namespaceObject.isTextField)(target)) {
        return;
      }

      event.preventDefault();

      if (keyCode === external_wp_keycodes_namespaceObject.ENTER) {
        insertDefaultBlock({}, getBlockRootClientId(clientId), getBlockIndex(clientId) + 1);
      } else {
        removeBlock(clientId);
      }
    }
    /**
     * Prevents default dragging behavior within a block. To do: we must
     * handle this in the future and clean up the drag target.
     *
     * @param {DragEvent} event Drag event.
     */


    function onDragStart(event) {
      event.preventDefault();
    }

    node.addEventListener('keydown', onKeyDown);
    node.addEventListener('dragstart', onDragStart);
    return () => {
      node.removeEventListener('keydown', onKeyDown);
      node.removeEventListener('dragstart', onDragStart);
    };
  }, [clientId, isSelected, getBlockRootClientId, getBlockIndex, insertDefaultBlock, removeBlock]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-nav-mode-exit.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Allows navigation mode to be exited by clicking in the selected block.
 *
 * @param {string} clientId Block client ID.
 */

function useNavModeExit(clientId) {
  const {
    isNavigationMode,
    isBlockSelected
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    setNavigationMode,
    selectBlock
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    function onMouseDown(event) {
      // Don't select a block if it's already handled by a child
      // block.
      if (isNavigationMode() && !event.defaultPrevented) {
        // Prevent focus from moving to the block.
        event.preventDefault(); // When clicking on a selected block, exit navigation mode.

        if (isBlockSelected(clientId)) {
          setNavigationMode(false);
        } else {
          selectBlock(clientId);
        }
      }
    }

    node.addEventListener('mousedown', onMouseDown);
    return () => {
      node.addEventListener('mousedown', onMouseDown);
    };
  }, [clientId, isNavigationMode, isBlockSelected, setNavigationMode]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/provider/block-refs-provider.js


/**
 * WordPress dependencies
 */

const BlockRefs = (0,external_wp_element_namespaceObject.createContext)({
  refs: new Map(),
  callbacks: new Map()
});
function BlockRefsProvider({
  children
}) {
  const value = (0,external_wp_element_namespaceObject.useMemo)(() => ({
    refs: new Map(),
    callbacks: new Map()
  }), []);
  return (0,external_wp_element_namespaceObject.createElement)(BlockRefs.Provider, {
    value: value
  }, children);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-refs.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/** @typedef {import('@wordpress/element').RefCallback} RefCallback */

/** @typedef {import('@wordpress/element').RefObject} RefObject */

/**
 * Provides a ref to the BlockRefs context.
 *
 * @param {string} clientId The client ID of the element ref.
 *
 * @return {RefCallback} Ref callback.
 */

function useBlockRefProvider(clientId) {
  const {
    refs,
    callbacks
  } = (0,external_wp_element_namespaceObject.useContext)(BlockRefs);
  const ref = (0,external_wp_element_namespaceObject.useRef)();
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    refs.set(ref, clientId);
    return () => {
      refs.delete(ref);
    };
  }, [clientId]);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(element => {
    // Update the ref in the provider.
    ref.current = element; // Call any update functions.

    callbacks.forEach((id, setElement) => {
      if (clientId === id) {
        setElement(element);
      }
    });
  }, [clientId]);
}
/**
 * Gets a ref pointing to the current block element. Continues to return a
 * stable ref even if the block client ID changes.
 *
 * @param {string} clientId The client ID to get a ref for.
 *
 * @return {RefObject} A ref containing the element.
 */

function useBlockRef(clientId) {
  const {
    refs
  } = (0,external_wp_element_namespaceObject.useContext)(BlockRefs);
  const freshClientId = (0,external_wp_element_namespaceObject.useRef)();
  freshClientId.current = clientId; // Always return an object, even if no ref exists for a given client ID, so
  // that `current` works at a later point.

  return (0,external_wp_element_namespaceObject.useMemo)(() => ({
    get current() {
      let element = null; // Multiple refs may be created for a single block. Find the
      // first that has an element set.

      for (const [ref, id] of refs.entries()) {
        if (id === freshClientId.current && ref.current) {
          element = ref.current;
        }
      }

      return element;
    }

  }), []);
}
/**
 * Return the element for a given client ID. Updates whenever the element
 * changes, becomes available, or disappears.
 *
 * @param {string} clientId The client ID to an element for.
 *
 * @return {Element|null} The block's wrapper element.
 */


function useBlockElement(clientId) {
  const {
    callbacks
  } = (0,external_wp_element_namespaceObject.useContext)(BlockRefs);
  const ref = useBlockRef(clientId);
  const [element, setElement] = (0,external_wp_element_namespaceObject.useState)(null);
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    if (!clientId) {
      return;
    }

    callbacks.set(setElement, clientId);
    return () => {
      callbacks.delete(setElement);
    };
  }, [clientId]);
  return ref.current || element;
}




;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-intersection-observer.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function useIntersectionObserver() {
  const observer = (0,external_wp_element_namespaceObject.useContext)(block_list_IntersectionObserver);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    if (observer) {
      observer.observe(node);
      return () => {
        observer.unobserve(node);
      };
    }
  }, [observer]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-content-overlay/index.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


function useBlockOverlayActive(clientId) {
  return (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      __unstableHasActiveBlockOverlayActive
    } = select(store);
    return __unstableHasActiveBlockOverlayActive(clientId);
  }, [clientId]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */


















/**
 * If the block count exceeds the threshold, we disable the reordering animation
 * to avoid laginess.
 */

const BLOCK_ANIMATION_THRESHOLD = 200;
/**
 * This hook is used to lightly mark an element as a block element. The element
 * should be the outermost element of a block. Call this hook and pass the
 * returned props to the element to mark as a block. If you define a ref for the
 * element, it is important to pass the ref to this hook, which the hook in turn
 * will pass to the component through the props it returns. Optionally, you can
 * also pass any other props through this hook, and they will be merged and
 * returned.
 *
 * @param {Object}  props                    Optional. Props to pass to the element. Must contain
 *                                           the ref if one is defined.
 * @param {Object}  options                  Options for internal use only.
 * @param {boolean} options.__unstableIsHtml
 *
 * @return {Object} Props to pass to the element to mark as a block.
 */

function useBlockProps(props = {}, {
  __unstableIsHtml
} = {}) {
  const {
    clientId,
    className,
    wrapperProps = {},
    isAligned
  } = (0,external_wp_element_namespaceObject.useContext)(BlockListBlockContext);
  const {
    index,
    mode,
    name,
    blockApiVersion,
    blockTitle,
    isPartOfSelection,
    adjustScrolling,
    enableAnimation,
    isSubtreeDisabled
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockAttributes,
      getBlockIndex,
      getBlockMode,
      getBlockName,
      isTyping,
      getGlobalBlockCount,
      isBlockSelected,
      isBlockMultiSelected,
      isAncestorMultiSelected,
      isFirstMultiSelectedBlock,
      isBlockSubtreeDisabled
    } = unlock(select(store));
    const {
      getActiveBlockVariation
    } = select(external_wp_blocks_namespaceObject.store);
    const isSelected = isBlockSelected(clientId);
    const isPartOfMultiSelection = isBlockMultiSelected(clientId) || isAncestorMultiSelected(clientId);
    const blockName = getBlockName(clientId);
    const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockName);
    const attributes = getBlockAttributes(clientId);
    const match = getActiveBlockVariation(blockName, attributes);
    return {
      index: getBlockIndex(clientId),
      mode: getBlockMode(clientId),
      name: blockName,
      blockApiVersion: blockType?.apiVersion || 1,
      blockTitle: match?.title || blockType?.title,
      isPartOfSelection: isSelected || isPartOfMultiSelection,
      adjustScrolling: isSelected || isFirstMultiSelectedBlock(clientId),
      enableAnimation: !isTyping() && getGlobalBlockCount() <= BLOCK_ANIMATION_THRESHOLD,
      isSubtreeDisabled: isBlockSubtreeDisabled(clientId)
    };
  }, [clientId]);
  const hasOverlay = useBlockOverlayActive(clientId); // translators: %s: Type of block (i.e. Text, Image etc)

  const blockLabel = (0,external_wp_i18n_namespaceObject.sprintf)((0,external_wp_i18n_namespaceObject.__)('Block: %s'), blockTitle);
  const htmlSuffix = mode === 'html' && !__unstableIsHtml ? '-visual' : '';
  const mergedRefs = (0,external_wp_compose_namespaceObject.useMergeRefs)([props.ref, useFocusFirstElement(clientId), useBlockRefProvider(clientId), useFocusHandler(clientId), useEventHandlers(clientId), useNavModeExit(clientId), useIsHovered(), useIntersectionObserver(), use_moving_animation({
    isSelected: isPartOfSelection,
    adjustScrolling,
    enableAnimation,
    triggerAnimationOnChange: index
  }), (0,external_wp_compose_namespaceObject.useDisabled)({
    isDisabled: !hasOverlay
  })]);
  const blockEditContext = useBlockEditContext(); // Ensures it warns only inside the `edit` implementation for the block.

  if (blockApiVersion < 2 && clientId === blockEditContext.clientId) {
    typeof process !== "undefined" && process.env && "production" !== "production" ? 0 : void 0;
  }

  return {
    tabIndex: 0,
    ...wrapperProps,
    ...props,
    ref: mergedRefs,
    id: `block-${clientId}${htmlSuffix}`,
    role: 'document',
    'aria-label': blockLabel,
    'data-block': clientId,
    'data-type': name,
    'data-title': blockTitle,
    inert: isSubtreeDisabled ? 'true' : undefined,
    className: classnames_default()( // The wp-block className is important for editor styles.
    classnames_default()('block-editor-block-list__block', {
      'wp-block': !isAligned,
      'has-block-overlay': hasOverlay
    }), className, props.className, wrapperProps.className, useBlockClassNames(clientId), useBlockDefaultClassName(clientId), useBlockCustomClassName(clientId), useBlockMovingModeClassNames(clientId)),
    style: { ...wrapperProps.style,
      ...props.style
    }
  };
}
/**
 * Call within a save function to get the props for the block wrapper.
 *
 * @param {Object} props Optional. Props to pass to the element.
 */

useBlockProps.save = external_wp_blocks_namespaceObject.__unstableGetBlockProps;

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/block.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */











/**
 * Merges wrapper props with special handling for classNames and styles.
 *
 * @param {Object} propsA
 * @param {Object} propsB
 *
 * @return {Object} Merged props.
 */

function mergeWrapperProps(propsA, propsB) {
  const newProps = { ...propsA,
    ...propsB
  };

  if (propsA?.className && propsB?.className) {
    newProps.className = classnames_default()(propsA.className, propsB.className);
  }

  if (propsA?.style && propsB?.style) {
    newProps.style = { ...propsA.style,
      ...propsB.style
    };
  }

  return newProps;
}

function Block({
  children,
  isHtml,
  ...props
}) {
  return (0,external_wp_element_namespaceObject.createElement)("div", { ...useBlockProps(props, {
      __unstableIsHtml: isHtml
    })
  }, children);
}

function BlockListBlock({
  block: {
    __unstableBlockSource
  },
  mode,
  isLocked,
  canRemove,
  clientId,
  isSelected,
  isSelectionEnabled,
  className,
  __unstableLayoutClassNames: layoutClassNames,
  name,
  isValid,
  attributes,
  wrapperProps,
  setAttributes,
  onReplace,
  onInsertBlocksAfter,
  onMerge,
  toggleSelection
}) {
  var _wrapperProps;

  const {
    themeSupportsLayout,
    isTemporarilyEditingAsBlocks,
    blockEditingMode
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getSettings,
      __unstableGetTemporarilyEditingAsBlocks,
      getBlockEditingMode
    } = unlock(select(store));
    return {
      themeSupportsLayout: getSettings().supportsLayout,
      isTemporarilyEditingAsBlocks: __unstableGetTemporarilyEditingAsBlocks() === clientId,
      blockEditingMode: getBlockEditingMode(clientId)
    };
  }, [clientId]);
  const {
    removeBlock
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const onRemove = (0,external_wp_element_namespaceObject.useCallback)(() => removeBlock(clientId), [clientId]);
  const parentLayout = useLayout() || {}; // We wrap the BlockEdit component in a div that hides it when editing in
  // HTML mode. This allows us to render all of the ancillary pieces
  // (InspectorControls, etc.) which are inside `BlockEdit` but not
  // `BlockHTML`, even in HTML mode.

  let blockEdit = (0,external_wp_element_namespaceObject.createElement)(BlockEdit, {
    name: name,
    isSelected: isSelected,
    attributes: attributes,
    setAttributes: setAttributes,
    insertBlocksAfter: isLocked ? undefined : onInsertBlocksAfter,
    onReplace: canRemove ? onReplace : undefined,
    onRemove: canRemove ? onRemove : undefined,
    mergeBlocks: canRemove ? onMerge : undefined,
    clientId: clientId,
    isSelectionEnabled: isSelectionEnabled,
    toggleSelection: toggleSelection,
    __unstableLayoutClassNames: layoutClassNames,
    __unstableParentLayout: Object.keys(parentLayout).length ? parentLayout : undefined
  });
  const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(name);

  if (blockEditingMode === 'disabled') {
    wrapperProps = { ...wrapperProps,
      tabIndex: -1
    };
  } // Determine whether the block has props to apply to the wrapper.


  if (blockType?.getEditWrapperProps) {
    wrapperProps = mergeWrapperProps(wrapperProps, blockType.getEditWrapperProps(attributes));
  }

  const isAligned = wrapperProps && !!wrapperProps['data-align'] && !themeSupportsLayout; // For aligned blocks, provide a wrapper element so the block can be
  // positioned relative to the block column.
  // This is only kept for classic themes that don't support layout
  // Historically we used to rely on extra divs and data-align to
  // provide the alignments styles in the editor.
  // Due to the differences between frontend and backend, we migrated
  // to the layout feature, and we're now aligning the markup of frontend
  // and backend.

  if (isAligned) {
    blockEdit = (0,external_wp_element_namespaceObject.createElement)("div", {
      className: "wp-block",
      "data-align": wrapperProps['data-align']
    }, blockEdit);
  }

  let block;

  if (!isValid) {
    const saveContent = __unstableBlockSource ? (0,external_wp_blocks_namespaceObject.serializeRawBlock)(__unstableBlockSource) : (0,external_wp_blocks_namespaceObject.getSaveContent)(blockType, attributes);
    block = (0,external_wp_element_namespaceObject.createElement)(Block, {
      className: "has-warning"
    }, (0,external_wp_element_namespaceObject.createElement)(BlockInvalidWarning, {
      clientId: clientId
    }), (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.RawHTML, null, (0,external_wp_dom_namespaceObject.safeHTML)(saveContent)));
  } else if (mode === 'html') {
    // Render blockEdit so the inspector controls don't disappear.
    // See #8969.
    block = (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)("div", {
      style: {
        display: 'none'
      }
    }, blockEdit), (0,external_wp_element_namespaceObject.createElement)(Block, {
      isHtml: true
    }, (0,external_wp_element_namespaceObject.createElement)(block_html, {
      clientId: clientId
    })));
  } else if (blockType?.apiVersion > 1) {
    block = blockEdit;
  } else {
    block = (0,external_wp_element_namespaceObject.createElement)(Block, { ...wrapperProps
    }, blockEdit);
  }

  const {
    'data-align': dataAlign,
    ...restWrapperProps
  } = (_wrapperProps = wrapperProps) !== null && _wrapperProps !== void 0 ? _wrapperProps : {};
  const value = {
    clientId,
    className: classnames_default()({
      'is-editing-disabled': blockEditingMode === 'disabled',
      'is-content-locked-temporarily-editing-as-blocks': isTemporarilyEditingAsBlocks
    }, dataAlign && themeSupportsLayout && `align${dataAlign}`, className),
    wrapperProps: restWrapperProps,
    isAligned
  };
  const memoizedValue = (0,external_wp_element_namespaceObject.useMemo)(() => value, Object.values(value));
  return (0,external_wp_element_namespaceObject.createElement)(BlockListBlockContext.Provider, {
    value: memoizedValue
  }, (0,external_wp_element_namespaceObject.createElement)(block_crash_boundary, {
    fallback: (0,external_wp_element_namespaceObject.createElement)(Block, {
      className: "has-warning"
    }, (0,external_wp_element_namespaceObject.createElement)(block_crash_warning, null))
  }, block));
}

const applyWithSelect = (0,external_wp_data_namespaceObject.withSelect)((select, {
  clientId,
  rootClientId
}) => {
  const {
    isBlockSelected,
    getBlockMode,
    isSelectionEnabled,
    getTemplateLock,
    __unstableGetBlockWithoutInnerBlocks,
    canRemoveBlock,
    canMoveBlock
  } = select(store);

  const block = __unstableGetBlockWithoutInnerBlocks(clientId);

  const isSelected = isBlockSelected(clientId);
  const templateLock = getTemplateLock(rootClientId);
  const canRemove = canRemoveBlock(clientId, rootClientId);
  const canMove = canMoveBlock(clientId, rootClientId); // The fallback to `{}` is a temporary fix.
  // This function should never be called when a block is not present in
  // the state. It happens now because the order in withSelect rendering
  // is not correct.

  const {
    name,
    attributes,
    isValid
  } = block || {}; // Do not add new properties here, use `useSelect` instead to avoid
  // leaking new props to the public API (editor.BlockListBlock filter).

  return {
    mode: getBlockMode(clientId),
    isSelectionEnabled: isSelectionEnabled(),
    isLocked: !!templateLock,
    canRemove,
    canMove,
    // Users of the editor.BlockListBlock filter used to be able to
    // access the block prop.
    // Ideally these blocks would rely on the clientId prop only.
    // This is kept for backward compatibility reasons.
    block,
    name,
    attributes,
    isValid,
    isSelected
  };
});
const applyWithDispatch = (0,external_wp_data_namespaceObject.withDispatch)((dispatch, ownProps, registry) => {
  const {
    updateBlockAttributes,
    insertBlocks,
    mergeBlocks,
    replaceBlocks,
    toggleSelection,
    __unstableMarkLastChangeAsPersistent,
    moveBlocksToPosition,
    removeBlock
  } = dispatch(store); // Do not add new properties here, use `useDispatch` instead to avoid
  // leaking new props to the public API (editor.BlockListBlock filter).

  return {
    setAttributes(newAttributes) {
      const {
        getMultiSelectedBlockClientIds
      } = registry.select(store);
      const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds();
      const {
        clientId
      } = ownProps;
      const clientIds = multiSelectedBlockClientIds.length ? multiSelectedBlockClientIds : [clientId];
      updateBlockAttributes(clientIds, newAttributes);
    },

    onInsertBlocks(blocks, index) {
      const {
        rootClientId
      } = ownProps;
      insertBlocks(blocks, index, rootClientId);
    },

    onInsertBlocksAfter(blocks) {
      const {
        clientId,
        rootClientId
      } = ownProps;
      const {
        getBlockIndex
      } = registry.select(store);
      const index = getBlockIndex(clientId);
      insertBlocks(blocks, index + 1, rootClientId);
    },

    onMerge(forward) {
      const {
        clientId,
        rootClientId
      } = ownProps;
      const {
        getPreviousBlockClientId,
        getNextBlockClientId,
        getBlock,
        getBlockAttributes,
        getBlockName,
        getBlockOrder,
        getBlockIndex,
        getBlockRootClientId,
        canInsertBlockType
      } = registry.select(store);
      /**
       * Moves the block with clientId up one level. If the block type
       * cannot be inserted at the new location, it will be attempted to
       * convert to the default block type.
       *
       * @param {string}  _clientId       The block to move.
       * @param {boolean} changeSelection Whether to change the selection
       *                                  to the moved block.
       */

      function moveFirstItemUp(_clientId, changeSelection = true) {
        const targetRootClientId = getBlockRootClientId(_clientId);
        const blockOrder = getBlockOrder(_clientId);
        const [firstClientId] = blockOrder;

        if (blockOrder.length === 1 && (0,external_wp_blocks_namespaceObject.isUnmodifiedBlock)(getBlock(firstClientId))) {
          removeBlock(_clientId);
        } else {
          registry.batch(() => {
            if (canInsertBlockType(getBlockName(firstClientId), targetRootClientId)) {
              moveBlocksToPosition([firstClientId], _clientId, targetRootClientId, getBlockIndex(_clientId));
            } else {
              const replacement = (0,external_wp_blocks_namespaceObject.switchToBlockType)(getBlock(firstClientId), (0,external_wp_blocks_namespaceObject.getDefaultBlockName)());

              if (replacement && replacement.length) {
                insertBlocks(replacement, getBlockIndex(_clientId), targetRootClientId, changeSelection);
                removeBlock(firstClientId, false);
              }
            }

            if (!getBlockOrder(_clientId).length && (0,external_wp_blocks_namespaceObject.isUnmodifiedBlock)(getBlock(_clientId))) {
              removeBlock(_clientId, false);
            }
          });
        }
      } // For `Delete` or forward merge, we should do the exact same thing
      // as `Backspace`, but from the other block.


      if (forward) {
        if (rootClientId) {
          const nextRootClientId = getNextBlockClientId(rootClientId);

          if (nextRootClientId) {
            // If there is a block that follows with the same parent
            // block name and the same attributes, merge the inner
            // blocks.
            if (getBlockName(rootClientId) === getBlockName(nextRootClientId)) {
              const rootAttributes = getBlockAttributes(rootClientId);
              const previousRootAttributes = getBlockAttributes(nextRootClientId);

              if (Object.keys(rootAttributes).every(key => rootAttributes[key] === previousRootAttributes[key])) {
                registry.batch(() => {
                  moveBlocksToPosition(getBlockOrder(nextRootClientId), nextRootClientId, rootClientId);
                  removeBlock(nextRootClientId, false);
                });
                return;
              }
            } else {
              mergeBlocks(rootClientId, nextRootClientId);
              return;
            }
          }
        }

        const nextBlockClientId = getNextBlockClientId(clientId);

        if (!nextBlockClientId) {
          return;
        }

        if (getBlockOrder(nextBlockClientId).length) {
          moveFirstItemUp(nextBlockClientId, false);
        } else {
          mergeBlocks(clientId, nextBlockClientId);
        }
      } else {
        const previousBlockClientId = getPreviousBlockClientId(clientId);

        if (previousBlockClientId) {
          mergeBlocks(previousBlockClientId, clientId);
        } else if (rootClientId) {
          const previousRootClientId = getPreviousBlockClientId(rootClientId); // If there is a preceding block with the same parent block
          // name and the same attributes, merge the inner blocks.

          if (previousRootClientId && getBlockName(rootClientId) === getBlockName(previousRootClientId)) {
            const rootAttributes = getBlockAttributes(rootClientId);
            const previousRootAttributes = getBlockAttributes(previousRootClientId);

            if (Object.keys(rootAttributes).every(key => rootAttributes[key] === previousRootAttributes[key])) {
              registry.batch(() => {
                moveBlocksToPosition(getBlockOrder(rootClientId), rootClientId, previousRootClientId);
                removeBlock(rootClientId, false);
              });
              return;
            }
          }

          moveFirstItemUp(rootClientId);
        }
      }
    },

    onReplace(blocks, indexToSelect, initialPosition) {
      if (blocks.length && !(0,external_wp_blocks_namespaceObject.isUnmodifiedDefaultBlock)(blocks[blocks.length - 1])) {
        __unstableMarkLastChangeAsPersistent();
      }

      replaceBlocks([ownProps.clientId], blocks, indexToSelect, initialPosition);
    },

    toggleSelection(selectionEnabled) {
      toggleSelection(selectionEnabled);
    }

  };
});
/* harmony default export */ var block = ((0,external_wp_compose_namespaceObject.compose)(external_wp_compose_namespaceObject.pure, applyWithSelect, applyWithDispatch, // Block is sometimes not mounted at the right time, causing it be undefined
// see issue for more info
// https://github.com/WordPress/gutenberg/issues/17013
(0,external_wp_compose_namespaceObject.ifCondition)(({
  block
}) => !!block), (0,external_wp_components_namespaceObject.withFilters)('editor.BlockListBlock'))(BlockListBlock));

;// CONCATENATED MODULE: external ["wp","htmlEntities"]
var external_wp_htmlEntities_namespaceObject = window["wp"]["htmlEntities"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/plus.js


/**
 * WordPress dependencies
 */

const plus = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M18 11.2h-5.2V6h-1.6v5.2H6v1.6h5.2V18h1.6v-5.2H18z"
}));
/* harmony default export */ var library_plus = (plus);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/tips.js


/**
 * WordPress dependencies
 */



const globalTips = [(0,external_wp_element_namespaceObject.createInterpolateElement)((0,external_wp_i18n_namespaceObject.__)('While writing, you can press <kbd>/</kbd> to quickly insert new blocks.'), {
  kbd: (0,external_wp_element_namespaceObject.createElement)("kbd", null)
}), (0,external_wp_element_namespaceObject.createInterpolateElement)((0,external_wp_i18n_namespaceObject.__)('Indent a list by pressing <kbd>space</kbd> at the beginning of a line.'), {
  kbd: (0,external_wp_element_namespaceObject.createElement)("kbd", null)
}), (0,external_wp_element_namespaceObject.createInterpolateElement)((0,external_wp_i18n_namespaceObject.__)('Outdent a list by pressing <kbd>backspace</kbd> at the beginning of a line.'), {
  kbd: (0,external_wp_element_namespaceObject.createElement)("kbd", null)
}), (0,external_wp_i18n_namespaceObject.__)('Drag files into the editor to automatically insert media blocks.'), (0,external_wp_i18n_namespaceObject.__)("Change a block's type by pressing the block icon on the toolbar.")];

function Tips() {
  const [randomIndex] = (0,external_wp_element_namespaceObject.useState)( // Disable Reason: I'm not generating an HTML id.
  // eslint-disable-next-line no-restricted-syntax
  Math.floor(Math.random() * globalTips.length));
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Tip, null, globalTips[randomIndex]);
}

/* harmony default export */ var tips = (Tips);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/chevron-right.js


/**
 * WordPress dependencies
 */

const chevronRight = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M10.6 6L9.4 7l4.6 5-4.6 5 1.2 1 5.4-6z"
}));
/* harmony default export */ var chevron_right = (chevronRight);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/chevron-left.js


/**
 * WordPress dependencies
 */

const chevronLeft = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M14.6 7l-1.2-1L8 12l5.4 6 1.2-1-4.6-5z"
}));
/* harmony default export */ var chevron_left = (chevronLeft);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/block-default.js


/**
 * WordPress dependencies
 */

const blockDefault = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M19 8h-1V6h-5v2h-2V6H6v2H5c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-8c0-1.1-.9-2-2-2zm.5 10c0 .3-.2.5-.5.5H5c-.3 0-.5-.2-.5-.5v-8c0-.3.2-.5.5-.5h14c.3 0 .5.2.5.5v8z"
}));
/* harmony default export */ var block_default = (blockDefault);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-icon/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





function BlockIcon({
  icon,
  showColors = false,
  className,
  context
}) {
  if (icon?.src === 'block-default') {
    icon = {
      src: block_default
    };
  }

  const renderedIcon = (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Icon, {
    icon: icon && icon.src ? icon.src : icon,
    context: context
  });
  const style = showColors ? {
    backgroundColor: icon && icon.background,
    color: icon && icon.foreground
  } : {};
  return (0,external_wp_element_namespaceObject.createElement)("span", {
    style: style,
    className: classnames_default()('block-editor-block-icon', className, {
      'has-colors': showColors
    })
  }, renderedIcon);
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-icon/README.md
 */


/* harmony default export */ var block_icon = ((0,external_wp_element_namespaceObject.memo)(BlockIcon));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-card/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




function BlockCard({
  title,
  icon,
  description,
  blockType,
  className
}) {
  if (blockType) {
    external_wp_deprecated_default()('`blockType` property in `BlockCard component`', {
      since: '5.7',
      alternative: '`title, icon and description` properties'
    });
    ({
      title,
      icon,
      description
    } = blockType);
  }

  const {
    parentNavBlockClientId
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getSelectedBlockClientId,
      getBlockParentsByBlockName
    } = select(store);

    const _selectedBlockClientId = getSelectedBlockClientId();

    return {
      parentNavBlockClientId: getBlockParentsByBlockName(_selectedBlockClientId, 'core/navigation', true)[0]
    };
  }, []);
  const {
    selectBlock
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: classnames_default()('block-editor-block-card', className)
  }, parentNavBlockClientId && // This is only used by the Navigation block for now. It's not ideal having Navigation block specific code here.
  (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    onClick: () => selectBlock(parentNavBlockClientId),
    label: (0,external_wp_i18n_namespaceObject.__)('Go to parent Navigation block'),
    style: // TODO: This style override is also used in ToolsPanelHeader.
    // It should be supported out-of-the-box by Button.
    {
      minWidth: 24,
      padding: 0
    },
    icon: (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_right : chevron_left,
    isSmall: true
  }), (0,external_wp_element_namespaceObject.createElement)(block_icon, {
    icon: icon,
    showColors: true
  }), (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-card__content"
  }, (0,external_wp_element_namespaceObject.createElement)("h2", {
    className: "block-editor-block-card__title"
  }, title), (0,external_wp_element_namespaceObject.createElement)("span", {
    className: "block-editor-block-card__description"
  }, description)));
}

/* harmony default export */ var block_card = (BlockCard);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/provider/with-registry-provider.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



const withRegistryProvider = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(WrappedComponent => {
  return (0,external_wp_data_namespaceObject.withRegistry)(({
    useSubRegistry = true,
    registry,
    ...props
  }) => {
    if (!useSubRegistry) {
      return (0,external_wp_element_namespaceObject.createElement)(WrappedComponent, {
        registry: registry,
        ...props
      });
    }

    const [subRegistry, setSubRegistry] = (0,external_wp_element_namespaceObject.useState)(null);
    (0,external_wp_element_namespaceObject.useEffect)(() => {
      const newRegistry = (0,external_wp_data_namespaceObject.createRegistry)({}, registry);
      newRegistry.registerStore(STORE_NAME, storeConfig);
      setSubRegistry(newRegistry);
    }, [registry]);

    if (!subRegistry) {
      return null;
    }

    return (0,external_wp_element_namespaceObject.createElement)(external_wp_data_namespaceObject.RegistryProvider, {
      value: subRegistry
    }, (0,external_wp_element_namespaceObject.createElement)(WrappedComponent, {
      registry: subRegistry,
      ...props
    }));
  });
}, 'withRegistryProvider');
/* harmony default export */ var with_registry_provider = (withRegistryProvider);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/provider/use-block-sync.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



const use_block_sync_noop = () => {};
/**
 * A function to call when the block value has been updated in the block-editor
 * store.
 *
 * @callback onBlockUpdate
 * @param {Object[]} blocks  The updated blocks.
 * @param {Object}   options The updated block options, such as selectionStart
 *                           and selectionEnd.
 */

/**
 * useBlockSync is a side effect which handles bidirectional sync between the
 * block-editor store and a controlling data source which provides blocks. This
 * is most commonly used by the BlockEditorProvider to synchronize the contents
 * of the block-editor store with the root entity, like a post.
 *
 * Another example would be the template part block, which provides blocks from
 * a separate entity data source than a root entity. This hook syncs edits to
 * the template part in the block editor back to the entity and vice-versa.
 *
 * Here are some of its basic functions:
 * - Initalizes the block-editor store for the given clientID to the blocks
 *   given via props.
 * - Adds incoming changes (like undo) to the block-editor store.
 * - Adds outgoing changes (like editing content) to the controlling entity,
 *   determining if a change should be considered persistent or not.
 * - Handles edge cases and race conditions which occur in those operations.
 * - Ignores changes which happen to other entities (like nested inner block
 *   controllers.
 * - Passes selection state from the block-editor store to the controlling entity.
 *
 * @param {Object}        props           Props for the block sync hook
 * @param {string}        props.clientId  The client ID of the inner block controller.
 *                                        If none is passed, then it is assumed to be a
 *                                        root controller rather than an inner block
 *                                        controller.
 * @param {Object[]}      props.value     The control value for the blocks. This value
 *                                        is used to initalize the block-editor store
 *                                        and for resetting the blocks to incoming
 *                                        changes like undo.
 * @param {Object}        props.selection The selection state responsible to restore the selection on undo/redo.
 * @param {onBlockUpdate} props.onChange  Function to call when a persistent
 *                                        change has been made in the block-editor blocks
 *                                        for the given clientId. For example, after
 *                                        this function is called, an entity is marked
 *                                        dirty because it has changes to save.
 * @param {onBlockUpdate} props.onInput   Function to call when a non-persistent
 *                                        change has been made in the block-editor blocks
 *                                        for the given clientId. When this is called,
 *                                        controlling sources do not become dirty.
 */


function useBlockSync({
  clientId = null,
  value: controlledBlocks,
  selection: controlledSelection,
  onChange = use_block_sync_noop,
  onInput = use_block_sync_noop
}) {
  const registry = (0,external_wp_data_namespaceObject.useRegistry)();
  const {
    resetBlocks,
    resetSelection,
    replaceInnerBlocks,
    selectBlock,
    setHasControlledInnerBlocks,
    __unstableMarkNextChangeAsNotPersistent
  } = registry.dispatch(store);
  const {
    hasSelectedBlock,
    getBlockName,
    getBlocks,
    getSelectionStart,
    getSelectionEnd,
    getBlock
  } = registry.select(store);
  const isControlled = (0,external_wp_data_namespaceObject.useSelect)(select => {
    return !clientId || select(store).areInnerBlocksControlled(clientId);
  }, [clientId]);
  const pendingChanges = (0,external_wp_element_namespaceObject.useRef)({
    incoming: null,
    outgoing: []
  });
  const subscribed = (0,external_wp_element_namespaceObject.useRef)(false);

  const setControlledBlocks = () => {
    if (!controlledBlocks) {
      return;
    } // We don't need to persist this change because we only replace
    // controlled inner blocks when the change was caused by an entity,
    // and so it would already be persisted.


    __unstableMarkNextChangeAsNotPersistent();

    if (clientId) {
      // It is important to batch here because otherwise,
      // as soon as `setHasControlledInnerBlocks` is called
      // the effect to restore might be triggered
      // before the actual blocks get set properly in state.
      registry.batch(() => {
        setHasControlledInnerBlocks(clientId, true);
        const storeBlocks = controlledBlocks.map(block => (0,external_wp_blocks_namespaceObject.cloneBlock)(block));

        if (subscribed.current) {
          pendingChanges.current.incoming = storeBlocks;
        }

        __unstableMarkNextChangeAsNotPersistent();

        replaceInnerBlocks(clientId, storeBlocks);
      });
    } else {
      if (subscribed.current) {
        pendingChanges.current.incoming = controlledBlocks;
      }

      resetBlocks(controlledBlocks);
    }
  }; // Clean up the changes made by setControlledBlocks() when the component
  // containing useBlockSync() unmounts.


  const unsetControlledBlocks = () => {
    __unstableMarkNextChangeAsNotPersistent();

    if (clientId) {
      setHasControlledInnerBlocks(clientId, false);

      __unstableMarkNextChangeAsNotPersistent();

      replaceInnerBlocks(clientId, []);
    } else {
      resetBlocks([]);
    }
  }; // Add a subscription to the block-editor registry to detect when changes
  // have been made. This lets us inform the data source of changes. This
  // is an effect so that the subscriber can run synchronously without
  // waiting for React renders for changes.


  const onInputRef = (0,external_wp_element_namespaceObject.useRef)(onInput);
  const onChangeRef = (0,external_wp_element_namespaceObject.useRef)(onChange);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    onInputRef.current = onInput;
    onChangeRef.current = onChange;
  }, [onInput, onChange]); // Determine if blocks need to be reset when they change.

  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (pendingChanges.current.outgoing.includes(controlledBlocks)) {
      // Skip block reset if the value matches expected outbound sync
      // triggered by this component by a preceding change detection.
      // Only skip if the value matches expectation, since a reset should
      // still occur if the value is modified (not equal by reference),
      // to allow that the consumer may apply modifications to reflect
      // back on the editor.
      if (pendingChanges.current.outgoing[pendingChanges.current.outgoing.length - 1] === controlledBlocks) {
        pendingChanges.current.outgoing = [];
      }
    } else if (getBlocks(clientId) !== controlledBlocks) {
      // Reset changing value in all other cases than the sync described
      // above. Since this can be reached in an update following an out-
      // bound sync, unset the outbound value to avoid considering it in
      // subsequent renders.
      pendingChanges.current.outgoing = [];
      const hadSelecton = hasSelectedBlock();
      const selectionAnchor = getSelectionStart();
      const selectionFocus = getSelectionEnd();
      setControlledBlocks();

      if (controlledSelection) {
        resetSelection(controlledSelection.selectionStart, controlledSelection.selectionEnd, controlledSelection.initialPosition);
      } else {
        const selectionStillExists = getBlock(selectionAnchor.clientId);

        if (hadSelecton && !selectionStillExists) {
          selectBlock(clientId);
        } else {
          resetSelection(selectionAnchor, selectionFocus);
        }
      }
    }
  }, [controlledBlocks, clientId]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    // When the block becomes uncontrolled, it means its inner state has been reset
    // we need to take the blocks again from the external value property.
    if (!isControlled) {
      pendingChanges.current.outgoing = [];
      setControlledBlocks();
    }
  }, [isControlled]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    const {
      getSelectedBlocksInitialCaretPosition,
      isLastBlockChangePersistent,
      __unstableIsLastBlockChangeIgnored,
      areInnerBlocksControlled
    } = registry.select(store);
    let blocks = getBlocks(clientId);
    let isPersistent = isLastBlockChangePersistent();
    let previousAreBlocksDifferent = false;
    subscribed.current = true;
    const unsubscribe = registry.subscribe(() => {
      // Sometimes, when changing block lists, lingering subscriptions
      // might trigger before they are cleaned up. If the block for which
      // the subscription runs is no longer in the store, this would clear
      // its parent entity's block list. To avoid this, we bail out if
      // the subscription is triggering for a block (`clientId !== null`)
      // and its block name can't be found because it's not on the list.
      // (`getBlockName( clientId ) === null`).
      if (clientId !== null && getBlockName(clientId) === null) return; // When RESET_BLOCKS on parent blocks get called, the controlled blocks
      // can reset to uncontrolled, in these situations, it means we need to populate
      // the blocks again from the external blocks (the value property here)
      // and we should stop triggering onChange

      const isStillControlled = !clientId || areInnerBlocksControlled(clientId);

      if (!isStillControlled) {
        return;
      }

      const newIsPersistent = isLastBlockChangePersistent();
      const newBlocks = getBlocks(clientId);
      const areBlocksDifferent = newBlocks !== blocks;
      blocks = newBlocks;

      if (areBlocksDifferent && (pendingChanges.current.incoming || __unstableIsLastBlockChangeIgnored())) {
        pendingChanges.current.incoming = null;
        isPersistent = newIsPersistent;
        return;
      } // Since we often dispatch an action to mark the previous action as
      // persistent, we need to make sure that the blocks changed on the
      // previous action before committing the change.


      const didPersistenceChange = previousAreBlocksDifferent && !areBlocksDifferent && newIsPersistent && !isPersistent;

      if (areBlocksDifferent || didPersistenceChange) {
        isPersistent = newIsPersistent; // We know that onChange/onInput will update controlledBlocks.
        // We need to be aware that it was caused by an outgoing change
        // so that we do not treat it as an incoming change later on,
        // which would cause a block reset.

        pendingChanges.current.outgoing.push(blocks); // Inform the controlling entity that changes have been made to
        // the block-editor store they should be aware about.

        const updateParent = isPersistent ? onChangeRef.current : onInputRef.current;
        updateParent(blocks, {
          selection: {
            selectionStart: getSelectionStart(),
            selectionEnd: getSelectionEnd(),
            initialPosition: getSelectedBlocksInitialCaretPosition()
          }
        });
      }

      previousAreBlocksDifferent = areBlocksDifferent;
    });
    return () => {
      subscribed.current = false;
      unsubscribe();
    };
  }, [registry, clientId]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    return () => {
      unsetControlledBlocks();
    };
  }, []);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/provider/index.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */






/** @typedef {import('@wordpress/data').WPDataRegistry} WPDataRegistry */

const ExperimentalBlockEditorProvider = with_registry_provider(props => {
  const {
    children,
    settings,
    stripExperimentalSettings = false
  } = props;
  const {
    __experimentalUpdateSettings
  } = unlock((0,external_wp_data_namespaceObject.useDispatch)(store));
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    __experimentalUpdateSettings({ ...settings,
      __internalIsInitialized: true
    }, stripExperimentalSettings);
  }, [settings]); // Syncs the entity provider with changes in the block-editor store.

  useBlockSync(props);
  return (0,external_wp_element_namespaceObject.createElement)(BlockRefsProvider, null, children);
});
const BlockEditorProvider = props => {
  return (0,external_wp_element_namespaceObject.createElement)(ExperimentalBlockEditorProvider, { ...props,
    stripExperimentalSettings: true
  }, props.children);
};
/* harmony default export */ var provider = (BlockEditorProvider);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-selection-clearer/index.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Pass the returned ref callback to an element that should clear block
 * selection. Selection will only be cleared if the element is clicked directly,
 * not if a child element is clicked.
 *
 * @return {import('react').RefCallback} Ref callback.
 */

function useBlockSelectionClearer() {
  const {
    getSettings,
    hasSelectedBlock,
    hasMultiSelection
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    clearSelectedBlock
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const {
    clearBlockSelection: isEnabled
  } = getSettings();
  return (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    if (!isEnabled) {
      return;
    }

    function onMouseDown(event) {
      if (!hasSelectedBlock() && !hasMultiSelection()) {
        return;
      } // Only handle clicks on the element, not the children.


      if (event.target !== node) {
        return;
      }

      clearSelectedBlock();
    }

    node.addEventListener('mousedown', onMouseDown);
    return () => {
      node.removeEventListener('mousedown', onMouseDown);
    };
  }, [hasSelectedBlock, hasMultiSelection, clearSelectedBlock, isEnabled]);
}
function BlockSelectionClearer(props) {
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    ref: useBlockSelectionClearer(),
    ...props
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-multi-selection.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function selector(select) {
  const {
    isMultiSelecting,
    getMultiSelectedBlockClientIds,
    hasMultiSelection,
    getSelectedBlockClientId,
    getSelectedBlocksInitialCaretPosition,
    __unstableIsFullySelected
  } = select(store);
  return {
    isMultiSelecting: isMultiSelecting(),
    multiSelectedBlockClientIds: getMultiSelectedBlockClientIds(),
    hasMultiSelection: hasMultiSelection(),
    selectedBlockClientId: getSelectedBlockClientId(),
    initialPosition: getSelectedBlocksInitialCaretPosition(),
    isFullSelection: __unstableIsFullySelected()
  };
}

function useMultiSelection() {
  const {
    initialPosition,
    isMultiSelecting,
    multiSelectedBlockClientIds,
    hasMultiSelection,
    selectedBlockClientId,
    isFullSelection
  } = (0,external_wp_data_namespaceObject.useSelect)(selector, []);
  /**
   * When the component updates, and there is multi selection, we need to
   * select the entire block contents.
   */

  return (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    const {
      ownerDocument
    } = node;
    const {
      defaultView
    } = ownerDocument; // Allow initialPosition to bypass focus behavior. This is useful
    // for the list view or other areas where we don't want to transfer
    // focus to the editor canvas.

    if (initialPosition === undefined || initialPosition === null) {
      return;
    }

    if (!hasMultiSelection || isMultiSelecting) {
      return;
    }

    const {
      length
    } = multiSelectedBlockClientIds;

    if (length < 2) {
      return;
    }

    if (!isFullSelection) {
      return;
    } // Allow cross contentEditable selection by temporarily making
    // all content editable. We can't rely on using the store and
    // React because re-rending happens too slowly. We need to be
    // able to select across instances immediately.


    node.contentEditable = true; // For some browsers, like Safari, it is important that focus
    // happens BEFORE selection removal.

    node.focus();
    defaultView.getSelection().removeAllRanges();
  }, [hasMultiSelection, isMultiSelecting, multiSelectedBlockClientIds, selectedBlockClientId, initialPosition, isFullSelection]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-tab-nav.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


function useTabNav() {
  const container = (0,external_wp_element_namespaceObject.useRef)();
  const focusCaptureBeforeRef = (0,external_wp_element_namespaceObject.useRef)();
  const focusCaptureAfterRef = (0,external_wp_element_namespaceObject.useRef)();
  const lastFocus = (0,external_wp_element_namespaceObject.useRef)();
  const {
    hasMultiSelection,
    getSelectedBlockClientId,
    getBlockCount
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    setNavigationMode
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const isNavigationMode = (0,external_wp_data_namespaceObject.useSelect)(select => select(store).isNavigationMode(), []); // Don't allow tabbing to this element in Navigation mode.

  const focusCaptureTabIndex = !isNavigationMode ? '0' : undefined; // Reference that holds the a flag for enabling or disabling
  // capturing on the focus capture elements.

  const noCapture = (0,external_wp_element_namespaceObject.useRef)();

  function onFocusCapture(event) {
    // Do not capture incoming focus if set by us in WritingFlow.
    if (noCapture.current) {
      noCapture.current = null;
    } else if (hasMultiSelection()) {
      container.current.focus();
    } else if (getSelectedBlockClientId()) {
      lastFocus.current.focus();
    } else {
      setNavigationMode(true);
      const canvasElement = container.current.ownerDocument === event.target.ownerDocument ? container.current : container.current.ownerDocument.defaultView.frameElement;
      const isBefore = // eslint-disable-next-line no-bitwise
      event.target.compareDocumentPosition(canvasElement) & event.target.DOCUMENT_POSITION_FOLLOWING;
      const tabbables = external_wp_dom_namespaceObject.focus.tabbable.find(container.current);

      if (tabbables.length) {
        const next = isBefore ? tabbables[0] : tabbables[tabbables.length - 1];
        next.focus();
      }
    }
  }

  const before = (0,external_wp_element_namespaceObject.createElement)("div", {
    ref: focusCaptureBeforeRef,
    tabIndex: focusCaptureTabIndex,
    onFocus: onFocusCapture
  });
  const after = (0,external_wp_element_namespaceObject.createElement)("div", {
    ref: focusCaptureAfterRef,
    tabIndex: focusCaptureTabIndex,
    onFocus: onFocusCapture
  });
  const ref = (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }

      if (event.keyCode === external_wp_keycodes_namespaceObject.ESCAPE && !hasMultiSelection()) {
        event.preventDefault();
        setNavigationMode(true);
        return;
      } // In Edit mode, Tab should focus the first tabbable element after
      // the content, which is normally the sidebar (with block controls)
      // and Shift+Tab should focus the first tabbable element before the
      // content, which is normally the block toolbar.
      // Arrow keys can be used, and Tab and arrow keys can be used in
      // Navigation mode (press Esc), to navigate through blocks.


      if (event.keyCode !== external_wp_keycodes_namespaceObject.TAB) {
        return;
      }

      const isShift = event.shiftKey;
      const direction = isShift ? 'findPrevious' : 'findNext';

      if (!hasMultiSelection() && !getSelectedBlockClientId()) {
        // Preserve the behaviour of entering navigation mode when
        // tabbing into the content without a block selection.
        // `onFocusCapture` already did this previously, but we need to
        // do it again here because after clearing block selection,
        // focus land on the writing flow container and pressing Tab
        // will no longer send focus through the focus capture element.
        if (event.target === node) setNavigationMode(true);
        return;
      } // We want to constrain the tabbing to the block and its child blocks.
      // If the preceding form element is within a different block,
      // such as two sibling image blocks in the placeholder state,
      // we want shift + tab from the first form element to move to the image
      // block toolbar and not the previous image block's form element.
      // TODO: Should this become a utility function?

      /**
       * Determine whether an element is part of or is the selected block.
       *
       * @param {Object} selectedBlockElement
       * @param {Object} element
       * @return {boolean} Whether the element is part of or is the selected block.
       */


      const isElementPartOfSelectedBlock = (selectedBlockElement, element) => {
        // Check if the element is or is within the selected block by finding the
        // closest element with a data-block attribute and seeing if
        // it matches our current selected block ID
        const elementBlockId = element.closest('[data-block]')?.getAttribute('data-block');
        const isElementSameBlock = elementBlockId === getSelectedBlockClientId(); // Check if the element is a child of the selected block. This could be a
        // child block in a group or column block, etc.

        const isElementChildOfBlock = selectedBlockElement.contains(element);
        return isElementSameBlock || isElementChildOfBlock;
      };

      const nextTabbable = external_wp_dom_namespaceObject.focus.tabbable[direction](event.target); // Allow tabbing from the block wrapper to a form element,
      // and between form elements rendered in a block and its child blocks,
      // such as inside a placeholder. Form elements are generally
      // meant to be UI rather than part of the content. Ideally
      // these are not rendered in the content and perhaps in the
      // future they can be rendered in an iframe or shadow DOM.

      if ((0,external_wp_dom_namespaceObject.isFormElement)(nextTabbable) && isElementPartOfSelectedBlock(event.target.closest('[data-block]'), nextTabbable)) {
        return;
      }

      const next = isShift ? focusCaptureBeforeRef : focusCaptureAfterRef; // Disable focus capturing on the focus capture element, so it
      // doesn't refocus this block and so it allows default behaviour
      // (moving focus to the next tabbable element).

      noCapture.current = true; // Focusing the focus capture element, which is located above and
      // below the editor, should not scroll the page all the way up or
      // down.

      next.current.focus({
        preventScroll: true
      });
    }

    function onFocusOut(event) {
      lastFocus.current = event.target;
      const {
        ownerDocument
      } = node; // If focus disappears due to there being no blocks, move focus to
      // the writing flow wrapper.

      if (!event.relatedTarget && ownerDocument.activeElement === ownerDocument.body && getBlockCount() === 0) {
        node.focus();
      }
    } // When tabbing back to an element in block list, this event handler prevents scrolling if the
    // focus capture divs (before/after) are outside of the viewport. (For example shift+tab back to a paragraph
    // when focus is on a sidebar element. This prevents the scrollable writing area from jumping either to the
    // top or bottom of the document.
    //
    // Note that it isn't possible to disable scrolling in the onFocus event. We need to intercept this
    // earlier in the keypress handler, and call focus( { preventScroll: true } ) instead.
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLOrForeignElement/focus#parameters


    function preventScrollOnTab(event) {
      if (event.keyCode !== external_wp_keycodes_namespaceObject.TAB) {
        return;
      }

      if (event.target?.getAttribute('role') === 'region') {
        return;
      }

      if (container.current === event.target) {
        return;
      }

      const isShift = event.shiftKey;
      const direction = isShift ? 'findPrevious' : 'findNext';
      const target = external_wp_dom_namespaceObject.focus.tabbable[direction](event.target); // Only do something when the next tabbable is a focus capture div (before/after)

      if (target === focusCaptureBeforeRef.current || target === focusCaptureAfterRef.current) {
        event.preventDefault();
        target.focus({
          preventScroll: true
        });
      }
    }

    const {
      ownerDocument
    } = node;
    const {
      defaultView
    } = ownerDocument;
    defaultView.addEventListener('keydown', preventScrollOnTab);
    node.addEventListener('keydown', onKeyDown);
    node.addEventListener('focusout', onFocusOut);
    return () => {
      defaultView.removeEventListener('keydown', preventScrollOnTab);
      node.removeEventListener('keydown', onKeyDown);
      node.removeEventListener('focusout', onFocusOut);
    };
  }, []);
  const mergedRefs = (0,external_wp_compose_namespaceObject.useMergeRefs)([container, ref]);
  return [before, mergedRefs, after];
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-arrow-nav.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



/**
 * Returns true if the element should consider edge navigation upon a keyboard
 * event of the given directional key code, or false otherwise.
 *
 * @param {Element} element     HTML element to test.
 * @param {number}  keyCode     KeyboardEvent keyCode to test.
 * @param {boolean} hasModifier Whether a modifier is pressed.
 *
 * @return {boolean} Whether element should consider edge navigation.
 */

function isNavigationCandidate(element, keyCode, hasModifier) {
  const isVertical = keyCode === external_wp_keycodes_namespaceObject.UP || keyCode === external_wp_keycodes_namespaceObject.DOWN;
  const {
    tagName
  } = element;
  const elementType = element.getAttribute('type'); // Native inputs should not navigate vertically, unless they are simple types that don't need up/down arrow keys.

  if (isVertical && !hasModifier) {
    if (tagName === 'INPUT') {
      const verticalInputTypes = ['date', 'datetime-local', 'month', 'number', 'range', 'time', 'week'];
      return !verticalInputTypes.includes(elementType);
    }

    return true;
  } // Native inputs should not navigate horizontally, unless they are simple types that don't need left/right arrow keys.


  if (tagName === 'INPUT') {
    const simpleInputTypes = ['button', 'checkbox', 'number', 'color', 'file', 'image', 'radio', 'reset', 'submit'];
    return simpleInputTypes.includes(elementType);
  } // Native textareas should not navigate horizontally.


  return tagName !== 'TEXTAREA';
}
/**
 * Returns the optimal tab target from the given focused element in the desired
 * direction. A preference is made toward text fields, falling back to the block
 * focus stop if no other candidates exist for the block.
 *
 * @param {Element} target           Currently focused text field.
 * @param {boolean} isReverse        True if considering as the first field.
 * @param {Element} containerElement Element containing all blocks.
 * @param {boolean} onlyVertical     Whether to only consider tabbable elements
 *                                   that are visually above or under the
 *                                   target.
 *
 * @return {?Element} Optimal tab target, if one exists.
 */

function getClosestTabbable(target, isReverse, containerElement, onlyVertical) {
  // Since the current focus target is not guaranteed to be a text field, find
  // all focusables. Tabbability is considered later.
  let focusableNodes = external_wp_dom_namespaceObject.focus.focusable.find(containerElement);

  if (isReverse) {
    focusableNodes.reverse();
  } // Consider as candidates those focusables after the current target. It's
  // assumed this can only be reached if the target is focusable (on its
  // keydown event), so no need to verify it exists in the set.


  focusableNodes = focusableNodes.slice(focusableNodes.indexOf(target) + 1);
  let targetRect;

  if (onlyVertical) {
    targetRect = target.getBoundingClientRect();
  }

  function isTabCandidate(node) {
    // Skip if there's only one child that is content editable (and thus a
    // better candidate).
    if (node.children.length === 1 && isInSameBlock(node, node.firstElementChild) && node.firstElementChild.getAttribute('contenteditable') === 'true') {
      return;
    } // Not a candidate if the node is not tabbable.


    if (!external_wp_dom_namespaceObject.focus.tabbable.isTabbableIndex(node)) {
      return false;
    } // Skip focusable elements such as links within content editable nodes.


    if (node.isContentEditable && node.contentEditable !== 'true') {
      return false;
    }

    if (onlyVertical) {
      const nodeRect = node.getBoundingClientRect();

      if (nodeRect.left >= targetRect.right || nodeRect.right <= targetRect.left) {
        return false;
      }
    }

    return true;
  }

  return focusableNodes.find(isTabCandidate);
}
function useArrowNav() {
  const {
    getMultiSelectedBlocksStartClientId,
    getMultiSelectedBlocksEndClientId,
    getSettings,
    hasMultiSelection,
    __unstableIsFullySelected
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    selectBlock
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    // Here a DOMRect is stored while moving the caret vertically so
    // vertical position of the start position can be restored. This is to
    // recreate browser behaviour across blocks.
    let verticalRect;

    function onMouseDown() {
      verticalRect = null;
    }

    function isClosestTabbableABlock(target, isReverse) {
      const closestTabbable = getClosestTabbable(target, isReverse, node);
      return closestTabbable && getBlockClientId(closestTabbable);
    }

    function onKeyDown(event) {
      // Abort if navigation has already been handled (e.g. RichText
      // inline boundaries).
      if (event.defaultPrevented) {
        return;
      }

      const {
        keyCode,
        target,
        shiftKey,
        ctrlKey,
        altKey,
        metaKey
      } = event;
      const isUp = keyCode === external_wp_keycodes_namespaceObject.UP;
      const isDown = keyCode === external_wp_keycodes_namespaceObject.DOWN;
      const isLeft = keyCode === external_wp_keycodes_namespaceObject.LEFT;
      const isRight = keyCode === external_wp_keycodes_namespaceObject.RIGHT;
      const isReverse = isUp || isLeft;
      const isHorizontal = isLeft || isRight;
      const isVertical = isUp || isDown;
      const isNav = isHorizontal || isVertical;
      const hasModifier = shiftKey || ctrlKey || altKey || metaKey;
      const isNavEdge = isVertical ? external_wp_dom_namespaceObject.isVerticalEdge : external_wp_dom_namespaceObject.isHorizontalEdge;
      const {
        ownerDocument
      } = node;
      const {
        defaultView
      } = ownerDocument;

      if (!isNav) {
        return;
      } // If there is a multi-selection, the arrow keys should collapse the
      // selection to the start or end of the selection.


      if (hasMultiSelection()) {
        if (shiftKey) {
          return;
        } // Only handle if we have a full selection (not a native partial
        // selection).


        if (!__unstableIsFullySelected()) {
          return;
        }

        event.preventDefault();

        if (isReverse) {
          selectBlock(getMultiSelectedBlocksStartClientId());
        } else {
          selectBlock(getMultiSelectedBlocksEndClientId(), -1);
        }

        return;
      } // Abort if our current target is not a candidate for navigation
      // (e.g. preserve native input behaviors).


      if (!isNavigationCandidate(target, keyCode, hasModifier)) {
        return;
      } // When presing any key other than up or down, the initial vertical
      // position must ALWAYS be reset. The vertical position is saved so
      // it can be restored as well as possible on sebsequent vertical
      // arrow key presses. It may not always be possible to restore the
      // exact same position (such as at an empty line), so it wouldn't be
      // good to compute the position right before any vertical arrow key
      // press.


      if (!isVertical) {
        verticalRect = null;
      } else if (!verticalRect) {
        verticalRect = (0,external_wp_dom_namespaceObject.computeCaretRect)(defaultView);
      } // In the case of RTL scripts, right means previous and left means
      // next, which is the exact reverse of LTR.


      const isReverseDir = (0,external_wp_dom_namespaceObject.isRTL)(target) ? !isReverse : isReverse;
      const {
        keepCaretInsideBlock
      } = getSettings();

      if (shiftKey) {
        if (isClosestTabbableABlock(target, isReverse) && isNavEdge(target, isReverse)) {
          node.contentEditable = true; // Firefox doesn't automatically move focus.

          node.focus();
        }
      } else if (isVertical && (0,external_wp_dom_namespaceObject.isVerticalEdge)(target, isReverse) && ( // When Alt is pressed, only intercept if the caret is also at
      // the horizontal edge.
      altKey ? (0,external_wp_dom_namespaceObject.isHorizontalEdge)(target, isReverseDir) : true) && !keepCaretInsideBlock) {
        const closestTabbable = getClosestTabbable(target, isReverse, node, true);

        if (closestTabbable) {
          (0,external_wp_dom_namespaceObject.placeCaretAtVerticalEdge)(closestTabbable, // When Alt is pressed, place the caret at the furthest
          // horizontal edge and the furthest vertical edge.
          altKey ? !isReverse : isReverse, altKey ? undefined : verticalRect);
          event.preventDefault();
        }
      } else if (isHorizontal && defaultView.getSelection().isCollapsed && (0,external_wp_dom_namespaceObject.isHorizontalEdge)(target, isReverseDir) && !keepCaretInsideBlock) {
        const closestTabbable = getClosestTabbable(target, isReverseDir, node);
        (0,external_wp_dom_namespaceObject.placeCaretAtHorizontalEdge)(closestTabbable, isReverse);
        event.preventDefault();
      }
    }

    node.addEventListener('mousedown', onMouseDown);
    node.addEventListener('keydown', onKeyDown);
    return () => {
      node.removeEventListener('mousedown', onMouseDown);
      node.removeEventListener('keydown', onKeyDown);
    };
  }, []);
}

;// CONCATENATED MODULE: external ["wp","keyboardShortcuts"]
var external_wp_keyboardShortcuts_namespaceObject = window["wp"]["keyboardShortcuts"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-select-all.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


function useSelectAll() {
  const {
    getBlockOrder,
    getSelectedBlockClientIds,
    getBlockRootClientId
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    multiSelect,
    selectBlock
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const isMatch = (0,external_wp_keyboardShortcuts_namespaceObject.__unstableUseShortcutEventMatch)();
  return (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    function onKeyDown(event) {
      if (!isMatch('core/block-editor/select-all', event)) {
        return;
      }

      const selectedClientIds = getSelectedBlockClientIds();

      if (selectedClientIds.length < 2 && !(0,external_wp_dom_namespaceObject.isEntirelySelected)(event.target)) {
        return;
      }

      event.preventDefault();
      const [firstSelectedClientId] = selectedClientIds;
      const rootClientId = getBlockRootClientId(firstSelectedClientId);
      const blockClientIds = getBlockOrder(rootClientId); // If we have selected all sibling nested blocks, try selecting up a
      // level. See: https://github.com/WordPress/gutenberg/pull/31859/

      if (selectedClientIds.length === blockClientIds.length) {
        if (rootClientId) {
          node.ownerDocument.defaultView.getSelection().removeAllRanges();
          selectBlock(rootClientId);
        }

        return;
      }

      multiSelect(blockClientIds[0], blockClientIds[blockClientIds.length - 1]);
    }

    node.addEventListener('keydown', onKeyDown);
    return () => {
      node.removeEventListener('keydown', onKeyDown);
    };
  }, []);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-drag-selection.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Sets the `contenteditable` wrapper element to `value`.
 *
 * @param {HTMLElement} node  Block element.
 * @param {boolean}     value `contentEditable` value (true or false)
 */

function setContentEditableWrapper(node, value) {
  node.contentEditable = value; // Firefox doesn't automatically move focus.

  if (value) node.focus();
}
/**
 * Sets a multi-selection based on the native selection across blocks.
 */


function useDragSelection() {
  const {
    startMultiSelect,
    stopMultiSelect
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const {
    isSelectionEnabled,
    hasMultiSelection,
    isDraggingBlocks
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    const {
      ownerDocument
    } = node;
    const {
      defaultView
    } = ownerDocument;
    let anchorElement;
    let rafId;

    function onMouseUp() {
      stopMultiSelect(); // Equivalent to attaching the listener once.

      defaultView.removeEventListener('mouseup', onMouseUp); // The browser selection won't have updated yet at this point,
      // so wait until the next animation frame to get the browser
      // selection.

      rafId = defaultView.requestAnimationFrame(() => {
        if (hasMultiSelection()) {
          return;
        } // If the selection is complete (on mouse up), and no
        // multiple blocks have been selected, set focus back to the
        // anchor element. if the anchor element contains the
        // selection. Additionally, the contentEditable wrapper can
        // now be disabled again.


        setContentEditableWrapper(node, false);
        const selection = defaultView.getSelection();

        if (selection.rangeCount) {
          const {
            commonAncestorContainer
          } = selection.getRangeAt(0);

          if (anchorElement.contains(commonAncestorContainer)) {
            anchorElement.focus();
          }
        }
      });
    }

    function onMouseLeave({
      buttons,
      target
    }) {
      // Avoid triggering a multi-selection if the user is already
      // dragging blocks.
      if (isDraggingBlocks()) {
        return;
      } // The primary button must be pressed to initiate selection.
      // See https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons


      if (buttons !== 1) {
        return;
      } // Check the attribute, not the contentEditable attribute. All
      // child elements of the content editable wrapper are editable
      // and return true for this property. We only want to start
      // multi selecting when the mouse leaves the wrapper.


      if (target.getAttribute('contenteditable') !== 'true') {
        return;
      }

      if (!isSelectionEnabled()) {
        return;
      }

      anchorElement = ownerDocument.activeElement;
      startMultiSelect(); // `onSelectionStart` is called after `mousedown` and
      // `mouseleave` (from a block). The selection ends when
      // `mouseup` happens anywhere in the window.

      defaultView.addEventListener('mouseup', onMouseUp); // Allow cross contentEditable selection by temporarily making
      // all content editable. We can't rely on using the store and
      // React because re-rending happens too slowly. We need to be
      // able to select across instances immediately.

      setContentEditableWrapper(node, true);
    }

    node.addEventListener('mouseout', onMouseLeave);
    return () => {
      node.removeEventListener('mouseout', onMouseLeave);
      defaultView.removeEventListener('mouseup', onMouseUp);
      defaultView.cancelAnimationFrame(rafId);
    };
  }, [startMultiSelect, stopMultiSelect, isSelectionEnabled, hasMultiSelection]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-selection-observer.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/**
 * Extract the selection start node from the selection. When the anchor node is
 * not a text node, the selection offset is the index of a child node.
 *
 * @param {Selection} selection The selection.
 *
 * @return {Element} The selection start node.
 */

function extractSelectionStartNode(selection) {
  const {
    anchorNode,
    anchorOffset
  } = selection;

  if (anchorNode.nodeType === anchorNode.TEXT_NODE) {
    return anchorNode;
  }

  if (anchorOffset === 0) {
    return anchorNode;
  }

  return anchorNode.childNodes[anchorOffset - 1];
}
/**
 * Extract the selection end node from the selection. When the focus node is not
 * a text node, the selection offset is the index of a child node. The selection
 * reaches up to but excluding that child node.
 *
 * @param {Selection} selection The selection.
 *
 * @return {Element} The selection start node.
 */


function extractSelectionEndNode(selection) {
  const {
    focusNode,
    focusOffset
  } = selection;

  if (focusNode.nodeType === focusNode.TEXT_NODE) {
    return focusNode;
  }

  if (focusOffset === focusNode.childNodes.length) {
    return focusNode;
  }

  return focusNode.childNodes[focusOffset];
}

function findDepth(a, b) {
  let depth = 0;

  while (a[depth] === b[depth]) {
    depth++;
  }

  return depth;
}
/**
 * Sets the `contenteditable` wrapper element to `value`.
 *
 * @param {HTMLElement} node  Block element.
 * @param {boolean}     value `contentEditable` value (true or false)
 */


function use_selection_observer_setContentEditableWrapper(node, value) {
  // Since we are calling this on every selection change, check if the value
  // needs to be updated first because it trigger the browser to recalculate
  // style.
  if (node.contentEditable !== String(value)) node.contentEditable = value; // Firefox doesn't automatically move focus.

  if (value) node.focus();
}
/**
 * Sets a multi-selection based on the native selection across blocks.
 */


function useSelectionObserver() {
  const {
    multiSelect,
    selectBlock,
    selectionChange
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const {
    getBlockParents,
    getBlockSelectionStart
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    const {
      ownerDocument
    } = node;
    const {
      defaultView
    } = ownerDocument;

    function onSelectionChange(event) {
      const selection = defaultView.getSelection();

      if (!selection.rangeCount) {
        return;
      } // If selection is collapsed and we haven't used `shift+click`,
      // end multi selection and disable the contentEditable wrapper.
      // We have to check about `shift+click` case because elements
      // that don't support text selection might be involved, and we might
      // update the clientIds to multi-select blocks.
      // For now we check if the event is a `mouse` event.


      const isClickShift = event.shiftKey && event.type === 'mouseup';

      if (selection.isCollapsed && !isClickShift) {
        use_selection_observer_setContentEditableWrapper(node, false);
        return;
      }

      let startClientId = getBlockClientId(extractSelectionStartNode(selection));
      let endClientId = getBlockClientId(extractSelectionEndNode(selection)); // If the selection has changed and we had pressed `shift+click`,
      // we need to check if in an element that doesn't support
      // text selection has been clicked.

      if (isClickShift) {
        const selectedClientId = getBlockSelectionStart();
        const clickedClientId = getBlockClientId(event.target); // `endClientId` is not defined if we end the selection by clicking a non-selectable block.
        // We need to check if there was already a selection with a non-selectable focusNode.

        const focusNodeIsNonSelectable = clickedClientId !== endClientId;

        if (startClientId === endClientId && selection.isCollapsed || !endClientId || focusNodeIsNonSelectable) {
          endClientId = clickedClientId;
        } // Handle the case when we have a non-selectable block
        // selected and click another one.


        if (startClientId !== selectedClientId) {
          startClientId = selectedClientId;
        }
      } // If the selection did not involve a block, return.


      if (startClientId === undefined && endClientId === undefined) {
        use_selection_observer_setContentEditableWrapper(node, false);
        return;
      }

      const isSingularSelection = startClientId === endClientId;

      if (isSingularSelection) {
        selectBlock(startClientId);
      } else {
        const startPath = [...getBlockParents(startClientId), startClientId];
        const endPath = [...getBlockParents(endClientId), endClientId];
        const depth = findDepth(startPath, endPath);
        multiSelect(startPath[depth], endPath[depth]);
      }
    }

    function addListeners() {
      ownerDocument.addEventListener('selectionchange', onSelectionChange);
      defaultView.addEventListener('mouseup', onSelectionChange);
    }

    function removeListeners() {
      ownerDocument.removeEventListener('selectionchange', onSelectionChange);
      defaultView.removeEventListener('mouseup', onSelectionChange);
    }

    function resetListeners() {
      removeListeners();
      addListeners();
    }

    addListeners(); // We must allow rich text to set selection first. This ensures that
    // our `selectionchange` listener is always reset to be called after
    // the rich text one.

    node.addEventListener('focusin', resetListeners);
    return () => {
      removeListeners();
      node.removeEventListener('focusin', resetListeners);
    };
  }, [multiSelect, selectBlock, selectionChange, getBlockParents]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-click-selection.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function useClickSelection() {
  const {
    selectBlock
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const {
    isSelectionEnabled,
    getBlockSelectionStart,
    hasMultiSelection
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    function onMouseDown(event) {
      // The main button.
      // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
      if (!isSelectionEnabled() || event.button !== 0) {
        return;
      }

      const startClientId = getBlockSelectionStart();
      const clickedClientId = getBlockClientId(event.target);

      if (event.shiftKey) {
        if (startClientId !== clickedClientId) {
          node.contentEditable = true; // Firefox doesn't automatically move focus.

          node.focus();
        }
      } else if (hasMultiSelection()) {
        // Allow user to escape out of a multi-selection to a
        // singular selection of a block via click. This is handled
        // here since focus handling excludes blocks when there is
        // multiselection, as focus can be incurred by starting a
        // multiselection (focus moved to first block's multi-
        // controls).
        selectBlock(clickedClientId);
      }
    }

    node.addEventListener('mousedown', onMouseDown);
    return () => {
      node.removeEventListener('mousedown', onMouseDown);
    };
  }, [selectBlock, isSelectionEnabled, getBlockSelectionStart, hasMultiSelection]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-input.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/**
 * Handles input for selections across blocks.
 */

function useInput() {
  const {
    __unstableIsFullySelected,
    getSelectedBlockClientIds,
    __unstableIsSelectionMergeable,
    hasMultiSelection
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    replaceBlocks,
    __unstableSplitSelection,
    removeBlocks,
    __unstableDeleteSelection,
    __unstableExpandSelection
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    function onBeforeInput(event) {
      // If writing flow is editable, NEVER allow the browser to alter the
      // DOM. This will cause React errors (and the DOM should only be
      // altered in a controlled fashion).
      if (node.contentEditable === 'true') {
        event.preventDefault();
      }
    }

    function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }

      if (!hasMultiSelection()) {
        return;
      }

      if (event.keyCode === external_wp_keycodes_namespaceObject.ENTER) {
        node.contentEditable = false;
        event.preventDefault();

        if (__unstableIsFullySelected()) {
          replaceBlocks(getSelectedBlockClientIds(), (0,external_wp_blocks_namespaceObject.createBlock)((0,external_wp_blocks_namespaceObject.getDefaultBlockName)()));
        } else {
          __unstableSplitSelection();
        }
      } else if (event.keyCode === external_wp_keycodes_namespaceObject.BACKSPACE || event.keyCode === external_wp_keycodes_namespaceObject.DELETE) {
        node.contentEditable = false;
        event.preventDefault();

        if (__unstableIsFullySelected()) {
          removeBlocks(getSelectedBlockClientIds());
        } else if (__unstableIsSelectionMergeable()) {
          __unstableDeleteSelection(event.keyCode === external_wp_keycodes_namespaceObject.DELETE);
        } else {
          __unstableExpandSelection();
        }
      } else if ( // If key.length is longer than 1, it's a control key that doesn't
      // input anything.
      event.key.length === 1 && !(event.metaKey || event.ctrlKey)) {
        node.contentEditable = false;

        if (__unstableIsSelectionMergeable()) {
          __unstableDeleteSelection(event.keyCode === external_wp_keycodes_namespaceObject.DELETE);
        } else {
          event.preventDefault(); // Safari does not stop default behaviour with either
          // event.preventDefault() or node.contentEditable = false, so
          // remove the selection to stop browser manipulation.

          node.ownerDocument.defaultView.getSelection().removeAllRanges();
        }
      }
    }

    function onCompositionStart(event) {
      if (!hasMultiSelection()) {
        return;
      }

      node.contentEditable = false;

      if (__unstableIsSelectionMergeable()) {
        __unstableDeleteSelection();
      } else {
        event.preventDefault(); // Safari does not stop default behaviour with either
        // event.preventDefault() or node.contentEditable = false, so
        // remove the selection to stop browser manipulation.

        node.ownerDocument.defaultView.getSelection().removeAllRanges();
      }
    }

    node.addEventListener('beforeinput', onBeforeInput);
    node.addEventListener('keydown', onKeyDown);
    node.addEventListener('compositionstart', onCompositionStart);
    return () => {
      node.removeEventListener('beforeinput', onBeforeInput);
      node.removeEventListener('keydown', onKeyDown);
      node.removeEventListener('compositionstart', onCompositionStart);
    };
  }, []);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */










function useWritingFlow() {
  const [before, ref, after] = useTabNav();
  const hasMultiSelection = (0,external_wp_data_namespaceObject.useSelect)(select => select(store).hasMultiSelection(), []);
  return [before, (0,external_wp_compose_namespaceObject.useMergeRefs)([ref, useInput(), useDragSelection(), useSelectionObserver(), useClickSelection(), useMultiSelection(), useSelectAll(), useArrowNav(), (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    node.tabIndex = 0;
    node.contentEditable = hasMultiSelection;

    if (!hasMultiSelection) {
      return;
    }

    node.classList.add('has-multi-selection');
    node.setAttribute('aria-label', (0,external_wp_i18n_namespaceObject.__)('Multiple selected blocks'));
    return () => {
      node.classList.remove('has-multi-selection');
      node.removeAttribute('aria-label');
    };
  }, [hasMultiSelection])]), after];
}

function WritingFlow({
  children,
  ...props
}, forwardedRef) {
  const [before, ref, after] = useWritingFlow();
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, before, (0,external_wp_element_namespaceObject.createElement)("div", { ...props,
    ref: (0,external_wp_compose_namespaceObject.useMergeRefs)([ref, forwardedRef]),
    className: classnames_default()(props.className, 'block-editor-writing-flow')
  }, children), after);
}
/**
 * Handles selection and navigation across blocks. This component should be
 * wrapped around BlockList.
 *
 * @param {Object}    props          Component properties.
 * @param {WPElement} props.children Children to be rendered.
 */


/* harmony default export */ var writing_flow = ((0,external_wp_element_namespaceObject.forwardRef)(WritingFlow));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/iframe/use-compatibility-styles.js
/**
 * WordPress dependencies
 */

/**
 * Returns a list of stylesheets that target the editor canvas. A stylesheet is
 * considered targetting the editor a canvas if it contains the
 * `editor-styles-wrapper`, `wp-block`, or `wp-block-*` class selectors.
 *
 * Ideally, this hook should be removed in the future and styles should be added
 * explicitly as editor styles.
 */

function useCompatibilityStyles() {
  // Only memoize the result once on load, since these stylesheets should not
  // change.
  return (0,external_wp_element_namespaceObject.useMemo)(() => {
    // Search the document for stylesheets targetting the editor canvas.
    return Array.from(document.styleSheets).reduce((accumulator, styleSheet) => {
      try {
        // May fail for external styles.
        // eslint-disable-next-line no-unused-expressions
        styleSheet.cssRules;
      } catch (e) {
        return accumulator;
      }

      const {
        ownerNode,
        cssRules
      } = styleSheet; // Stylesheet is added by another stylesheet. See
      // https://developer.mozilla.org/en-US/docs/Web/API/StyleSheet/ownerNode#notes.

      if (ownerNode === null) {
        return accumulator;
      }

      if (!cssRules) {
        return accumulator;
      } // Don't try to add the reset styles, which were removed as a dependency
      // from `edit-blocks` for the iframe since we don't need to reset admin
      // styles.


      if (ownerNode.id === 'wp-reset-editor-styles-css') {
        return accumulator;
      } // Don't try to add styles without ID. Styles enqueued via the WP dependency system will always have IDs.


      if (!ownerNode.id) {
        return accumulator;
      }

      function matchFromRules(_cssRules) {
        return Array.from(_cssRules).find(({
          selectorText,
          conditionText,
          cssRules: __cssRules
        }) => {
          // If the rule is conditional then it will not have selector text.
          // Recurse into child CSS ruleset to determine selector eligibility.
          if (conditionText) {
            return matchFromRules(__cssRules);
          }

          return selectorText && (selectorText.includes('.editor-styles-wrapper') || selectorText.includes('.wp-block'));
        });
      }

      if (matchFromRules(cssRules)) {
        const isInline = ownerNode.tagName === 'STYLE';

        if (isInline) {
          // If the current target is inline,
          // it could be a dependency of an existing stylesheet.
          // Look for that dependency and add it BEFORE the current target.
          const mainStylesCssId = ownerNode.id.replace('-inline-css', '-css');
          const mainStylesElement = document.getElementById(mainStylesCssId);

          if (mainStylesElement) {
            accumulator.push(mainStylesElement.cloneNode(true));
          }
        }

        accumulator.push(ownerNode.cloneNode(true));

        if (!isInline) {
          // If the current target is not inline,
          // we still look for inline styles that could be relevant for the current target.
          // If they exist, add them AFTER the current target.
          const inlineStylesCssId = ownerNode.id.replace('-css', '-inline-css');
          const inlineStylesElement = document.getElementById(inlineStylesCssId);

          if (inlineStylesElement) {
            accumulator.push(inlineStylesElement.cloneNode(true));
          }
        }
      }

      return accumulator;
    }, []);
  }, []);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/iframe/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */





/**
 * Bubbles some event types (keydown, keypress, and dragover) to parent document
 * document to ensure that the keyboard shortcuts and drag and drop work.
 *
 * Ideally, we should remove event bubbling in the future. Keyboard shortcuts
 * should be context dependent, e.g. actions on blocks like Cmd+A should not
 * work globally outside the block editor.
 *
 * @param {Document} doc Document to attach listeners to.
 */

function bubbleEvents(doc) {
  const {
    defaultView
  } = doc;
  const {
    frameElement
  } = defaultView;

  function bubbleEvent(event) {
    const prototype = Object.getPrototypeOf(event);
    const constructorName = prototype.constructor.name;
    const Constructor = window[constructorName];
    const init = {};

    for (const key in event) {
      init[key] = event[key];
    }

    if (event instanceof defaultView.MouseEvent) {
      const rect = frameElement.getBoundingClientRect();
      init.clientX += rect.left;
      init.clientY += rect.top;
    }

    const newEvent = new Constructor(event.type, init);
    const cancelled = !frameElement.dispatchEvent(newEvent);

    if (cancelled) {
      event.preventDefault();
    }
  }

  const eventTypes = ['dragover', 'mousemove'];

  for (const name of eventTypes) {
    doc.addEventListener(name, bubbleEvent);
  }
}

function Iframe({
  contentRef,
  children,
  tabIndex = 0,
  scale = 1,
  frameSize = 0,
  expand = false,
  readonly,
  forwardedRef: ref,
  ...props
}) {
  const {
    resolvedAssets,
    isPreviewMode
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const settings = select(store).getSettings();
    return {
      resolvedAssets: settings.__unstableResolvedAssets,
      isPreviewMode: settings.__unstableIsPreviewMode
    };
  }, []);
  const {
    styles = '',
    scripts = ''
  } = resolvedAssets;
  const [iframeDocument, setIframeDocument] = (0,external_wp_element_namespaceObject.useState)();
  const [bodyClasses, setBodyClasses] = (0,external_wp_element_namespaceObject.useState)([]);
  const compatStyles = useCompatibilityStyles();
  const clearerRef = useBlockSelectionClearer();
  const [before, writingFlowRef, after] = useWritingFlow();
  const [contentResizeListener, {
    height: contentHeight
  }] = (0,external_wp_compose_namespaceObject.useResizeObserver)();
  const setRef = (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    node._load = () => {
      setIframeDocument(node.contentDocument);
    };

    let iFrameDocument; // Prevent the default browser action for files dropped outside of dropzones.

    function preventFileDropDefault(event) {
      event.preventDefault();
    }

    function onLoad() {
      const {
        contentDocument,
        ownerDocument
      } = node;
      const {
        documentElement
      } = contentDocument;
      iFrameDocument = contentDocument;
      bubbleEvents(contentDocument);
      clearerRef(documentElement); // Ideally ALL classes that are added through get_body_class should
      // be added in the editor too, which we'll somehow have to get from
      // the server in the future (which will run the PHP filters).

      setBodyClasses(Array.from(ownerDocument.body.classList).filter(name => name.startsWith('admin-color-') || name.startsWith('post-type-') || name === 'wp-embed-responsive'));
      contentDocument.dir = ownerDocument.dir;

      for (const compatStyle of compatStyles) {
        if (contentDocument.getElementById(compatStyle.id)) {
          continue;
        }

        contentDocument.head.appendChild(compatStyle.cloneNode(true));

        if (!isPreviewMode) {
          // eslint-disable-next-line no-console
          console.warn(`${compatStyle.id} was added to the iframe incorrectly. Please use block.json or enqueue_block_assets to add styles to the iframe.`, compatStyle);
        }
      }

      iFrameDocument.addEventListener('dragover', preventFileDropDefault, false);
      iFrameDocument.addEventListener('drop', preventFileDropDefault, false);
    }

    node.addEventListener('load', onLoad);
    return () => {
      node.removeEventListener('load', onLoad);
      iFrameDocument?.removeEventListener('dragover', preventFileDropDefault);
      iFrameDocument?.removeEventListener('drop', preventFileDropDefault);
    };
  }, []);
  const disabledRef = (0,external_wp_compose_namespaceObject.useDisabled)({
    isDisabled: !readonly
  });
  const bodyRef = (0,external_wp_compose_namespaceObject.useMergeRefs)([contentRef, clearerRef, writingFlowRef, disabledRef]); // Correct doctype is required to enable rendering in standards
  // mode. Also preload the styles to avoid a flash of unstyled
  // content.

  const html = `<!doctype html>
<html>
	<head>
		<script>window.frameElement._load()</script>
		<style>html{height:auto!important;min-height:100%;}body{margin:0}</style>
		${styles}
		${scripts}
	</head>
	<body>
		<script>document.currentScript.parentElement.remove()</script>
	</body>
</html>`;
  const [src, cleanup] = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const _src = URL.createObjectURL(new window.Blob([html], {
      type: 'text/html'
    }));

    return [_src, () => URL.revokeObjectURL(_src)];
  }, [html]);
  (0,external_wp_element_namespaceObject.useEffect)(() => cleanup, [cleanup]); // We need to counter the margin created by scaling the iframe. If the scale
  // is e.g. 0.45, then the top + bottom margin is 0.55 (1 - scale). Just the
  // top or bottom margin is 0.55 / 2 ((1 - scale) / 2).

  const marginFromScaling = contentHeight * (1 - scale) / 2;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, tabIndex >= 0 && before, (0,external_wp_element_namespaceObject.createElement)("iframe", { ...props,
    style: { ...props.style,
      height: expand ? contentHeight : props.style?.height,
      marginTop: scale !== 1 ? -marginFromScaling + frameSize : props.style?.marginTop,
      marginBottom: scale !== 1 ? -marginFromScaling + frameSize : props.style?.marginBottom,
      transform: scale !== 1 ? `scale( ${scale} )` : props.style?.transform,
      transition: 'all .3s'
    },
    ref: (0,external_wp_compose_namespaceObject.useMergeRefs)([ref, setRef]),
    tabIndex: tabIndex // Correct doctype is required to enable rendering in standards
    // mode. Also preload the styles to avoid a flash of unstyled
    // content.
    ,
    src: src,
    title: (0,external_wp_i18n_namespaceObject.__)('Editor canvas')
  }, iframeDocument && (0,external_wp_element_namespaceObject.createPortal)((0,external_wp_element_namespaceObject.createElement)("body", {
    ref: bodyRef,
    className: classnames_default()('block-editor-iframe__body', 'editor-styles-wrapper', ...bodyClasses)
  }, contentResizeListener, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalStyleProvider, {
    document: iframeDocument
  }, children)), iframeDocument.documentElement)), tabIndex >= 0 && after);
}

function IframeIfReady(props, ref) {
  const isInitialised = (0,external_wp_data_namespaceObject.useSelect)(select => select(store).getSettings().__internalIsInitialized, []); // We shouldn't render the iframe until the editor settings are initialised.
  // The initial settings are needed to get the styles for the srcDoc, which
  // cannot be changed after the iframe is mounted. srcDoc is used to to set
  // the initial iframe HTML, which is required to avoid a flash of unstyled
  // content.

  if (!isInitialised) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(Iframe, { ...props,
    forwardedRef: ref
  });
}

/* harmony default export */ var iframe = ((0,external_wp_element_namespaceObject.forwardRef)(IframeIfReady));

;// CONCATENATED MODULE: ./node_modules/colord/index.mjs
var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return"string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,p=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},"hsl"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return"string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):"","#"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return"number"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return"number"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};

;// CONCATENATED MODULE: ./node_modules/colord/plugins/names.mjs
/* harmony default export */ function names(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"])}

;// CONCATENATED MODULE: ./node_modules/colord/plugins/a11y.mjs
var a11y_o=function(o){var t=o/255;return t<.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)},a11y_t=function(t){return.2126*a11y_o(t.r)+.7152*a11y_o(t.g)+.0722*a11y_o(t.b)};/* harmony default export */ function a11y(o){o.prototype.luminance=function(){return o=a11y_t(this.rgba),void 0===(r=2)&&(r=0),void 0===n&&(n=Math.pow(10,r)),Math.round(n*o)/n+0;var o,r,n},o.prototype.contrast=function(r){void 0===r&&(r="#FFF");var n,a,i,e,v,u,d,c=r instanceof o?r:new o(r);return e=this.rgba,v=c.toRgb(),u=a11y_t(e),d=a11y_t(v),n=u>d?(u+.05)/(d+.05):(d+.05)/(u+.05),void 0===(a=2)&&(a=0),void 0===i&&(i=Math.pow(10,a)),Math.floor(i*n)/i+0},o.prototype.isReadable=function(o,t){return void 0===o&&(o="#FFF"),void 0===t&&(t={}),this.contrast(o)>=(e=void 0===(i=(r=t).size)?"normal":i,"AAA"===(a=void 0===(n=r.level)?"AA":n)&&"normal"===e?7:"AA"===a&&"large"===e?3:4.5);var r,n,a,i,e}}

// EXTERNAL MODULE: ./node_modules/traverse/index.js
var traverse = __webpack_require__(3124);
var traverse_default = /*#__PURE__*/__webpack_require__.n(traverse);
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/parse.js
/* eslint-disable @wordpress/no-unused-vars-before-return */
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.
// http://www.w3.org/TR/CSS21/grammar.htm
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
const commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
/* harmony default export */ function parse(css, options) {
  options = options || {};
  /**
   * Positional.
   */

  let lineno = 1;
  let column = 1;
  /**
   * Update lineno and column based on `str`.
   */

  function updatePosition(str) {
    const lines = str.match(/\n/g);

    if (lines) {
      lineno += lines.length;
    }

    const i = str.lastIndexOf('\n'); // eslint-disable-next-line no-bitwise

    column = ~i ? str.length - i : column + str.length;
  }
  /**
   * Mark position and patch `node.position`.
   */


  function position() {
    const start = {
      line: lineno,
      column
    };
    return function (node) {
      node.position = new Position(start);
      whitespace();
      return node;
    };
  }
  /**
   * Store position information for a node
   */


  function Position(start) {
    this.start = start;
    this.end = {
      line: lineno,
      column
    };
    this.source = options.source;
  }
  /**
   * Non-enumerable source string
   */


  Position.prototype.content = css;
  /**
   * Error `msg`.
   */

  const errorsList = [];

  function error(msg) {
    const err = new Error(options.source + ':' + lineno + ':' + column + ': ' + msg);
    err.reason = msg;
    err.filename = options.source;
    err.line = lineno;
    err.column = column;
    err.source = css;

    if (options.silent) {
      errorsList.push(err);
    } else {
      throw err;
    }
  }
  /**
   * Parse stylesheet.
   */


  function stylesheet() {
    const rulesList = rules();
    return {
      type: 'stylesheet',
      stylesheet: {
        source: options.source,
        rules: rulesList,
        parsingErrors: errorsList
      }
    };
  }
  /**
   * Opening brace.
   */


  function open() {
    return match(/^{\s*/);
  }
  /**
   * Closing brace.
   */


  function close() {
    return match(/^}/);
  }
  /**
   * Parse ruleset.
   */


  function rules() {
    let node;
    const accumulator = [];
    whitespace();
    comments(accumulator);

    while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {
      if (node !== false) {
        accumulator.push(node);
        comments(accumulator);
      }
    }

    return accumulator;
  }
  /**
   * Match `re` and return captures.
   */


  function match(re) {
    const m = re.exec(css);

    if (!m) {
      return;
    }

    const str = m[0];
    updatePosition(str);
    css = css.slice(str.length);
    return m;
  }
  /**
   * Parse whitespace.
   */


  function whitespace() {
    match(/^\s*/);
  }
  /**
   * Parse comments;
   */


  function comments(accumulator) {
    let c;
    accumulator = accumulator || []; // eslint-disable-next-line no-cond-assign

    while (c = comment()) {
      if (c !== false) {
        accumulator.push(c);
      }
    }

    return accumulator;
  }
  /**
   * Parse comment.
   */


  function comment() {
    const pos = position();

    if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {
      return;
    }

    let i = 2;

    while ('' !== css.charAt(i) && ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))) {
      ++i;
    }

    i += 2;

    if ('' === css.charAt(i - 1)) {
      return error('End of comment missing');
    }

    const str = css.slice(2, i - 2);
    column += 2;
    updatePosition(str);
    css = css.slice(i);
    column += 2;
    return pos({
      type: 'comment',
      comment: str
    });
  }
  /**
   * Parse selector.
   */


  function selector() {
    const m = match(/^([^{]+)/);

    if (!m) {
      return;
    } // FIXME: Remove all comments from selectors http://ostermiller.org/findcomment.html


    return trim(m[0]).replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, '').replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function (matched) {
      return matched.replace(/,/g, '\u200C');
    }).split(/\s*(?![^(]*\)),\s*/).map(function (s) {
      return s.replace(/\u200C/g, ',');
    });
  }
  /**
   * Parse declaration.
   */


  function declaration() {
    const pos = position(); // prop.

    let prop = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);

    if (!prop) {
      return;
    }

    prop = trim(prop[0]); // :

    if (!match(/^:\s*/)) {
      return error("property missing ':'");
    } // val.


    const val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);
    const ret = pos({
      type: 'declaration',
      property: prop.replace(commentre, ''),
      value: val ? trim(val[0]).replace(commentre, '') : ''
    }); // ;

    match(/^[;\s]*/);
    return ret;
  }
  /**
   * Parse declarations.
   */


  function declarations() {
    const decls = [];

    if (!open()) {
      return error("missing '{'");
    }

    comments(decls); // declarations.

    let decl; // eslint-disable-next-line no-cond-assign

    while (decl = declaration()) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }

    if (!close()) {
      return error("missing '}'");
    }

    return decls;
  }
  /**
   * Parse keyframe.
   */


  function keyframe() {
    let m;
    const vals = [];
    const pos = position(); // eslint-disable-next-line no-cond-assign

    while (m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
      vals.push(m[1]);
      match(/^,\s*/);
    }

    if (!vals.length) {
      return;
    }

    return pos({
      type: 'keyframe',
      values: vals,
      declarations: declarations()
    });
  }
  /**
   * Parse keyframes.
   */


  function atkeyframes() {
    const pos = position();
    let m = match(/^@([-\w]+)?keyframes\s*/);

    if (!m) {
      return;
    }

    const vendor = m[1]; // identifier

    m = match(/^([-\w]+)\s*/);

    if (!m) {
      return error('@keyframes missing name');
    }

    const name = m[1];

    if (!open()) {
      return error("@keyframes missing '{'");
    }

    let frame;
    let frames = comments(); // eslint-disable-next-line no-cond-assign

    while (frame = keyframe()) {
      frames.push(frame);
      frames = frames.concat(comments());
    }

    if (!close()) {
      return error("@keyframes missing '}'");
    }

    return pos({
      type: 'keyframes',
      name,
      vendor,
      keyframes: frames
    });
  }
  /**
   * Parse supports.
   */


  function atsupports() {
    const pos = position();
    const m = match(/^@supports *([^{]+)/);

    if (!m) {
      return;
    }

    const supports = trim(m[1]);

    if (!open()) {
      return error("@supports missing '{'");
    }

    const style = comments().concat(rules());

    if (!close()) {
      return error("@supports missing '}'");
    }

    return pos({
      type: 'supports',
      supports,
      rules: style
    });
  }
  /**
   * Parse host.
   */


  function athost() {
    const pos = position();
    const m = match(/^@host\s*/);

    if (!m) {
      return;
    }

    if (!open()) {
      return error("@host missing '{'");
    }

    const style = comments().concat(rules());

    if (!close()) {
      return error("@host missing '}'");
    }

    return pos({
      type: 'host',
      rules: style
    });
  }
  /**
   * Parse media.
   */


  function atmedia() {
    const pos = position();
    const m = match(/^@media *([^{]+)/);

    if (!m) {
      return;
    }

    const media = trim(m[1]);

    if (!open()) {
      return error("@media missing '{'");
    }

    const style = comments().concat(rules());

    if (!close()) {
      return error("@media missing '}'");
    }

    return pos({
      type: 'media',
      media,
      rules: style
    });
  }
  /**
   * Parse custom-media.
   */


  function atcustommedia() {
    const pos = position();
    const m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);

    if (!m) {
      return;
    }

    return pos({
      type: 'custom-media',
      name: trim(m[1]),
      media: trim(m[2])
    });
  }
  /**
   * Parse paged media.
   */


  function atpage() {
    const pos = position();
    const m = match(/^@page */);

    if (!m) {
      return;
    }

    const sel = selector() || [];

    if (!open()) {
      return error("@page missing '{'");
    }

    let decls = comments(); // declarations.

    let decl; // eslint-disable-next-line no-cond-assign

    while (decl = declaration()) {
      decls.push(decl);
      decls = decls.concat(comments());
    }

    if (!close()) {
      return error("@page missing '}'");
    }

    return pos({
      type: 'page',
      selectors: sel,
      declarations: decls
    });
  }
  /**
   * Parse document.
   */


  function atdocument() {
    const pos = position();
    const m = match(/^@([-\w]+)?document *([^{]+)/);

    if (!m) {
      return;
    }

    const vendor = trim(m[1]);
    const doc = trim(m[2]);

    if (!open()) {
      return error("@document missing '{'");
    }

    const style = comments().concat(rules());

    if (!close()) {
      return error("@document missing '}'");
    }

    return pos({
      type: 'document',
      document: doc,
      vendor,
      rules: style
    });
  }
  /**
   * Parse font-face.
   */


  function atfontface() {
    const pos = position();
    const m = match(/^@font-face\s*/);

    if (!m) {
      return;
    }

    if (!open()) {
      return error("@font-face missing '{'");
    }

    let decls = comments(); // declarations.

    let decl; // eslint-disable-next-line no-cond-assign

    while (decl = declaration()) {
      decls.push(decl);
      decls = decls.concat(comments());
    }

    if (!close()) {
      return error("@font-face missing '}'");
    }

    return pos({
      type: 'font-face',
      declarations: decls
    });
  }
  /**
   * Parse import
   */


  const atimport = _compileAtrule('import');
  /**
   * Parse charset
   */


  const atcharset = _compileAtrule('charset');
  /**
   * Parse namespace
   */


  const atnamespace = _compileAtrule('namespace');
  /**
   * Parse non-block at-rules
   */


  function _compileAtrule(name) {
    const re = new RegExp('^@' + name + '\\s*([^;]+);');
    return function () {
      const pos = position();
      const m = match(re);

      if (!m) {
        return;
      }

      const ret = {
        type: name
      };
      ret[name] = m[1].trim();
      return pos(ret);
    };
  }
  /**
   * Parse at rule.
   */


  function atrule() {
    if (css[0] !== '@') {
      return;
    }

    return atkeyframes() || atmedia() || atcustommedia() || atsupports() || atimport() || atcharset() || atnamespace() || atdocument() || atpage() || athost() || atfontface();
  }
  /**
   * Parse rule.
   */


  function rule() {
    const pos = position();
    const sel = selector();

    if (!sel) {
      return error('selector missing');
    }

    comments();
    return pos({
      type: 'rule',
      selectors: sel,
      declarations: declarations()
    });
  }

  return addParent(stylesheet());
}
/**
 * Trim `str`.
 */

function trim(str) {
  return str ? str.replace(/^\s+|\s+$/g, '') : '';
}
/**
 * Adds non-enumerable parent node reference to each node.
 */


function addParent(obj, parent) {
  const isNode = obj && typeof obj.type === 'string';
  const childParent = isNode ? obj : parent;

  for (const k in obj) {
    const value = obj[k];

    if (Array.isArray(value)) {
      value.forEach(function (v) {
        addParent(v, childParent);
      });
    } else if (value && typeof value === 'object') {
      addParent(value, childParent);
    }
  }

  if (isNode) {
    Object.defineProperty(obj, 'parent', {
      configurable: true,
      writable: true,
      enumerable: false,
      value: parent || null
    });
  }

  return obj;
}
/* eslint-enable @wordpress/no-unused-vars-before-return */

// EXTERNAL MODULE: ./node_modules/inherits/inherits_browser.js
var inherits_browser = __webpack_require__(8575);
var inherits_browser_default = /*#__PURE__*/__webpack_require__.n(inherits_browser);
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/compiler.js
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.

/**
 * Expose `Compiler`.
 */
/* harmony default export */ var compiler = (Compiler);
/**
 * Initialize a compiler.
 */

function Compiler(opts) {
  this.options = opts || {};
}
/**
 * Emit `str`
 */


Compiler.prototype.emit = function (str) {
  return str;
};
/**
 * Visit `node`.
 */


Compiler.prototype.visit = function (node) {
  return this[node.type](node);
};
/**
 * Map visit over array of `nodes`, optionally using a `delim`
 */


Compiler.prototype.mapVisit = function (nodes, delim) {
  let buf = '';
  delim = delim || '';

  for (let i = 0, length = nodes.length; i < length; i++) {
    buf += this.visit(nodes[i]);

    if (delim && i < length - 1) {
      buf += this.emit(delim);
    }
  }

  return buf;
};

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/compress.js
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Expose compiler.
 */

/* harmony default export */ var compress = (compress_Compiler);
/**
 * Initialize a new `Compiler`.
 */

function compress_Compiler(options) {
  compiler.call(this, options);
}
/**
 * Inherit from `Base.prototype`.
 */


inherits_browser_default()(compress_Compiler, compiler);
/**
 * Compile `node`.
 */

compress_Compiler.prototype.compile = function (node) {
  return node.stylesheet.rules.map(this.visit, this).join('');
};
/**
 * Visit comment node.
 */


compress_Compiler.prototype.comment = function (node) {
  return this.emit('', node.position);
};
/**
 * Visit import node.
 */


compress_Compiler.prototype.import = function (node) {
  return this.emit('@import ' + node.import + ';', node.position);
};
/**
 * Visit media node.
 */


compress_Compiler.prototype.media = function (node) {
  return this.emit('@media ' + node.media, node.position) + this.emit('{') + this.mapVisit(node.rules) + this.emit('}');
};
/**
 * Visit document node.
 */


compress_Compiler.prototype.document = function (node) {
  const doc = '@' + (node.vendor || '') + 'document ' + node.document;
  return this.emit(doc, node.position) + this.emit('{') + this.mapVisit(node.rules) + this.emit('}');
};
/**
 * Visit charset node.
 */


compress_Compiler.prototype.charset = function (node) {
  return this.emit('@charset ' + node.charset + ';', node.position);
};
/**
 * Visit namespace node.
 */


compress_Compiler.prototype.namespace = function (node) {
  return this.emit('@namespace ' + node.namespace + ';', node.position);
};
/**
 * Visit supports node.
 */


compress_Compiler.prototype.supports = function (node) {
  return this.emit('@supports ' + node.supports, node.position) + this.emit('{') + this.mapVisit(node.rules) + this.emit('}');
};
/**
 * Visit keyframes node.
 */


compress_Compiler.prototype.keyframes = function (node) {
  return this.emit('@' + (node.vendor || '') + 'keyframes ' + node.name, node.position) + this.emit('{') + this.mapVisit(node.keyframes) + this.emit('}');
};
/**
 * Visit keyframe node.
 */


compress_Compiler.prototype.keyframe = function (node) {
  const decls = node.declarations;
  return this.emit(node.values.join(','), node.position) + this.emit('{') + this.mapVisit(decls) + this.emit('}');
};
/**
 * Visit page node.
 */


compress_Compiler.prototype.page = function (node) {
  const sel = node.selectors.length ? node.selectors.join(', ') : '';
  return this.emit('@page ' + sel, node.position) + this.emit('{') + this.mapVisit(node.declarations) + this.emit('}');
};
/**
 * Visit font-face node.
 */


compress_Compiler.prototype['font-face'] = function (node) {
  return this.emit('@font-face', node.position) + this.emit('{') + this.mapVisit(node.declarations) + this.emit('}');
};
/**
 * Visit host node.
 */


compress_Compiler.prototype.host = function (node) {
  return this.emit('@host', node.position) + this.emit('{') + this.mapVisit(node.rules) + this.emit('}');
};
/**
 * Visit custom-media node.
 */


compress_Compiler.prototype['custom-media'] = function (node) {
  return this.emit('@custom-media ' + node.name + ' ' + node.media + ';', node.position);
};
/**
 * Visit rule node.
 */


compress_Compiler.prototype.rule = function (node) {
  const decls = node.declarations;

  if (!decls.length) {
    return '';
  }

  return this.emit(node.selectors.join(','), node.position) + this.emit('{') + this.mapVisit(decls) + this.emit('}');
};
/**
 * Visit declaration node.
 */


compress_Compiler.prototype.declaration = function (node) {
  return this.emit(node.property + ':' + node.value, node.position) + this.emit(';');
};

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/identity.js
/* eslint-disable @wordpress/no-unused-vars-before-return */
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Expose compiler.
 */

/* harmony default export */ var stringify_identity = (identity_Compiler);
/**
 * Initialize a new `Compiler`.
 */

function identity_Compiler(options) {
  options = options || {};
  compiler.call(this, options);
  this.indentation = options.indent;
}
/**
 * Inherit from `Base.prototype`.
 */


inherits_browser_default()(identity_Compiler, compiler);
/**
 * Compile `node`.
 */

identity_Compiler.prototype.compile = function (node) {
  return this.stylesheet(node);
};
/**
 * Visit stylesheet node.
 */


identity_Compiler.prototype.stylesheet = function (node) {
  return this.mapVisit(node.stylesheet.rules, '\n\n');
};
/**
 * Visit comment node.
 */


identity_Compiler.prototype.comment = function (node) {
  return this.emit(this.indent() + '/*' + node.comment + '*/', node.position);
};
/**
 * Visit import node.
 */


identity_Compiler.prototype.import = function (node) {
  return this.emit('@import ' + node.import + ';', node.position);
};
/**
 * Visit media node.
 */


identity_Compiler.prototype.media = function (node) {
  return this.emit('@media ' + node.media, node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(node.rules, '\n\n') + this.emit(this.indent(-1) + '\n}');
};
/**
 * Visit document node.
 */


identity_Compiler.prototype.document = function (node) {
  const doc = '@' + (node.vendor || '') + 'document ' + node.document;
  return this.emit(doc, node.position) + this.emit(' ' + ' {\n' + this.indent(1)) + this.mapVisit(node.rules, '\n\n') + this.emit(this.indent(-1) + '\n}');
};
/**
 * Visit charset node.
 */


identity_Compiler.prototype.charset = function (node) {
  return this.emit('@charset ' + node.charset + ';', node.position);
};
/**
 * Visit namespace node.
 */


identity_Compiler.prototype.namespace = function (node) {
  return this.emit('@namespace ' + node.namespace + ';', node.position);
};
/**
 * Visit supports node.
 */


identity_Compiler.prototype.supports = function (node) {
  return this.emit('@supports ' + node.supports, node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(node.rules, '\n\n') + this.emit(this.indent(-1) + '\n}');
};
/**
 * Visit keyframes node.
 */


identity_Compiler.prototype.keyframes = function (node) {
  return this.emit('@' + (node.vendor || '') + 'keyframes ' + node.name, node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(node.keyframes, '\n') + this.emit(this.indent(-1) + '}');
};
/**
 * Visit keyframe node.
 */


identity_Compiler.prototype.keyframe = function (node) {
  const decls = node.declarations;
  return this.emit(this.indent()) + this.emit(node.values.join(', '), node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(decls, '\n') + this.emit(this.indent(-1) + '\n' + this.indent() + '}\n');
};
/**
 * Visit page node.
 */


identity_Compiler.prototype.page = function (node) {
  const sel = node.selectors.length ? node.selectors.join(', ') + ' ' : '';
  return this.emit('@page ' + sel, node.position) + this.emit('{\n') + this.emit(this.indent(1)) + this.mapVisit(node.declarations, '\n') + this.emit(this.indent(-1)) + this.emit('\n}');
};
/**
 * Visit font-face node.
 */


identity_Compiler.prototype['font-face'] = function (node) {
  return this.emit('@font-face ', node.position) + this.emit('{\n') + this.emit(this.indent(1)) + this.mapVisit(node.declarations, '\n') + this.emit(this.indent(-1)) + this.emit('\n}');
};
/**
 * Visit host node.
 */


identity_Compiler.prototype.host = function (node) {
  return this.emit('@host', node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(node.rules, '\n\n') + this.emit(this.indent(-1) + '\n}');
};
/**
 * Visit custom-media node.
 */


identity_Compiler.prototype['custom-media'] = function (node) {
  return this.emit('@custom-media ' + node.name + ' ' + node.media + ';', node.position);
};
/**
 * Visit rule node.
 */


identity_Compiler.prototype.rule = function (node) {
  const indent = this.indent();
  const decls = node.declarations;

  if (!decls.length) {
    return '';
  }

  return this.emit(node.selectors.map(function (s) {
    return indent + s;
  }).join(',\n'), node.position) + this.emit(' {\n') + this.emit(this.indent(1)) + this.mapVisit(decls, '\n') + this.emit(this.indent(-1)) + this.emit('\n' + this.indent() + '}');
};
/**
 * Visit declaration node.
 */


identity_Compiler.prototype.declaration = function (node) {
  return this.emit(this.indent()) + this.emit(node.property + ': ' + node.value, node.position) + this.emit(';');
};
/**
 * Increase, decrease or return current indentation.
 */


identity_Compiler.prototype.indent = function (level) {
  this.level = this.level || 1;

  if (null !== level) {
    this.level += level;
    return '';
  }

  return Array(this.level).join(this.indentation || '  ');
};
/* eslint-enable @wordpress/no-unused-vars-before-return */

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/index.js
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.

/**
 * Internal dependencies
 */


/**
 * Stringfy the given AST `node`.
 *
 * Options:
 *
 *  - `compress` space-optimized output
 *  - `sourcemap` return an object with `.code` and `.map`
 *
 * @param {Object} node
 * @param {Object} [options]
 * @return {string}
 */

/* harmony default export */ function stringify(node, options) {
  options = options || {};
  const compiler = options.compress ? new compress(options) : new stringify_identity(options);
  const code = compiler.compile(node);
  return code;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/transform-styles/traverse.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */



function traverseCSS(css, callback) {
  try {
    const parsed = parse(css);
    const updated = traverse_default().map(parsed, function (node) {
      if (!node) {
        return node;
      }

      const updatedNode = callback(node);
      return this.update(updatedNode);
    });
    return stringify(updated);
  } catch (err) {
    // eslint-disable-next-line no-console
    console.warn('Error while traversing the CSS: ' + err);
    return null;
  }
}

/* harmony default export */ var transform_styles_traverse = (traverseCSS);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/transform-styles/transforms/url-rewrite.js
/**
 * Return `true` if the given path is http/https.
 *
 * @param {string} filePath path
 *
 * @return {boolean} is remote path.
 */
function isRemotePath(filePath) {
  return /^(?:https?:)?\/\//.test(filePath);
}
/**
 * Return `true` if the given filePath is an absolute url.
 *
 * @param {string} filePath path
 *
 * @return {boolean} is absolute path.
 */


function isAbsolutePath(filePath) {
  return /^\/(?!\/)/.test(filePath);
}
/**
 * Whether or not the url should be inluded.
 *
 * @param {Object} meta url meta info
 *
 * @return {boolean} is valid.
 */


function isValidURL(meta) {
  // Ignore hashes or data uris.
  if (meta.value.indexOf('data:') === 0 || meta.value.indexOf('#') === 0) {
    return false;
  }

  if (isAbsolutePath(meta.value)) {
    return false;
  } // Do not handle the http/https urls if `includeRemote` is false.


  if (isRemotePath(meta.value)) {
    return false;
  }

  return true;
}
/**
 * Get the absolute path of the url, relative to the basePath
 *
 * @param {string} str     the url
 * @param {string} baseURL base URL
 *
 * @return {string} the full path to the file
 */


function getResourcePath(str, baseURL) {
  return new URL(str, baseURL).toString();
}
/**
 * Process the single `url()` pattern
 *
 * @param {string} baseURL the base URL for relative URLs.
 *
 * @return {Promise} the Promise.
 */


function processURL(baseURL) {
  return meta => ({ ...meta,
    newUrl: 'url(' + meta.before + meta.quote + getResourcePath(meta.value, baseURL) + meta.quote + meta.after + ')'
  });
}
/**
 * Get all `url()`s, and return the meta info
 *
 * @param {string} value decl.value.
 *
 * @return {Array} the urls.
 */


function getURLs(value) {
  const reg = /url\((\s*)(['"]?)(.+?)\2(\s*)\)/g;
  let match;
  const URLs = [];

  while ((match = reg.exec(value)) !== null) {
    const meta = {
      source: match[0],
      before: match[1],
      quote: match[2],
      value: match[3],
      after: match[4]
    };

    if (isValidURL(meta)) {
      URLs.push(meta);
    }
  }

  return URLs;
}
/**
 * Replace the raw value's `url()` segment to the new value
 *
 * @param {string} raw  the raw value.
 * @param {Array}  URLs the URLs to replace.
 *
 * @return {string} the new value.
 */


function replaceURLs(raw, URLs) {
  URLs.forEach(item => {
    raw = raw.replace(item.source, item.newUrl);
  });
  return raw;
}

const rewrite = rootURL => node => {
  if (node.type === 'declaration') {
    const updatedURLs = getURLs(node.value).map(processURL(rootURL));
    return { ...node,
      value: replaceURLs(node.value, updatedURLs)
    };
  }

  return node;
};

/* harmony default export */ var url_rewrite = (rewrite);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/transform-styles/transforms/wrap.js
/**
 * @constant string IS_ROOT_TAG Regex to check if the selector is a root tag selector.
 */
const IS_ROOT_TAG = /^(body|html|:root).*$/;
/**
 * Creates a callback to modify selectors so they only apply within a certain
 * namespace.
 *
 * @param {string}   namespace Namespace to prefix selectors with.
 * @param {string[]} ignore    Selectors to not prefix.
 *
 * @return {(node: Object) => Object} Callback to wrap selectors.
 */

const wrap = (namespace, ignore = []) => node => {
  /**
   * Updates selector if necessary.
   *
   * @param {string} selector Selector to modify.
   *
   * @return {string} Updated selector.
   */
  const updateSelector = selector => {
    if (ignore.includes(selector.trim())) {
      return selector;
    } // Anything other than a root tag is always prefixed.


    {
      if (!selector.match(IS_ROOT_TAG)) {
        return namespace + ' ' + selector;
      }
    } // HTML and Body elements cannot be contained within our container so lets extract their styles.

    return selector.replace(/^(body|html|:root)/, namespace);
  };

  if (node.type === 'rule') {
    return { ...node,
      selectors: node.selectors.map(updateSelector)
    };
  }

  return node;
};

/* harmony default export */ var transforms_wrap = (wrap);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/transform-styles/index.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




/**
 * Applies a series of CSS rule transforms to wrap selectors inside a given class and/or rewrite URLs depending on the parameters passed.
 *
 * @param {Object|Array} styles           CSS rules.
 * @param {string}       wrapperClassName Wrapper Class Name.
 * @return {Array} converted rules.
 */

const transform_styles_transformStyles = (styles, wrapperClassName = '') => {
  return Object.values(styles !== null && styles !== void 0 ? styles : []).map(({
    css,
    baseURL
  }) => {
    const transforms = [];

    if (wrapperClassName) {
      transforms.push(transforms_wrap(wrapperClassName));
    }

    if (baseURL) {
      transforms.push(url_rewrite(baseURL));
    }

    if (transforms.length) {
      return transform_styles_traverse(css, (0,external_wp_compose_namespaceObject.compose)(transforms));
    }

    return css;
  });
};

/* harmony default export */ var transform_styles = (transform_styles_transformStyles);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/editor-styles/index.js


/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


const EDITOR_STYLES_SELECTOR = '.editor-styles-wrapper';
k([names, a11y]);

function useDarkThemeBodyClassName(styles) {
  return (0,external_wp_element_namespaceObject.useCallback)(node => {
    if (!node) {
      return;
    }

    const {
      ownerDocument
    } = node;
    const {
      defaultView,
      body
    } = ownerDocument;
    const canvas = ownerDocument.querySelector(EDITOR_STYLES_SELECTOR);
    let backgroundColor;

    if (!canvas) {
      // The real .editor-styles-wrapper element might not exist in the
      // DOM, so calculate the background color by creating a fake
      // wrapper.
      const tempCanvas = ownerDocument.createElement('div');
      tempCanvas.classList.add('editor-styles-wrapper');
      body.appendChild(tempCanvas);
      backgroundColor = defaultView?.getComputedStyle(tempCanvas, null).getPropertyValue('background-color');
      body.removeChild(tempCanvas);
    } else {
      backgroundColor = defaultView?.getComputedStyle(canvas, null).getPropertyValue('background-color');
    }

    const colordBackgroundColor = w(backgroundColor); // If background is transparent, it should be treated as light color.

    if (colordBackgroundColor.luminance() > 0.5 || colordBackgroundColor.alpha() === 0) {
      body.classList.remove('is-dark-theme');
    } else {
      body.classList.add('is-dark-theme');
    }
  }, [styles]);
}

function EditorStyles({
  styles
}) {
  const stylesArray = (0,external_wp_element_namespaceObject.useMemo)(() => Object.values(styles !== null && styles !== void 0 ? styles : []), [styles]);
  const transformedStyles = (0,external_wp_element_namespaceObject.useMemo)(() => transform_styles(stylesArray.filter(style => style?.css), EDITOR_STYLES_SELECTOR), [stylesArray]);
  const transformedSvgs = (0,external_wp_element_namespaceObject.useMemo)(() => stylesArray.filter(style => style.__unstableType === 'svgs').map(style => style.assets).join(''), [stylesArray]);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)("style", {
    ref: useDarkThemeBodyClassName(stylesArray)
  }), transformedStyles.map((css, index) => (0,external_wp_element_namespaceObject.createElement)("style", {
    key: index
  }, css)), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 0 0",
    width: "0",
    height: "0",
    role: "none",
    style: {
      visibility: 'hidden',
      position: 'absolute',
      left: '-9999px',
      overflow: 'hidden'
    },
    dangerouslySetInnerHTML: {
      __html: transformedSvgs
    }
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-preview/auto.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




 // This is used to avoid rendering the block list if the sizes change.

let MemoizedBlockList;
const MAX_HEIGHT = 2000;

function ScaledBlockPreview({
  viewportWidth,
  containerWidth,
  minHeight,
  additionalStyles = []
}) {
  if (!viewportWidth) {
    viewportWidth = containerWidth;
  }

  const [contentResizeListener, {
    height: contentHeight
  }] = (0,external_wp_compose_namespaceObject.useResizeObserver)();
  const {
    styles
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const settings = select(store).getSettings();
    return {
      styles: settings.styles
    };
  }, []); // Avoid scrollbars for pattern previews.

  const editorStyles = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (styles) {
      return [...styles, {
        css: 'body{height:auto;overflow:hidden;border:none;padding:0;}',
        __unstableType: 'presets'
      }, ...additionalStyles];
    }

    return styles;
  }, [styles, additionalStyles]); // Initialize on render instead of module top level, to avoid circular dependency issues.

  MemoizedBlockList = MemoizedBlockList || (0,external_wp_compose_namespaceObject.pure)(BlockList);
  const scale = containerWidth / viewportWidth;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Disabled, {
    className: "block-editor-block-preview__content",
    style: {
      transform: `scale(${scale})`,
      height: contentHeight * scale,
      maxHeight: contentHeight > MAX_HEIGHT ? MAX_HEIGHT * scale : undefined,
      minHeight
    }
  }, (0,external_wp_element_namespaceObject.createElement)(iframe, {
    contentRef: (0,external_wp_compose_namespaceObject.useRefEffect)(bodyElement => {
      const {
        ownerDocument: {
          documentElement
        }
      } = bodyElement;
      documentElement.classList.add('block-editor-block-preview__content-iframe');
      documentElement.style.position = 'absolute';
      documentElement.style.width = '100%'; // Necessary for contentResizeListener to work.

      bodyElement.style.boxSizing = 'border-box';
      bodyElement.style.position = 'absolute';
      bodyElement.style.width = '100%';
    }, []),
    "aria-hidden": true,
    tabIndex: -1,
    style: {
      position: 'absolute',
      width: viewportWidth,
      height: contentHeight,
      pointerEvents: 'none',
      // This is a catch-all max-height for patterns.
      // See: https://github.com/WordPress/gutenberg/pull/38175.
      maxHeight: MAX_HEIGHT,
      minHeight: scale !== 0 && scale < 1 && minHeight ? minHeight / scale : minHeight
    }
  }, (0,external_wp_element_namespaceObject.createElement)(EditorStyles, {
    styles: editorStyles
  }), contentResizeListener, (0,external_wp_element_namespaceObject.createElement)(MemoizedBlockList, {
    renderAppender: false
  })));
}

function AutoBlockPreview(props) {
  const [containerResizeListener, {
    width: containerWidth
  }] = (0,external_wp_compose_namespaceObject.useResizeObserver)();
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)("div", {
    style: {
      position: 'relative',
      width: '100%',
      height: 0
    }
  }, containerResizeListener), (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-preview__container"
  }, !!containerWidth && (0,external_wp_element_namespaceObject.createElement)(ScaledBlockPreview, { ...props,
    containerWidth: containerWidth
  })));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-preview/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */





function BlockPreview({
  blocks,
  viewportWidth = 1200,
  minHeight,
  additionalStyles = [],
  // Deprecated props:
  __experimentalMinHeight,
  __experimentalPadding
}) {
  if (__experimentalMinHeight) {
    minHeight = __experimentalMinHeight;
    external_wp_deprecated_default()('The __experimentalMinHeight prop', {
      since: '6.2',
      version: '6.4',
      alternative: 'minHeight'
    });
  }

  if (__experimentalPadding) {
    additionalStyles = [...additionalStyles, {
      css: `body { padding: ${__experimentalPadding}px; }`
    }];
    external_wp_deprecated_default()('The __experimentalPadding prop of BlockPreview', {
      since: '6.2',
      version: '6.4',
      alternative: 'additionalStyles'
    });
  }

  const originalSettings = (0,external_wp_data_namespaceObject.useSelect)(select => select(store).getSettings(), []);
  const settings = (0,external_wp_element_namespaceObject.useMemo)(() => ({ ...originalSettings,
    __unstableIsPreviewMode: true
  }), [originalSettings]);
  const renderedBlocks = (0,external_wp_element_namespaceObject.useMemo)(() => Array.isArray(blocks) ? blocks : [blocks], [blocks]);

  if (!blocks || blocks.length === 0) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(ExperimentalBlockEditorProvider, {
    value: renderedBlocks,
    settings: settings
  }, (0,external_wp_element_namespaceObject.createElement)(AutoBlockPreview, {
    viewportWidth: viewportWidth,
    minHeight: minHeight,
    additionalStyles: additionalStyles
  }));
}
/**
 * BlockPreview renders a preview of a block or array of blocks.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-preview/README.md
 *
 * @param {Object}       preview               options for how the preview should be shown
 * @param {Array|Object} preview.blocks        A block instance (object) or an array of blocks to be previewed.
 * @param {number}       preview.viewportWidth Width of the preview container in pixels. Controls at what size the blocks will be rendered inside the preview. Default: 700.
 *
 * @return {WPComponent} The component to be rendered.
 */

/* harmony default export */ var block_preview = ((0,external_wp_element_namespaceObject.memo)(BlockPreview));
/**
 * This hook is used to lightly mark an element as a block preview wrapper
 * element. Call this hook and pass the returned props to the element to mark as
 * a block preview wrapper, automatically rendering inner blocks as children. If
 * you define a ref for the element, it is important to pass the ref to this
 * hook, which the hook in turn will pass to the component through the props it
 * returns. Optionally, you can also pass any other props through this hook, and
 * they will be merged and returned.
 *
 * @param {Object}    options        Preview options.
 * @param {WPBlock[]} options.blocks Block objects.
 * @param {Object}    options.props  Optional. Props to pass to the element. Must contain
 *                                   the ref if one is defined.
 * @param {Object}    options.layout Layout settings to be used in the preview.
 *
 */

function useBlockPreview({
  blocks,
  props = {},
  layout
}) {
  const originalSettings = (0,external_wp_data_namespaceObject.useSelect)(select => select(store).getSettings(), []);
  const settings = (0,external_wp_element_namespaceObject.useMemo)(() => ({ ...originalSettings,
    __unstableIsPreviewMode: true
  }), [originalSettings]);
  const disabledRef = (0,external_wp_compose_namespaceObject.useDisabled)();
  const ref = (0,external_wp_compose_namespaceObject.useMergeRefs)([props.ref, disabledRef]);
  const renderedBlocks = (0,external_wp_element_namespaceObject.useMemo)(() => Array.isArray(blocks) ? blocks : [blocks], [blocks]);
  const children = (0,external_wp_element_namespaceObject.createElement)(ExperimentalBlockEditorProvider, {
    value: renderedBlocks,
    settings: settings
  }, (0,external_wp_element_namespaceObject.createElement)(BlockListItems, {
    renderAppender: false,
    layout: layout
  }));
  return { ...props,
    ref,
    className: classnames_default()(props.className, 'block-editor-block-preview__live-content', 'components-disabled'),
    children: blocks?.length ? children : null
  };
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/preview-panel.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function InserterPreviewPanel({
  item
}) {
  var _example$viewportWidt;

  const {
    name,
    title,
    icon,
    description,
    initialAttributes,
    example
  } = item;
  const isReusable = (0,external_wp_blocks_namespaceObject.isReusableBlock)(item);
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__preview-container"
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__preview"
  }, isReusable || example ? (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__preview-content"
  }, (0,external_wp_element_namespaceObject.createElement)(block_preview, {
    blocks: example ? (0,external_wp_blocks_namespaceObject.getBlockFromExample)(name, {
      attributes: { ...example.attributes,
        ...initialAttributes
      },
      innerBlocks: example.innerBlocks
    }) : (0,external_wp_blocks_namespaceObject.createBlock)(name, initialAttributes),
    viewportWidth: (_example$viewportWidt = example?.viewportWidth) !== null && _example$viewportWidt !== void 0 ? _example$viewportWidt : 500,
    additionalStyles: [{
      css: 'body { padding: 16px; }'
    }]
  })) : (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__preview-content-missing"
  }, (0,external_wp_i18n_namespaceObject.__)('No Preview Available.'))), !isReusable && (0,external_wp_element_namespaceObject.createElement)(block_card, {
    title: title,
    icon: icon,
    description: description
  }));
}

/* harmony default export */ var preview_panel = (InserterPreviewPanel);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/context.js
/**
 * WordPress dependencies
 */

const InserterListboxContext = (0,external_wp_element_namespaceObject.createContext)();
/* harmony default export */ var context = (InserterListboxContext);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/item.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function InserterListboxItem({
  isFirst,
  as: Component,
  children,
  ...props
}, ref) {
  const state = (0,external_wp_element_namespaceObject.useContext)(context);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__unstableCompositeItem, {
    ref: ref,
    state: state,
    role: "option" // Use the CompositeItem `focusable` prop over Button's
    // isFocusable. The latter was shown to cause an issue
    // with tab order in the inserter list.
    ,
    focusable: true,
    ...props
  }, htmlProps => {
    const propsWithTabIndex = { ...htmlProps,
      tabIndex: isFirst ? 0 : htmlProps.tabIndex
    };

    if (Component) {
      return (0,external_wp_element_namespaceObject.createElement)(Component, { ...propsWithTabIndex
      }, children);
    }

    if (typeof children === 'function') {
      return children(propsWithTabIndex);
    }

    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, { ...propsWithTabIndex
    }, children);
  });
}

/* harmony default export */ var inserter_listbox_item = ((0,external_wp_element_namespaceObject.forwardRef)(InserterListboxItem));

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/drag-handle.js


/**
 * WordPress dependencies
 */

const dragHandle = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  width: "24",
  height: "24",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M8 7h2V5H8v2zm0 6h2v-2H8v2zm0 6h2v-2H8v2zm6-14v2h2V5h-2zm0 8h2v-2h-2v2zm0 6h2v-2h-2v2z"
}));
/* harmony default export */ var drag_handle = (dragHandle);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-draggable/draggable-chip.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


function BlockDraggableChip({
  count,
  icon,
  isPattern
}) {
  const patternLabel = isPattern && (0,external_wp_i18n_namespaceObject.__)('Pattern');

  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-draggable-chip-wrapper"
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-draggable-chip",
    "data-testid": "block-draggable-chip"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Flex, {
    justify: "center",
    className: "block-editor-block-draggable-chip__content"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, null, icon ? (0,external_wp_element_namespaceObject.createElement)(block_icon, {
    icon: icon
  }) : patternLabel || (0,external_wp_i18n_namespaceObject.sprintf)(
  /* translators: %d: Number of blocks. */
  (0,external_wp_i18n_namespaceObject._n)('%d block', '%d blocks', count), count)), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, null, (0,external_wp_element_namespaceObject.createElement)(block_icon, {
    icon: drag_handle
  })))));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter-draggable-blocks/index.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const InserterDraggableBlocks = ({
  isEnabled,
  blocks,
  icon,
  children,
  isPattern
}) => {
  const transferData = {
    type: 'inserter',
    blocks
  };
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Draggable, {
    __experimentalTransferDataType: "wp-blocks",
    transferData: transferData,
    onDragStart: event => {
      event.dataTransfer.setData('text/html', (0,external_wp_blocks_namespaceObject.serialize)(blocks));
    },
    __experimentalDragComponent: (0,external_wp_element_namespaceObject.createElement)(BlockDraggableChip, {
      count: blocks.length,
      icon: icon,
      isPattern: isPattern
    })
  }, ({
    onDraggableStart,
    onDraggableEnd
  }) => {
    return children({
      draggable: isEnabled,
      onDragStart: isEnabled ? onDraggableStart : undefined,
      onDragEnd: isEnabled ? onDraggableEnd : undefined
    });
  });
};

/* harmony default export */ var inserter_draggable_blocks = (InserterDraggableBlocks);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter-list-item/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */





function InserterListItem({
  className,
  isFirst,
  item,
  onSelect,
  onHover,
  isDraggable,
  ...props
}) {
  const isDragging = (0,external_wp_element_namespaceObject.useRef)(false);
  const itemIconStyle = item.icon ? {
    backgroundColor: item.icon.background,
    color: item.icon.foreground
  } : {};
  const blocks = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return [(0,external_wp_blocks_namespaceObject.createBlock)(item.name, item.initialAttributes, (0,external_wp_blocks_namespaceObject.createBlocksFromInnerBlocksTemplate)(item.innerBlocks))];
  }, [item.name, item.initialAttributes, item.initialAttributes]);
  const isSynced = (0,external_wp_blocks_namespaceObject.isReusableBlock)(item) && item.syncStatus !== 'unsynced' || (0,external_wp_blocks_namespaceObject.isTemplatePart)(item);
  return (0,external_wp_element_namespaceObject.createElement)(inserter_draggable_blocks, {
    isEnabled: isDraggable && !item.disabled,
    blocks: blocks,
    icon: item.icon
  }, ({
    draggable,
    onDragStart,
    onDragEnd
  }) => (0,external_wp_element_namespaceObject.createElement)("div", {
    className: classnames_default()('block-editor-block-types-list__list-item', {
      'is-synced': isSynced
    }),
    draggable: draggable,
    onDragStart: event => {
      isDragging.current = true;

      if (onDragStart) {
        onHover(null);
        onDragStart(event);
      }
    },
    onDragEnd: event => {
      isDragging.current = false;

      if (onDragEnd) {
        onDragEnd(event);
      }
    }
  }, (0,external_wp_element_namespaceObject.createElement)(inserter_listbox_item, {
    isFirst: isFirst,
    className: classnames_default()('block-editor-block-types-list__item', className),
    disabled: item.isDisabled,
    onClick: event => {
      event.preventDefault();
      onSelect(item, (0,external_wp_keycodes_namespaceObject.isAppleOS)() ? event.metaKey : event.ctrlKey);
      onHover(null);
    },
    onKeyDown: event => {
      const {
        keyCode
      } = event;

      if (keyCode === external_wp_keycodes_namespaceObject.ENTER) {
        event.preventDefault();
        onSelect(item, (0,external_wp_keycodes_namespaceObject.isAppleOS)() ? event.metaKey : event.ctrlKey);
        onHover(null);
      }
    },
    onMouseEnter: () => {
      if (isDragging.current) {
        return;
      }

      onHover(item);
    },
    onMouseLeave: () => onHover(null),
    ...props
  }, (0,external_wp_element_namespaceObject.createElement)("span", {
    className: "block-editor-block-types-list__item-icon",
    style: itemIconStyle
  }, (0,external_wp_element_namespaceObject.createElement)(block_icon, {
    icon: item.icon,
    showColors: true
  })), (0,external_wp_element_namespaceObject.createElement)("span", {
    className: "block-editor-block-types-list__item-title"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalTruncate, {
    numberOfLines: 3
  }, item.title)))));
}

/* harmony default export */ var inserter_list_item = ((0,external_wp_element_namespaceObject.memo)(InserterListItem));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/group.js


/**
 * WordPress dependencies
 */




function InserterListboxGroup(props, ref) {
  const [shouldSpeak, setShouldSpeak] = (0,external_wp_element_namespaceObject.useState)(false);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (shouldSpeak) {
      (0,external_wp_a11y_namespaceObject.speak)((0,external_wp_i18n_namespaceObject.__)('Use left and right arrow keys to move through blocks'));
    }
  }, [shouldSpeak]);
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    ref: ref,
    role: "listbox",
    "aria-orientation": "horizontal",
    onFocus: () => {
      setShouldSpeak(true);
    },
    onBlur: event => {
      const focusingOutsideGroup = !event.currentTarget.contains(event.relatedTarget);

      if (focusingOutsideGroup) {
        setShouldSpeak(false);
      }
    },
    ...props
  });
}

/* harmony default export */ var group = ((0,external_wp_element_namespaceObject.forwardRef)(InserterListboxGroup));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/row.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function InserterListboxRow(props, ref) {
  const state = (0,external_wp_element_namespaceObject.useContext)(context);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__unstableCompositeGroup, {
    state: state,
    role: "presentation",
    ref: ref,
    ...props
  });
}

/* harmony default export */ var inserter_listbox_row = ((0,external_wp_element_namespaceObject.forwardRef)(InserterListboxRow));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-types-list/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




function chunk(array, size) {
  const chunks = [];

  for (let i = 0, j = array.length; i < j; i += size) {
    chunks.push(array.slice(i, i + size));
  }

  return chunks;
}

function BlockTypesList({
  items = [],
  onSelect,
  onHover = () => {},
  children,
  label,
  isDraggable = true
}) {
  return (0,external_wp_element_namespaceObject.createElement)(group, {
    className: "block-editor-block-types-list",
    "aria-label": label
  }, chunk(items, 3).map((row, i) => (0,external_wp_element_namespaceObject.createElement)(inserter_listbox_row, {
    key: i
  }, row.map((item, j) => (0,external_wp_element_namespaceObject.createElement)(inserter_list_item, {
    key: item.id,
    item: item,
    className: (0,external_wp_blocks_namespaceObject.getBlockMenuDefaultClassName)(item.id),
    onSelect: onSelect,
    onHover: onHover,
    isDraggable: isDraggable && !item.isDisabled,
    isFirst: i === 0 && j === 0
  })))), children);
}

/* harmony default export */ var block_types_list = (BlockTypesList);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/panel.js


/**
 * WordPress dependencies
 */


function InserterPanel({
  title,
  icon,
  children
}) {
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__panel-header"
  }, (0,external_wp_element_namespaceObject.createElement)("h2", {
    className: "block-editor-inserter__panel-title"
  }, title), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Icon, {
    icon: icon
  })), (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__panel-content"
  }, children));
}

/* harmony default export */ var panel = (InserterPanel);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-block-types-state.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Retrieves the block types inserter state.
 *
 * @param {string=}  rootClientId Insertion's root client ID.
 * @param {Function} onInsert     function called when inserter a list of blocks.
 * @return {Array} Returns the block types state. (block types, categories, collections, onSelect handler)
 */

const useBlockTypesState = (rootClientId, onInsert) => {
  const {
    categories,
    collections,
    items
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getInserterItems
    } = select(store);
    const {
      getCategories,
      getCollections
    } = select(external_wp_blocks_namespaceObject.store);
    return {
      categories: getCategories(),
      collections: getCollections(),
      items: getInserterItems(rootClientId)
    };
  }, [rootClientId]);
  const onSelectItem = (0,external_wp_element_namespaceObject.useCallback)(({
    name,
    initialAttributes,
    innerBlocks,
    syncStatus,
    content
  }, shouldFocusBlock) => {
    const insertedBlock = syncStatus === 'unsynced' ? (0,external_wp_blocks_namespaceObject.parse)(content, {
      __unstableSkipMigrationLogs: true
    }) : (0,external_wp_blocks_namespaceObject.createBlock)(name, initialAttributes, (0,external_wp_blocks_namespaceObject.createBlocksFromInnerBlocksTemplate)(innerBlocks));
    onInsert(insertedBlock, undefined, shouldFocusBlock);
  }, [onInsert]);
  return [items, categories, collections, onSelectItem];
};

/* harmony default export */ var use_block_types_state = (useBlockTypesState);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */






function InserterListbox({
  children
}) {
  const compositeState = (0,external_wp_components_namespaceObject.__unstableUseCompositeState)({
    shift: true,
    wrap: 'horizontal'
  });
  return (0,external_wp_element_namespaceObject.createElement)(context.Provider, {
    value: compositeState
  }, children);
}

/* harmony default export */ var inserter_listbox = (InserterListbox);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/block-types-tab.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */







const getBlockNamespace = item => item.name.split('/')[0];

const MAX_SUGGESTED_ITEMS = 6;
/**
 * Shared reference to an empty array for cases where it is important to avoid
 * returning a new array reference on every invocation and rerendering the component.
 *
 * @type {Array}
 */

const block_types_tab_EMPTY_ARRAY = [];
function BlockTypesTab({
  rootClientId,
  onInsert,
  onHover,
  showMostUsedBlocks
}) {
  const [items, categories, collections, onSelectItem] = use_block_types_state(rootClientId, onInsert);
  const suggestedItems = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return orderBy(items, 'frecency', 'desc').slice(0, MAX_SUGGESTED_ITEMS);
  }, [items]);
  const uncategorizedItems = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return items.filter(item => !item.category);
  }, [items]);
  const itemsPerCategory = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return (0,external_wp_compose_namespaceObject.pipe)(itemList => itemList.filter(item => item.category && item.category !== 'reusable'), itemList => itemList.reduce((acc, item) => {
      const {
        category
      } = item;

      if (!acc[category]) {
        acc[category] = [];
      }

      acc[category].push(item);
      return acc;
    }, {}))(items);
  }, [items]);
  const itemsPerCollection = (0,external_wp_element_namespaceObject.useMemo)(() => {
    // Create a new Object to avoid mutating collection.
    const result = { ...collections
    };
    Object.keys(collections).forEach(namespace => {
      result[namespace] = items.filter(item => getBlockNamespace(item) === namespace);

      if (result[namespace].length === 0) {
        delete result[namespace];
      }
    });
    return result;
  }, [items, collections]); // Hide block preview on unmount.

  (0,external_wp_element_namespaceObject.useEffect)(() => () => onHover(null), []);
  /**
   * The inserter contains a big number of blocks and opening it is a costful operation.
   * The rendering is the most costful part of it, in order to improve the responsiveness
   * of the "opening" action, these lazy lists allow us to render the inserter category per category,
   * once all the categories are rendered, we start rendering the collections and the uncategorized block types.
   */

  const currentlyRenderedCategories = (0,external_wp_compose_namespaceObject.useAsyncList)(categories);
  const didRenderAllCategories = categories.length === currentlyRenderedCategories.length; // Async List requires an array.

  const collectionEntries = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return Object.entries(collections);
  }, [collections]);
  const currentlyRenderedCollections = (0,external_wp_compose_namespaceObject.useAsyncList)(didRenderAllCategories ? collectionEntries : block_types_tab_EMPTY_ARRAY);
  return (0,external_wp_element_namespaceObject.createElement)(inserter_listbox, null, (0,external_wp_element_namespaceObject.createElement)("div", null, showMostUsedBlocks && !!suggestedItems.length && (0,external_wp_element_namespaceObject.createElement)(panel, {
    title: (0,external_wp_i18n_namespaceObject._x)('Most used', 'blocks')
  }, (0,external_wp_element_namespaceObject.createElement)(block_types_list, {
    items: suggestedItems,
    onSelect: onSelectItem,
    onHover: onHover,
    label: (0,external_wp_i18n_namespaceObject._x)('Most used', 'blocks')
  })), currentlyRenderedCategories.map(category => {
    const categoryItems = itemsPerCategory[category.slug];

    if (!categoryItems || !categoryItems.length) {
      return null;
    }

    return (0,external_wp_element_namespaceObject.createElement)(panel, {
      key: category.slug,
      title: category.title,
      icon: category.icon
    }, (0,external_wp_element_namespaceObject.createElement)(block_types_list, {
      items: categoryItems,
      onSelect: onSelectItem,
      onHover: onHover,
      label: category.title
    }));
  }), didRenderAllCategories && uncategorizedItems.length > 0 && (0,external_wp_element_namespaceObject.createElement)(panel, {
    className: "block-editor-inserter__uncategorized-blocks-panel",
    title: (0,external_wp_i18n_namespaceObject.__)('Uncategorized')
  }, (0,external_wp_element_namespaceObject.createElement)(block_types_list, {
    items: uncategorizedItems,
    onSelect: onSelectItem,
    onHover: onHover,
    label: (0,external_wp_i18n_namespaceObject.__)('Uncategorized')
  })), currentlyRenderedCollections.map(([namespace, collection]) => {
    const collectionItems = itemsPerCollection[namespace];

    if (!collectionItems || !collectionItems.length) {
      return null;
    }

    return (0,external_wp_element_namespaceObject.createElement)(panel, {
      key: namespace,
      title: collection.title,
      icon: collection.icon
    }, (0,external_wp_element_namespaceObject.createElement)(block_types_list, {
      items: collectionItems,
      onSelect: onSelectItem,
      onHover: onHover,
      label: collection.title
    }));
  })));
}
/* harmony default export */ var block_types_tab = (BlockTypesTab);

;// CONCATENATED MODULE: external ["wp","notices"]
var external_wp_notices_namespaceObject = window["wp"]["notices"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-patterns-state.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


const CUSTOM_CATEGORY = {
  name: 'custom',
  label: (0,external_wp_i18n_namespaceObject.__)('My patterns'),
  description: (0,external_wp_i18n_namespaceObject.__)('Custom patterns add by site users')
};
/**
 * Retrieves the block patterns inserter state.
 *
 * @param {Function} onInsert     function called when inserter a list of blocks.
 * @param {string=}  rootClientId Insertion's root client ID.
 *
 * @return {Array} Returns the patterns state. (patterns, categories, onSelect handler)
 */

const usePatternsState = (onInsert, rootClientId) => {
  const {
    patternCategories,
    patterns
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      __experimentalGetAllowedPatterns,
      getSettings
    } = select(store);
    return {
      patterns: __experimentalGetAllowedPatterns(rootClientId),
      patternCategories: getSettings().__experimentalBlockPatternCategories
    };
  }, [rootClientId]);
  const allCategories = (0,external_wp_element_namespaceObject.useMemo)(() => [...patternCategories, CUSTOM_CATEGORY], [patternCategories]);
  const {
    createSuccessNotice
  } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_notices_namespaceObject.store);
  const onClickPattern = (0,external_wp_element_namespaceObject.useCallback)((pattern, blocks) => {
    onInsert((blocks !== null && blocks !== void 0 ? blocks : []).map(block => (0,external_wp_blocks_namespaceObject.cloneBlock)(block)), pattern.name);
    createSuccessNotice((0,external_wp_i18n_namespaceObject.sprintf)(
    /* translators: %s: block pattern title. */
    (0,external_wp_i18n_namespaceObject.__)('Block pattern "%s" inserted.'), pattern.title), {
      type: 'snackbar',
      id: 'block-pattern-inserted-notice'
    });
  }, [createSuccessNotice, onInsert]);
  return [patterns, allCategories, onClickPattern];
};

/* harmony default export */ var use_patterns_state = (usePatternsState);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-patterns-list/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




const WithToolTip = ({
  showTooltip,
  title,
  children
}) => {
  if (showTooltip) {
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Tooltip, {
      text: title
    }, children);
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, children);
};

function BlockPattern({
  isDraggable,
  pattern,
  onClick,
  onHover,
  composite,
  showTooltip
}) {
  const [isDragging, setIsDragging] = (0,external_wp_element_namespaceObject.useState)(false);
  const {
    blocks,
    viewportWidth
  } = pattern;
  const instanceId = (0,external_wp_compose_namespaceObject.useInstanceId)(BlockPattern);
  const descriptionId = `block-editor-block-patterns-list__item-description-${instanceId}`;
  return (0,external_wp_element_namespaceObject.createElement)(inserter_draggable_blocks, {
    isEnabled: isDraggable,
    blocks: blocks,
    isPattern: !!pattern
  }, ({
    draggable,
    onDragStart,
    onDragEnd
  }) => (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-patterns-list__list-item",
    draggable: draggable,
    onDragStart: event => {
      setIsDragging(true);

      if (onDragStart) {
        onHover?.(null);
        onDragStart(event);
      }
    },
    onDragEnd: event => {
      setIsDragging(false);

      if (onDragEnd) {
        onDragEnd(event);
      }
    }
  }, (0,external_wp_element_namespaceObject.createElement)(WithToolTip, {
    showTooltip: showTooltip,
    title: pattern.title
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__unstableCompositeItem, {
    role: "option",
    as: "div",
    ...composite,
    className: "block-editor-block-patterns-list__item",
    onClick: () => {
      onClick(pattern, blocks);
      onHover?.(null);
    },
    onMouseEnter: () => {
      if (isDragging) {
        return;
      }

      onHover?.(pattern);
    },
    onMouseLeave: () => onHover?.(null),
    "aria-label": pattern.title,
    "aria-describedby": pattern.description ? descriptionId : undefined
  }, (0,external_wp_element_namespaceObject.createElement)(block_preview, {
    blocks: blocks,
    viewportWidth: viewportWidth
  }), !showTooltip && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-patterns-list__item-title"
  }, pattern.title), !!pattern.description && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.VisuallyHidden, {
    id: descriptionId
  }, pattern.description)))));
}

function BlockPatternPlaceholder() {
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-patterns-list__item is-placeholder"
  });
}

function BlockPatternList({
  isDraggable,
  blockPatterns,
  shownPatterns,
  onHover,
  onClickPattern,
  orientation,
  label = (0,external_wp_i18n_namespaceObject.__)('Block Patterns'),
  showTitlesAsTooltip
}) {
  const composite = (0,external_wp_components_namespaceObject.__unstableUseCompositeState)({
    orientation
  });
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__unstableComposite, { ...composite,
    role: "listbox",
    className: "block-editor-block-patterns-list",
    "aria-label": label
  }, blockPatterns.map(pattern => {
    const isShown = shownPatterns.includes(pattern);
    return isShown ? (0,external_wp_element_namespaceObject.createElement)(BlockPattern, {
      key: pattern.name,
      pattern: pattern,
      onClick: onClickPattern,
      onHover: onHover,
      isDraggable: isDraggable,
      composite: composite,
      showTooltip: showTitlesAsTooltip
    }) : (0,external_wp_element_namespaceObject.createElement)(BlockPatternPlaceholder, {
      key: pattern.name
    });
  }));
}

/* harmony default export */ var block_patterns_list = (BlockPatternList);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-explorer/sidebar.js


/**
 * WordPress dependencies
 */



function PatternCategoriesList({
  selectedCategory,
  patternCategories,
  onClickCategory
}) {
  const baseClassName = 'block-editor-block-patterns-explorer__sidebar';
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: `${baseClassName}__categories-list`
  }, patternCategories.map(({
    name,
    label
  }) => {
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
      key: name,
      label: label,
      className: `${baseClassName}__categories-list__item`,
      isPressed: selectedCategory === name,
      onClick: () => {
        onClickCategory(name);
      }
    }, label);
  }));
}

function PatternsExplorerSearch({
  filterValue,
  setFilterValue
}) {
  const baseClassName = 'block-editor-block-patterns-explorer__search';
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: baseClassName
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SearchControl, {
    __nextHasNoMarginBottom: true,
    onChange: setFilterValue,
    value: filterValue,
    label: (0,external_wp_i18n_namespaceObject.__)('Search for patterns'),
    placeholder: (0,external_wp_i18n_namespaceObject.__)('Search')
  }));
}

function PatternExplorerSidebar({
  selectedCategory,
  patternCategories,
  onClickCategory,
  filterValue,
  setFilterValue
}) {
  const baseClassName = 'block-editor-block-patterns-explorer__sidebar';
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: baseClassName
  }, (0,external_wp_element_namespaceObject.createElement)(PatternsExplorerSearch, {
    filterValue: filterValue,
    setFilterValue: setFilterValue
  }), !filterValue && (0,external_wp_element_namespaceObject.createElement)(PatternCategoriesList, {
    selectedCategory: selectedCategory,
    patternCategories: patternCategories,
    onClickCategory: onClickCategory
  }));
}

/* harmony default export */ var sidebar = (PatternExplorerSidebar);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/no-results.js


/**
 * WordPress dependencies
 */



function InserterNoResults() {
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__no-results"
  }, (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
    className: "block-editor-inserter__no-results-icon",
    icon: block_default
  }), (0,external_wp_element_namespaceObject.createElement)("p", null, (0,external_wp_i18n_namespaceObject.__)('No results found.')));
}

/* harmony default export */ var no_results = (InserterNoResults);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-insertion-point.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


/**
 * @typedef WPInserterConfig
 *
 * @property {string=}   rootClientId   If set, insertion will be into the
 *                                      block with this ID.
 * @property {number=}   insertionIndex If set, insertion will be into this
 *                                      explicit position.
 * @property {string=}   clientId       If set, insertion will be after the
 *                                      block with this ID.
 * @property {boolean=}  isAppender     Whether the inserter is an appender
 *                                      or not.
 * @property {Function=} onSelect       Called after insertion.
 */

/**
 * Returns the insertion point state given the inserter config.
 *
 * @param {WPInserterConfig} config Inserter Config.
 * @return {Array} Insertion Point State (rootClientID, onInsertBlocks and onToggle).
 */

function useInsertionPoint({
  rootClientId = '',
  insertionIndex,
  clientId,
  isAppender,
  onSelect,
  shouldFocusBlock = true,
  selectBlockOnInsert = true
}) {
  const {
    getSelectedBlock
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    destinationRootClientId,
    destinationIndex
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getSelectedBlockClientId,
      getBlockRootClientId,
      getBlockIndex,
      getBlockOrder
    } = select(store);
    const selectedBlockClientId = getSelectedBlockClientId();
    let _destinationRootClientId = rootClientId;

    let _destinationIndex;

    if (insertionIndex !== undefined) {
      // Insert into a specific index.
      _destinationIndex = insertionIndex;
    } else if (clientId) {
      // Insert after a specific client ID.
      _destinationIndex = getBlockIndex(clientId);
    } else if (!isAppender && selectedBlockClientId) {
      _destinationRootClientId = getBlockRootClientId(selectedBlockClientId);
      _destinationIndex = getBlockIndex(selectedBlockClientId) + 1;
    } else {
      // Insert at the end of the list.
      _destinationIndex = getBlockOrder(_destinationRootClientId).length;
    }

    return {
      destinationRootClientId: _destinationRootClientId,
      destinationIndex: _destinationIndex
    };
  }, [rootClientId, insertionIndex, clientId, isAppender]);
  const {
    replaceBlocks,
    insertBlocks,
    showInsertionPoint,
    hideInsertionPoint
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const onInsertBlocks = (0,external_wp_element_namespaceObject.useCallback)((blocks, meta, shouldForceFocusBlock = false) => {
    const selectedBlock = getSelectedBlock();

    if (!isAppender && selectedBlock && (0,external_wp_blocks_namespaceObject.isUnmodifiedDefaultBlock)(selectedBlock)) {
      replaceBlocks(selectedBlock.clientId, blocks, null, shouldFocusBlock || shouldForceFocusBlock ? 0 : null, meta);
    } else {
      insertBlocks(blocks, destinationIndex, destinationRootClientId, selectBlockOnInsert, shouldFocusBlock || shouldForceFocusBlock ? 0 : null, meta);
    }

    const blockLength = Array.isArray(blocks) ? blocks.length : 1;
    const message = (0,external_wp_i18n_namespaceObject.sprintf)( // translators: %d: the name of the block that has been added
    (0,external_wp_i18n_namespaceObject._n)('%d block added.', '%d blocks added.', blockLength), blockLength);
    (0,external_wp_a11y_namespaceObject.speak)(message);

    if (onSelect) {
      onSelect(blocks);
    }
  }, [isAppender, getSelectedBlock, replaceBlocks, insertBlocks, destinationRootClientId, destinationIndex, onSelect, shouldFocusBlock, selectBlockOnInsert]);
  const onToggleInsertionPoint = (0,external_wp_element_namespaceObject.useCallback)(show => {
    if (show) {
      showInsertionPoint(destinationRootClientId, destinationIndex);
    } else {
      hideInsertionPoint();
    }
  }, [showInsertionPoint, hideInsertionPoint, destinationRootClientId, destinationIndex]);
  return [destinationRootClientId, onInsertBlocks, onToggleInsertionPoint];
}

/* harmony default export */ var use_insertion_point = (useInsertionPoint);

// EXTERNAL MODULE: ./node_modules/remove-accents/index.js
var remove_accents = __webpack_require__(4793);
var remove_accents_default = /*#__PURE__*/__webpack_require__.n(remove_accents);
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/search-items.js
/**
 * External dependencies
 */

 // Default search helpers.

const defaultGetName = item => item.name || '';

const defaultGetTitle = item => item.title;

const defaultGetDescription = item => item.description || '';

const defaultGetKeywords = item => item.keywords || [];

const defaultGetCategory = item => item.category;

const defaultGetCollection = () => null;
/**
 * Extracts words from an input string.
 *
 * @param {string} input The input string.
 *
 * @return {Array} Words, extracted from the input string.
 */


function extractWords(input = '') {
  return noCase(input, {
    splitRegexp: [/([\p{Ll}\p{Lo}\p{N}])([\p{Lu}\p{Lt}])/gu, // One lowercase or digit, followed by one uppercase.
    /([\p{Lu}\p{Lt}])([\p{Lu}\p{Lt}][\p{Ll}\p{Lo}])/gu // One uppercase followed by one uppercase and one lowercase.
    ],
    stripRegexp: /(\p{C}|\p{P}|\p{S})+/giu // Anything that's not a punctuation, symbol or control/format character.

  }).split(' ').filter(Boolean);
}
/**
 * Sanitizes the search input string.
 *
 * @param {string} input The search input to normalize.
 *
 * @return {string} The normalized search input.
 */


function normalizeSearchInput(input = '') {
  // Disregard diacritics.
  //  Input: "média"
  input = remove_accents_default()(input); // Accommodate leading slash, matching autocomplete expectations.
  //  Input: "/media"

  input = input.replace(/^\//, ''); // Lowercase.
  //  Input: "MEDIA"

  input = input.toLowerCase();
  return input;
}
/**
 * Converts the search term into a list of normalized terms.
 *
 * @param {string} input The search term to normalize.
 *
 * @return {string[]} The normalized list of search terms.
 */


const getNormalizedSearchTerms = (input = '') => {
  return extractWords(normalizeSearchInput(input));
};

const removeMatchingTerms = (unmatchedTerms, unprocessedTerms) => {
  return unmatchedTerms.filter(term => !getNormalizedSearchTerms(unprocessedTerms).some(unprocessedTerm => unprocessedTerm.includes(term)));
};

const searchBlockItems = (items, categories, collections, searchInput) => {
  const normalizedSearchTerms = getNormalizedSearchTerms(searchInput);

  if (normalizedSearchTerms.length === 0) {
    return items;
  }

  const config = {
    getCategory: item => categories.find(({
      slug
    }) => slug === item.category)?.title,
    getCollection: item => collections[item.name.split('/')[0]]?.title
  };
  return searchItems(items, searchInput, config);
};
/**
 * Filters an item list given a search term.
 *
 * @param {Array}  items       Item list
 * @param {string} searchInput Search input.
 * @param {Object} config      Search Config.
 *
 * @return {Array} Filtered item list.
 */

const searchItems = (items = [], searchInput = '', config = {}) => {
  const normalizedSearchTerms = getNormalizedSearchTerms(searchInput);

  if (normalizedSearchTerms.length === 0) {
    return items;
  }

  const rankedItems = items.map(item => {
    return [item, getItemSearchRank(item, searchInput, config)];
  }).filter(([, rank]) => rank > 0);
  rankedItems.sort(([, rank1], [, rank2]) => rank2 - rank1);
  return rankedItems.map(([item]) => item);
};
/**
 * Get the search rank for a given item and a specific search term.
 * The better the match, the higher the rank.
 * If the rank equals 0, it should be excluded from the results.
 *
 * @param {Object} item       Item to filter.
 * @param {string} searchTerm Search term.
 * @param {Object} config     Search Config.
 *
 * @return {number} Search Rank.
 */

function getItemSearchRank(item, searchTerm, config = {}) {
  const {
    getName = defaultGetName,
    getTitle = defaultGetTitle,
    getDescription = defaultGetDescription,
    getKeywords = defaultGetKeywords,
    getCategory = defaultGetCategory,
    getCollection = defaultGetCollection
  } = config;
  const name = getName(item);
  const title = getTitle(item);
  const description = getDescription(item);
  const keywords = getKeywords(item);
  const category = getCategory(item);
  const collection = getCollection(item);
  const normalizedSearchInput = normalizeSearchInput(searchTerm);
  const normalizedTitle = normalizeSearchInput(title);
  let rank = 0; // Prefers exact matches
  // Then prefers if the beginning of the title matches the search term
  // name, keywords, categories, collection, variations match come later.

  if (normalizedSearchInput === normalizedTitle) {
    rank += 30;
  } else if (normalizedTitle.startsWith(normalizedSearchInput)) {
    rank += 20;
  } else {
    const terms = [name, title, description, ...keywords, category, collection].join(' ');
    const normalizedSearchTerms = extractWords(normalizedSearchInput);
    const unmatchedTerms = removeMatchingTerms(normalizedSearchTerms, terms);

    if (unmatchedTerms.length === 0) {
      rank += 10;
    }
  } // Give a better rank to "core" namespaced items.


  if (rank !== 0 && name.startsWith('core/')) {
    const isCoreBlockVariation = name !== item.id; // Give a bit better rank to "core" blocks over "core" block variations.

    rank += isCoreBlockVariation ? 1 : 2;
  }

  return rank;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-explorer/patterns-list.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */







const INITIAL_INSERTER_RESULTS = 2;

function PatternsListHeader({
  filterValue,
  filteredBlockPatternsLength
}) {
  if (!filterValue) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHeading, {
    level: 2,
    lineHeight: '48px',
    className: "block-editor-block-patterns-explorer__search-results-count"
  }, (0,external_wp_i18n_namespaceObject.sprintf)(
  /* translators: %d: number of patterns. %s: block pattern search query */
  (0,external_wp_i18n_namespaceObject._n)('%1$d pattern found for "%2$s"', '%1$d patterns found for "%2$s"', filteredBlockPatternsLength), filteredBlockPatternsLength, filterValue));
}

function PatternList({
  filterValue,
  selectedCategory,
  patternCategories
}) {
  const debouncedSpeak = (0,external_wp_compose_namespaceObject.useDebounce)(external_wp_a11y_namespaceObject.speak, 500);
  const [destinationRootClientId, onInsertBlocks] = use_insertion_point({
    shouldFocusBlock: true
  });
  const [allPatterns,, onSelectBlockPattern] = use_patterns_state(onInsertBlocks, destinationRootClientId);
  const registeredPatternCategories = (0,external_wp_element_namespaceObject.useMemo)(() => patternCategories.map(patternCategory => patternCategory.name), [patternCategories]);
  const filteredBlockPatterns = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (!filterValue) {
      return allPatterns.filter(pattern => selectedCategory === 'uncategorized' ? !pattern.categories?.length || pattern.categories.every(category => !registeredPatternCategories.includes(category)) : pattern.categories?.includes(selectedCategory));
    }

    return searchItems(allPatterns, filterValue);
  }, [filterValue, allPatterns, selectedCategory, registeredPatternCategories]); // Announce search results on change.

  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!filterValue) {
      return;
    }

    const count = filteredBlockPatterns.length;
    const resultsFoundMessage = (0,external_wp_i18n_namespaceObject.sprintf)(
    /* translators: %d: number of results. */
    (0,external_wp_i18n_namespaceObject._n)('%d result found.', '%d results found.', count), count);
    debouncedSpeak(resultsFoundMessage);
  }, [filterValue, debouncedSpeak, filteredBlockPatterns.length]);
  const currentShownPatterns = (0,external_wp_compose_namespaceObject.useAsyncList)(filteredBlockPatterns, {
    step: INITIAL_INSERTER_RESULTS
  });
  const hasItems = !!filteredBlockPatterns?.length;
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-patterns-explorer__list"
  }, hasItems && (0,external_wp_element_namespaceObject.createElement)(PatternsListHeader, {
    filterValue: filterValue,
    filteredBlockPatternsLength: filteredBlockPatterns.length
  }), (0,external_wp_element_namespaceObject.createElement)(inserter_listbox, null, !hasItems && (0,external_wp_element_namespaceObject.createElement)(no_results, null), hasItems && (0,external_wp_element_namespaceObject.createElement)(block_patterns_list, {
    shownPatterns: currentShownPatterns,
    blockPatterns: filteredBlockPatterns,
    onClickPattern: onSelectBlockPattern,
    isDraggable: false
  })));
}

/* harmony default export */ var patterns_list = (PatternList);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-explorer/explorer.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




function PatternsExplorer({
  initialCategory,
  patternCategories
}) {
  const [filterValue, setFilterValue] = (0,external_wp_element_namespaceObject.useState)('');
  const [selectedCategory, setSelectedCategory] = (0,external_wp_element_namespaceObject.useState)(initialCategory?.name);
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-patterns-explorer"
  }, (0,external_wp_element_namespaceObject.createElement)(sidebar, {
    selectedCategory: selectedCategory,
    patternCategories: patternCategories,
    onClickCategory: setSelectedCategory,
    filterValue: filterValue,
    setFilterValue: setFilterValue
  }), (0,external_wp_element_namespaceObject.createElement)(patterns_list, {
    filterValue: filterValue,
    selectedCategory: selectedCategory,
    patternCategories: patternCategories
  }));
}

function PatternsExplorerModal({
  onModalClose,
  ...restProps
}) {
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Modal, {
    title: (0,external_wp_i18n_namespaceObject.__)('Patterns'),
    onRequestClose: onModalClose,
    isFullScreen: true
  }, (0,external_wp_element_namespaceObject.createElement)(PatternsExplorer, { ...restProps
  }));
}

/* harmony default export */ var explorer = (PatternsExplorerModal);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/mobile-tab-navigation.js


/**
 * WordPress dependencies
 */




function ScreenHeader({
  title
}) {
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalVStack, {
    spacing: 0
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalView, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalSpacer, {
    marginBottom: 0,
    paddingX: 4,
    paddingY: 3
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHStack, {
    spacing: 2
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalNavigatorBackButton, {
    style: // TODO: This style override is also used in ToolsPanelHeader.
    // It should be supported out-of-the-box by Button.
    {
      minWidth: 24,
      padding: 0
    },
    icon: (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_right : chevron_left,
    isSmall: true,
    "aria-label": (0,external_wp_i18n_namespaceObject.__)('Navigate to the previous view')
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalSpacer, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHeading, {
    level: 5
  }, title))))));
}

function MobileTabNavigation({
  categories,
  children
}) {
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalNavigatorProvider, {
    initialPath: "/",
    className: "block-editor-inserter__mobile-tab-navigation"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalNavigatorScreen, {
    path: "/"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalItemGroup, null, categories.map(category => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalNavigatorButton, {
    key: category.name,
    path: `/category/${category.name}`,
    as: external_wp_components_namespaceObject.__experimentalItem,
    isAction: true
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHStack, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexBlock, null, category.label), (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
    icon: (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_left : chevron_right
  })))))), categories.map(category => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalNavigatorScreen, {
    key: category.name,
    path: `/category/${category.name}`
  }, (0,external_wp_element_namespaceObject.createElement)(ScreenHeader, {
    title: (0,external_wp_i18n_namespaceObject.__)('Back')
  }), children(category))));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-tab.js


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */






const block_patterns_tab_noop = () => {}; // Preferred order of pattern categories. Any other categories should
// be at the bottom without any re-ordering.


const patternCategoriesOrder = ['custom', 'featured', 'posts', 'text', 'gallery', 'call-to-action', 'banner', 'header', 'footer'];

function usePatternsCategories(rootClientId) {
  const [allPatterns, allCategories] = use_patterns_state(undefined, rootClientId);
  const hasRegisteredCategory = (0,external_wp_element_namespaceObject.useCallback)(pattern => {
    if (!pattern.categories || !pattern.categories.length) {
      return false;
    }

    return pattern.categories.some(cat => allCategories.some(category => category.name === cat));
  }, [allCategories]); // Remove any empty categories.

  const populatedCategories = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const categories = allCategories.filter(category => allPatterns.some(pattern => pattern.categories?.includes(category.name))).sort(({
      name: aName
    }, {
      name: bName
    }) => {
      // Sort categories according to `patternCategoriesOrder`.
      let aIndex = patternCategoriesOrder.indexOf(aName);
      let bIndex = patternCategoriesOrder.indexOf(bName); // All other categories should come after that.

      if (aIndex < 0) aIndex = patternCategoriesOrder.length;
      if (bIndex < 0) bIndex = patternCategoriesOrder.length;
      return aIndex - bIndex;
    });

    if (allPatterns.some(pattern => !hasRegisteredCategory(pattern)) && !categories.find(category => category.name === 'uncategorized')) {
      categories.push({
        name: 'uncategorized',
        label: (0,external_wp_i18n_namespaceObject._x)('Uncategorized')
      });
    }

    return categories;
  }, [allCategories, allPatterns, hasRegisteredCategory]);
  return populatedCategories;
}

function BlockPatternsCategoryDialog({
  rootClientId,
  onInsert,
  onHover,
  category,
  showTitlesAsTooltip
}) {
  const container = (0,external_wp_element_namespaceObject.useRef)();
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    const timeout = setTimeout(() => {
      const [firstTabbable] = external_wp_dom_namespaceObject.focus.tabbable.find(container.current);
      firstTabbable?.focus();
    });
    return () => clearTimeout(timeout);
  }, [category]);
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    ref: container,
    className: "block-editor-inserter__patterns-category-dialog"
  }, (0,external_wp_element_namespaceObject.createElement)(BlockPatternsCategoryPanel, {
    rootClientId: rootClientId,
    onInsert: onInsert,
    onHover: onHover,
    category: category,
    showTitlesAsTooltip: showTitlesAsTooltip
  }));
}
function BlockPatternsCategoryPanel({
  rootClientId,
  onInsert,
  onHover = block_patterns_tab_noop,
  category,
  showTitlesAsTooltip
}) {
  const [allPatterns,, onClick] = use_patterns_state(onInsert, rootClientId);
  const availableCategories = usePatternsCategories(rootClientId);
  const currentCategoryPatterns = (0,external_wp_element_namespaceObject.useMemo)(() => allPatterns.filter(pattern => {
    var _pattern$categories$f;

    if (category.name !== 'uncategorized') {
      return pattern.categories?.includes(category.name);
    } // The uncategorized category should show all the patterns without any category
    // or with no available category.


    const availablePatternCategories = (_pattern$categories$f = pattern.categories?.filter(cat => availableCategories.find(availableCategory => availableCategory.name === cat))) !== null && _pattern$categories$f !== void 0 ? _pattern$categories$f : [];
    return availablePatternCategories.length === 0;
  }), [allPatterns, availableCategories, category.name]);
  const categoryPatternsList = (0,external_wp_compose_namespaceObject.useAsyncList)(currentCategoryPatterns); // Hide block pattern preview on unmount.

  (0,external_wp_element_namespaceObject.useEffect)(() => () => onHover(null), []);

  if (!currentCategoryPatterns.length) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__patterns-category-panel"
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__patterns-category-panel-title"
  }, category.label), (0,external_wp_element_namespaceObject.createElement)("p", null, category.description), (0,external_wp_element_namespaceObject.createElement)(block_patterns_list, {
    shownPatterns: categoryPatternsList,
    blockPatterns: currentCategoryPatterns,
    onClickPattern: onClick,
    onHover: onHover,
    label: category.label,
    orientation: "vertical",
    category: category.label,
    isDraggable: true,
    showTitlesAsTooltip: showTitlesAsTooltip
  }));
}

function BlockPatternsTabs({
  onSelectCategory,
  selectedCategory,
  onInsert,
  rootClientId
}) {
  const [showPatternsExplorer, setShowPatternsExplorer] = (0,external_wp_element_namespaceObject.useState)(false);
  const categories = usePatternsCategories(rootClientId);
  const initialCategory = selectedCategory || categories[0];
  const isMobile = (0,external_wp_compose_namespaceObject.useViewportMatch)('medium', '<');
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, !isMobile && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__block-patterns-tabs-container"
  }, (0,external_wp_element_namespaceObject.createElement)("nav", {
    "aria-label": (0,external_wp_i18n_namespaceObject.__)('Block pattern categories')
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalItemGroup, {
    role: "list",
    className: "block-editor-inserter__block-patterns-tabs"
  }, categories.map(category => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalItem, {
    role: "listitem",
    key: category.name,
    onClick: () => onSelectCategory(category),
    className: category === selectedCategory ? 'block-editor-inserter__patterns-category block-editor-inserter__patterns-selected-category' : 'block-editor-inserter__patterns-category',
    "aria-label": category.label,
    "aria-current": category === selectedCategory ? 'true' : undefined
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHStack, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexBlock, null, category.label), (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
    icon: (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_left : chevron_right
  })))), (0,external_wp_element_namespaceObject.createElement)("div", {
    role: "listitem"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    className: "block-editor-inserter__patterns-explore-button",
    onClick: () => setShowPatternsExplorer(true),
    variant: "secondary"
  }, (0,external_wp_i18n_namespaceObject.__)('Explore all patterns')))))), isMobile && (0,external_wp_element_namespaceObject.createElement)(MobileTabNavigation, {
    categories: categories
  }, category => (0,external_wp_element_namespaceObject.createElement)(BlockPatternsCategoryPanel, {
    onInsert: onInsert,
    rootClientId: rootClientId,
    category: category,
    showTitlesAsTooltip: false
  })), showPatternsExplorer && (0,external_wp_element_namespaceObject.createElement)(explorer, {
    initialCategory: initialCategory,
    patternCategories: categories,
    onModalClose: () => setShowPatternsExplorer(false)
  }));
}

/* harmony default export */ var block_patterns_tab = (BlockPatternsTabs);

;// CONCATENATED MODULE: external ["wp","url"]
var external_wp_url_namespaceObject = window["wp"]["url"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/close.js


/**
 * WordPress dependencies
 */

const close_close = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M13 11.8l6.1-6.3-1-1-6.1 6.2-6.1-6.2-1 1 6.1 6.3-6.5 6.7 1 1 6.5-6.6 6.5 6.6 1-1z"
}));
/* harmony default export */ var library_close = (close_close);

;// CONCATENATED MODULE: external ["wp","preferences"]
var external_wp_preferences_namespaceObject = window["wp"]["preferences"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/reusable-block-rename-hint.js


/**
 * WordPress dependencies
 */







const PREFERENCE_NAME = 'isResuableBlocksrRenameHintVisible';
/*
 * This hook was added in 6.3 to help users with the transition from Reusable blocks to Patterns.
 * It is only exported for use in the reusable-blocks package as well as block-editor.
 * It will be removed in 6.4. and should not be used in any new code.
 */

function useReusableBlocksRenameHint() {
  return (0,external_wp_data_namespaceObject.useSelect)(select => {
    var _select$get;

    return (_select$get = select(external_wp_preferences_namespaceObject.store).get('core', PREFERENCE_NAME)) !== null && _select$get !== void 0 ? _select$get : true;
  }, []);
}
/*
 * This component was added in 6.3 to help users with the transition from Reusable blocks to Patterns.
 * It is only exported for use in the reusable-blocks package as well as block-editor.
 * It will be removed in 6.4. and should not be used in any new code.
 */

function ReusableBlocksRenameHint() {
  const isReusableBlocksRenameHint = (0,external_wp_data_namespaceObject.useSelect)(select => {
    var _select$get2;

    return (_select$get2 = select(external_wp_preferences_namespaceObject.store).get('core', PREFERENCE_NAME)) !== null && _select$get2 !== void 0 ? _select$get2 : true;
  }, []);
  const ref = (0,external_wp_element_namespaceObject.useRef)();
  const {
    set: setPreference
  } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_preferences_namespaceObject.store);

  if (!isReusableBlocksRenameHint) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)("div", {
    ref: ref,
    className: "reusable-blocks-menu-items__rename-hint"
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "reusable-blocks-menu-items__rename-hint-content"
  }, (0,external_wp_i18n_namespaceObject.__)('Reusable blocks are now synced patterns. A synced pattern will behave in exactly the same way as a reusable block.')), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    className: "reusable-blocks-menu-items__rename-hint-dismiss",
    icon: library_close,
    iconSize: "16",
    label: (0,external_wp_i18n_namespaceObject.__)('Dismiss hint'),
    onClick: () => {
      // Retain focus when dismissing the element.
      const previousElement = external_wp_dom_namespaceObject.focus.tabbable.findPrevious(ref.current);
      previousElement?.focus();
      setPreference('core', PREFERENCE_NAME, false);
    },
    showTooltip: false
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/reusable-blocks-tab.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */







function ReusableBlocksList({
  onHover,
  onInsert,
  rootClientId
}) {
  const [items,,, onSelectItem] = use_block_types_state(rootClientId, onInsert);
  const filteredItems = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return items.filter(({
      category
    }) => category === 'reusable');
  }, [items]);

  if (filteredItems.length === 0) {
    return (0,external_wp_element_namespaceObject.createElement)(no_results, null);
  }

  return (0,external_wp_element_namespaceObject.createElement)(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Synced patterns')
  }, (0,external_wp_element_namespaceObject.createElement)(block_types_list, {
    items: filteredItems,
    onSelect: onSelectItem,
    onHover: onHover,
    label: (0,external_wp_i18n_namespaceObject.__)('Synced patterns')
  }));
} // The unwrapped component is only exported for use by unit tests.

/**
 * List of reusable blocks shown in the "Reusable" tab of the inserter.
 *
 * @param {Object}   props              Component props.
 * @param {?string}  props.rootClientId Client id of block to insert into.
 * @param {Function} props.onInsert     Callback to run when item is inserted.
 * @param {Function} props.onHover      Callback to run when item is hovered.
 *
 * @return {WPComponent} The component.
 */


function ReusableBlocksTab({
  rootClientId,
  onInsert,
  onHover
}) {
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__hint"
  }, (0,external_wp_element_namespaceObject.createElement)(ReusableBlocksRenameHint, null)), (0,external_wp_element_namespaceObject.createElement)(ReusableBlocksList, {
    onHover: onHover,
    onInsert: onInsert,
    rootClientId: rootClientId
  }), (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__manage-reusable-blocks-container"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    className: "block-editor-inserter__manage-reusable-blocks",
    variant: "secondary",
    href: (0,external_wp_url_namespaceObject.addQueryArgs)('edit.php', {
      post_type: 'wp_block'
    })
  }, (0,external_wp_i18n_namespaceObject.__)('Manage my patterns'))));
}
/* harmony default export */ var reusable_blocks_tab = (ReusableBlocksTab);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/media-tab/hooks.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Interface for inserter media requests.
 *
 * @typedef {Object} InserterMediaRequest
 * @property {number} per_page How many items to fetch per page.
 * @property {string} search   The search term to use for filtering the results.
 */

/**
 * Interface for inserter media responses. Any media resource should
 * map their response to this interface, in order to create the core
 * WordPress media blocks (image, video, audio).
 *
 * @typedef {Object} InserterMediaItem
 * @property {string}        title        The title of the media item.
 * @property {string}        url          The source url of the media item.
 * @property {string}        [previewUrl] The preview source url of the media item to display in the media list.
 * @property {number}        [id]         The WordPress id of the media item.
 * @property {number|string} [sourceId]   The id of the media item from external source.
 * @property {string}        [alt]        The alt text of the media item.
 * @property {string}        [caption]    The caption of the media item.
 */

/**
 * Fetches media items based on the provided category.
 * Each media category is responsible for providing a `fetch` function.
 *
 * @param {Object}               category The media category to fetch results for.
 * @param {InserterMediaRequest} query    The query args to use for the request.
 * @return {InserterMediaItem[]} The media results.
 */

function useMediaResults(category, query = {}) {
  const [mediaList, setMediaList] = (0,external_wp_element_namespaceObject.useState)();
  const [isLoading, setIsLoading] = (0,external_wp_element_namespaceObject.useState)(false); // We need to keep track of the last request made because
  // multiple request can be fired without knowing the order
  // of resolution, and we need to ensure we are showing
  // the results of the last request.
  // In the future we could use AbortController to cancel previous
  // requests, but we don't for now as it involves adding support
  // for this to `core-data` package.

  const lastRequest = (0,external_wp_element_namespaceObject.useRef)();
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    (async () => {
      const key = JSON.stringify({
        category: category.name,
        ...query
      });
      lastRequest.current = key;
      setIsLoading(true);
      setMediaList([]); // Empty the previous results.

      const _media = await category.fetch?.(query);

      if (key === lastRequest.current) {
        setMediaList(_media);
        setIsLoading(false);
      }
    })();
  }, [category.name, ...Object.values(query)]);
  return {
    mediaList,
    isLoading
  };
}

function useInserterMediaCategories() {
  const {
    inserterMediaCategories,
    allowedMimeTypes,
    enableOpenverseMediaCategory
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const settings = select(store).getSettings();
    return {
      inserterMediaCategories: settings.inserterMediaCategories,
      allowedMimeTypes: settings.allowedMimeTypes,
      enableOpenverseMediaCategory: settings.enableOpenverseMediaCategory
    };
  }, []); // The allowed `mime_types` can be altered by `upload_mimes` filter and restrict
  // some of them. In this case we shouldn't add the category to the available media
  // categories list in the inserter.

  const allowedCategories = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (!inserterMediaCategories || !allowedMimeTypes) {
      return;
    }

    return inserterMediaCategories.filter(category => {
      // Check if Openverse category is enabled.
      if (!enableOpenverseMediaCategory && category.name === 'openverse') {
        return false;
      }

      return Object.values(allowedMimeTypes).some(mimeType => mimeType.startsWith(`${category.mediaType}/`));
    });
  }, [inserterMediaCategories, allowedMimeTypes, enableOpenverseMediaCategory]);
  return allowedCategories;
}

function useMediaCategories(rootClientId) {
  const [categories, setCategories] = (0,external_wp_element_namespaceObject.useState)([]);
  const {
    canInsertImage,
    canInsertVideo,
    canInsertAudio
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      canInsertBlockType
    } = select(store);
    return {
      canInsertImage: canInsertBlockType('core/image', rootClientId),
      canInsertVideo: canInsertBlockType('core/video', rootClientId),
      canInsertAudio: canInsertBlockType('core/audio', rootClientId)
    };
  }, [rootClientId]);
  const inserterMediaCategories = useInserterMediaCategories();
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    (async () => {
      const _categories = []; // If `inserterMediaCategories` is not defined in
      // block editor settings, do not show any media categories.

      if (!inserterMediaCategories) {
        return;
      } // Loop through categories to check if they have at least one media item.


      const categoriesHaveMedia = new Map(await Promise.all(inserterMediaCategories.map(async category => {
        // Some sources are external and we don't need to make a request.
        if (category.isExternalResource) {
          return [category.name, true];
        }

        let results = [];

        try {
          results = await category.fetch({
            per_page: 1
          });
        } catch (e) {// If the request fails, we shallow the error and just don't show
          // the category, in order to not break the media tab.
        }

        return [category.name, !!results.length];
      }))); // We need to filter out categories that don't have any media items or
      // whose corresponding block type is not allowed to be inserted, based
      // on the category's `mediaType`.

      const canInsertMediaType = {
        image: canInsertImage,
        video: canInsertVideo,
        audio: canInsertAudio
      };
      inserterMediaCategories.forEach(category => {
        if (canInsertMediaType[category.mediaType] && categoriesHaveMedia.get(category.name)) {
          _categories.push(category);
        }
      });

      if (!!_categories.length) {
        setCategories(_categories);
      }
    })();
  }, [canInsertImage, canInsertVideo, canInsertAudio, inserterMediaCategories]);
  return categories;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/more-vertical.js


/**
 * WordPress dependencies
 */

const moreVertical = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M13 19h-2v-2h2v2zm0-6h-2v-2h2v2zm0-6h-2V5h2v2z"
}));
/* harmony default export */ var more_vertical = (moreVertical);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/external.js


/**
 * WordPress dependencies
 */

const external = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M19.5 4.5h-7V6h4.44l-5.97 5.97 1.06 1.06L18 7.06v4.44h1.5v-7Zm-13 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-3H17v3a.5.5 0 0 1-.5.5h-10a.5.5 0 0 1-.5-.5v-10a.5.5 0 0 1 .5-.5h3V5.5h-3Z"
}));
/* harmony default export */ var library_external = (external);

;// CONCATENATED MODULE: external ["wp","blob"]
var external_wp_blob_namespaceObject = window["wp"]["blob"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/media-tab/utils.js


/**
 * WordPress dependencies
 */

const mediaTypeTag = {
  image: 'img',
  video: 'video',
  audio: 'audio'
};
/** @typedef {import('./hooks').InserterMediaItem} InserterMediaItem */

/**
 * Creates a block and a preview element from a media object.
 *
 * @param {InserterMediaItem}         media     The media object to create the block from.
 * @param {('image'|'audio'|'video')} mediaType The media type to create the block for.
 * @return {[WPBlock, JSX.Element]} An array containing the block and the preview element.
 */

function getBlockAndPreviewFromMedia(media, mediaType) {
  // Add the common attributes between the different media types.
  const attributes = {
    id: media.id || undefined,
    caption: media.caption || undefined
  };
  const mediaSrc = media.url;
  const alt = media.alt || undefined;

  if (mediaType === 'image') {
    attributes.url = mediaSrc;
    attributes.alt = alt;
  } else if (['video', 'audio'].includes(mediaType)) {
    attributes.src = mediaSrc;
  }

  const PreviewTag = mediaTypeTag[mediaType];
  const preview = (0,external_wp_element_namespaceObject.createElement)(PreviewTag, {
    src: media.previewUrl || mediaSrc,
    alt: alt,
    controls: mediaType === 'audio' ? true : undefined,
    inert: "true",
    onError: ({
      currentTarget
    }) => {
      // Fall back to the media source if the preview cannot be loaded.
      if (currentTarget.src === media.previewUrl) {
        currentTarget.src = mediaSrc;
      }
    }
  });
  return [(0,external_wp_blocks_namespaceObject.createBlock)(`core/${mediaType}`, attributes), preview];
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/media-tab/media-preview.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */









/**
 * Internal dependencies
 */




const ALLOWED_MEDIA_TYPES = ['image'];
const MAXIMUM_TITLE_LENGTH = 25;
const MEDIA_OPTIONS_POPOVER_PROPS = {
  position: 'bottom left',
  className: 'block-editor-inserter__media-list__item-preview-options__popover'
};

function MediaPreviewOptions({
  category,
  media
}) {
  if (!category.getReportUrl) {
    return null;
  }

  const reportUrl = category.getReportUrl(media);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.DropdownMenu, {
    className: "block-editor-inserter__media-list__item-preview-options",
    label: (0,external_wp_i18n_namespaceObject.__)('Options'),
    popoverProps: MEDIA_OPTIONS_POPOVER_PROPS,
    icon: more_vertical
  }, () => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuGroup, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    onClick: () => window.open(reportUrl, '_blank').focus(),
    icon: library_external
  }, (0,external_wp_i18n_namespaceObject.sprintf)(
  /* translators: %s: The media type to report e.g: "image", "video", "audio" */
  (0,external_wp_i18n_namespaceObject.__)('Report %s'), category.mediaType))));
}

function InsertExternalImageModal({
  onClose,
  onSubmit
}) {
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Modal, {
    title: (0,external_wp_i18n_namespaceObject.__)('Insert external image'),
    onRequestClose: onClose,
    className: "block-editor-inserter-media-tab-media-preview-inserter-external-image-modal"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalVStack, {
    spacing: 3
  }, (0,external_wp_element_namespaceObject.createElement)("p", null, (0,external_wp_i18n_namespaceObject.__)('This image cannot be uploaded to your Media Library, but it can still be inserted as an external image.')), (0,external_wp_element_namespaceObject.createElement)("p", null, (0,external_wp_i18n_namespaceObject.__)('External images can be removed by the external provider without warning and could even have legal compliance issues related to privacy legislation.'))), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Flex, {
    className: "block-editor-block-lock-modal__actions",
    justify: "flex-end",
    expanded: false
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    variant: "tertiary",
    onClick: onClose
  }, (0,external_wp_i18n_namespaceObject.__)('Cancel'))), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    variant: "primary",
    onClick: onSubmit
  }, (0,external_wp_i18n_namespaceObject.__)('Insert')))));
}

function MediaPreview({
  media,
  onClick,
  composite,
  category
}) {
  const [showExternalUploadModal, setShowExternalUploadModal] = (0,external_wp_element_namespaceObject.useState)(false);
  const [isHovered, setIsHovered] = (0,external_wp_element_namespaceObject.useState)(false);
  const [isInserting, setIsInserting] = (0,external_wp_element_namespaceObject.useState)(false);
  const [block, preview] = (0,external_wp_element_namespaceObject.useMemo)(() => getBlockAndPreviewFromMedia(media, category.mediaType), [media, category.mediaType]);
  const {
    createErrorNotice,
    createSuccessNotice
  } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_notices_namespaceObject.store);
  const mediaUpload = (0,external_wp_data_namespaceObject.useSelect)(select => select(store).getSettings().mediaUpload, []);
  const onMediaInsert = (0,external_wp_element_namespaceObject.useCallback)(previewBlock => {
    // Prevent multiple uploads when we're in the process of inserting.
    if (isInserting) {
      return;
    }

    const clonedBlock = (0,external_wp_blocks_namespaceObject.cloneBlock)(previewBlock);
    const {
      id,
      url,
      caption
    } = clonedBlock.attributes; // Media item already exists in library, so just insert it.

    if (!!id) {
      onClick(clonedBlock);
      return;
    }

    setIsInserting(true); // Media item does not exist in library, so try to upload it.
    // Fist fetch the image data. This may fail if the image host
    // doesn't allow CORS with the domain.
    // If this happens, we insert the image block using the external
    // URL and let the user know about the possible implications.

    window.fetch(url).then(response => response.blob()).then(blob => {
      mediaUpload({
        filesList: [blob],
        additionalData: {
          caption
        },

        onFileChange([img]) {
          if ((0,external_wp_blob_namespaceObject.isBlobURL)(img.url)) {
            return;
          }

          onClick({ ...clonedBlock,
            attributes: { ...clonedBlock.attributes,
              id: img.id,
              url: img.url
            }
          });
          createSuccessNotice((0,external_wp_i18n_namespaceObject.__)('Image uploaded and inserted.'), {
            type: 'snackbar'
          });
          setIsInserting(false);
        },

        allowedTypes: ALLOWED_MEDIA_TYPES,

        onError(message) {
          createErrorNotice(message, {
            type: 'snackbar'
          });
          setIsInserting(false);
        }

      });
    }).catch(() => {
      setShowExternalUploadModal(true);
      setIsInserting(false);
    });
  }, [isInserting, onClick, mediaUpload, createErrorNotice, createSuccessNotice]);
  const title = media.title?.rendered || media.title;
  let truncatedTitle;

  if (title.length > MAXIMUM_TITLE_LENGTH) {
    const omission = '...';
    truncatedTitle = title.slice(0, MAXIMUM_TITLE_LENGTH - omission.length) + omission;
  }

  const onMouseEnter = (0,external_wp_element_namespaceObject.useCallback)(() => setIsHovered(true), []);
  const onMouseLeave = (0,external_wp_element_namespaceObject.useCallback)(() => setIsHovered(false), []);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(inserter_draggable_blocks, {
    isEnabled: true,
    blocks: [block]
  }, ({
    draggable,
    onDragStart,
    onDragEnd
  }) => (0,external_wp_element_namespaceObject.createElement)("div", {
    className: classnames_default()('block-editor-inserter__media-list__list-item', {
      'is-hovered': isHovered
    }),
    draggable: draggable,
    onDragStart: onDragStart,
    onDragEnd: onDragEnd
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Tooltip, {
    text: truncatedTitle || title
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__unstableCompositeItem, {
    role: "option",
    as: "div",
    ...composite,
    className: "block-editor-inserter__media-list__item",
    onClick: () => onMediaInsert(block),
    "aria-label": title
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__media-list__item-preview"
  }, preview, isInserting && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__media-list__item-preview-spinner"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Spinner, null)))), !isInserting && (0,external_wp_element_namespaceObject.createElement)(MediaPreviewOptions, {
    category: category,
    media: media
  }))))), showExternalUploadModal && (0,external_wp_element_namespaceObject.createElement)(InsertExternalImageModal, {
    onClose: () => setShowExternalUploadModal(false),
    onSubmit: () => {
      onClick((0,external_wp_blocks_namespaceObject.cloneBlock)(block));
      createSuccessNotice((0,external_wp_i18n_namespaceObject.__)('Image inserted.'), {
        type: 'snackbar'
      });
      setShowExternalUploadModal(false);
    }
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/media-tab/media-list.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function MediaList({
  mediaList,
  category,
  onClick,
  label = (0,external_wp_i18n_namespaceObject.__)('Media List')
}) {
  const composite = (0,external_wp_components_namespaceObject.__unstableUseCompositeState)();
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__unstableComposite, { ...composite,
    role: "listbox",
    className: "block-editor-inserter__media-list",
    "aria-label": label
  }, mediaList.map((media, index) => (0,external_wp_element_namespaceObject.createElement)(MediaPreview, {
    key: media.id || media.sourceId || index,
    media: media,
    category: category,
    onClick: onClick,
    composite: composite
  })));
}

/* harmony default export */ var media_list = (MediaList);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-debounced-input.js
/**
 * WordPress dependencies
 */


function useDebouncedInput(defaultValue = '') {
  const [input, setInput] = (0,external_wp_element_namespaceObject.useState)(defaultValue);
  const [debounced, setter] = (0,external_wp_element_namespaceObject.useState)(defaultValue);
  const setDebounced = (0,external_wp_compose_namespaceObject.useDebounce)(setter, 250);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (debounced !== input) {
      setDebounced(input);
    }
  }, [debounced, input]);
  return [input, setInput, debounced];
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/media-tab/media-panel.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





const INITIAL_MEDIA_ITEMS_PER_PAGE = 10;
function MediaCategoryDialog({
  rootClientId,
  onInsert,
  category
}) {
  const container = (0,external_wp_element_namespaceObject.useRef)();
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    const timeout = setTimeout(() => {
      const [firstTabbable] = external_wp_dom_namespaceObject.focus.tabbable.find(container.current);
      firstTabbable?.focus();
    });
    return () => clearTimeout(timeout);
  }, [category]);
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    ref: container,
    className: "block-editor-inserter__media-dialog"
  }, (0,external_wp_element_namespaceObject.createElement)(MediaCategoryPanel, {
    rootClientId: rootClientId,
    onInsert: onInsert,
    category: category
  }));
}
function MediaCategoryPanel({
  rootClientId,
  onInsert,
  category
}) {
  const [search, setSearch, debouncedSearch] = useDebouncedInput();
  const {
    mediaList,
    isLoading
  } = useMediaResults(category, {
    per_page: !!debouncedSearch ? 20 : INITIAL_MEDIA_ITEMS_PER_PAGE,
    search: debouncedSearch
  });
  const baseCssClass = 'block-editor-inserter__media-panel';

  const searchLabel = category.labels.search_items || (0,external_wp_i18n_namespaceObject.__)('Search');

  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: baseCssClass
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SearchControl, {
    className: `${baseCssClass}-search`,
    onChange: setSearch,
    value: search,
    label: searchLabel,
    placeholder: searchLabel
  }), isLoading && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: `${baseCssClass}-spinner`
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Spinner, null)), !isLoading && !mediaList?.length && (0,external_wp_element_namespaceObject.createElement)(no_results, null), !isLoading && !!mediaList?.length && (0,external_wp_element_namespaceObject.createElement)(media_list, {
    rootClientId: rootClientId,
    onClick: onInsert,
    mediaList: mediaList,
    category: category
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/media-upload/check.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


function MediaUploadCheck({
  fallback = null,
  children
}) {
  const hasUploadPermissions = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getSettings
    } = select(store);
    return !!getSettings().mediaUpload;
  }, []);
  return hasUploadPermissions ? children : fallback;
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/media-upload/README.md
 */

/* harmony default export */ var check = (MediaUploadCheck);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/media-upload/index.js
/**
 * WordPress dependencies
 */

/**
 * This is a placeholder for the media upload component necessary to make it possible to provide
 * an integration with the core blocks that handle media files. By default it renders nothing but
 * it provides a way to have it overridden with the `editor.MediaUpload` filter.
 *
 * @return {WPComponent} The component to be rendered.
 */

const MediaUpload = () => null;
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/media-upload/README.md
 */


/* harmony default export */ var media_upload = ((0,external_wp_components_namespaceObject.withFilters)('editor.MediaUpload')(MediaUpload));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/media-tab/media-tab.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */







const media_tab_ALLOWED_MEDIA_TYPES = ['image', 'video', 'audio'];

function MediaTab({
  rootClientId,
  selectedCategory,
  onSelectCategory,
  onInsert
}) {
  const mediaCategories = useMediaCategories(rootClientId);
  const isMobile = (0,external_wp_compose_namespaceObject.useViewportMatch)('medium', '<');
  const baseCssClass = 'block-editor-inserter__media-tabs';
  const onSelectMedia = (0,external_wp_element_namespaceObject.useCallback)(media => {
    if (!media?.url) {
      return;
    }

    const [block] = getBlockAndPreviewFromMedia(media, media.type);
    onInsert(block);
  }, [onInsert]);
  const mobileMediaCategories = (0,external_wp_element_namespaceObject.useMemo)(() => mediaCategories.map(mediaCategory => ({ ...mediaCategory,
    label: mediaCategory.labels.name
  })), [mediaCategories]);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, !isMobile && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: `${baseCssClass}-container`
  }, (0,external_wp_element_namespaceObject.createElement)("nav", {
    "aria-label": (0,external_wp_i18n_namespaceObject.__)('Media categories')
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalItemGroup, {
    role: "list",
    className: baseCssClass
  }, mediaCategories.map(mediaCategory => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalItem, {
    role: "listitem",
    key: mediaCategory.name,
    onClick: () => onSelectCategory(mediaCategory),
    className: classnames_default()(`${baseCssClass}__media-category`, {
      'is-selected': selectedCategory === mediaCategory
    }),
    "aria-label": mediaCategory.labels.name,
    "aria-current": mediaCategory === selectedCategory ? 'true' : undefined
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHStack, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexBlock, null, mediaCategory.labels.name), (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
    icon: (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_left : chevron_right
  })))), (0,external_wp_element_namespaceObject.createElement)("div", {
    role: "listitem"
  }, (0,external_wp_element_namespaceObject.createElement)(check, null, (0,external_wp_element_namespaceObject.createElement)(media_upload, {
    multiple: false,
    onSelect: onSelectMedia,
    allowedTypes: media_tab_ALLOWED_MEDIA_TYPES,
    render: ({
      open
    }) => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
      onClick: event => {
        // Safari doesn't emit a focus event on button elements when
        // clicked and we need to manually focus the button here.
        // The reason is that core's Media Library modal explicitly triggers a
        // focus event and therefore a `blur` event is triggered on a different
        // element, which doesn't contain the `data-unstable-ignore-focus-outside-for-relatedtarget`
        // attribute making the Inserter dialog to close.
        event.target.focus();
        open();
      },
      className: "block-editor-inserter__media-library-button",
      variant: "secondary",
      "data-unstable-ignore-focus-outside-for-relatedtarget": ".media-modal"
    }, (0,external_wp_i18n_namespaceObject.__)('Open Media Library'))
  })))))), isMobile && (0,external_wp_element_namespaceObject.createElement)(MobileTabNavigation, {
    categories: mobileMediaCategories
  }, category => (0,external_wp_element_namespaceObject.createElement)(MediaCategoryPanel, {
    onInsert: onInsert,
    rootClientId: rootClientId,
    category: category
  })));
}

/* harmony default export */ var media_tab = (MediaTab);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter-menu-extension/index.js
/**
 * WordPress dependencies
 */

const {
  Fill: __unstableInserterMenuExtension,
  Slot
} = (0,external_wp_components_namespaceObject.createSlotFill)('__unstableInserterMenuExtension');
__unstableInserterMenuExtension.Slot = Slot;
/* harmony default export */ var inserter_menu_extension = (__unstableInserterMenuExtension);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/order-inserter-block-items.js
/** @typedef {import('../store/selectors').WPEditorInserterItem} WPEditorInserterItem */

/**
 * Helper function to order inserter block items according to a provided array of prioritized blocks.
 *
 * @param {WPEditorInserterItem[]} items    The array of editor inserter block items to be sorted.
 * @param {string[]}               priority The array of block names to be prioritized.
 * @return {WPEditorInserterItem[]} The sorted array of editor inserter block items.
 */
const orderInserterBlockItems = (items, priority) => {
  if (!priority) {
    return items;
  }

  items.sort(({
    id: aName
  }, {
    id: bName
  }) => {
    // Sort block items according to `priority`.
    let aIndex = priority.indexOf(aName);
    let bIndex = priority.indexOf(bName); // All other block items should come after that.

    if (aIndex < 0) aIndex = priority.length;
    if (bIndex < 0) bIndex = priority.length;
    return aIndex - bIndex;
  });
  return items;
};

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/search-results.js


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */














const search_results_INITIAL_INSERTER_RESULTS = 9;
/**
 * Shared reference to an empty array for cases where it is important to avoid
 * returning a new array reference on every invocation and rerendering the component.
 *
 * @type {Array}
 */

const search_results_EMPTY_ARRAY = [];

function InserterSearchResults({
  filterValue,
  onSelect,
  onHover,
  rootClientId,
  clientId,
  isAppender,
  __experimentalInsertionIndex,
  maxBlockPatterns,
  maxBlockTypes,
  showBlockDirectory = false,
  isDraggable = true,
  shouldFocusBlock = true,
  prioritizePatterns,
  selectBlockOnInsert
}) {
  const debouncedSpeak = (0,external_wp_compose_namespaceObject.useDebounce)(external_wp_a11y_namespaceObject.speak, 500);
  const {
    prioritizedBlocks
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const blockListSettings = select(store).getBlockListSettings(rootClientId);
    return {
      prioritizedBlocks: blockListSettings?.prioritizedInserterBlocks || search_results_EMPTY_ARRAY
    };
  }, [rootClientId]);
  const [destinationRootClientId, onInsertBlocks] = use_insertion_point({
    onSelect,
    rootClientId,
    clientId,
    isAppender,
    insertionIndex: __experimentalInsertionIndex,
    shouldFocusBlock,
    selectBlockOnInsert
  });
  const [blockTypes, blockTypeCategories, blockTypeCollections, onSelectBlockType] = use_block_types_state(destinationRootClientId, onInsertBlocks);
  const [patterns,, onSelectBlockPattern] = use_patterns_state(onInsertBlocks, destinationRootClientId);
  const filteredBlockPatterns = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (maxBlockPatterns === 0) {
      return [];
    }

    const results = searchItems(patterns, filterValue);
    return maxBlockPatterns !== undefined ? results.slice(0, maxBlockPatterns) : results;
  }, [filterValue, patterns, maxBlockPatterns]);
  let maxBlockTypesToShow = maxBlockTypes;

  if (prioritizePatterns && filteredBlockPatterns.length > 2) {
    maxBlockTypesToShow = 0;
  }

  const filteredBlockTypes = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (maxBlockTypesToShow === 0) {
      return [];
    }

    let orderedItems = orderBy(blockTypes, 'frecency', 'desc');

    if (!filterValue && prioritizedBlocks.length) {
      orderedItems = orderInserterBlockItems(orderedItems, prioritizedBlocks);
    }

    const results = searchBlockItems(orderedItems, blockTypeCategories, blockTypeCollections, filterValue);
    return maxBlockTypesToShow !== undefined ? results.slice(0, maxBlockTypesToShow) : results;
  }, [filterValue, blockTypes, blockTypeCategories, blockTypeCollections, maxBlockTypesToShow, prioritizedBlocks]); // Announce search results on change.

  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!filterValue) {
      return;
    }

    const count = filteredBlockTypes.length + filteredBlockPatterns.length;
    const resultsFoundMessage = (0,external_wp_i18n_namespaceObject.sprintf)(
    /* translators: %d: number of results. */
    (0,external_wp_i18n_namespaceObject._n)('%d result found.', '%d results found.', count), count);
    debouncedSpeak(resultsFoundMessage);
  }, [filterValue, debouncedSpeak, filteredBlockTypes, filteredBlockPatterns]);
  const currentShownBlockTypes = (0,external_wp_compose_namespaceObject.useAsyncList)(filteredBlockTypes, {
    step: search_results_INITIAL_INSERTER_RESULTS
  });
  const currentShownPatterns = (0,external_wp_compose_namespaceObject.useAsyncList)(currentShownBlockTypes.length === filteredBlockTypes.length ? filteredBlockPatterns : search_results_EMPTY_ARRAY);
  const hasItems = filteredBlockTypes.length > 0 || filteredBlockPatterns.length > 0;
  const blocksUI = !!filteredBlockTypes.length && (0,external_wp_element_namespaceObject.createElement)(panel, {
    title: (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.VisuallyHidden, null, (0,external_wp_i18n_namespaceObject.__)('Blocks'))
  }, (0,external_wp_element_namespaceObject.createElement)(block_types_list, {
    items: currentShownBlockTypes,
    onSelect: onSelectBlockType,
    onHover: onHover,
    label: (0,external_wp_i18n_namespaceObject.__)('Blocks'),
    isDraggable: isDraggable
  }));
  const patternsUI = !!filteredBlockPatterns.length && (0,external_wp_element_namespaceObject.createElement)(panel, {
    title: (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.VisuallyHidden, null, (0,external_wp_i18n_namespaceObject.__)('Block Patterns'))
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__quick-inserter-patterns"
  }, (0,external_wp_element_namespaceObject.createElement)(block_patterns_list, {
    shownPatterns: currentShownPatterns,
    blockPatterns: filteredBlockPatterns,
    onClickPattern: onSelectBlockPattern,
    onHover: onHover,
    isDraggable: isDraggable
  })));
  return (0,external_wp_element_namespaceObject.createElement)(inserter_listbox, null, !showBlockDirectory && !hasItems && (0,external_wp_element_namespaceObject.createElement)(no_results, null), prioritizePatterns ? patternsUI : blocksUI, !!filteredBlockTypes.length && !!filteredBlockPatterns.length && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__quick-inserter-separator"
  }), prioritizePatterns ? blocksUI : patternsUI, showBlockDirectory && (0,external_wp_element_namespaceObject.createElement)(inserter_menu_extension.Slot, {
    fillProps: {
      onSelect: onSelectBlockType,
      onHover,
      filterValue,
      hasItems,
      rootClientId: destinationRootClientId
    }
  }, fills => {
    if (fills.length) {
      return fills;
    }

    if (!hasItems) {
      return (0,external_wp_element_namespaceObject.createElement)(no_results, null);
    }

    return null;
  }));
}

/* harmony default export */ var search_results = (InserterSearchResults);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/tabs.js


/**
 * WordPress dependencies
 */




const blocksTab = {
  name: 'blocks',

  /* translators: Blocks tab title in the block inserter. */
  title: (0,external_wp_i18n_namespaceObject.__)('Blocks')
};
const patternsTab = {
  name: 'patterns',

  /* translators: Theme and Directory Patterns tab title in the block inserter. */
  title: (0,external_wp_i18n_namespaceObject.__)('Patterns')
};
const reusableBlocksTab = {
  name: 'reusable',

  /* translators: Locally created Patterns tab title in the block inserter. */
  title: (0,external_wp_i18n_namespaceObject.__)('Synced patterns'),
  icon: library_symbol
};
const mediaTab = {
  name: 'media',

  /* translators: Media tab title in the block inserter. */
  title: (0,external_wp_i18n_namespaceObject.__)('Media')
};

function InserterTabs({
  children,
  showPatterns = false,
  showReusableBlocks = false,
  showMedia = false,
  onSelect,
  prioritizePatterns
}) {
  const tabs = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const tempTabs = [];

    if (prioritizePatterns && showPatterns) {
      tempTabs.push(patternsTab);
    }

    tempTabs.push(blocksTab);

    if (!prioritizePatterns && showPatterns) {
      tempTabs.push(patternsTab);
    }

    if (showMedia) {
      tempTabs.push(mediaTab);
    }

    if (showReusableBlocks) {
      tempTabs.push(reusableBlocksTab);
    }

    return tempTabs;
  }, [prioritizePatterns, showPatterns, showReusableBlocks, showMedia]);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.TabPanel, {
    className: "block-editor-inserter__tabs",
    tabs: tabs,
    onSelect: onSelect
  }, children);
}

/* harmony default export */ var tabs = (InserterTabs);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/menu.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */













function InserterMenu({
  rootClientId,
  clientId,
  isAppender,
  __experimentalInsertionIndex,
  onSelect,
  showInserterHelpPanel,
  showMostUsedBlocks,
  __experimentalFilterValue = '',
  shouldFocusBlock = true,
  prioritizePatterns
}, ref) {
  const [filterValue, setFilterValue, delayedFilterValue] = useDebouncedInput(__experimentalFilterValue);
  const [hoveredItem, setHoveredItem] = (0,external_wp_element_namespaceObject.useState)(null);
  const [selectedPatternCategory, setSelectedPatternCategory] = (0,external_wp_element_namespaceObject.useState)(null);
  const [selectedMediaCategory, setSelectedMediaCategory] = (0,external_wp_element_namespaceObject.useState)(null);
  const [selectedTab, setSelectedTab] = (0,external_wp_element_namespaceObject.useState)(null);
  const [destinationRootClientId, onInsertBlocks, onToggleInsertionPoint] = use_insertion_point({
    rootClientId,
    clientId,
    isAppender,
    insertionIndex: __experimentalInsertionIndex,
    shouldFocusBlock
  });
  const {
    showPatterns,
    inserterItems
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      __experimentalGetAllowedPatterns,
      getInserterItems
    } = select(store);
    return {
      showPatterns: !!__experimentalGetAllowedPatterns(destinationRootClientId).length,
      inserterItems: getInserterItems(destinationRootClientId)
    };
  }, [destinationRootClientId]);
  const hasReusableBlocks = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return inserterItems.some(({
      category
    }) => category === 'reusable');
  }, [inserterItems]);
  const mediaCategories = useMediaCategories(destinationRootClientId);
  const showMedia = !!mediaCategories.length;
  const onInsert = (0,external_wp_element_namespaceObject.useCallback)((blocks, meta, shouldForceFocusBlock) => {
    onInsertBlocks(blocks, meta, shouldForceFocusBlock);
    onSelect();
  }, [onInsertBlocks, onSelect]);
  const onInsertPattern = (0,external_wp_element_namespaceObject.useCallback)((blocks, patternName) => {
    onInsertBlocks(blocks, {
      patternName
    });
    onSelect();
  }, [onInsertBlocks, onSelect]);
  const onHover = (0,external_wp_element_namespaceObject.useCallback)(item => {
    onToggleInsertionPoint(!!item);
    setHoveredItem(item);
  }, [onToggleInsertionPoint, setHoveredItem]);
  const onHoverPattern = (0,external_wp_element_namespaceObject.useCallback)(item => {
    onToggleInsertionPoint(!!item);
  }, [onToggleInsertionPoint]);
  const onClickPatternCategory = (0,external_wp_element_namespaceObject.useCallback)(patternCategory => {
    setSelectedPatternCategory(patternCategory);
  }, [setSelectedPatternCategory]);
  const blocksTab = (0,external_wp_element_namespaceObject.useMemo)(() => (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__block-list"
  }, (0,external_wp_element_namespaceObject.createElement)(block_types_tab, {
    rootClientId: destinationRootClientId,
    onInsert: onInsert,
    onHover: onHover,
    showMostUsedBlocks: showMostUsedBlocks
  })), showInserterHelpPanel && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__tips"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.VisuallyHidden, {
    as: "h2"
  }, (0,external_wp_i18n_namespaceObject.__)('A tip for using the block editor')), (0,external_wp_element_namespaceObject.createElement)(tips, null))), [destinationRootClientId, onInsert, onHover, showMostUsedBlocks, showInserterHelpPanel]);
  const patternsTab = (0,external_wp_element_namespaceObject.useMemo)(() => (0,external_wp_element_namespaceObject.createElement)(block_patterns_tab, {
    rootClientId: destinationRootClientId,
    onInsert: onInsertPattern,
    onSelectCategory: onClickPatternCategory,
    selectedCategory: selectedPatternCategory
  }), [destinationRootClientId, onInsertPattern, onClickPatternCategory, selectedPatternCategory]);
  const reusableBlocksTab = (0,external_wp_element_namespaceObject.useMemo)(() => (0,external_wp_element_namespaceObject.createElement)(reusable_blocks_tab, {
    rootClientId: destinationRootClientId,
    onInsert: onInsert,
    onHover: onHover
  }), [destinationRootClientId, onInsert, onHover]);
  const mediaTab = (0,external_wp_element_namespaceObject.useMemo)(() => (0,external_wp_element_namespaceObject.createElement)(media_tab, {
    rootClientId: destinationRootClientId,
    selectedCategory: selectedMediaCategory,
    onSelectCategory: setSelectedMediaCategory,
    onInsert: onInsert
  }), [destinationRootClientId, onInsert, selectedMediaCategory, setSelectedMediaCategory]);
  const getCurrentTab = (0,external_wp_element_namespaceObject.useCallback)(tab => {
    if (tab.name === 'blocks') {
      return blocksTab;
    } else if (tab.name === 'patterns') {
      return patternsTab;
    } else if (tab.name === 'reusable') {
      return reusableBlocksTab;
    } else if (tab.name === 'media') {
      return mediaTab;
    }
  }, [blocksTab, patternsTab, reusableBlocksTab, mediaTab]);
  const searchRef = (0,external_wp_element_namespaceObject.useRef)();
  (0,external_wp_element_namespaceObject.useImperativeHandle)(ref, () => ({
    focusSearch: () => {
      searchRef.current.focus();
    }
  }));
  const showPatternPanel = selectedTab === 'patterns' && !delayedFilterValue && selectedPatternCategory;
  const showAsTabs = !delayedFilterValue && (showPatterns || hasReusableBlocks || showMedia);
  const showMediaPanel = selectedTab === 'media' && !delayedFilterValue && selectedMediaCategory;
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__menu"
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: classnames_default()('block-editor-inserter__main-area', {
      'show-as-tabs': showAsTabs
    })
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SearchControl, {
    __nextHasNoMarginBottom: true,
    className: "block-editor-inserter__search",
    onChange: value => {
      if (hoveredItem) setHoveredItem(null);
      setFilterValue(value);
    },
    value: filterValue,
    label: (0,external_wp_i18n_namespaceObject.__)('Search for blocks and patterns'),
    placeholder: (0,external_wp_i18n_namespaceObject.__)('Search'),
    ref: searchRef
  }), !!delayedFilterValue && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__no-tab-container"
  }, (0,external_wp_element_namespaceObject.createElement)(search_results, {
    filterValue: delayedFilterValue,
    onSelect: onSelect,
    onHover: onHover,
    rootClientId: rootClientId,
    clientId: clientId,
    isAppender: isAppender,
    __experimentalInsertionIndex: __experimentalInsertionIndex,
    showBlockDirectory: true,
    shouldFocusBlock: shouldFocusBlock
  })), showAsTabs && (0,external_wp_element_namespaceObject.createElement)(tabs, {
    showPatterns: showPatterns,
    showReusableBlocks: hasReusableBlocks,
    showMedia: showMedia,
    prioritizePatterns: prioritizePatterns,
    onSelect: setSelectedTab
  }, getCurrentTab), !delayedFilterValue && !showAsTabs && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__no-tab-container"
  }, blocksTab)), showMediaPanel && (0,external_wp_element_namespaceObject.createElement)(MediaCategoryDialog, {
    rootClientId: destinationRootClientId,
    onInsert: onInsert,
    category: selectedMediaCategory
  }), showInserterHelpPanel && hoveredItem && (0,external_wp_element_namespaceObject.createElement)(preview_panel, {
    item: hoveredItem
  }), showPatternPanel && (0,external_wp_element_namespaceObject.createElement)(BlockPatternsCategoryDialog, {
    rootClientId: destinationRootClientId,
    onInsert: onInsertPattern,
    onHover: onHoverPattern,
    category: selectedPatternCategory,
    showTitlesAsTooltip: true
  }));
}

/* harmony default export */ var menu = ((0,external_wp_element_namespaceObject.forwardRef)(InserterMenu));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/quick-inserter.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */






const SEARCH_THRESHOLD = 6;
const SHOWN_BLOCK_TYPES = 6;
const SHOWN_BLOCK_PATTERNS = 2;
const SHOWN_BLOCK_PATTERNS_WITH_PRIORITIZATION = 4;
function QuickInserter({
  onSelect,
  rootClientId,
  clientId,
  isAppender,
  prioritizePatterns,
  selectBlockOnInsert
}) {
  const [filterValue, setFilterValue] = (0,external_wp_element_namespaceObject.useState)('');
  const [destinationRootClientId, onInsertBlocks] = use_insertion_point({
    onSelect,
    rootClientId,
    clientId,
    isAppender,
    selectBlockOnInsert
  });
  const [blockTypes] = use_block_types_state(destinationRootClientId, onInsertBlocks);
  const [patterns] = use_patterns_state(onInsertBlocks, destinationRootClientId);
  const {
    setInserterIsOpened,
    insertionIndex
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getSettings,
      getBlockIndex,
      getBlockCount
    } = select(store);
    const settings = getSettings();
    const index = getBlockIndex(clientId);
    const blockCount = getBlockCount();
    return {
      setInserterIsOpened: settings.__experimentalSetIsInserterOpened,
      insertionIndex: index === -1 ? blockCount : index
    };
  }, [clientId]);
  const showPatterns = patterns.length && (!!filterValue || prioritizePatterns);
  const showSearch = showPatterns && patterns.length > SEARCH_THRESHOLD || blockTypes.length > SEARCH_THRESHOLD;
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (setInserterIsOpened) {
      setInserterIsOpened(false);
    }
  }, [setInserterIsOpened]); // When clicking Browse All select the appropriate block so as
  // the insertion point can work as expected.

  const onBrowseAll = () => {
    setInserterIsOpened({
      rootClientId,
      insertionIndex,
      filterValue
    });
  };

  let maxBlockPatterns = 0;

  if (showPatterns) {
    maxBlockPatterns = prioritizePatterns ? SHOWN_BLOCK_PATTERNS_WITH_PRIORITIZATION : SHOWN_BLOCK_PATTERNS;
  }

  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: classnames_default()('block-editor-inserter__quick-inserter', {
      'has-search': showSearch,
      'has-expand': setInserterIsOpened
    })
  }, showSearch && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SearchControl, {
    __nextHasNoMarginBottom: true,
    className: "block-editor-inserter__search",
    value: filterValue,
    onChange: value => {
      setFilterValue(value);
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Search for blocks and patterns'),
    placeholder: (0,external_wp_i18n_namespaceObject.__)('Search')
  }), (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inserter__quick-inserter-results"
  }, (0,external_wp_element_namespaceObject.createElement)(search_results, {
    filterValue: filterValue,
    onSelect: onSelect,
    rootClientId: rootClientId,
    clientId: clientId,
    isAppender: isAppender,
    maxBlockPatterns: maxBlockPatterns,
    maxBlockTypes: SHOWN_BLOCK_TYPES,
    isDraggable: false,
    prioritizePatterns: prioritizePatterns,
    selectBlockOnInsert: selectBlockOnInsert
  })), setInserterIsOpened && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    className: "block-editor-inserter__quick-inserter-expand",
    onClick: onBrowseAll,
    "aria-label": (0,external_wp_i18n_namespaceObject.__)('Browse all. This will open the main inserter panel in the editor toolbar.')
  }, (0,external_wp_i18n_namespaceObject.__)('Browse all')));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */









/**
 * Internal dependencies
 */





const defaultRenderToggle = ({
  onToggle,
  disabled,
  isOpen,
  blockTitle,
  hasSingleBlockType,
  toggleProps = {},
  prioritizePatterns
}) => {
  const {
    as: Wrapper = external_wp_components_namespaceObject.Button,
    label: labelProp,
    onClick,
    ...rest
  } = toggleProps;
  let label = labelProp;

  if (!label && hasSingleBlockType) {
    label = (0,external_wp_i18n_namespaceObject.sprintf)( // translators: %s: the name of the block when there is only one
    (0,external_wp_i18n_namespaceObject._x)('Add %s', 'directly add the only allowed block'), blockTitle);
  } else if (!label && prioritizePatterns) {
    label = (0,external_wp_i18n_namespaceObject.__)('Add pattern');
  } else if (!label) {
    label = (0,external_wp_i18n_namespaceObject._x)('Add block', 'Generic label for block inserter button');
  } // Handle both onClick functions from the toggle and the parent component.


  function handleClick(event) {
    if (onToggle) {
      onToggle(event);
    }

    if (onClick) {
      onClick(event);
    }
  }

  return (0,external_wp_element_namespaceObject.createElement)(Wrapper, {
    icon: library_plus,
    label: label,
    tooltipPosition: "bottom",
    onClick: handleClick,
    className: "block-editor-inserter__toggle",
    "aria-haspopup": !hasSingleBlockType ? 'true' : false,
    "aria-expanded": !hasSingleBlockType ? isOpen : false,
    disabled: disabled,
    ...rest
  });
};

class PrivateInserter extends external_wp_element_namespaceObject.Component {
  constructor() {
    super(...arguments);
    this.onToggle = this.onToggle.bind(this);
    this.renderToggle = this.renderToggle.bind(this);
    this.renderContent = this.renderContent.bind(this);
  }

  onToggle(isOpen) {
    const {
      onToggle
    } = this.props; // Surface toggle callback to parent component.

    if (onToggle) {
      onToggle(isOpen);
    }
  }
  /**
   * Render callback to display Dropdown toggle element.
   *
   * @param {Object}   options
   * @param {Function} options.onToggle Callback to invoke when toggle is
   *                                    pressed.
   * @param {boolean}  options.isOpen   Whether dropdown is currently open.
   *
   * @return {WPElement} Dropdown toggle element.
   */


  renderToggle({
    onToggle,
    isOpen
  }) {
    const {
      disabled,
      blockTitle,
      hasSingleBlockType,
      directInsertBlock,
      toggleProps,
      hasItems,
      renderToggle = defaultRenderToggle,
      prioritizePatterns
    } = this.props;
    return renderToggle({
      onToggle,
      isOpen,
      disabled: disabled || !hasItems,
      blockTitle,
      hasSingleBlockType,
      directInsertBlock,
      toggleProps,
      prioritizePatterns
    });
  }
  /**
   * Render callback to display Dropdown content element.
   *
   * @param {Object}   options
   * @param {Function} options.onClose Callback to invoke when dropdown is
   *                                   closed.
   *
   * @return {WPElement} Dropdown content element.
   */


  renderContent({
    onClose
  }) {
    const {
      rootClientId,
      clientId,
      isAppender,
      showInserterHelpPanel,
      // This prop is experimental to give some time for the quick inserter to mature
      // Feel free to make them stable after a few releases.
      __experimentalIsQuick: isQuick,
      prioritizePatterns,
      onSelectOrClose,
      selectBlockOnInsert
    } = this.props;

    if (isQuick) {
      return (0,external_wp_element_namespaceObject.createElement)(QuickInserter, {
        onSelect: blocks => {
          const firstBlock = Array.isArray(blocks) && blocks?.length ? blocks[0] : blocks;

          if (onSelectOrClose && typeof onSelectOrClose === 'function') {
            onSelectOrClose(firstBlock);
          }

          onClose();
        },
        rootClientId: rootClientId,
        clientId: clientId,
        isAppender: isAppender,
        prioritizePatterns: prioritizePatterns,
        selectBlockOnInsert: selectBlockOnInsert
      });
    }

    return (0,external_wp_element_namespaceObject.createElement)(menu, {
      onSelect: () => {
        onClose();
      },
      rootClientId: rootClientId,
      clientId: clientId,
      isAppender: isAppender,
      showInserterHelpPanel: showInserterHelpPanel,
      prioritizePatterns: prioritizePatterns
    });
  }

  render() {
    const {
      position,
      hasSingleBlockType,
      directInsertBlock,
      insertOnlyAllowedBlock,
      __experimentalIsQuick: isQuick,
      onSelectOrClose
    } = this.props;

    if (hasSingleBlockType || directInsertBlock) {
      return this.renderToggle({
        onToggle: insertOnlyAllowedBlock
      });
    }

    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Dropdown, {
      className: "block-editor-inserter",
      contentClassName: classnames_default()('block-editor-inserter__popover', {
        'is-quick': isQuick
      }),
      popoverProps: {
        position,
        shift: true
      },
      onToggle: this.onToggle,
      expandOnMobile: true,
      headerTitle: (0,external_wp_i18n_namespaceObject.__)('Add a block'),
      renderToggle: this.renderToggle,
      renderContent: this.renderContent,
      onClose: onSelectOrClose
    });
  }

}

const ComposedPrivateInserter = (0,external_wp_compose_namespaceObject.compose)([(0,external_wp_data_namespaceObject.withSelect)((select, {
  clientId,
  rootClientId,
  shouldDirectInsert = true
}) => {
  const {
    getBlockRootClientId,
    hasInserterItems,
    getAllowedBlocks,
    __experimentalGetDirectInsertBlock,
    getSettings
  } = select(store);
  const {
    getBlockVariations
  } = select(external_wp_blocks_namespaceObject.store);
  rootClientId = rootClientId || getBlockRootClientId(clientId) || undefined;
  const allowedBlocks = getAllowedBlocks(rootClientId);

  const directInsertBlock = shouldDirectInsert && __experimentalGetDirectInsertBlock(rootClientId);

  const settings = getSettings();
  const hasSingleBlockType = allowedBlocks?.length === 1 && getBlockVariations(allowedBlocks[0].name, 'inserter')?.length === 0;
  let allowedBlockType = false;

  if (hasSingleBlockType) {
    allowedBlockType = allowedBlocks[0];
  }

  return {
    hasItems: hasInserterItems(rootClientId),
    hasSingleBlockType,
    blockTitle: allowedBlockType ? allowedBlockType.title : '',
    allowedBlockType,
    directInsertBlock,
    rootClientId,
    prioritizePatterns: settings.__experimentalPreferPatternsOnRoot && !rootClientId
  };
}), (0,external_wp_data_namespaceObject.withDispatch)((dispatch, ownProps, {
  select
}) => {
  return {
    insertOnlyAllowedBlock() {
      const {
        rootClientId,
        clientId,
        isAppender,
        hasSingleBlockType,
        allowedBlockType,
        directInsertBlock,
        onSelectOrClose,
        selectBlockOnInsert
      } = ownProps;

      if (!hasSingleBlockType && !directInsertBlock) {
        return;
      }

      function getAdjacentBlockAttributes(attributesToCopy) {
        const {
          getBlock,
          getPreviousBlockClientId
        } = select(store);

        if (!attributesToCopy || !clientId && !rootClientId) {
          return {};
        }

        const result = {};
        let adjacentAttributes = {}; // If there is no clientId, then attempt to get attributes
        // from the last block within innerBlocks of the root block.

        if (!clientId) {
          const parentBlock = getBlock(rootClientId);

          if (parentBlock?.innerBlocks?.length) {
            const lastInnerBlock = parentBlock.innerBlocks[parentBlock.innerBlocks.length - 1];

            if (directInsertBlock && directInsertBlock?.name === lastInnerBlock.name) {
              adjacentAttributes = lastInnerBlock.attributes;
            }
          }
        } else {
          // Otherwise, attempt to get attributes from the
          // previous block relative to the current clientId.
          const currentBlock = getBlock(clientId);
          const previousBlock = getBlock(getPreviousBlockClientId(clientId));

          if (currentBlock?.name === previousBlock?.name) {
            adjacentAttributes = previousBlock?.attributes || {};
          }
        } // Copy over only those attributes flagged to be copied.


        attributesToCopy.forEach(attribute => {
          if (adjacentAttributes.hasOwnProperty(attribute)) {
            result[attribute] = adjacentAttributes[attribute];
          }
        });
        return result;
      }

      function getInsertionIndex() {
        const {
          getBlockIndex,
          getBlockSelectionEnd,
          getBlockOrder,
          getBlockRootClientId
        } = select(store); // If the clientId is defined, we insert at the position of the block.

        if (clientId) {
          return getBlockIndex(clientId);
        } // If there a selected block, we insert after the selected block.


        const end = getBlockSelectionEnd();

        if (!isAppender && end && getBlockRootClientId(end) === rootClientId) {
          return getBlockIndex(end) + 1;
        } // Otherwise, we insert at the end of the current rootClientId.


        return getBlockOrder(rootClientId).length;
      }

      const {
        insertBlock
      } = dispatch(store);
      let blockToInsert; // Attempt to augment the directInsertBlock with attributes from an adjacent block.
      // This ensures styling from nearby blocks is preserved in the newly inserted block.
      // See: https://github.com/WordPress/gutenberg/issues/37904

      if (directInsertBlock) {
        const newAttributes = getAdjacentBlockAttributes(directInsertBlock.attributesToCopy);
        blockToInsert = (0,external_wp_blocks_namespaceObject.createBlock)(directInsertBlock.name, { ...(directInsertBlock.attributes || {}),
          ...newAttributes
        });
      } else {
        blockToInsert = (0,external_wp_blocks_namespaceObject.createBlock)(allowedBlockType.name);
      }

      insertBlock(blockToInsert, getInsertionIndex(), rootClientId, selectBlockOnInsert);

      if (onSelectOrClose) {
        onSelectOrClose({
          clientId: blockToInsert?.clientId
        });
      }

      const message = (0,external_wp_i18n_namespaceObject.sprintf)( // translators: %s: the name of the block that has been added
      (0,external_wp_i18n_namespaceObject.__)('%s block added'), allowedBlockType.title);
      (0,external_wp_a11y_namespaceObject.speak)(message);
    }

  };
}), // The global inserter should always be visible, we are using ( ! isAppender && ! rootClientId && ! clientId ) as
// a way to detect the global Inserter.
(0,external_wp_compose_namespaceObject.ifCondition)(({
  hasItems,
  isAppender,
  rootClientId,
  clientId
}) => hasItems || !isAppender && !rootClientId && !clientId)])(PrivateInserter);
const Inserter = (0,external_wp_element_namespaceObject.forwardRef)((props, ref) => {
  return (0,external_wp_element_namespaceObject.createElement)(ComposedPrivateInserter, {
    ref: ref,
    ...props
  });
});
/* harmony default export */ var inserter = (Inserter);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/default-block-appender/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */



/**
 * Zero width non-breaking space, used as padding for the paragraph when it is
 * empty.
 */

const ZWNBSP = '\ufeff';
function DefaultBlockAppender({
  isLocked,
  onAppend,
  showPrompt,
  placeholder,
  rootClientId
}) {
  if (isLocked) {
    return null;
  }

  const value = (0,external_wp_htmlEntities_namespaceObject.decodeEntities)(placeholder) || (0,external_wp_i18n_namespaceObject.__)('Type / to choose a block');

  return (0,external_wp_element_namespaceObject.createElement)("div", {
    "data-root-client-id": rootClientId || '',
    className: classnames_default()('block-editor-default-block-appender', {
      'has-visible-prompt': showPrompt
    })
  }, (0,external_wp_element_namespaceObject.createElement)("p", {
    tabIndex: "0" // We want this element to be styled as a paragraph by themes.
    // eslint-disable-next-line jsx-a11y/no-noninteractive-element-to-interactive-role
    ,
    role: "button",
    "aria-label": (0,external_wp_i18n_namespaceObject.__)('Add default block') // A wrapping container for this one already has the wp-block className.
    ,
    className: "block-editor-default-block-appender__content",
    onKeyDown: event => {
      if (external_wp_keycodes_namespaceObject.ENTER === event.keyCode || external_wp_keycodes_namespaceObject.SPACE === event.keyCode) {
        onAppend();
      }
    },
    onClick: () => onAppend(),
    onFocus: () => {
      if (showPrompt) {
        onAppend();
      }
    }
  }, showPrompt ? value : ZWNBSP), (0,external_wp_element_namespaceObject.createElement)(inserter, {
    rootClientId: rootClientId,
    position: "bottom right",
    isAppender: true,
    __experimentalIsQuick: true
  }));
}
/* harmony default export */ var default_block_appender = ((0,external_wp_compose_namespaceObject.compose)((0,external_wp_data_namespaceObject.withSelect)((select, ownProps) => {
  const {
    getBlockCount,
    getSettings,
    getTemplateLock
  } = select(store);
  const isEmpty = !getBlockCount(ownProps.rootClientId);
  const {
    bodyPlaceholder
  } = getSettings();
  return {
    showPrompt: isEmpty,
    isLocked: !!getTemplateLock(ownProps.rootClientId),
    placeholder: bodyPlaceholder
  };
}), (0,external_wp_data_namespaceObject.withDispatch)((dispatch, ownProps) => {
  const {
    insertDefaultBlock,
    startTyping
  } = dispatch(store);
  return {
    onAppend() {
      const {
        rootClientId
      } = ownProps;
      insertDefaultBlock(undefined, rootClientId);
      startTyping();
    }

  };
}))(DefaultBlockAppender));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/button-block-appender/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */



function ButtonBlockAppender({
  rootClientId,
  className,
  onFocus,
  tabIndex
}, ref) {
  return (0,external_wp_element_namespaceObject.createElement)(inserter, {
    position: "bottom center",
    rootClientId: rootClientId,
    __experimentalIsQuick: true,
    renderToggle: ({
      onToggle,
      disabled,
      isOpen,
      blockTitle,
      hasSingleBlockType
    }) => {
      let label;

      if (hasSingleBlockType) {
        label = (0,external_wp_i18n_namespaceObject.sprintf)( // translators: %s: the name of the block when there is only one
        (0,external_wp_i18n_namespaceObject._x)('Add %s', 'directly add the only allowed block'), blockTitle);
      } else {
        label = (0,external_wp_i18n_namespaceObject._x)('Add block', 'Generic label for block inserter button');
      }

      const isToggleButton = !hasSingleBlockType;
      let inserterButton = (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
        ref: ref,
        onFocus: onFocus,
        tabIndex: tabIndex,
        className: classnames_default()(className, 'block-editor-button-block-appender'),
        onClick: onToggle,
        "aria-haspopup": isToggleButton ? 'true' : undefined,
        "aria-expanded": isToggleButton ? isOpen : undefined,
        disabled: disabled,
        label: label
      }, !hasSingleBlockType && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.VisuallyHidden, {
        as: "span"
      }, label), (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
        icon: library_plus
      }));

      if (isToggleButton || hasSingleBlockType) {
        inserterButton = (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Tooltip, {
          text: label
        }, inserterButton);
      }

      return inserterButton;
    },
    isAppender: true
  });
}
/**
 * Use `ButtonBlockAppender` instead.
 *
 * @deprecated
 */


const ButtonBlockerAppender = (0,external_wp_element_namespaceObject.forwardRef)((props, ref) => {
  external_wp_deprecated_default()(`wp.blockEditor.ButtonBlockerAppender`, {
    alternative: 'wp.blockEditor.ButtonBlockAppender',
    since: '5.9'
  });
  return ButtonBlockAppender(props, ref);
});
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/button-block-appender/README.md
 */

/* harmony default export */ var button_block_appender = ((0,external_wp_element_namespaceObject.forwardRef)(ButtonBlockAppender));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list-appender/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */






function DefaultAppender({
  rootClientId
}) {
  const canInsertDefaultBlock = (0,external_wp_data_namespaceObject.useSelect)(select => select(store).canInsertBlockType((0,external_wp_blocks_namespaceObject.getDefaultBlockName)(), rootClientId));

  if (canInsertDefaultBlock) {
    // Render the default block appender if the context supports use
    // of the default appender.
    return (0,external_wp_element_namespaceObject.createElement)(default_block_appender, {
      rootClientId: rootClientId
    });
  } // Fallback in case the default block can't be inserted.


  return (0,external_wp_element_namespaceObject.createElement)(button_block_appender, {
    rootClientId: rootClientId,
    className: "block-list-appender__toggle"
  });
}

function useAppender(rootClientId, CustomAppender) {
  const isVisible = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getTemplateLock,
      getSelectedBlockClientId,
      __unstableGetEditorMode,
      getBlockEditingMode
    } = unlock(select(store));

    if (CustomAppender === false) {
      return false;
    }

    if (!CustomAppender) {
      const selectedBlockClientId = getSelectedBlockClientId();
      const isParentSelected = rootClientId === selectedBlockClientId || !rootClientId && !selectedBlockClientId;

      if (!isParentSelected) {
        return false;
      }
    }

    if (getTemplateLock(rootClientId) || getBlockEditingMode(rootClientId) === 'disabled' || __unstableGetEditorMode() === 'zoom-out') {
      return false;
    }

    return true;
  }, [rootClientId, CustomAppender]);

  if (!isVisible) {
    return null;
  }

  return CustomAppender ? (0,external_wp_element_namespaceObject.createElement)(CustomAppender, null) : (0,external_wp_element_namespaceObject.createElement)(DefaultAppender, {
    rootClientId: rootClientId
  });
}

function BlockListAppender({
  rootClientId,
  renderAppender,
  className,
  tagName: TagName = 'div'
}) {
  const appender = useAppender(rootClientId, renderAppender);
  const isDragOver = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockInsertionPoint,
      isBlockInsertionPointVisible,
      getBlockCount
    } = select(store);
    const insertionPoint = getBlockInsertionPoint(); // Ideally we should also check for `isDragging` but currently it
    // requires a lot more setup. We can revisit this once we refactor
    // the DnD utility hooks.

    return isBlockInsertionPointVisible() && rootClientId === insertionPoint?.rootClientId && getBlockCount(rootClientId) === 0;
  }, [rootClientId]);

  if (!appender) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(TagName // A `tabIndex` is used on the wrapping `div` element in order to
  // force a focus event to occur when an appender `button` element
  // is clicked. In some browsers (Firefox, Safari), button clicks do
  // not emit a focus event, which could cause this event to propagate
  // unexpectedly. The `tabIndex` ensures that the interaction is
  // captured as a focus, without also adding an extra tab stop.
  //
  // See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
  , {
    tabIndex: -1,
    className: classnames_default()('block-list-appender wp-block', className, {
      'is-drag-over': isDragOver
    }) // Needed in case the whole editor is content editable (for multi
    // selection). It fixes an edge case where ArrowDown and ArrowRight
    // should collapse the selection to the end of that selection and
    // not into the appender.
    ,
    contentEditable: false // The appender exists to let you add the first Paragraph before
    // any is inserted. To that end, this appender should visually be
    // presented as a block. That means theme CSS should style it as if
    // it were an empty paragraph block. That means a `wp-block` class to
    // ensure the width is correct, and a [data-block] attribute to ensure
    // the correct margin is applied, especially for classic themes which
    // have commonly targeted that attribute for margins.
    ,
    "data-block": true
  }, appender);
}

/* harmony default export */ var block_list_appender = (BlockListAppender);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-popover/use-popover-scroll.js
/**
 * WordPress dependencies
 */

/**
 * Allow scrolling "through" popovers over the canvas. This is only called for
 * as long as the pointer is over a popover. Do not use React events because it
 * will bubble through portals.
 *
 * @param {Object} scrollableRef
 */

function usePopoverScroll(scrollableRef) {
  return (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    if (!scrollableRef) {
      return;
    }

    function onWheel(event) {
      const {
        deltaX,
        deltaY
      } = event;
      scrollableRef.current.scrollBy(deltaX, deltaY);
    } // Tell the browser that we do not call event.preventDefault
    // See https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#improving_scrolling_performance_with_passive_listeners


    const options = {
      passive: true
    };
    node.addEventListener('wheel', onWheel, options);
    return () => {
      node.removeEventListener('wheel', onWheel, options);
    };
  }, [scrollableRef]);
}

/* harmony default export */ var use_popover_scroll = (usePopoverScroll);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-popover/inbetween.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




const MAX_POPOVER_RECOMPUTE_COUNTER = Number.MAX_SAFE_INTEGER;
const InsertionPointOpenRef = (0,external_wp_element_namespaceObject.createContext)();

function BlockPopoverInbetween({
  previousClientId,
  nextClientId,
  children,
  __unstablePopoverSlot,
  __unstableContentRef,
  ...props
}) {
  // This is a temporary hack to get the inbetween inserter to recompute properly.
  const [popoverRecomputeCounter, forcePopoverRecompute] = (0,external_wp_element_namespaceObject.useReducer)( // Module is there to make sure that the counter doesn't overflow.
  s => (s + 1) % MAX_POPOVER_RECOMPUTE_COUNTER, 0);
  const {
    orientation,
    rootClientId,
    isVisible
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockListSettings,
      getBlockRootClientId,
      isBlockVisible
    } = select(store);

    const _rootClientId = getBlockRootClientId(previousClientId !== null && previousClientId !== void 0 ? previousClientId : nextClientId);

    return {
      orientation: getBlockListSettings(_rootClientId)?.orientation || 'vertical',
      rootClientId: _rootClientId,
      isVisible: isBlockVisible(previousClientId) && isBlockVisible(nextClientId)
    };
  }, [previousClientId, nextClientId]);
  const previousElement = useBlockElement(previousClientId);
  const nextElement = useBlockElement(nextClientId);
  const isVertical = orientation === 'vertical';
  const popoverAnchor = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if ( // popoverRecomputeCounter is by definition always equal or greater than 0.
    // This check is only there to satisfy the correctness of the
    // exhaustive-deps rule for the `useMemo` hook.
    popoverRecomputeCounter < 0 || !previousElement && !nextElement || !isVisible) {
      return undefined;
    }

    const {
      ownerDocument
    } = previousElement || nextElement;
    return {
      ownerDocument,

      getBoundingClientRect() {
        const previousRect = previousElement ? previousElement.getBoundingClientRect() : null;
        const nextRect = nextElement ? nextElement.getBoundingClientRect() : null;
        let left = 0;
        let top = 0;
        let width = 0;
        let height = 0;

        if (isVertical) {
          // vertical
          top = previousRect ? previousRect.bottom : nextRect.top;
          width = previousRect ? previousRect.width : nextRect.width;
          height = nextRect && previousRect ? nextRect.top - previousRect.bottom : 0;
          left = previousRect ? previousRect.left : nextRect.left;
        } else {
          top = previousRect ? previousRect.top : nextRect.top;
          height = previousRect ? previousRect.height : nextRect.height;

          if ((0,external_wp_i18n_namespaceObject.isRTL)()) {
            // non vertical, rtl
            left = nextRect ? nextRect.right : previousRect.left;
            width = previousRect && nextRect ? previousRect.left - nextRect.right : 0;
          } else {
            // non vertical, ltr
            left = previousRect ? previousRect.right : nextRect.left;
            width = previousRect && nextRect ? nextRect.left - previousRect.right : 0;
          }
        }

        return new window.DOMRect(left, top, width, height);
      }

    };
  }, [previousElement, nextElement, popoverRecomputeCounter, isVertical, isVisible]);
  const popoverScrollRef = use_popover_scroll(__unstableContentRef); // This is only needed for a smooth transition when moving blocks.
  // When blocks are moved up/down, their position can be set by
  // updating the `transform` property manually (i.e. without using CSS
  // transitions or animations). The animation, which can also scroll the block
  // editor, can sometimes cause the position of the Popover to get out of sync.
  // A MutationObserver is therefore used to make sure that changes to the
  // selectedElement's attribute (i.e. `transform`) can be tracked and used to
  // trigger the Popover to rerender.

  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    if (!previousElement) {
      return;
    }

    const observer = new window.MutationObserver(forcePopoverRecompute);
    observer.observe(previousElement, {
      attributes: true
    });
    return () => {
      observer.disconnect();
    };
  }, [previousElement]);
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    if (!nextElement) {
      return;
    }

    const observer = new window.MutationObserver(forcePopoverRecompute);
    observer.observe(nextElement, {
      attributes: true
    });
    return () => {
      observer.disconnect();
    };
  }, [nextElement]);
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    if (!previousElement) {
      return;
    }

    previousElement.ownerDocument.defaultView.addEventListener('resize', forcePopoverRecompute);
    return () => {
      previousElement.ownerDocument.defaultView?.removeEventListener('resize', forcePopoverRecompute);
    };
  }, [previousElement]); // If there's either a previous or a next element, show the inbetween popover.
  // Note that drag and drop uses the inbetween popover to show the drop indicator
  // before the first block and after the last block.

  if (!previousElement && !nextElement || !isVisible) {
    return null;
  }
  /* eslint-disable jsx-a11y/no-static-element-interactions, jsx-a11y/click-events-have-key-events */
  // While ideally it would be enough to capture the
  // bubbling focus event from the Inserter, due to the
  // characteristics of click focusing of `button`s in
  // Firefox and Safari, it is not reliable.
  //
  // See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus


  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Popover, {
    ref: popoverScrollRef,
    animate: false,
    anchor: popoverAnchor,
    focusOnMount: false // Render in the old slot if needed for backward compatibility,
    // otherwise render in place (not in the default popover slot).
    ,
    __unstableSlotName: __unstablePopoverSlot || null // Forces a remount of the popover when its position changes
    // This makes sure the popover doesn't animate from its previous position.
    ,
    key: nextClientId + '--' + rootClientId,
    ...props,
    className: classnames_default()('block-editor-block-popover', 'block-editor-block-popover__inbetween', props.className),
    resize: false,
    flip: false,
    placement: "overlay",
    variant: "unstyled"
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-popover__inbetween-container"
  }, children));
  /* eslint-enable jsx-a11y/no-static-element-interactions, jsx-a11y/click-events-have-key-events */
}

/* harmony default export */ var inbetween = (BlockPopoverInbetween);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-popover/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



const block_popover_MAX_POPOVER_RECOMPUTE_COUNTER = Number.MAX_SAFE_INTEGER;

function BlockPopover({
  clientId,
  bottomClientId,
  children,
  __unstableRefreshSize,
  __unstableCoverTarget = false,
  __unstablePopoverSlot,
  __unstableContentRef,
  shift = true,
  ...props
}, ref) {
  const selectedElement = useBlockElement(clientId);
  const lastSelectedElement = useBlockElement(bottomClientId !== null && bottomClientId !== void 0 ? bottomClientId : clientId);
  const mergedRefs = (0,external_wp_compose_namespaceObject.useMergeRefs)([ref, use_popover_scroll(__unstableContentRef)]);
  const [popoverDimensionsRecomputeCounter, forceRecomputePopoverDimensions] = (0,external_wp_element_namespaceObject.useReducer)( // Module is there to make sure that the counter doesn't overflow.
  s => (s + 1) % block_popover_MAX_POPOVER_RECOMPUTE_COUNTER, 0); // When blocks are moved up/down, they are animated to their new position by
  // updating the `transform` property manually (i.e. without using CSS
  // transitions or animations). The animation, which can also scroll the block
  // editor, can sometimes cause the position of the Popover to get out of sync.
  // A MutationObserver is therefore used to make sure that changes to the
  // selectedElement's attribute (i.e. `transform`) can be tracked and used to
  // trigger the Popover to rerender.

  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    if (!selectedElement) {
      return;
    }

    const observer = new window.MutationObserver(forceRecomputePopoverDimensions);
    observer.observe(selectedElement, {
      attributes: true
    });
    return () => {
      observer.disconnect();
    };
  }, [selectedElement]);
  const style = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if ( // popoverDimensionsRecomputeCounter is by definition always equal or greater
    // than 0. This check is only there to satisfy the correctness of the
    // exhaustive-deps rule for the `useMemo` hook.
    popoverDimensionsRecomputeCounter < 0 || !selectedElement || lastSelectedElement !== selectedElement) {
      return {};
    }

    return {
      position: 'absolute',
      width: selectedElement.offsetWidth,
      height: selectedElement.offsetHeight
    };
  }, [selectedElement, lastSelectedElement, __unstableRefreshSize, popoverDimensionsRecomputeCounter]);
  const popoverAnchor = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if ( // popoverDimensionsRecomputeCounter is by definition always equal or greater
    // than 0. This check is only there to satisfy the correctness of the
    // exhaustive-deps rule for the `useMemo` hook.
    popoverDimensionsRecomputeCounter < 0 || !selectedElement || bottomClientId && !lastSelectedElement) {
      return undefined;
    }

    return {
      getBoundingClientRect() {
        var _lastSelectedBCR$left, _lastSelectedBCR$top, _lastSelectedBCR$righ, _lastSelectedBCR$bott;

        const selectedBCR = selectedElement.getBoundingClientRect();
        const lastSelectedBCR = lastSelectedElement?.getBoundingClientRect(); // Get the biggest rectangle that encompasses completely the currently
        // selected element and the last selected element:
        // - for top/left coordinates, use the smaller numbers
        // - for the bottom/right coordinates, use the largest numbers

        const left = Math.min(selectedBCR.left, (_lastSelectedBCR$left = lastSelectedBCR?.left) !== null && _lastSelectedBCR$left !== void 0 ? _lastSelectedBCR$left : Infinity);
        const top = Math.min(selectedBCR.top, (_lastSelectedBCR$top = lastSelectedBCR?.top) !== null && _lastSelectedBCR$top !== void 0 ? _lastSelectedBCR$top : Infinity);
        const right = Math.max(selectedBCR.right, (_lastSelectedBCR$righ = lastSelectedBCR.right) !== null && _lastSelectedBCR$righ !== void 0 ? _lastSelectedBCR$righ : -Infinity);
        const bottom = Math.max(selectedBCR.bottom, (_lastSelectedBCR$bott = lastSelectedBCR.bottom) !== null && _lastSelectedBCR$bott !== void 0 ? _lastSelectedBCR$bott : -Infinity);
        const width = right - left;
        const height = bottom - top;
        return new window.DOMRect(left, top, width, height);
      },

      ownerDocument: selectedElement.ownerDocument
    };
  }, [bottomClientId, lastSelectedElement, selectedElement, popoverDimensionsRecomputeCounter]);

  if (!selectedElement || bottomClientId && !lastSelectedElement) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Popover, {
    ref: mergedRefs,
    animate: false,
    focusOnMount: false,
    anchor: popoverAnchor // Render in the old slot if needed for backward compatibility,
    // otherwise render in place (not in the default popover slot).
    ,
    __unstableSlotName: __unstablePopoverSlot || null,
    placement: "top-start",
    resize: false,
    flip: false,
    shift: shift,
    ...props,
    className: classnames_default()('block-editor-block-popover', props.className),
    variant: "unstyled"
  }, __unstableCoverTarget && (0,external_wp_element_namespaceObject.createElement)("div", {
    style: style
  }, children), !__unstableCoverTarget && children);
}

/* harmony default export */ var block_popover = ((0,external_wp_element_namespaceObject.forwardRef)(BlockPopover));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-popover/drop-zone.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



const animateVariants = {
  hide: {
    opacity: 0,
    scaleY: 0.75
  },
  show: {
    opacity: 1,
    scaleY: 1
  },
  exit: {
    opacity: 0,
    scaleY: 0.9
  }
};

function BlockDropZonePopover({
  __unstablePopoverSlot,
  __unstableContentRef
}) {
  const {
    clientId
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockOrder,
      getBlockInsertionPoint
    } = select(store);
    const insertionPoint = getBlockInsertionPoint();
    const order = getBlockOrder(insertionPoint.rootClientId);

    if (!order.length) {
      return {};
    }

    return {
      clientId: order[insertionPoint.index]
    };
  }, []);
  const reducedMotion = (0,external_wp_compose_namespaceObject.useReducedMotion)();
  return (0,external_wp_element_namespaceObject.createElement)(block_popover, {
    clientId: clientId,
    __unstableCoverTarget: true,
    __unstablePopoverSlot: __unstablePopoverSlot,
    __unstableContentRef: __unstableContentRef,
    className: "block-editor-block-popover__drop-zone"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__unstableMotion.div, {
    "data-testid": "block-popover-drop-zone",
    initial: reducedMotion ? animateVariants.show : animateVariants.hide,
    animate: animateVariants.show,
    exit: reducedMotion ? animateVariants.show : animateVariants.exit,
    className: "block-editor-block-popover__drop-zone-foreground"
  }));
}

/* harmony default export */ var drop_zone = (BlockDropZonePopover);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-tools/insertion-point.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */





const insertion_point_InsertionPointOpenRef = (0,external_wp_element_namespaceObject.createContext)();

function InbetweenInsertionPointPopover({
  __unstablePopoverSlot,
  __unstableContentRef
}) {
  const {
    selectBlock,
    hideInsertionPoint
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const openRef = (0,external_wp_element_namespaceObject.useContext)(insertion_point_InsertionPointOpenRef);
  const ref = (0,external_wp_element_namespaceObject.useRef)();
  const {
    orientation,
    previousClientId,
    nextClientId,
    rootClientId,
    isInserterShown,
    isDistractionFree,
    isNavigationMode
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockOrder,
      getBlockListSettings,
      getBlockInsertionPoint,
      isBlockBeingDragged,
      getPreviousBlockClientId,
      getNextBlockClientId,
      getSettings,
      isNavigationMode: _isNavigationMode
    } = select(store);
    const insertionPoint = getBlockInsertionPoint();
    const order = getBlockOrder(insertionPoint.rootClientId);

    if (!order.length) {
      return {};
    }

    let _previousClientId = order[insertionPoint.index - 1];
    let _nextClientId = order[insertionPoint.index];

    while (isBlockBeingDragged(_previousClientId)) {
      _previousClientId = getPreviousBlockClientId(_previousClientId);
    }

    while (isBlockBeingDragged(_nextClientId)) {
      _nextClientId = getNextBlockClientId(_nextClientId);
    }

    const settings = getSettings();
    return {
      previousClientId: _previousClientId,
      nextClientId: _nextClientId,
      orientation: getBlockListSettings(insertionPoint.rootClientId)?.orientation || 'vertical',
      rootClientId: insertionPoint.rootClientId,
      isNavigationMode: _isNavigationMode(),
      isDistractionFree: settings.isDistractionFree,
      isInserterShown: insertionPoint?.__unstableWithInserter
    };
  }, []);
  const disableMotion = (0,external_wp_compose_namespaceObject.useReducedMotion)();

  function onClick(event) {
    if (event.target === ref.current && nextClientId) {
      selectBlock(nextClientId, -1);
    }
  }

  function maybeHideInserterPoint(event) {
    // Only hide the inserter if it's triggered on the wrapper,
    // and the inserter is not open.
    if (event.target === ref.current && !openRef.current) {
      hideInsertionPoint();
    }
  }

  function onFocus(event) {
    // Only handle click on the wrapper specifically, and not an event
    // bubbled from the inserter itself.
    if (event.target !== ref.current) {
      openRef.current = true;
    }
  }

  const lineVariants = {
    // Initial position starts from the center and invisible.
    start: {
      opacity: 0,
      scale: 0
    },
    // The line expands to fill the container. If the inserter is visible it
    // is delayed so it appears orchestrated.
    rest: {
      opacity: 1,
      scale: 1,
      transition: {
        delay: isInserterShown ? 0.5 : 0,
        type: 'tween'
      }
    },
    hover: {
      opacity: 1,
      scale: 1,
      transition: {
        delay: 0.5,
        type: 'tween'
      }
    }
  };
  const inserterVariants = {
    start: {
      scale: disableMotion ? 1 : 0
    },
    rest: {
      scale: 1,
      transition: {
        delay: 0.4,
        type: 'tween'
      }
    }
  };

  if (isDistractionFree && !isNavigationMode) {
    return null;
  }

  const className = classnames_default()('block-editor-block-list__insertion-point', 'is-' + orientation);
  return (0,external_wp_element_namespaceObject.createElement)(inbetween, {
    previousClientId: previousClientId,
    nextClientId: nextClientId,
    __unstablePopoverSlot: __unstablePopoverSlot,
    __unstableContentRef: __unstableContentRef
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__unstableMotion.div, {
    layout: !disableMotion,
    initial: disableMotion ? 'rest' : 'start',
    animate: "rest",
    whileHover: "hover",
    whileTap: "pressed",
    exit: "start",
    ref: ref,
    tabIndex: -1,
    onClick: onClick,
    onFocus: onFocus,
    className: classnames_default()(className, {
      'is-with-inserter': isInserterShown
    }),
    onHoverEnd: maybeHideInserterPoint
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__unstableMotion.div, {
    variants: lineVariants,
    className: "block-editor-block-list__insertion-point-indicator",
    "data-testid": "block-list-insertion-point-indicator"
  }), isInserterShown && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__unstableMotion.div, {
    variants: inserterVariants,
    className: classnames_default()('block-editor-block-list__insertion-point-inserter')
  }, (0,external_wp_element_namespaceObject.createElement)(inserter, {
    position: "bottom center",
    clientId: nextClientId,
    rootClientId: rootClientId,
    __experimentalIsQuick: true,
    onToggle: isOpen => {
      openRef.current = isOpen;
    },
    onSelectOrClose: () => {
      openRef.current = false;
    }
  }))));
}

function InsertionPoint(props) {
  const {
    insertionPoint,
    isVisible,
    isBlockListEmpty
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockInsertionPoint,
      isBlockInsertionPointVisible,
      getBlockCount
    } = select(store);
    const blockInsertionPoint = getBlockInsertionPoint();
    return {
      insertionPoint: blockInsertionPoint,
      isVisible: isBlockInsertionPointVisible(),
      isBlockListEmpty: getBlockCount(blockInsertionPoint?.rootClientId) === 0
    };
  }, []);

  if (!isVisible || // Don't render the insertion point if the block list is empty.
  // The insertion point will be represented by the appender instead.
  isBlockListEmpty) {
    return null;
  }
  /**
   * Render a popover that overlays the block when the desired operation is to replace it.
   * Otherwise, render a popover in between blocks for the indication of inserting between them.
   */


  return insertionPoint.operation === 'replace' ? (0,external_wp_element_namespaceObject.createElement)(drop_zone // Force remount to trigger the animation.
  , {
    key: `${insertionPoint.rootClientId}-${insertionPoint.index}`,
    ...props
  }) : (0,external_wp_element_namespaceObject.createElement)(InbetweenInsertionPointPopover, { ...props
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-in-between-inserter.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




function useInBetweenInserter() {
  const openRef = (0,external_wp_element_namespaceObject.useContext)(insertion_point_InsertionPointOpenRef);
  const isInBetweenInserterDisabled = (0,external_wp_data_namespaceObject.useSelect)(select => select(store).getSettings().isDistractionFree || select(store).__unstableGetEditorMode() === 'zoom-out', []);
  const {
    getBlockListSettings,
    getBlockIndex,
    isMultiSelecting,
    getSelectedBlockClientIds,
    getTemplateLock,
    __unstableIsWithinBlockOverlay,
    getBlockEditingMode
  } = unlock((0,external_wp_data_namespaceObject.useSelect)(store));
  const {
    showInsertionPoint,
    hideInsertionPoint
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    if (isInBetweenInserterDisabled) {
      return;
    }

    function onMouseMove(event) {
      if (openRef.current) {
        return;
      } // Ignore text nodes sometimes detected in FireFox.


      if (event.target.nodeType === event.target.TEXT_NODE) {
        return;
      }

      if (isMultiSelecting()) {
        return;
      }

      if (!event.target.classList.contains('block-editor-block-list__layout')) {
        hideInsertionPoint();
        return;
      }

      let rootClientId;

      if (!event.target.classList.contains('is-root-container')) {
        const blockElement = !!event.target.getAttribute('data-block') ? event.target : event.target.closest('[data-block]');
        rootClientId = blockElement.getAttribute('data-block');
      }

      if (getTemplateLock(rootClientId) || getBlockEditingMode(rootClientId) === 'disabled') {
        return;
      }

      const orientation = getBlockListSettings(rootClientId)?.orientation || 'vertical';
      const offsetTop = event.clientY;
      const offsetLeft = event.clientX;
      const children = Array.from(event.target.children);
      let element = children.find(blockEl => {
        const blockElRect = blockEl.getBoundingClientRect();
        return blockEl.classList.contains('wp-block') && orientation === 'vertical' && blockElRect.top > offsetTop || blockEl.classList.contains('wp-block') && orientation === 'horizontal' && ((0,external_wp_i18n_namespaceObject.isRTL)() ? blockElRect.right < offsetLeft : blockElRect.left > offsetLeft);
      });

      if (!element) {
        hideInsertionPoint();
        return;
      } // The block may be in an alignment wrapper, so check the first direct
      // child if the element has no ID.


      if (!element.id) {
        element = element.firstElementChild;

        if (!element) {
          hideInsertionPoint();
          return;
        }
      } // Don't show the insertion point if a parent block has an "overlay"
      // See https://github.com/WordPress/gutenberg/pull/34012#pullrequestreview-727762337


      const clientId = element.id.slice('block-'.length);

      if (!clientId || __unstableIsWithinBlockOverlay(clientId)) {
        return;
      } // Don't show the inserter when hovering above (conflicts with
      // block toolbar) or inside selected block(s).


      if (getSelectedBlockClientIds().includes(clientId)) {
        return;
      }

      const elementRect = element.getBoundingClientRect();

      if (orientation === 'horizontal' && (event.clientY > elementRect.bottom || event.clientY < elementRect.top) || orientation === 'vertical' && (event.clientX > elementRect.right || event.clientX < elementRect.left)) {
        hideInsertionPoint();
        return;
      }

      const index = getBlockIndex(clientId); // Don't show the in-between inserter before the first block in
      // the list (preserves the original behaviour).

      if (index === 0) {
        hideInsertionPoint();
        return;
      }

      showInsertionPoint(rootClientId, index, {
        __unstableWithInserter: true
      });
    }

    node.addEventListener('mousemove', onMouseMove);
    return () => {
      node.removeEventListener('mousemove', onMouseMove);
    };
  }, [openRef, getBlockListSettings, getBlockIndex, isMultiSelecting, showInsertionPoint, hideInsertionPoint, getSelectedBlockClientIds, isInBetweenInserterDisabled]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/pre-parse-patterns.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const requestIdleCallback = (() => {
  if (typeof window === 'undefined') {
    return callback => {
      setTimeout(() => callback(Date.now()), 0);
    };
  }

  return window.requestIdleCallback || window.requestAnimationFrame;
})();

const cancelIdleCallback = (() => {
  if (typeof window === 'undefined') {
    return clearTimeout;
  }

  return window.cancelIdleCallback || window.cancelAnimationFrame;
})();

function usePreParsePatterns() {
  const {
    patterns,
    isPreviewMode
  } = (0,external_wp_data_namespaceObject.useSelect)(_select => {
    const {
      __experimentalBlockPatterns,
      __unstableIsPreviewMode
    } = _select(store).getSettings();

    return {
      patterns: __experimentalBlockPatterns,
      isPreviewMode: __unstableIsPreviewMode
    };
  }, []);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (isPreviewMode) {
      return;
    }

    if (!patterns?.length) {
      return;
    }

    let handle;
    let index = -1;

    const callback = () => {
      index++;

      if (index >= patterns.length) {
        return;
      }

      (0,external_wp_data_namespaceObject.select)(store).__experimentalGetParsedPattern(patterns[index].name);

      handle = requestIdleCallback(callback);
    };

    handle = requestIdleCallback(callback);
    return () => cancelIdleCallback(handle);
  }, [patterns, isPreviewMode]);
  return null;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/with-client-id.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


const withClientId = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(WrappedComponent => props => {
  const {
    clientId
  } = useBlockEditContext();
  return (0,external_wp_element_namespaceObject.createElement)(WrappedComponent, { ...props,
    clientId: clientId
  });
}, 'withClientId');
/* harmony default export */ var with_client_id = (withClientId);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/button-block-appender.js


/**
 * External dependencies
 */

/**
 * Internal dependencies
 */



const button_block_appender_ButtonBlockAppender = ({
  clientId,
  showSeparator,
  isFloating,
  onAddBlock,
  isToggle
}) => {
  return (0,external_wp_element_namespaceObject.createElement)(button_block_appender, {
    className: classnames_default()({
      'block-list-appender__toggle': isToggle
    }),
    rootClientId: clientId,
    showSeparator: showSeparator,
    isFloating: isFloating,
    onAddBlock: onAddBlock
  });
};
/* harmony default export */ var inner_blocks_button_block_appender = (with_client_id(button_block_appender_ButtonBlockAppender));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/default-block-appender.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




const default_block_appender_DefaultBlockAppender = ({
  clientId
}) => {
  return (0,external_wp_element_namespaceObject.createElement)(default_block_appender, {
    rootClientId: clientId
  });
};
/* harmony default export */ var inner_blocks_default_block_appender = ((0,external_wp_compose_namespaceObject.compose)([with_client_id, (0,external_wp_data_namespaceObject.withSelect)((select, {
  clientId
}) => {
  const {
    getBlockOrder
  } = select(store);
  const blockClientIds = getBlockOrder(clientId);
  return {
    lastBlockClientId: blockClientIds[blockClientIds.length - 1]
  };
})])(default_block_appender_DefaultBlockAppender));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/use-nested-settings-update.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/** @typedef {import('../../selectors').WPDirectInsertBlock } WPDirectInsertBlock */

const pendingSettingsUpdates = new WeakMap();
/**
 * This hook is a side effect which updates the block-editor store when changes
 * happen to inner block settings. The given props are transformed into a
 * settings object, and if that is different from the current settings object in
 * the block-editor store, then the store is updated with the new settings which
 * came from props.
 *
 * @param {string}               clientId                   The client ID of the block to update.
 * @param {string[]}             allowedBlocks              An array of block names which are permitted
 *                                                          in inner blocks.
 * @param {string[]}             prioritizedInserterBlocks  Block names and/or block variations to be prioritized in the inserter, in the format {blockName}/{variationName}.
 * @param {?WPDirectInsertBlock} __experimentalDefaultBlock The default block to insert: [ blockName, { blockAttributes } ].
 * @param {?Function|boolean}    __experimentalDirectInsert If a default block should be inserted directly by the
 *                                                          appender.
 * @param {string}               [templateLock]             The template lock specified for the inner
 *                                                          blocks component. (e.g. "all")
 * @param {boolean}              captureToolbars            Whether or children toolbars should be shown
 *                                                          in the inner blocks component rather than on
 *                                                          the child block.
 * @param {string}               orientation                The direction in which the block
 *                                                          should face.
 * @param {Object}               layout                     The layout object for the block container.
 */

function useNestedSettingsUpdate(clientId, allowedBlocks, prioritizedInserterBlocks, __experimentalDefaultBlock, __experimentalDirectInsert, templateLock, captureToolbars, orientation, layout) {
  const {
    updateBlockListSettings
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const registry = (0,external_wp_data_namespaceObject.useRegistry)();
  const {
    parentLock
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const rootClientId = select(store).getBlockRootClientId(clientId);
    return {
      parentLock: select(store).getTemplateLock(rootClientId)
    };
  }, [clientId]); // Memoize allowedBlocks and prioritisedInnerBlocks based on the contents
  // of the arrays. Implementors often pass a new array on every render,
  // and the contents of the arrays are just strings, so the entire array
  // can be passed as dependencies.

  const _allowedBlocks = (0,external_wp_element_namespaceObject.useMemo)(() => allowedBlocks, // eslint-disable-next-line react-hooks/exhaustive-deps
  allowedBlocks);

  const _prioritizedInserterBlocks = (0,external_wp_element_namespaceObject.useMemo)(() => prioritizedInserterBlocks, // eslint-disable-next-line react-hooks/exhaustive-deps
  prioritizedInserterBlocks);

  const _templateLock = templateLock === undefined || parentLock === 'contentOnly' ? parentLock : templateLock;

  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    const newSettings = {
      allowedBlocks: _allowedBlocks,
      prioritizedInserterBlocks: _prioritizedInserterBlocks,
      templateLock: _templateLock
    }; // These values are not defined for RN, so only include them if they
    // are defined.

    if (captureToolbars !== undefined) {
      newSettings.__experimentalCaptureToolbars = captureToolbars;
    } // Orientation depends on layout,
    // ideally the separate orientation prop should be deprecated.


    if (orientation !== undefined) {
      newSettings.orientation = orientation;
    } else {
      const layoutType = getLayoutType(layout?.type);
      newSettings.orientation = layoutType.getOrientation(layout);
    }

    if (__experimentalDefaultBlock !== undefined) {
      newSettings.__experimentalDefaultBlock = __experimentalDefaultBlock;
    }

    if (__experimentalDirectInsert !== undefined) {
      newSettings.__experimentalDirectInsert = __experimentalDirectInsert;
    } // Batch updates to block list settings to avoid triggering cascading renders
    // for each container block included in a tree and optimize initial render.
    // To avoid triggering updateBlockListSettings for each container block
    // causing X re-renderings for X container blocks,
    // we batch all the updatedBlockListSettings in a single "data" batch
    // which results in a single re-render.


    if (!pendingSettingsUpdates.get(registry)) {
      pendingSettingsUpdates.set(registry, []);
    }

    pendingSettingsUpdates.get(registry).push([clientId, newSettings]);
    window.queueMicrotask(() => {
      if (pendingSettingsUpdates.get(registry)?.length) {
        registry.batch(() => {
          pendingSettingsUpdates.get(registry).forEach(args => {
            updateBlockListSettings(...args);
          });
          pendingSettingsUpdates.set(registry, []);
        });
      }
    });
  }, [clientId, _allowedBlocks, _prioritizedInserterBlocks, _templateLock, __experimentalDefaultBlock, __experimentalDirectInsert, captureToolbars, orientation, updateBlockListSettings, layout, registry]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/use-inner-block-template-sync.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/**
 * This hook makes sure that a block's inner blocks stay in sync with the given
 * block "template". The template is a block hierarchy to which inner blocks must
 * conform. If the blocks get "out of sync" with the template and the template
 * is meant to be locked (e.g. templateLock = "all" or templateLock = "contentOnly"),
 * then we replace the inner blocks with the correct value after synchronizing it with the template.
 *
 * @param {string}  clientId                       The block client ID.
 * @param {Object}  template                       The template to match.
 * @param {string}  templateLock                   The template lock state for the inner blocks. For
 *                                                 example, if the template lock is set to "all",
 *                                                 then the inner blocks will stay in sync with the
 *                                                 template. If not defined or set to false, then
 *                                                 the inner blocks will not be synchronized with
 *                                                 the given template.
 * @param {boolean} templateInsertUpdatesSelection Whether or not to update the
 *                                                 block-editor selection state when inner blocks
 *                                                 are replaced after template synchronization.
 */

function useInnerBlockTemplateSync(clientId, template, templateLock, templateInsertUpdatesSelection) {
  const {
    getBlocks,
    getSelectedBlocksInitialCaretPosition,
    isBlockSelected
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    replaceInnerBlocks,
    __unstableMarkNextChangeAsNotPersistent
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const {
    innerBlocks
  } = (0,external_wp_data_namespaceObject.useSelect)(select => ({
    innerBlocks: select(store).getBlocks(clientId)
  }), [clientId]); // Maintain a reference to the previous value so we can do a deep equality check.

  const existingTemplate = (0,external_wp_element_namespaceObject.useRef)(null);
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    let isCancelled = false; // There's an implicit dependency between useInnerBlockTemplateSync and useNestedSettingsUpdate
    // The former needs to happen after the latter and since the latter is using microtasks to batch updates (performance optimization),
    // we need to schedule this one in a microtask as well.
    // Example: If you remove queueMicrotask here, ctrl + click to insert quote block won't close the inserter.

    window.queueMicrotask(() => {
      if (isCancelled) {
        return;
      } // Only synchronize innerBlocks with template if innerBlocks are empty
      // or a locking "all" or "contentOnly" exists directly on the block.


      const currentInnerBlocks = getBlocks(clientId);
      const shouldApplyTemplate = currentInnerBlocks.length === 0 || templateLock === 'all' || templateLock === 'contentOnly';
      const hasTemplateChanged = !es6_default()(template, existingTemplate.current);

      if (!shouldApplyTemplate || !hasTemplateChanged) {
        return;
      }

      existingTemplate.current = template;
      const nextBlocks = (0,external_wp_blocks_namespaceObject.synchronizeBlocksWithTemplate)(currentInnerBlocks, template);

      if (!es6_default()(nextBlocks, currentInnerBlocks)) {
        __unstableMarkNextChangeAsNotPersistent();

        replaceInnerBlocks(clientId, nextBlocks, currentInnerBlocks.length === 0 && templateInsertUpdatesSelection && nextBlocks.length !== 0 && isBlockSelected(clientId), // This ensures the "initialPosition" doesn't change when applying the template
        // If we're supposed to focus the block, we'll focus the first inner block
        // otherwise, we won't apply any auto-focus.
        // This ensures for instance that the focus stays in the inserter when inserting the "buttons" block.
        getSelectedBlocksInitialCaretPosition());
      }
    });
    return () => {
      isCancelled = true;
    };
  }, [innerBlocks, template, templateLock, clientId]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/use-block-context.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Returns a context object for a given block.
 *
 * @param {string} clientId The block client ID.
 *
 * @return {Record<string,*>} Context value.
 */

function useBlockContext(clientId) {
  return (0,external_wp_data_namespaceObject.useSelect)(select => {
    const block = select(store).getBlock(clientId);

    if (!block) {
      return undefined;
    }

    const blockType = select(external_wp_blocks_namespaceObject.store).getBlockType(block.name);

    if (!blockType) {
      return undefined;
    }

    if (Object.keys(blockType.providesContext).length === 0) {
      return undefined;
    }

    return Object.fromEntries(Object.entries(blockType.providesContext).map(([contextName, attributeName]) => [contextName, block.attributes[attributeName]]));
  }, [clientId]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/use-on-block-drop/index.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/** @typedef {import('@wordpress/element').WPSyntheticEvent} WPSyntheticEvent */

/** @typedef {import('./types').WPDropOperation} WPDropOperation */

/**
 * Retrieve the data for a block drop event.
 *
 * @param {WPSyntheticEvent} event The drop event.
 *
 * @return {Object} An object with block drag and drop data.
 */

function parseDropEvent(event) {
  let result = {
    srcRootClientId: null,
    srcClientIds: null,
    srcIndex: null,
    type: null,
    blocks: null
  };

  if (!event.dataTransfer) {
    return result;
  }

  try {
    result = Object.assign(result, JSON.parse(event.dataTransfer.getData('wp-blocks')));
  } catch (err) {
    return result;
  }

  return result;
}
/**
 * A function that returns an event handler function for block drop events.
 *
 * @param {string}   targetRootClientId        The root client id where the block(s) will be inserted.
 * @param {number}   targetBlockIndex          The index where the block(s) will be inserted.
 * @param {Function} getBlockIndex             A function that gets the index of a block.
 * @param {Function} getClientIdsOfDescendants A function that gets the client ids of descendant blocks.
 * @param {Function} moveBlocks                A function that moves blocks.
 * @param {Function} insertOrReplaceBlocks     A function that inserts or replaces blocks.
 * @param {Function} clearSelectedBlock        A function that clears block selection.
 * @return {Function} The event handler for a block drop event.
 */

function onBlockDrop(targetRootClientId, targetBlockIndex, getBlockIndex, getClientIdsOfDescendants, moveBlocks, insertOrReplaceBlocks, clearSelectedBlock) {
  return event => {
    const {
      srcRootClientId: sourceRootClientId,
      srcClientIds: sourceClientIds,
      type: dropType,
      blocks
    } = parseDropEvent(event); // If the user is inserting a block.

    if (dropType === 'inserter') {
      clearSelectedBlock();
      const blocksToInsert = blocks.map(block => (0,external_wp_blocks_namespaceObject.cloneBlock)(block));
      insertOrReplaceBlocks(blocksToInsert, true, null);
    } // If the user is moving a block.


    if (dropType === 'block') {
      const sourceBlockIndex = getBlockIndex(sourceClientIds[0]); // If the user is dropping to the same position, return early.

      if (sourceRootClientId === targetRootClientId && sourceBlockIndex === targetBlockIndex) {
        return;
      } // If the user is attempting to drop a block within its own
      // nested blocks, return early as this would create infinite
      // recursion.


      if (sourceClientIds.includes(targetRootClientId) || getClientIdsOfDescendants(sourceClientIds).some(id => id === targetRootClientId)) {
        return;
      }

      const isAtSameLevel = sourceRootClientId === targetRootClientId;
      const draggedBlockCount = sourceClientIds.length; // If the block is kept at the same level and moved downwards,
      // subtract to take into account that the blocks being dragged
      // were removed from the block list above the insertion point.

      const insertIndex = isAtSameLevel && sourceBlockIndex < targetBlockIndex ? targetBlockIndex - draggedBlockCount : targetBlockIndex;
      moveBlocks(sourceClientIds, sourceRootClientId, insertIndex);
    }
  };
}
/**
 * A function that returns an event handler function for block-related file drop events.
 *
 * @param {string}   targetRootClientId    The root client id where the block(s) will be inserted.
 * @param {number}   targetBlockIndex      The index where the block(s) will be inserted.
 * @param {boolean}  hasUploadPermissions  Whether the user has upload permissions.
 * @param {Function} updateBlockAttributes A function that updates a block's attributes.
 * @param {Function} canInsertBlockType    A function that returns checks whether a block type can be inserted.
 * @param {Function} insertOrReplaceBlocks A function that inserts or replaces blocks.
 *
 * @return {Function} The event handler for a block-related file drop event.
 */

function onFilesDrop(targetRootClientId, targetBlockIndex, hasUploadPermissions, updateBlockAttributes, canInsertBlockType, insertOrReplaceBlocks) {
  return files => {
    if (!hasUploadPermissions) {
      return;
    }

    const transformation = (0,external_wp_blocks_namespaceObject.findTransform)((0,external_wp_blocks_namespaceObject.getBlockTransforms)('from'), transform => transform.type === 'files' && canInsertBlockType(transform.blockName, targetRootClientId) && transform.isMatch(files));

    if (transformation) {
      const blocks = transformation.transform(files, updateBlockAttributes);
      insertOrReplaceBlocks(blocks);
    }
  };
}
/**
 * A function that returns an event handler function for block-related HTML drop events.
 *
 * @param {string}   targetRootClientId    The root client id where the block(s) will be inserted.
 * @param {number}   targetBlockIndex      The index where the block(s) will be inserted.
 * @param {Function} insertOrReplaceBlocks A function that inserts or replaces blocks.
 *
 * @return {Function} The event handler for a block-related HTML drop event.
 */

function onHTMLDrop(targetRootClientId, targetBlockIndex, insertOrReplaceBlocks) {
  return HTML => {
    const blocks = (0,external_wp_blocks_namespaceObject.pasteHandler)({
      HTML,
      mode: 'BLOCKS'
    });

    if (blocks.length) {
      insertOrReplaceBlocks(blocks);
    }
  };
}
/**
 * A React hook for handling block drop events.
 *
 * @param {string}          targetRootClientId  The root client id where the block(s) will be inserted.
 * @param {number}          targetBlockIndex    The index where the block(s) will be inserted.
 * @param {Object}          options             The optional options.
 * @param {WPDropOperation} [options.operation] The type of operation to perform on drop. Could be `insert` or `replace` for now.
 *
 * @return {Function} A function to be passed to the onDrop handler.
 */

function useOnBlockDrop(targetRootClientId, targetBlockIndex, options = {}) {
  const {
    operation = 'insert'
  } = options;
  const hasUploadPermissions = (0,external_wp_data_namespaceObject.useSelect)(select => select(store).getSettings().mediaUpload, []);
  const {
    canInsertBlockType,
    getBlockIndex,
    getClientIdsOfDescendants,
    getBlockOrder,
    getBlocksByClientId
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    insertBlocks,
    moveBlocksToPosition,
    updateBlockAttributes,
    clearSelectedBlock,
    replaceBlocks,
    removeBlocks
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const registry = (0,external_wp_data_namespaceObject.useRegistry)();
  const insertOrReplaceBlocks = (0,external_wp_element_namespaceObject.useCallback)((blocks, updateSelection = true, initialPosition = 0) => {
    if (operation === 'replace') {
      const clientIds = getBlockOrder(targetRootClientId);
      const clientId = clientIds[targetBlockIndex];
      replaceBlocks(clientId, blocks, undefined, initialPosition);
    } else {
      insertBlocks(blocks, targetBlockIndex, targetRootClientId, updateSelection, initialPosition);
    }
  }, [operation, getBlockOrder, insertBlocks, replaceBlocks, targetBlockIndex, targetRootClientId]);
  const moveBlocks = (0,external_wp_element_namespaceObject.useCallback)((sourceClientIds, sourceRootClientId, insertIndex) => {
    if (operation === 'replace') {
      const sourceBlocks = getBlocksByClientId(sourceClientIds);
      const targetBlockClientIds = getBlockOrder(targetRootClientId);
      const targetBlockClientId = targetBlockClientIds[targetBlockIndex];
      registry.batch(() => {
        // Remove the source blocks.
        removeBlocks(sourceClientIds, false); // Replace the target block with the source blocks.

        replaceBlocks(targetBlockClientId, sourceBlocks, undefined, 0);
      });
    } else {
      moveBlocksToPosition(sourceClientIds, sourceRootClientId, targetRootClientId, insertIndex);
    }
  }, [operation, getBlockOrder, getBlocksByClientId, insertBlocks, moveBlocksToPosition, removeBlocks, targetBlockIndex, targetRootClientId]);

  const _onDrop = onBlockDrop(targetRootClientId, targetBlockIndex, getBlockIndex, getClientIdsOfDescendants, moveBlocks, insertOrReplaceBlocks, clearSelectedBlock);

  const _onFilesDrop = onFilesDrop(targetRootClientId, targetBlockIndex, hasUploadPermissions, updateBlockAttributes, canInsertBlockType, insertOrReplaceBlocks);

  const _onHTMLDrop = onHTMLDrop(targetRootClientId, targetBlockIndex, insertOrReplaceBlocks);

  return event => {
    const files = (0,external_wp_dom_namespaceObject.getFilesFromDataTransfer)(event.dataTransfer);
    const html = event.dataTransfer.getData('text/html');
    /**
     * From Windows Chrome 96, the `event.dataTransfer` returns both file object and HTML.
     * The order of the checks is important to recognise the HTML drop.
     */

    if (html) {
      _onHTMLDrop(html);
    } else if (files.length) {
      _onFilesDrop(files);
    } else {
      _onDrop(event);
    }
  };
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/math.js
/**
 * A string representing the name of an edge.
 *
 * @typedef {'top'|'right'|'bottom'|'left'} WPEdgeName
 */

/**
 * @typedef  {Object} WPPoint
 * @property {number} x The horizontal position.
 * @property {number} y The vertical position.
 */

/**
 * Given a point, a DOMRect and the name of an edge, returns the distance to
 * that edge of the rect.
 *
 * This function works for edges that are horizontal or vertical (e.g. not
 * rotated), the following terms are used so that the function works in both
 * orientations:
 *
 * - Forward, meaning the axis running horizontally when an edge is vertical
 *   and vertically when an edge is horizontal.
 * - Lateral, meaning the axis running vertically when an edge is vertical
 *   and horizontally when an edge is horizontal.
 *
 * @param {WPPoint}    point The point to measure distance from.
 * @param {DOMRect}    rect  A DOM Rect containing edge positions.
 * @param {WPEdgeName} edge  The edge to measure to.
 */
function getDistanceFromPointToEdge(point, rect, edge) {
  const isHorizontal = edge === 'top' || edge === 'bottom';
  const {
    x,
    y
  } = point;
  const pointLateralPosition = isHorizontal ? x : y;
  const pointForwardPosition = isHorizontal ? y : x;
  const edgeStart = isHorizontal ? rect.left : rect.top;
  const edgeEnd = isHorizontal ? rect.right : rect.bottom;
  const edgeForwardPosition = rect[edge]; // Measure the straight line distance to the edge of the rect, when the
  // point is adjacent to the edge.
  // Else, if the point is positioned diagonally to the edge of the rect,
  // measure diagonally to the nearest corner that the edge meets.

  let edgeLateralPosition;

  if (pointLateralPosition >= edgeStart && pointLateralPosition <= edgeEnd) {
    edgeLateralPosition = pointLateralPosition;
  } else if (pointLateralPosition < edgeEnd) {
    edgeLateralPosition = edgeStart;
  } else {
    edgeLateralPosition = edgeEnd;
  }

  return Math.sqrt((pointLateralPosition - edgeLateralPosition) ** 2 + (pointForwardPosition - edgeForwardPosition) ** 2);
}
/**
 * Given a point, a DOMRect and a list of allowed edges returns the name of and
 * distance to the nearest edge.
 *
 * @param {WPPoint}      point        The point to measure distance from.
 * @param {DOMRect}      rect         A DOM Rect containing edge positions.
 * @param {WPEdgeName[]} allowedEdges A list of the edges included in the
 *                                    calculation. Defaults to all edges.
 *
 * @return {[number, string]} An array where the first value is the distance
 *                              and a second is the edge name.
 */

function getDistanceToNearestEdge(point, rect, allowedEdges = ['top', 'bottom', 'left', 'right']) {
  let candidateDistance;
  let candidateEdge;
  allowedEdges.forEach(edge => {
    const distance = getDistanceFromPointToEdge(point, rect, edge);

    if (candidateDistance === undefined || distance < candidateDistance) {
      candidateDistance = distance;
      candidateEdge = edge;
    }
  });
  return [candidateDistance, candidateEdge];
}
/**
 * Is the point contained by the rectangle.
 *
 * @param {WPPoint} point The point.
 * @param {DOMRect} rect  The rectangle.
 *
 * @return {boolean} True if the point is contained by the rectangle, false otherwise.
 */

function isPointContainedByRect(point, rect) {
  return rect.left <= point.x && rect.right >= point.x && rect.top <= point.y && rect.bottom >= point.y;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/use-block-drop-zone/index.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */





/** @typedef {import('../../utils/math').WPPoint} WPPoint */

/** @typedef {import('../use-on-block-drop/types').WPDropOperation} WPDropOperation */

/**
 * The orientation of a block list.
 *
 * @typedef {'horizontal'|'vertical'|undefined} WPBlockListOrientation
 */

/**
 * The insert position when dropping a block.
 *
 * @typedef {'before'|'after'} WPInsertPosition
 */

/**
 * @typedef {Object} WPBlockData
 * @property {boolean}       isUnmodifiedDefaultBlock Is the block unmodified default block.
 * @property {() => DOMRect} getBoundingClientRect    Get the bounding client rect of the block.
 * @property {number}        blockIndex               The index of the block.
 */

/**
 * Get the drop target position from a given drop point and the orientation.
 *
 * @param {WPBlockData[]}          blocksData  The block data list.
 * @param {WPPoint}                position    The position of the item being dragged.
 * @param {WPBlockListOrientation} orientation The orientation of the block list.
 * @return {[number, WPDropOperation]} The drop target position.
 */

function getDropTargetPosition(blocksData, position, orientation = 'vertical') {
  const allowedEdges = orientation === 'horizontal' ? ['left', 'right'] : ['top', 'bottom'];
  const isRightToLeft = (0,external_wp_i18n_namespaceObject.isRTL)();
  let nearestIndex = 0;
  let insertPosition = 'before';
  let minDistance = Infinity;
  blocksData.forEach(({
    isUnmodifiedDefaultBlock,
    getBoundingClientRect,
    blockIndex
  }) => {
    const rect = getBoundingClientRect();
    let [distance, edge] = getDistanceToNearestEdge(position, rect, allowedEdges); // Prioritize the element if the point is inside of an unmodified default block.

    if (isUnmodifiedDefaultBlock && isPointContainedByRect(position, rect)) {
      distance = 0;
    }

    if (distance < minDistance) {
      // Where the dropped block will be inserted on the nearest block.
      insertPosition = edge === 'bottom' || !isRightToLeft && edge === 'right' || isRightToLeft && edge === 'left' ? 'after' : 'before'; // Update the currently known best candidate.

      minDistance = distance;
      nearestIndex = blockIndex;
    }
  });
  const adjacentIndex = nearestIndex + (insertPosition === 'after' ? 1 : -1);
  const isNearestBlockUnmodifiedDefaultBlock = !!blocksData[nearestIndex]?.isUnmodifiedDefaultBlock;
  const isAdjacentBlockUnmodifiedDefaultBlock = !!blocksData[adjacentIndex]?.isUnmodifiedDefaultBlock; // If both blocks are not unmodified default blocks then just insert between them.

  if (!isNearestBlockUnmodifiedDefaultBlock && !isAdjacentBlockUnmodifiedDefaultBlock) {
    // If the user is dropping to the trailing edge of the block
    // add 1 to the index to represent dragging after.
    const insertionIndex = insertPosition === 'after' ? nearestIndex + 1 : nearestIndex;
    return [insertionIndex, 'insert'];
  } // Otherwise, replace the nearest unmodified default block.


  return [isNearestBlockUnmodifiedDefaultBlock ? nearestIndex : adjacentIndex, 'replace'];
}
/**
 * @typedef  {Object} WPBlockDropZoneConfig
 * @property {string} rootClientId The root client id for the block list.
 */

/**
 * A React hook that can be used to make a block list handle drag and drop.
 *
 * @param {WPBlockDropZoneConfig} dropZoneConfig configuration data for the drop zone.
 */

function useBlockDropZone({
  // An undefined value represents a top-level block. Default to an empty
  // string for this so that `targetRootClientId` can be easily compared to
  // values returned by the `getRootBlockClientId` selector, which also uses
  // an empty string to represent top-level blocks.
  rootClientId: targetRootClientId = ''
} = {}) {
  const registry = (0,external_wp_data_namespaceObject.useRegistry)();
  const [dropTarget, setDropTarget] = (0,external_wp_element_namespaceObject.useState)({
    index: null,
    operation: 'insert'
  });
  const isDisabled = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      __unstableIsWithinBlockOverlay,
      __unstableHasActiveBlockOverlayActive,
      getBlockEditingMode
    } = unlock(select(store));
    const blockEditingMode = getBlockEditingMode(targetRootClientId);
    return blockEditingMode !== 'default' || __unstableHasActiveBlockOverlayActive(targetRootClientId) || __unstableIsWithinBlockOverlay(targetRootClientId);
  }, [targetRootClientId]);
  const {
    getBlockListSettings,
    getBlocks,
    getBlockIndex
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    showInsertionPoint,
    hideInsertionPoint
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const onBlockDrop = useOnBlockDrop(targetRootClientId, dropTarget.index, {
    operation: dropTarget.operation
  });
  const throttled = (0,external_wp_compose_namespaceObject.useThrottle)((0,external_wp_element_namespaceObject.useCallback)((event, ownerDocument) => {
    const blocks = getBlocks(targetRootClientId); // The block list is empty, don't show the insertion point but still allow dropping.

    if (blocks.length === 0) {
      registry.batch(() => {
        setDropTarget({
          index: 0,
          operation: 'insert'
        });
        showInsertionPoint(targetRootClientId, 0, {
          operation: 'insert'
        });
      });
      return;
    }

    const blocksData = blocks.map(block => {
      const clientId = block.clientId;
      return {
        isUnmodifiedDefaultBlock: (0,external_wp_blocks_namespaceObject.isUnmodifiedDefaultBlock)(block),
        getBoundingClientRect: () => ownerDocument.getElementById(`block-${clientId}`).getBoundingClientRect(),
        blockIndex: getBlockIndex(clientId)
      };
    });
    const [targetIndex, operation] = getDropTargetPosition(blocksData, {
      x: event.clientX,
      y: event.clientY
    }, getBlockListSettings(targetRootClientId)?.orientation);
    registry.batch(() => {
      setDropTarget({
        index: targetIndex,
        operation
      });
      showInsertionPoint(targetRootClientId, targetIndex, {
        operation
      });
    });
  }, [getBlocks, targetRootClientId, getBlockListSettings, registry, showInsertionPoint, getBlockIndex]), 200);
  return (0,external_wp_compose_namespaceObject.__experimentalUseDropZone)({
    isDisabled,
    onDrop: onBlockDrop,

    onDragOver(event) {
      // `currentTarget` is only available while the event is being
      // handled, so get it now and pass it to the thottled function.
      // https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget
      throttled(event, event.currentTarget.ownerDocument);
    },

    onDragLeave() {
      throttled.cancel();
      hideInsertionPoint();
    },

    onDragEnd() {
      throttled.cancel();
      hideInsertionPoint();
    }

  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */













const EMPTY_OBJECT = {};
/**
 * InnerBlocks is a component which allows a single block to have multiple blocks
 * as children. The UncontrolledInnerBlocks component is used whenever the inner
 * blocks are not controlled by another entity. In other words, it is normally
 * used for inner blocks in the post editor
 *
 * @param {Object} props The component props.
 */

function UncontrolledInnerBlocks(props) {
  const {
    clientId,
    allowedBlocks,
    prioritizedInserterBlocks,
    __experimentalDefaultBlock,
    __experimentalDirectInsert,
    template,
    templateLock,
    wrapperRef,
    templateInsertUpdatesSelection,
    __experimentalCaptureToolbars: captureToolbars,
    __experimentalAppenderTagName,
    renderAppender,
    orientation,
    placeholder,
    layout
  } = props;
  useNestedSettingsUpdate(clientId, allowedBlocks, prioritizedInserterBlocks, __experimentalDefaultBlock, __experimentalDirectInsert, templateLock, captureToolbars, orientation, layout);
  useInnerBlockTemplateSync(clientId, template, templateLock, templateInsertUpdatesSelection);
  const context = useBlockContext(clientId);
  const name = (0,external_wp_data_namespaceObject.useSelect)(select => {
    return select(store).getBlock(clientId)?.name;
  }, [clientId]);
  const defaultLayoutBlockSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(name, 'layout') || (0,external_wp_blocks_namespaceObject.getBlockSupport)(name, '__experimentalLayout') || EMPTY_OBJECT;
  const {
    allowSizingOnChildren = false
  } = defaultLayoutBlockSupport;
  const defaultLayout = use_setting_useSetting('layout') || EMPTY_OBJECT;
  const usedLayout = layout || defaultLayoutBlockSupport;
  const memoedLayout = (0,external_wp_element_namespaceObject.useMemo)(() => ({ // Default layout will know about any content/wide size defined by the theme.
    ...defaultLayout,
    ...usedLayout,
    ...(allowSizingOnChildren && {
      allowSizingOnChildren: true
    })
  }), [defaultLayout, usedLayout, allowSizingOnChildren]); // This component needs to always be synchronous as it's the one changing
  // the async mode depending on the block selection.

  return (0,external_wp_element_namespaceObject.createElement)(BlockContextProvider, {
    value: context
  }, (0,external_wp_element_namespaceObject.createElement)(BlockListItems, {
    rootClientId: clientId,
    renderAppender: renderAppender,
    __experimentalAppenderTagName: __experimentalAppenderTagName,
    layout: memoedLayout,
    wrapperRef: wrapperRef,
    placeholder: placeholder
  }));
}
/**
 * The controlled inner blocks component wraps the uncontrolled inner blocks
 * component with the blockSync hook. This keeps the innerBlocks of the block in
 * the block-editor store in sync with the blocks of the controlling entity. An
 * example of an inner block controller is a template part block, which provides
 * its own blocks from the template part entity data source.
 *
 * @param {Object} props The component props.
 */


function ControlledInnerBlocks(props) {
  useBlockSync(props);
  return (0,external_wp_element_namespaceObject.createElement)(UncontrolledInnerBlocks, { ...props
  });
}

const ForwardedInnerBlocks = (0,external_wp_element_namespaceObject.forwardRef)((props, ref) => {
  const innerBlocksProps = useInnerBlocksProps({
    ref
  }, props);
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inner-blocks"
  }, (0,external_wp_element_namespaceObject.createElement)("div", { ...innerBlocksProps
  }));
});
/**
 * This hook is used to lightly mark an element as an inner blocks wrapper
 * element. Call this hook and pass the returned props to the element to mark as
 * an inner blocks wrapper, automatically rendering inner blocks as children. If
 * you define a ref for the element, it is important to pass the ref to this
 * hook, which the hook in turn will pass to the component through the props it
 * returns. Optionally, you can also pass any other props through this hook, and
 * they will be merged and returned.
 *
 * @param {Object} props   Optional. Props to pass to the element. Must contain
 *                         the ref if one is defined.
 * @param {Object} options Optional. Inner blocks options.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/inner-blocks/README.md
 */

function useInnerBlocksProps(props = {}, options = {}) {
  const {
    __unstableDisableLayoutClassNames,
    __unstableDisableDropZone
  } = options;
  const {
    clientId,
    layout = null,
    __unstableLayoutClassNames: layoutClassNames = ''
  } = useBlockEditContext();
  const isSmallScreen = (0,external_wp_compose_namespaceObject.useViewportMatch)('medium', '<');
  const {
    __experimentalCaptureToolbars,
    hasOverlay
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    if (!clientId) {
      return {};
    }

    const {
      getBlockName,
      isBlockSelected,
      hasSelectedInnerBlock,
      __unstableGetEditorMode
    } = select(store);
    const blockName = getBlockName(clientId);
    const enableClickThrough = __unstableGetEditorMode() === 'navigation' || isSmallScreen;
    return {
      __experimentalCaptureToolbars: select(external_wp_blocks_namespaceObject.store).hasBlockSupport(blockName, '__experimentalExposeControlsToChildren', false),
      hasOverlay: blockName !== 'core/template' && !isBlockSelected(clientId) && !hasSelectedInnerBlock(clientId, true) && enableClickThrough
    };
  }, [clientId, isSmallScreen]);
  const blockDropZoneRef = useBlockDropZone({
    rootClientId: clientId
  });
  const ref = (0,external_wp_compose_namespaceObject.useMergeRefs)([props.ref, __unstableDisableDropZone ? null : blockDropZoneRef]);
  const innerBlocksProps = {
    __experimentalCaptureToolbars,
    layout,
    ...options
  };
  const InnerBlocks = innerBlocksProps.value && innerBlocksProps.onChange ? ControlledInnerBlocks : UncontrolledInnerBlocks;
  return { ...props,
    ref,
    className: classnames_default()(props.className, 'block-editor-block-list__layout', __unstableDisableLayoutClassNames ? '' : layoutClassNames, {
      'has-overlay': hasOverlay
    }),
    children: clientId ? (0,external_wp_element_namespaceObject.createElement)(InnerBlocks, { ...innerBlocksProps,
      clientId: clientId
    }) : (0,external_wp_element_namespaceObject.createElement)(BlockListItems, { ...options
    })
  };
}
useInnerBlocksProps.save = external_wp_blocks_namespaceObject.__unstableGetInnerBlocksProps; // Expose default appender placeholders as components.

ForwardedInnerBlocks.DefaultBlockAppender = inner_blocks_default_block_appender;
ForwardedInnerBlocks.ButtonBlockAppender = inner_blocks_button_block_appender;

ForwardedInnerBlocks.Content = () => useInnerBlocksProps.save().children;
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/inner-blocks/README.md
 */


/* harmony default export */ var inner_blocks = (ForwardedInnerBlocks);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */










const elementContext = (0,external_wp_element_namespaceObject.createContext)();
const block_list_IntersectionObserver = (0,external_wp_element_namespaceObject.createContext)();
const pendingBlockVisibilityUpdatesPerRegistry = new WeakMap();

function Root({
  className,
  ...settings
}) {
  const [element, setElement] = (0,external_wp_element_namespaceObject.useState)();
  const isLargeViewport = (0,external_wp_compose_namespaceObject.useViewportMatch)('medium');
  const {
    isOutlineMode,
    isFocusMode,
    editorMode
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getSettings,
      __unstableGetEditorMode
    } = select(store);
    const {
      outlineMode,
      focusMode
    } = getSettings();
    return {
      isOutlineMode: outlineMode,
      isFocusMode: focusMode,
      editorMode: __unstableGetEditorMode()
    };
  }, []);
  const registry = (0,external_wp_data_namespaceObject.useRegistry)();
  const {
    setBlockVisibility
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const delayedBlockVisibilityUpdates = (0,external_wp_compose_namespaceObject.useDebounce)((0,external_wp_element_namespaceObject.useCallback)(() => {
    const updates = {};
    pendingBlockVisibilityUpdatesPerRegistry.get(registry).forEach(([id, isIntersecting]) => {
      updates[id] = isIntersecting;
    });
    setBlockVisibility(updates);
  }, [registry]), 300, {
    trailing: true
  });
  const intersectionObserver = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const {
      IntersectionObserver: Observer
    } = window;

    if (!Observer) {
      return;
    }

    return new Observer(entries => {
      if (!pendingBlockVisibilityUpdatesPerRegistry.get(registry)) {
        pendingBlockVisibilityUpdatesPerRegistry.set(registry, []);
      }

      for (const entry of entries) {
        const clientId = entry.target.getAttribute('data-block');
        pendingBlockVisibilityUpdatesPerRegistry.get(registry).push([clientId, entry.isIntersecting]);
      }

      delayedBlockVisibilityUpdates();
    });
  }, []);
  const innerBlocksProps = useInnerBlocksProps({
    ref: (0,external_wp_compose_namespaceObject.useMergeRefs)([useBlockSelectionClearer(), useInBetweenInserter(), setElement]),
    className: classnames_default()('is-root-container', className, {
      'is-outline-mode': isOutlineMode,
      'is-focus-mode': isFocusMode && isLargeViewport,
      'is-navigate-mode': editorMode === 'navigation'
    })
  }, settings);
  return (0,external_wp_element_namespaceObject.createElement)(elementContext.Provider, {
    value: element
  }, (0,external_wp_element_namespaceObject.createElement)(block_list_IntersectionObserver.Provider, {
    value: intersectionObserver
  }, (0,external_wp_element_namespaceObject.createElement)("div", { ...innerBlocksProps
  })));
}

function BlockList(settings) {
  usePreParsePatterns();
  return (0,external_wp_element_namespaceObject.createElement)(Provider, {
    value: DEFAULT_BLOCK_EDIT_CONTEXT
  }, (0,external_wp_element_namespaceObject.createElement)(Root, { ...settings
  }));
}
BlockList.__unstableElementContext = elementContext;

function Items({
  placeholder,
  rootClientId,
  renderAppender,
  __experimentalAppenderTagName,
  layout = defaultLayout
}) {
  const {
    order,
    selectedBlocks,
    visibleBlocks
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockOrder,
      getSelectedBlockClientIds,
      __unstableGetVisibleBlocks
    } = select(store);
    return {
      order: getBlockOrder(rootClientId),
      selectedBlocks: getSelectedBlockClientIds(),
      visibleBlocks: __unstableGetVisibleBlocks()
    };
  }, [rootClientId]);
  return (0,external_wp_element_namespaceObject.createElement)(LayoutProvider, {
    value: layout
  }, order.map(clientId => (0,external_wp_element_namespaceObject.createElement)(external_wp_data_namespaceObject.AsyncModeProvider, {
    key: clientId,
    value: // Only provide data asynchronously if the block is
    // not visible and not selected.
    !visibleBlocks.has(clientId) && !selectedBlocks.includes(clientId)
  }, (0,external_wp_element_namespaceObject.createElement)(block, {
    rootClientId: rootClientId,
    clientId: clientId
  }))), order.length < 1 && placeholder, (0,external_wp_element_namespaceObject.createElement)(block_list_appender, {
    tagName: __experimentalAppenderTagName,
    rootClientId: rootClientId,
    renderAppender: renderAppender
  }));
}

function BlockListItems(props) {
  // This component needs to always be synchronous as it's the one changing
  // the async mode depending on the block selection.
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_data_namespaceObject.AsyncModeProvider, {
    value: false
  }, (0,external_wp_element_namespaceObject.createElement)(Items, { ...props
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/colors/utils.js
/**
 * External dependencies
 */



/**
 * Internal dependencies
 */


k([names, a11y]);
/**
 * Provided an array of color objects as set by the theme or by the editor defaults,
 * and the values of the defined color or custom color returns a color object describing the color.
 *
 * @param {Array}   colors       Array of color objects as set by the theme or by the editor defaults.
 * @param {?string} definedColor A string containing the color slug.
 * @param {?string} customColor  A string containing the customColor value.
 *
 * @return {?Object} If definedColor is passed and the name is found in colors,
 *                   the color object exactly as set by the theme or editor defaults is returned.
 *                   Otherwise, an object that just sets the color is defined.
 */

const getColorObjectByAttributeValues = (colors, definedColor, customColor) => {
  if (definedColor) {
    const colorObj = colors?.find(color => color.slug === definedColor);

    if (colorObj) {
      return colorObj;
    }
  }

  return {
    color: customColor
  };
};
/**
 * Provided an array of color objects as set by the theme or by the editor defaults, and a color value returns the color object matching that value or undefined.
 *
 * @param {Array}   colors     Array of color objects as set by the theme or by the editor defaults.
 * @param {?string} colorValue A string containing the color value.
 *
 * @return {?Object} Color object included in the colors array whose color property equals colorValue.
 *                   Returns undefined if no color object matches this requirement.
 */

const getColorObjectByColorValue = (colors, colorValue) => {
  return colors?.find(color => color.color === colorValue);
};
/**
 * Returns a class based on the context a color is being used and its slug.
 *
 * @param {string} colorContextName Context/place where color is being used e.g: background, text etc...
 * @param {string} colorSlug        Slug of the color.
 *
 * @return {?string} String with the class corresponding to the color in the provided context.
 *                   Returns undefined if either colorContextName or colorSlug are not provided.
 */

function getColorClassName(colorContextName, colorSlug) {
  if (!colorContextName || !colorSlug) {
    return undefined;
  }

  return `has-${kebabCase(colorSlug)}-${colorContextName}`;
}
/**
 * Given an array of color objects and a color value returns the color value of the most readable color in the array.
 *
 * @param {Array}   colors     Array of color objects as set by the theme or by the editor defaults.
 * @param {?string} colorValue A string containing the color value.
 *
 * @return {string} String with the color value of the most readable color.
 */

function getMostReadableColor(colors, colorValue) {
  const colordColor = w(colorValue);

  const getColorContrast = ({
    color
  }) => colordColor.contrast(color);

  const maxContrast = Math.max(...colors.map(getColorContrast));
  return colors.find(color => getColorContrast(color) === maxContrast).color;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/colors-gradients/use-multiple-origin-colors-and-gradients.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Retrieves color and gradient related settings.
 *
 * The arrays for colors and gradients are made up of color palettes from each
 * origin i.e. "Core", "Theme", and "User".
 *
 * @return {Object} Color and gradient related settings.
 */

function useMultipleOriginColorsAndGradients() {
  const colorGradientSettings = {
    disableCustomColors: !use_setting_useSetting('color.custom'),
    disableCustomGradients: !use_setting_useSetting('color.customGradient')
  };
  const customColors = use_setting_useSetting('color.palette.custom');
  const themeColors = use_setting_useSetting('color.palette.theme');
  const defaultColors = use_setting_useSetting('color.palette.default');
  const shouldDisplayDefaultColors = use_setting_useSetting('color.defaultPalette');
  colorGradientSettings.colors = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const result = [];

    if (themeColors && themeColors.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)('Theme', 'Indicates this palette comes from the theme.'),
        colors: themeColors
      });
    }

    if (shouldDisplayDefaultColors && defaultColors && defaultColors.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)('Default', 'Indicates this palette comes from WordPress.'),
        colors: defaultColors
      });
    }

    if (customColors && customColors.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)('Custom', 'Indicates this palette comes from the theme.'),
        colors: customColors
      });
    }

    return result;
  }, [defaultColors, themeColors, customColors, shouldDisplayDefaultColors]);
  const customGradients = use_setting_useSetting('color.gradients.custom');
  const themeGradients = use_setting_useSetting('color.gradients.theme');
  const defaultGradients = use_setting_useSetting('color.gradients.default');
  const shouldDisplayDefaultGradients = use_setting_useSetting('color.defaultGradients');
  colorGradientSettings.gradients = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const result = [];

    if (themeGradients && themeGradients.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)('Theme', 'Indicates this palette comes from the theme.'),
        gradients: themeGradients
      });
    }

    if (shouldDisplayDefaultGradients && defaultGradients && defaultGradients.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)('Default', 'Indicates this palette comes from WordPress.'),
        gradients: defaultGradients
      });
    }

    if (customGradients && customGradients.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)('Custom', 'Indicates this palette is created by the user.'),
        gradients: customGradients
      });
    }

    return result;
  }, [customGradients, themeGradients, defaultGradients, shouldDisplayDefaultGradients]);
  colorGradientSettings.hasColorsOrGradients = !!colorGradientSettings.colors.length || !!colorGradientSettings.gradients.length;
  return colorGradientSettings;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/border-radius-control/utils.js
/**
 * WordPress dependencies
 */

/**
 * Gets the (non-undefined) item with the highest occurrence within an array
 * Based in part on: https://stackoverflow.com/a/20762713
 *
 * Undefined values are always sorted to the end by `sort`, so this function
 * returns the first element, to always prioritize real values over undefined
 * values.
 *
 * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#description
 *
 * @param {Array<any>} inputArray Array of items to check.
 * @return {any}                  The item with the most occurrences.
 */

function utils_mode(inputArray) {
  const arr = [...inputArray];
  return arr.sort((a, b) => inputArray.filter(v => v === b).length - inputArray.filter(v => v === a).length).shift();
}
/**
 * Returns the most common CSS unit from the current CSS unit selections.
 *
 * - If a single flat border radius is set, its unit will be used
 * - If individual corner selections, the most common of those will be used
 * - Failing any unit selections a default of 'px' is returned.
 *
 * @param {Object} selectedUnits Unit selections for flat radius & each corner.
 * @return {string} Most common CSS unit from current selections. Default: `px`.
 */

function getAllUnit(selectedUnits = {}) {
  const {
    flat,
    ...cornerUnits
  } = selectedUnits;
  return flat || utils_mode(Object.values(cornerUnits).filter(Boolean)) || 'px';
}
/**
 * Gets the 'all' input value and unit from values data.
 *
 * @param {Object|string} values Radius values.
 * @return {string}              A value + unit for the 'all' input.
 */

function getAllValue(values = {}) {
  /**
   * Border radius support was originally a single pixel value.
   *
   * To maintain backwards compatibility treat this case as the all value.
   */
  if (typeof values === 'string') {
    return values;
  }

  const parsedQuantitiesAndUnits = Object.values(values).map(value => (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(value));
  const allValues = parsedQuantitiesAndUnits.map(value => {
    var _value$;

    return (_value$ = value[0]) !== null && _value$ !== void 0 ? _value$ : '';
  });
  const allUnits = parsedQuantitiesAndUnits.map(value => value[1]);
  const value = allValues.every(v => v === allValues[0]) ? allValues[0] : '';
  const unit = utils_mode(allUnits);
  const allValue = value === 0 || value ? `${value}${unit}` : undefined;
  return allValue;
}
/**
 * Checks to determine if values are mixed.
 *
 * @param {Object} values Radius values.
 * @return {boolean}      Whether values are mixed.
 */

function hasMixedValues(values = {}) {
  const allValue = getAllValue(values);
  const isMixed = typeof values === 'string' ? false : isNaN(parseFloat(allValue));
  return isMixed;
}
/**
 * Checks to determine if values are defined.
 *
 * @param {Object} values Radius values.
 * @return {boolean}      Whether values are mixed.
 */

function hasDefinedValues(values) {
  if (!values) {
    return false;
  } // A string value represents a shorthand value.


  if (typeof values === 'string') {
    return true;
  } // An object represents longhand border radius values, if any are set
  // flag values as being defined.


  const filteredValues = Object.values(values).filter(value => {
    return !!value || value === 0;
  });
  return !!filteredValues.length;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/border-radius-control/all-input-control.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function AllInputControl({
  onChange,
  selectedUnits,
  setSelectedUnits,
  values,
  ...props
}) {
  let allValue = getAllValue(values);

  if (allValue === undefined) {
    // If we don't have any value set the unit to any current selection
    // or the most common unit from the individual radii values.
    allValue = getAllUnit(selectedUnits);
  }

  const hasValues = hasDefinedValues(values);
  const isMixed = hasValues && hasMixedValues(values);
  const allPlaceholder = isMixed ? (0,external_wp_i18n_namespaceObject.__)('Mixed') : null; // Filter out CSS-unit-only values to prevent invalid styles.

  const handleOnChange = next => {
    const isNumeric = !isNaN(parseFloat(next));
    const nextValue = isNumeric ? next : undefined;
    onChange(nextValue);
  }; // Store current unit selection for use as fallback for individual
  // radii controls.


  const handleOnUnitChange = unit => {
    setSelectedUnits({
      topLeft: unit,
      topRight: unit,
      bottomLeft: unit,
      bottomRight: unit
    });
  };

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalUnitControl, { ...props,
    "aria-label": (0,external_wp_i18n_namespaceObject.__)('Border radius'),
    disableUnits: isMixed,
    isOnly: true,
    value: allValue,
    onChange: handleOnChange,
    onUnitChange: handleOnUnitChange,
    placeholder: allPlaceholder,
    size: '__unstable-large'
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/border-radius-control/input-controls.js


/**
 * WordPress dependencies
 */


const CORNERS = {
  topLeft: (0,external_wp_i18n_namespaceObject.__)('Top left'),
  topRight: (0,external_wp_i18n_namespaceObject.__)('Top right'),
  bottomLeft: (0,external_wp_i18n_namespaceObject.__)('Bottom left'),
  bottomRight: (0,external_wp_i18n_namespaceObject.__)('Bottom right')
};
function BoxInputControls({
  onChange,
  selectedUnits,
  setSelectedUnits,
  values: valuesProp,
  ...props
}) {
  const createHandleOnChange = corner => next => {
    if (!onChange) {
      return;
    } // Filter out CSS-unit-only values to prevent invalid styles.


    const isNumeric = !isNaN(parseFloat(next));
    const nextValue = isNumeric ? next : undefined;
    onChange({ ...values,
      [corner]: nextValue
    });
  };

  const createHandleOnUnitChange = side => next => {
    const newUnits = { ...selectedUnits
    };
    newUnits[side] = next;
    setSelectedUnits(newUnits);
  }; // For shorthand style & backwards compatibility, handle flat string value.


  const values = typeof valuesProp !== 'string' ? valuesProp : {
    topLeft: valuesProp,
    topRight: valuesProp,
    bottomLeft: valuesProp,
    bottomRight: valuesProp
  }; // Controls are wrapped in tooltips as visible labels aren't desired here.
  // Tooltip rendering also requires the UnitControl to be wrapped. See:
  // https://github.com/WordPress/gutenberg/pull/24966#issuecomment-685875026

  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "components-border-radius-control__input-controls-wrapper"
  }, Object.entries(CORNERS).map(([corner, label]) => {
    const [parsedQuantity, parsedUnit] = (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(values[corner]);
    const computedUnit = values[corner] ? parsedUnit : selectedUnits[corner] || selectedUnits.flat;
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Tooltip, {
      text: label,
      position: "top",
      key: corner
    }, (0,external_wp_element_namespaceObject.createElement)("div", {
      className: "components-border-radius-control__tooltip-wrapper"
    }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalUnitControl, { ...props,
      "aria-label": label,
      value: [parsedQuantity, computedUnit].join(''),
      onChange: createHandleOnChange(corner),
      onUnitChange: createHandleOnUnitChange(corner),
      size: '__unstable-large'
    })));
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/link.js


/**
 * WordPress dependencies
 */

const link_link = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M10 17.389H8.444A5.194 5.194 0 1 1 8.444 7H10v1.5H8.444a3.694 3.694 0 0 0 0 7.389H10v1.5ZM14 7h1.556a5.194 5.194 0 0 1 0 10.39H14v-1.5h1.556a3.694 3.694 0 0 0 0-7.39H14V7Zm-4.5 6h5v-1.5h-5V13Z"
}));
/* harmony default export */ var library_link = (link_link);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/link-off.js


/**
 * WordPress dependencies
 */

const linkOff = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M17.031 4.703 15.576 4l-1.56 3H14v.03l-2.324 4.47H9.5V13h1.396l-1.502 2.889h-.95a3.694 3.694 0 0 1 0-7.389H10V7H8.444a5.194 5.194 0 1 0 0 10.389h.17L7.5 19.53l1.416.719L15.049 8.5h.507a3.694 3.694 0 0 1 0 7.39H14v1.5h1.556a5.194 5.194 0 0 0 .273-10.383l1.202-2.304Z"
}));
/* harmony default export */ var link_off = (linkOff);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/border-radius-control/linked-button.js


/**
 * WordPress dependencies
 */



function LinkedButton({
  isLinked,
  ...props
}) {
  const label = isLinked ? (0,external_wp_i18n_namespaceObject.__)('Unlink radii') : (0,external_wp_i18n_namespaceObject.__)('Link radii'); // TODO: Remove span after merging https://github.com/WordPress/gutenberg/pull/44198

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Tooltip, {
    text: label
  }, (0,external_wp_element_namespaceObject.createElement)("span", null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, { ...props,
    className: "component-border-radius-control__linked-button",
    isSmall: true,
    icon: isLinked ? library_link : link_off,
    iconSize: 24,
    "aria-label": label
  })));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/border-radius-control/index.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */






const border_radius_control_DEFAULT_VALUES = {
  topLeft: undefined,
  topRight: undefined,
  bottomLeft: undefined,
  bottomRight: undefined
};
const MIN_BORDER_RADIUS_VALUE = 0;
const MAX_BORDER_RADIUS_VALUES = {
  px: 100,
  em: 20,
  rem: 20
};
/**
 * Control to display border radius options.
 *
 * @param {Object}   props          Component props.
 * @param {Function} props.onChange Callback to handle onChange.
 * @param {Object}   props.values   Border radius values.
 *
 * @return {WPElement}              Custom border radius control.
 */

function BorderRadiusControl({
  onChange,
  values
}) {
  const [isLinked, setIsLinked] = (0,external_wp_element_namespaceObject.useState)(!hasDefinedValues(values) || !hasMixedValues(values)); // Tracking selected units via internal state allows filtering of CSS unit
  // only values from being saved while maintaining preexisting unit selection
  // behaviour. Filtering CSS unit only values prevents invalid style values.

  const [selectedUnits, setSelectedUnits] = (0,external_wp_element_namespaceObject.useState)({
    flat: typeof values === 'string' ? (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(values)[1] : undefined,
    topLeft: (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(values?.topLeft)[1],
    topRight: (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(values?.topRight)[1],
    bottomLeft: (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(values?.bottomLeft)[1],
    bottomRight: (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(values?.bottomRight)[1]
  });
  const units = (0,external_wp_components_namespaceObject.__experimentalUseCustomUnits)({
    availableUnits: use_setting_useSetting('spacing.units') || ['px', 'em', 'rem']
  });
  const unit = getAllUnit(selectedUnits);
  const unitConfig = units && units.find(item => item.value === unit);
  const step = unitConfig?.step || 1;
  const [allValue] = (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(getAllValue(values));

  const toggleLinked = () => setIsLinked(!isLinked);

  const handleSliderChange = next => {
    onChange(next !== undefined ? `${next}${unit}` : undefined);
  };

  return (0,external_wp_element_namespaceObject.createElement)("fieldset", {
    className: "components-border-radius-control"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.BaseControl.VisualLabel, {
    as: "legend"
  }, (0,external_wp_i18n_namespaceObject.__)('Radius')), (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "components-border-radius-control__wrapper"
  }, isLinked ? (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(AllInputControl, {
    className: "components-border-radius-control__unit-control",
    values: values,
    min: MIN_BORDER_RADIUS_VALUE,
    onChange: onChange,
    selectedUnits: selectedUnits,
    setSelectedUnits: setSelectedUnits,
    units: units
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.RangeControl, {
    label: (0,external_wp_i18n_namespaceObject.__)('Border radius'),
    hideLabelFromVision: true,
    className: "components-border-radius-control__range-control",
    value: allValue !== null && allValue !== void 0 ? allValue : '',
    min: MIN_BORDER_RADIUS_VALUE,
    max: MAX_BORDER_RADIUS_VALUES[unit],
    initialPosition: 0,
    withInputField: false,
    onChange: handleSliderChange,
    step: step,
    __nextHasNoMarginBottom: true
  })) : (0,external_wp_element_namespaceObject.createElement)(BoxInputControls, {
    min: MIN_BORDER_RADIUS_VALUE,
    onChange: onChange,
    selectedUnits: selectedUnits,
    setSelectedUnits: setSelectedUnits,
    values: values || border_radius_control_DEFAULT_VALUES,
    units: units
  }), (0,external_wp_element_namespaceObject.createElement)(LinkedButton, {
    onClick: toggleLinked,
    isLinked: isLinked
  })));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/global-styles/border-panel.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




function useHasBorderPanel(settings) {
  const controls = [useHasBorderColorControl(settings), useHasBorderRadiusControl(settings), useHasBorderStyleControl(settings), useHasBorderWidthControl(settings)];
  return controls.some(Boolean);
}

function useHasBorderColorControl(settings) {
  return settings?.border?.color;
}

function useHasBorderRadiusControl(settings) {
  return settings?.border?.radius;
}

function useHasBorderStyleControl(settings) {
  return settings?.border?.style;
}

function useHasBorderWidthControl(settings) {
  return settings?.border?.width;
}

function BorderToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children
}) {
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanel, {
    label: (0,external_wp_i18n_namespaceObject.__)('Border'),
    resetAll: resetAll,
    panelId: panelId
  }, children);
}

const border_panel_DEFAULT_CONTROLS = {
  radius: true,
  color: true,
  width: true
};
function BorderPanel({
  as: Wrapper = BorderToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  defaultControls = border_panel_DEFAULT_CONTROLS
}) {
  const colors = useColorsPerOrigin(settings);

  const decodeValue = rawValue => getValueFromVariable({
    settings
  }, '', rawValue);

  const encodeColorValue = colorValue => {
    const allColors = colors.flatMap(({
      colors: originColors
    }) => originColors);
    const colorObject = allColors.find(({
      color
    }) => color === colorValue);
    return colorObject ? 'var:preset|color|' + colorObject.slug : colorValue;
  };

  const decodeColorValue = (0,external_wp_element_namespaceObject.useCallback)(colorValue => {
    const allColors = colors.flatMap(({
      colors: originColors
    }) => originColors);
    const colorObject = allColors.find(({
      slug
    }) => colorValue === 'var:preset|color|' + slug);
    return colorObject ? colorObject.color : colorValue;
  }, [colors]);
  const border = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if ((0,external_wp_components_namespaceObject.__experimentalHasSplitBorders)(inheritedValue?.border)) {
      const borderValue = { ...inheritedValue?.border
      };
      ['top', 'right', 'bottom', 'left'].forEach(side => {
        borderValue[side] = { ...borderValue[side],
          color: decodeColorValue(borderValue[side]?.color)
        };
      });
      return borderValue;
    }

    return { ...inheritedValue?.border,
      color: inheritedValue?.border?.color ? decodeColorValue(inheritedValue?.border?.color) : undefined
    };
  }, [inheritedValue?.border, decodeColorValue]);

  const setBorder = newBorder => onChange({ ...value,
    border: newBorder
  });

  const showBorderColor = useHasBorderColorControl(settings);
  const showBorderStyle = useHasBorderStyleControl(settings);
  const showBorderWidth = useHasBorderWidthControl(settings); // Border radius.

  const showBorderRadius = useHasBorderRadiusControl(settings);
  const borderRadiusValues = decodeValue(border?.radius);

  const setBorderRadius = newBorderRadius => setBorder({ ...border,
    radius: newBorderRadius
  });

  const hasBorderRadius = () => {
    const borderValues = value?.border?.radius;

    if (typeof borderValues === 'object') {
      return Object.entries(borderValues).some(Boolean);
    }

    return !!borderValues;
  };

  const resetBorder = () => {
    if (hasBorderRadius()) {
      return setBorder({
        radius: value?.border?.radius
      });
    }

    setBorder(undefined);
  };

  const onBorderChange = newBorder => {
    // Ensure we have a visible border style when a border width or
    // color is being selected.
    const updatedBorder = { ...newBorder
    };

    if ((0,external_wp_components_namespaceObject.__experimentalHasSplitBorders)(updatedBorder)) {
      ['top', 'right', 'bottom', 'left'].forEach(side => {
        if (updatedBorder[side]) {
          updatedBorder[side] = { ...updatedBorder[side],
            color: encodeColorValue(updatedBorder[side]?.color)
          };
        }
      });
    } else if (updatedBorder) {
      updatedBorder.color = encodeColorValue(updatedBorder.color);
    } // As radius is maintained separately to color, style, and width
    // maintain its value. Undefined values here will be cleaned when
    // global styles are saved.


    setBorder({
      radius: border?.radius,
      ...updatedBorder
    });
  };

  const resetAllFilter = (0,external_wp_element_namespaceObject.useCallback)(previousValue => {
    return { ...previousValue,
      border: undefined
    };
  }, []);
  const showBorderByDefault = defaultControls?.color || defaultControls?.width;
  return (0,external_wp_element_namespaceObject.createElement)(Wrapper, {
    resetAllFilter: resetAllFilter,
    value: value,
    onChange: onChange,
    panelId: panelId
  }, (showBorderWidth || showBorderColor) && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    hasValue: () => (0,external_wp_components_namespaceObject.__experimentalIsDefinedBorder)(value?.border),
    label: (0,external_wp_i18n_namespaceObject.__)('Border'),
    onDeselect: () => resetBorder(),
    isShownByDefault: showBorderByDefault,
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalBorderBoxControl, {
    colors: colors,
    enableAlpha: true,
    enableStyle: showBorderStyle,
    onChange: onBorderChange,
    popoverOffset: 40,
    popoverPlacement: "left-start",
    value: border,
    __experimentalIsRenderedInSidebar: true,
    size: '__unstable-large'
  })), showBorderRadius && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    hasValue: hasBorderRadius,
    label: (0,external_wp_i18n_namespaceObject.__)('Radius'),
    onDeselect: () => setBorderRadius(undefined),
    isShownByDefault: defaultControls.radius,
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(BorderRadiusControl, {
    values: borderRadiusValues,
    onChange: newValue => {
      setBorderRadius(newValue || undefined);
    }
  })));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/border.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */






const BORDER_SUPPORT_KEY = '__experimentalBorder';

const getColorByProperty = (colors, property, value) => {
  let matchedColor;
  colors.some(origin => origin.colors.some(color => {
    if (color[property] === value) {
      matchedColor = color;
      return true;
    }

    return false;
  }));
  return matchedColor;
};

const getMultiOriginColor = ({
  colors,
  namedColor,
  customColor
}) => {
  // Search each origin (default, theme, or user) for matching color by name.
  if (namedColor) {
    const colorObject = getColorByProperty(colors, 'slug', namedColor);

    if (colorObject) {
      return colorObject;
    }
  } // Skip if no custom color or matching named color.


  if (!customColor) {
    return {
      color: undefined
    };
  } // Attempt to find color via custom color value or build new object.


  const colorObject = getColorByProperty(colors, 'color', customColor);
  return colorObject ? colorObject : {
    color: customColor
  };
};

function getColorSlugFromVariable(value) {
  const namedColor = /var:preset\|color\|(.+)/.exec(value);

  if (namedColor && namedColor[1]) {
    return namedColor[1];
  }

  return null;
}

function styleToAttributes(style) {
  if ((0,external_wp_components_namespaceObject.__experimentalHasSplitBorders)(style?.border)) {
    return {
      style,
      borderColor: undefined
    };
  }

  const borderColorValue = style?.border?.color;
  const borderColorSlug = borderColorValue?.startsWith('var:preset|color|') ? borderColorValue.substring('var:preset|color|'.length) : undefined;
  const updatedStyle = { ...style
  };
  updatedStyle.border = { ...updatedStyle.border,
    color: borderColorSlug ? undefined : borderColorValue
  };
  return {
    style: utils_cleanEmptyObject(updatedStyle),
    borderColor: borderColorSlug
  };
}

function attributesToStyle(attributes) {
  if ((0,external_wp_components_namespaceObject.__experimentalHasSplitBorders)(attributes.style?.border)) {
    return attributes.style;
  }

  return { ...attributes.style,
    border: { ...attributes.style?.border,
      color: attributes.borderColor ? 'var:preset|color|' + attributes.borderColor : attributes.style?.border?.color
    }
  };
}

function BordersInspectorControl({
  children,
  resetAllFilter
}) {
  const attributesResetAllFilter = (0,external_wp_element_namespaceObject.useCallback)(attributes => {
    const existingStyle = attributesToStyle(attributes);
    const updatedStyle = resetAllFilter(existingStyle);
    return { ...attributes,
      ...styleToAttributes(updatedStyle)
    };
  }, [resetAllFilter]);
  return (0,external_wp_element_namespaceObject.createElement)(inspector_controls, {
    group: "border",
    resetAllFilter: attributesResetAllFilter
  }, children);
}

function border_BorderPanel(props) {
  const {
    clientId,
    name,
    attributes,
    setAttributes
  } = props;
  const settings = useBlockSettings(name);
  const isEnabled = useHasBorderPanel(settings);
  const value = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return attributesToStyle({
      style: attributes.style,
      borderColor: attributes.borderColor
    });
  }, [attributes.style, attributes.borderColor]);

  const onChange = newStyle => {
    setAttributes(styleToAttributes(newStyle));
  };

  if (!isEnabled) {
    return null;
  }

  const defaultControls = (0,external_wp_blocks_namespaceObject.getBlockSupport)(props.name, [BORDER_SUPPORT_KEY, '__experimentalDefaultControls']);
  return (0,external_wp_element_namespaceObject.createElement)(BorderPanel, {
    as: BordersInspectorControl,
    panelId: clientId,
    settings: settings,
    value: value,
    onChange: onChange,
    defaultControls: defaultControls
  });
}
/**
 * Determine whether there is block support for border properties.
 *
 * @param {string} blockName Block name.
 * @param {string} feature   Border feature to check support for.
 *
 * @return {boolean} Whether there is support.
 */

function hasBorderSupport(blockName, feature = 'any') {
  if (external_wp_element_namespaceObject.Platform.OS !== 'web') {
    return false;
  }

  const support = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockName, BORDER_SUPPORT_KEY);

  if (support === true) {
    return true;
  }

  if (feature === 'any') {
    return !!(support?.color || support?.radius || support?.width || support?.style);
  }

  return !!support?.[feature];
}
/**
 * Returns a new style object where the specified border attribute has been
 * removed.
 *
 * @param {Object} style     Styles from block attributes.
 * @param {string} attribute The border style attribute to clear.
 *
 * @return {Object} Style object with the specified attribute removed.
 */

function removeBorderAttribute(style, attribute) {
  return cleanEmptyObject({ ...style,
    border: { ...style?.border,
      [attribute]: undefined
    }
  });
}
/**
 * Filters registered block settings, extending attributes to include
 * `borderColor` if needed.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Updated block settings.
 */

function addAttributes(settings) {
  if (!hasBorderSupport(settings, 'color')) {
    return settings;
  } // Allow blocks to specify default value if needed.


  if (settings.attributes.borderColor) {
    return settings;
  } // Add new borderColor attribute to block settings.


  return { ...settings,
    attributes: { ...settings.attributes,
      borderColor: {
        type: 'string'
      }
    }
  };
}
/**
 * Override props assigned to save component to inject border color.
 *
 * @param {Object} props      Additional props applied to save element.
 * @param {Object} blockType  Block type definition.
 * @param {Object} attributes Block's attributes.
 *
 * @return {Object} Filtered props to apply to save element.
 */


function border_addSaveProps(props, blockType, attributes) {
  if (!hasBorderSupport(blockType, 'color') || shouldSkipSerialization(blockType, BORDER_SUPPORT_KEY, 'color')) {
    return props;
  }

  const borderClasses = getBorderClasses(attributes);
  const newClassName = classnames_default()(props.className, borderClasses); // If we are clearing the last of the previous classes in `className`
  // set it to `undefined` to avoid rendering empty DOM attributes.

  props.className = newClassName ? newClassName : undefined;
  return props;
}
/**
 * Generates a CSS class name consisting of all the applicable border color
 * classes given the current block attributes.
 *
 * @param {Object} attributes Block's attributes.
 *
 * @return {string} CSS class name.
 */


function getBorderClasses(attributes) {
  const {
    borderColor,
    style
  } = attributes;
  const borderColorClass = getColorClassName('border-color', borderColor);
  return classnames_default()({
    'has-border-color': borderColor || style?.border?.color,
    [borderColorClass]: !!borderColorClass
  });
}
/**
 * Filters the registered block settings to apply border color styles and
 * classnames to the block edit wrapper.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function addEditProps(settings) {
  if (!hasBorderSupport(settings, 'color') || shouldSkipSerialization(settings, BORDER_SUPPORT_KEY, 'color')) {
    return settings;
  }

  const existingGetEditWrapperProps = settings.getEditWrapperProps;

  settings.getEditWrapperProps = attributes => {
    let props = {};

    if (existingGetEditWrapperProps) {
      props = existingGetEditWrapperProps(attributes);
    }

    return border_addSaveProps(props, settings, attributes);
  };

  return settings;
}
/**
 * This adds inline styles for color palette colors.
 * Ideally, this is not needed and themes should load their palettes on the editor.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */


const withBorderColorPaletteStyles = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(BlockListBlock => props => {
  const {
    name,
    attributes
  } = props;
  const {
    borderColor,
    style
  } = attributes;
  const {
    colors
  } = useMultipleOriginColorsAndGradients();

  if (!hasBorderSupport(name, 'color') || shouldSkipSerialization(name, BORDER_SUPPORT_KEY, 'color')) {
    return (0,external_wp_element_namespaceObject.createElement)(BlockListBlock, { ...props
    });
  }

  const {
    color: borderColorValue
  } = getMultiOriginColor({
    colors,
    namedColor: borderColor
  });
  const {
    color: borderTopColor
  } = getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style?.border?.top?.color)
  });
  const {
    color: borderRightColor
  } = getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style?.border?.right?.color)
  });
  const {
    color: borderBottomColor
  } = getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style?.border?.bottom?.color)
  });
  const {
    color: borderLeftColor
  } = getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style?.border?.left?.color)
  });
  const extraStyles = {
    borderTopColor: borderTopColor || borderColorValue,
    borderRightColor: borderRightColor || borderColorValue,
    borderBottomColor: borderBottomColor || borderColorValue,
    borderLeftColor: borderLeftColor || borderColorValue
  };
  let wrapperProps = props.wrapperProps;
  wrapperProps = { ...props.wrapperProps,
    style: { ...props.wrapperProps?.style,
      ...extraStyles
    }
  };
  return (0,external_wp_element_namespaceObject.createElement)(BlockListBlock, { ...props,
    wrapperProps: wrapperProps
  });
}, 'withBorderColorPaletteStyles');
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/border/addAttributes', addAttributes);
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.getSaveContent.extraProps', 'core/border/addSaveProps', border_addSaveProps);
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/border/addEditProps', addEditProps);
(0,external_wp_hooks_namespaceObject.addFilter)('editor.BlockListBlock', 'core/border/with-border-color-palette-styles', withBorderColorPaletteStyles);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/gradients/use-gradient.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function __experimentalGetGradientClass(gradientSlug) {
  if (!gradientSlug) {
    return undefined;
  }

  return `has-${gradientSlug}-gradient-background`;
}
/**
 * Retrieves the gradient value per slug.
 *
 * @param {Array}  gradients Gradient Palette
 * @param {string} slug      Gradient slug
 *
 * @return {string} Gradient value.
 */

function getGradientValueBySlug(gradients, slug) {
  const gradient = gradients?.find(g => g.slug === slug);
  return gradient && gradient.gradient;
}
function __experimentalGetGradientObjectByGradientValue(gradients, value) {
  const gradient = gradients?.find(g => g.gradient === value);
  return gradient;
}
/**
 * Retrieves the gradient slug per slug.
 *
 * @param {Array}  gradients Gradient Palette
 * @param {string} value     Gradient value
 * @return {string} Gradient slug.
 */

function getGradientSlugByValue(gradients, value) {
  const gradient = __experimentalGetGradientObjectByGradientValue(gradients, value);

  return gradient && gradient.slug;
}
function __experimentalUseGradient({
  gradientAttribute = 'gradient',
  customGradientAttribute = 'customGradient'
} = {}) {
  const {
    clientId
  } = useBlockEditContext();
  const userGradientPalette = use_setting_useSetting('color.gradients.custom');
  const themeGradientPalette = use_setting_useSetting('color.gradients.theme');
  const defaultGradientPalette = use_setting_useSetting('color.gradients.default');
  const allGradients = (0,external_wp_element_namespaceObject.useMemo)(() => [...(userGradientPalette || []), ...(themeGradientPalette || []), ...(defaultGradientPalette || [])], [userGradientPalette, themeGradientPalette, defaultGradientPalette]);
  const {
    gradient,
    customGradient
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockAttributes
    } = select(store);
    const attributes = getBlockAttributes(clientId) || {};
    return {
      customGradient: attributes[customGradientAttribute],
      gradient: attributes[gradientAttribute]
    };
  }, [clientId, gradientAttribute, customGradientAttribute]);
  const {
    updateBlockAttributes
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const setGradient = (0,external_wp_element_namespaceObject.useCallback)(newGradientValue => {
    const slug = getGradientSlugByValue(allGradients, newGradientValue);

    if (slug) {
      updateBlockAttributes(clientId, {
        [gradientAttribute]: slug,
        [customGradientAttribute]: undefined
      });
      return;
    }

    updateBlockAttributes(clientId, {
      [gradientAttribute]: undefined,
      [customGradientAttribute]: newGradientValue
    });
  }, [allGradients, clientId, updateBlockAttributes]);

  const gradientClass = __experimentalGetGradientClass(gradient);

  let gradientValue;

  if (gradient) {
    gradientValue = getGradientValueBySlug(allGradients, gradient);
  } else {
    gradientValue = customGradient;
  }

  return {
    gradientClass,
    gradientValue,
    setGradient
  };
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/colors-gradients/control.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


const colorsAndGradientKeys = ['colors', 'disableCustomColors', 'gradients', 'disableCustomGradients'];
const TAB_COLOR = {
  name: 'color',
  title: (0,external_wp_i18n_namespaceObject.__)('Solid'),
  value: 'color'
};
const TAB_GRADIENT = {
  name: 'gradient',
  title: (0,external_wp_i18n_namespaceObject.__)('Gradient'),
  value: 'gradient'
};
const TABS_SETTINGS = [TAB_COLOR, TAB_GRADIENT];

function ColorGradientControlInner({
  colors,
  gradients,
  disableCustomColors,
  disableCustomGradients,
  __experimentalIsRenderedInSidebar,
  className,
  label,
  onColorChange,
  onGradientChange,
  colorValue,
  gradientValue,
  clearable,
  showTitle = true,
  enableAlpha,
  headingLevel
}) {
  const canChooseAColor = onColorChange && (colors && colors.length > 0 || !disableCustomColors);
  const canChooseAGradient = onGradientChange && (gradients && gradients.length > 0 || !disableCustomGradients);

  if (!canChooseAColor && !canChooseAGradient) {
    return null;
  }

  const tabPanels = {
    [TAB_COLOR.value]: (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ColorPalette, {
      value: colorValue,
      onChange: canChooseAGradient ? newColor => {
        onColorChange(newColor);
        onGradientChange();
      } : onColorChange,
      colors,
      disableCustomColors,
      __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
      clearable: clearable,
      enableAlpha: enableAlpha,
      headingLevel: headingLevel
    }),
    [TAB_GRADIENT.value]: (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.GradientPicker, {
      __nextHasNoMargin: true,
      value: gradientValue,
      onChange: canChooseAColor ? newGradient => {
        onGradientChange(newGradient);
        onColorChange();
      } : onGradientChange,
      gradients,
      disableCustomGradients,
      __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
      clearable: clearable,
      headingLevel: headingLevel
    })
  };

  const renderPanelType = type => (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-color-gradient-control__panel"
  }, tabPanels[type]);

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.BaseControl, {
    __nextHasNoMarginBottom: true,
    className: classnames_default()('block-editor-color-gradient-control', className)
  }, (0,external_wp_element_namespaceObject.createElement)("fieldset", {
    className: "block-editor-color-gradient-control__fieldset"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalVStack, {
    spacing: 1
  }, showTitle && (0,external_wp_element_namespaceObject.createElement)("legend", null, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-color-gradient-control__color-indicator"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.BaseControl.VisualLabel, null, label))), canChooseAColor && canChooseAGradient && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.TabPanel, {
    className: "block-editor-color-gradient-control__tabs",
    tabs: TABS_SETTINGS,
    initialTabName: gradientValue ? TAB_GRADIENT.value : !!canChooseAColor && TAB_COLOR.value
  }, tab => renderPanelType(tab.value)), !canChooseAGradient && renderPanelType(TAB_COLOR.value), !canChooseAColor && renderPanelType(TAB_GRADIENT.value))));
}

function ColorGradientControlSelect(props) {
  const colorGradientSettings = {};
  colorGradientSettings.colors = use_setting_useSetting('color.palette');
  colorGradientSettings.gradients = use_setting_useSetting('color.gradients');
  colorGradientSettings.disableCustomColors = !use_setting_useSetting('color.custom');
  colorGradientSettings.disableCustomGradients = !use_setting_useSetting('color.customGradient');
  return (0,external_wp_element_namespaceObject.createElement)(ColorGradientControlInner, { ...colorGradientSettings,
    ...props
  });
}

function ColorGradientControl(props) {
  if (colorsAndGradientKeys.every(key => props.hasOwnProperty(key))) {
    return (0,external_wp_element_namespaceObject.createElement)(ColorGradientControlInner, { ...props
    });
  }

  return (0,external_wp_element_namespaceObject.createElement)(ColorGradientControlSelect, { ...props
  });
}

/* harmony default export */ var control = (ColorGradientControl);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/global-styles/color-panel.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





function useHasColorPanel(settings) {
  const hasTextPanel = useHasTextPanel(settings);
  const hasBackgroundPanel = useHasBackgroundPanel(settings);
  const hasLinkPanel = useHasLinkPanel(settings);
  const hasHeadingPanel = useHasHeadingPanel(settings);
  const hasButtonPanel = useHasHeadingPanel(settings);
  const hasCaptionPanel = useHasCaptionPanel(settings);
  return hasTextPanel || hasBackgroundPanel || hasLinkPanel || hasHeadingPanel || hasButtonPanel || hasCaptionPanel;
}
function useHasTextPanel(settings) {
  const colors = useColorsPerOrigin(settings);
  return settings?.color?.text && (colors?.length > 0 || settings?.color?.custom);
}
function useHasLinkPanel(settings) {
  const colors = useColorsPerOrigin(settings);
  return settings?.color?.link && (colors?.length > 0 || settings?.color?.custom);
}
function useHasCaptionPanel(settings) {
  const colors = useColorsPerOrigin(settings);
  return settings?.color?.caption && (colors?.length > 0 || settings?.color?.custom);
}
function useHasHeadingPanel(settings) {
  const colors = useColorsPerOrigin(settings);
  const gradients = useGradientsPerOrigin(settings);
  return settings?.color?.heading && (colors?.length > 0 || settings?.color?.custom || gradients?.length > 0 || settings?.color?.customGradient);
}
function useHasButtonPanel(settings) {
  const colors = useColorsPerOrigin(settings);
  const gradients = useGradientsPerOrigin(settings);
  return settings?.color?.button && (colors?.length > 0 || settings?.color?.custom || gradients?.length > 0 || settings?.color?.customGradient);
}
function useHasBackgroundPanel(settings) {
  const colors = useColorsPerOrigin(settings);
  const gradients = useGradientsPerOrigin(settings);
  return settings?.color?.background && (colors?.length > 0 || settings?.color?.custom || gradients?.length > 0 || settings?.color?.customGradient);
}

function ColorToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children
}) {
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanel, {
    label: (0,external_wp_i18n_namespaceObject.__)('Color'),
    resetAll: resetAll,
    panelId: panelId,
    hasInnerWrapper: true,
    className: "color-block-support-panel",
    __experimentalFirstVisibleItemClass: "first",
    __experimentalLastVisibleItemClass: "last"
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "color-block-support-panel__inner-wrapper"
  }, children));
}

const color_panel_DEFAULT_CONTROLS = {
  text: true,
  background: true,
  link: true,
  heading: true,
  button: true,
  caption: true
};
const popoverProps = {
  placement: 'left-start',
  offset: 36,
  shift: true
};

const LabeledColorIndicators = ({
  indicators,
  label
}) => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHStack, {
  justify: "flex-start"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalZStack, {
  isLayered: false,
  offset: -8
}, indicators.map((indicator, index) => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Flex, {
  key: index,
  expanded: false
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ColorIndicator, {
  colorValue: indicator
})))), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, {
  className: "block-editor-panel-color-gradient-settings__color-name",
  title: label
}, label));

function ColorPanelTab({
  isGradient,
  inheritedValue,
  userValue,
  setValue,
  colorGradientControlSettings
}) {
  return (0,external_wp_element_namespaceObject.createElement)(control, { ...colorGradientControlSettings,
    showTitle: false,
    enableAlpha: true,
    __experimentalIsRenderedInSidebar: true,
    colorValue: isGradient ? undefined : inheritedValue,
    gradientValue: isGradient ? inheritedValue : undefined,
    onColorChange: isGradient ? undefined : setValue,
    onGradientChange: isGradient ? setValue : undefined,
    clearable: inheritedValue === userValue,
    headingLevel: 3
  });
}

function ColorPanelDropdown({
  label,
  hasValue,
  resetValue,
  isShownByDefault,
  indicators,
  tabs,
  colorGradientControlSettings,
  panelId
}) {
  const tabConfigs = tabs.map(({
    key,
    label: tabLabel
  }) => {
    return {
      name: key,
      title: tabLabel
    };
  });
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    className: "block-editor-tools-panel-color-gradient-settings__item",
    hasValue: hasValue,
    label: label,
    onDeselect: resetValue,
    isShownByDefault: isShownByDefault,
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Dropdown, {
    popoverProps: popoverProps,
    className: "block-editor-tools-panel-color-gradient-settings__dropdown",
    renderToggle: ({
      onToggle,
      isOpen
    }) => {
      const toggleProps = {
        onClick: onToggle,
        className: classnames_default()('block-editor-panel-color-gradient-settings__dropdown', {
          'is-open': isOpen
        }),
        'aria-expanded': isOpen,
        'aria-label': (0,external_wp_i18n_namespaceObject.sprintf)(
        /* translators: %s is the type of color property, e.g., "background" */
        (0,external_wp_i18n_namespaceObject.__)('Color %s styles'), label)
      };
      return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, { ...toggleProps
      }, (0,external_wp_element_namespaceObject.createElement)(LabeledColorIndicators, {
        indicators: indicators,
        label: label
      }));
    },
    renderContent: () => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalDropdownContentWrapper, {
      paddingSize: "none"
    }, (0,external_wp_element_namespaceObject.createElement)("div", {
      className: "block-editor-panel-color-gradient-settings__dropdown-content"
    }, tabs.length === 1 && (0,external_wp_element_namespaceObject.createElement)(ColorPanelTab, { ...tabs[0],
      colorGradientControlSettings: colorGradientControlSettings
    }), tabs.length > 1 && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.TabPanel, {
      tabs: tabConfigs
    }, tab => {
      const selectedTab = tabs.find(t => t.key === tab.name);

      if (!selectedTab) {
        return null;
      }

      return (0,external_wp_element_namespaceObject.createElement)(ColorPanelTab, { ...selectedTab,
        colorGradientControlSettings: colorGradientControlSettings
      });
    })))
  }));
}

function ColorPanel({
  as: Wrapper = ColorToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  defaultControls = color_panel_DEFAULT_CONTROLS,
  children
}) {
  const colors = useColorsPerOrigin(settings);
  const gradients = useGradientsPerOrigin(settings);
  const areCustomSolidsEnabled = settings?.color?.custom;
  const areCustomGradientsEnabled = settings?.color?.customGradient;
  const hasSolidColors = colors.length > 0 || areCustomSolidsEnabled;
  const hasGradientColors = gradients.length > 0 || areCustomGradientsEnabled;

  const decodeValue = rawValue => getValueFromVariable({
    settings
  }, '', rawValue);

  const encodeColorValue = colorValue => {
    const allColors = colors.flatMap(({
      colors: originColors
    }) => originColors);
    const colorObject = allColors.find(({
      color
    }) => color === colorValue);
    return colorObject ? 'var:preset|color|' + colorObject.slug : colorValue;
  };

  const encodeGradientValue = gradientValue => {
    const allGradients = gradients.flatMap(({
      gradients: originGradients
    }) => originGradients);
    const gradientObject = allGradients.find(({
      gradient
    }) => gradient === gradientValue);
    return gradientObject ? 'var:preset|gradient|' + gradientObject.slug : gradientValue;
  }; // Text Color


  const showTextPanel = useHasTextPanel(settings);
  const textColor = decodeValue(inheritedValue?.color?.text);
  const userTextColor = decodeValue(value?.color?.text);

  const hasTextColor = () => !!userTextColor;

  const setTextColor = newColor => {
    onChange(setImmutably(value, ['color', 'text'], encodeColorValue(newColor)));
  };

  const resetTextColor = () => setTextColor(undefined); // BackgroundColor


  const showBackgroundPanel = useHasBackgroundPanel(settings);
  const backgroundColor = decodeValue(inheritedValue?.color?.background);
  const userBackgroundColor = decodeValue(value?.color?.background);
  const gradient = decodeValue(inheritedValue?.color?.gradient);
  const userGradient = decodeValue(value?.color?.gradient);

  const hasBackground = () => !!userBackgroundColor || !!userGradient;

  const setBackgroundColor = newColor => {
    const newValue = setImmutably(value, ['color', 'background'], encodeColorValue(newColor));
    newValue.color.gradient = undefined;
    onChange(newValue);
  };

  const setGradient = newGradient => {
    const newValue = setImmutably(value, ['color', 'gradient'], encodeGradientValue(newGradient));
    newValue.color.background = undefined;
    onChange(newValue);
  };

  const resetBackground = () => {
    const newValue = setImmutably(value, ['color', 'background'], undefined);
    newValue.color.gradient = undefined;
    onChange(newValue);
  }; // Links


  const showLinkPanel = useHasLinkPanel(settings);
  const linkColor = decodeValue(inheritedValue?.elements?.link?.color?.text);
  const userLinkColor = decodeValue(value?.elements?.link?.color?.text);

  const setLinkColor = newColor => {
    onChange(setImmutably(value, ['elements', 'link', 'color', 'text'], encodeColorValue(newColor)));
  };

  const hoverLinkColor = decodeValue(inheritedValue?.elements?.link?.[':hover']?.color?.text);
  const userHoverLinkColor = decodeValue(value?.elements?.link?.[':hover']?.color?.text);

  const setHoverLinkColor = newColor => {
    onChange(setImmutably(value, ['elements', 'link', ':hover', 'color', 'text'], encodeColorValue(newColor)));
  };

  const hasLink = () => !!userLinkColor || !!userHoverLinkColor;

  const resetLink = () => {
    let newValue = setImmutably(value, ['elements', 'link', ':hover', 'color', 'text'], undefined);
    newValue = setImmutably(newValue, ['elements', 'link', 'color', 'text'], undefined);
    onChange(newValue);
  }; // Elements


  const elements = [{
    name: 'caption',
    label: (0,external_wp_i18n_namespaceObject.__)('Captions'),
    showPanel: useHasCaptionPanel(settings)
  }, {
    name: 'button',
    label: (0,external_wp_i18n_namespaceObject.__)('Button'),
    showPanel: useHasButtonPanel(settings)
  }, {
    name: 'heading',
    label: (0,external_wp_i18n_namespaceObject.__)('Heading'),
    showPanel: useHasHeadingPanel(settings)
  }, {
    name: 'h1',
    label: (0,external_wp_i18n_namespaceObject.__)('H1'),
    showPanel: useHasHeadingPanel(settings)
  }, {
    name: 'h2',
    label: (0,external_wp_i18n_namespaceObject.__)('H2'),
    showPanel: useHasHeadingPanel(settings)
  }, {
    name: 'h3',
    label: (0,external_wp_i18n_namespaceObject.__)('H3'),
    showPanel: useHasHeadingPanel(settings)
  }, {
    name: 'h4',
    label: (0,external_wp_i18n_namespaceObject.__)('H4'),
    showPanel: useHasHeadingPanel(settings)
  }, {
    name: 'h5',
    label: (0,external_wp_i18n_namespaceObject.__)('H5'),
    showPanel: useHasHeadingPanel(settings)
  }, {
    name: 'h6',
    label: (0,external_wp_i18n_namespaceObject.__)('H6'),
    showPanel: useHasHeadingPanel(settings)
  }];
  const resetAllFilter = (0,external_wp_element_namespaceObject.useCallback)(previousValue => {
    return { ...previousValue,
      color: undefined,
      elements: { ...previousValue?.elements,
        link: { ...previousValue?.elements?.link,
          color: undefined,
          ':hover': {
            color: undefined
          }
        },
        ...elements.reduce((acc, element) => {
          return { ...acc,
            [element.name]: { ...previousValue?.elements?.[element.name],
              color: undefined
            }
          };
        }, {})
      }
    };
  }, []);
  const items = [showTextPanel && {
    key: 'text',
    label: (0,external_wp_i18n_namespaceObject.__)('Text'),
    hasValue: hasTextColor,
    resetValue: resetTextColor,
    isShownByDefault: defaultControls.text,
    indicators: [textColor],
    tabs: [{
      key: 'text',
      label: (0,external_wp_i18n_namespaceObject.__)('Text'),
      inheritedValue: textColor,
      setValue: setTextColor,
      userValue: userTextColor
    }]
  }, showBackgroundPanel && {
    key: 'background',
    label: (0,external_wp_i18n_namespaceObject.__)('Background'),
    hasValue: hasBackground,
    resetValue: resetBackground,
    isShownByDefault: defaultControls.background,
    indicators: [gradient !== null && gradient !== void 0 ? gradient : backgroundColor],
    tabs: [hasSolidColors && {
      key: 'background',
      label: (0,external_wp_i18n_namespaceObject.__)('Solid'),
      inheritedValue: backgroundColor,
      setValue: setBackgroundColor,
      userValue: userBackgroundColor
    }, hasGradientColors && {
      key: 'gradient',
      label: (0,external_wp_i18n_namespaceObject.__)('Gradient'),
      inheritedValue: gradient,
      setValue: setGradient,
      userValue: userGradient,
      isGradient: true
    }].filter(Boolean)
  }, showLinkPanel && {
    key: 'link',
    label: (0,external_wp_i18n_namespaceObject.__)('Link'),
    hasValue: hasLink,
    resetValue: resetLink,
    isShownByDefault: defaultControls.link,
    indicators: [linkColor, hoverLinkColor],
    tabs: [{
      key: 'link',
      label: (0,external_wp_i18n_namespaceObject.__)('Default'),
      inheritedValue: linkColor,
      setValue: setLinkColor,
      userValue: userLinkColor
    }, {
      key: 'hover',
      label: (0,external_wp_i18n_namespaceObject.__)('Hover'),
      inheritedValue: hoverLinkColor,
      setValue: setHoverLinkColor,
      userValue: userHoverLinkColor
    }]
  }].filter(Boolean);
  elements.forEach(({
    name,
    label,
    showPanel
  }) => {
    if (!showPanel) return;
    const elementBackgroundColor = decodeValue(inheritedValue?.elements?.[name]?.color?.background);
    const elementGradient = decodeValue(inheritedValue?.elements?.[name]?.color?.gradient);
    const elementTextColor = decodeValue(inheritedValue?.elements?.[name]?.color?.text);
    const elementBackgroundUserColor = decodeValue(value?.elements?.[name]?.color?.background);
    const elementGradientUserColor = decodeValue(value?.elements?.[name]?.color?.gradient);
    const elementTextUserColor = decodeValue(value?.elements?.[name]?.color?.text);

    const hasElement = () => !!(elementTextUserColor || elementBackgroundUserColor || elementGradientUserColor);

    const resetElement = () => {
      const newValue = setImmutably(value, ['elements', name, 'color', 'background'], undefined);
      newValue.elements[name].color.gradient = undefined;
      newValue.elements[name].color.text = undefined;
      onChange(newValue);
    };

    const setElementTextColor = newTextColor => {
      onChange(setImmutably(value, ['elements', name, 'color', 'text'], encodeColorValue(newTextColor)));
    };

    const setElementBackgroundColor = newBackgroundColor => {
      const newValue = setImmutably(value, ['elements', name, 'color', 'background'], encodeColorValue(newBackgroundColor));
      newValue.elements[name].color.gradient = undefined;
      onChange(newValue);
    };

    const setElementGradient = newGradient => {
      const newValue = setImmutably(value, ['elements', name, 'color', 'gradient'], encodeGradientValue(newGradient));
      newValue.elements[name].color.background = undefined;
      onChange(newValue);
    };

    const supportsTextColor = true; // Background color is not supported for `caption`
    // as there isn't yet a way to set padding for the element.

    const supportsBackground = name !== 'caption';
    items.push({
      key: name,
      label,
      hasValue: hasElement,
      resetValue: resetElement,
      isShownByDefault: defaultControls[name],
      indicators: supportsTextColor && supportsBackground ? [elementTextColor, elementGradient !== null && elementGradient !== void 0 ? elementGradient : elementBackgroundColor] : [supportsTextColor ? elementTextColor : elementGradient !== null && elementGradient !== void 0 ? elementGradient : elementBackgroundColor],
      tabs: [hasSolidColors && supportsTextColor && {
        key: 'text',
        label: (0,external_wp_i18n_namespaceObject.__)('Text'),
        inheritedValue: elementTextColor,
        setValue: setElementTextColor,
        userValue: elementTextUserColor
      }, hasSolidColors && supportsBackground && {
        key: 'background',
        label: (0,external_wp_i18n_namespaceObject.__)('Background'),
        inheritedValue: elementBackgroundColor,
        setValue: setElementBackgroundColor,
        userValue: elementBackgroundUserColor
      }, hasGradientColors && supportsBackground && {
        key: 'gradient',
        label: (0,external_wp_i18n_namespaceObject.__)('Gradient'),
        inheritedValue: elementGradient,
        setValue: setElementGradient,
        userValue: elementGradientUserColor,
        isGradient: true
      }].filter(Boolean)
    });
  });
  return (0,external_wp_element_namespaceObject.createElement)(Wrapper, {
    resetAllFilter: resetAllFilter,
    value: value,
    onChange: onChange,
    panelId: panelId
  }, items.map(item => (0,external_wp_element_namespaceObject.createElement)(ColorPanelDropdown, {
    key: item.key,
    ...item,
    colorGradientControlSettings: {
      colors,
      disableCustomColors: !areCustomSolidsEnabled,
      gradients,
      disableCustomGradients: !areCustomGradientsEnabled
    },
    panelId: panelId
  })), children);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/contrast-checker/index.js


/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */




k([names, a11y]);

function ContrastChecker({
  backgroundColor,
  fallbackBackgroundColor,
  fallbackTextColor,
  fallbackLinkColor,
  fontSize,
  // Font size value in pixels.
  isLargeText,
  textColor,
  linkColor,
  enableAlphaChecker = false
}) {
  const currentBackgroundColor = backgroundColor || fallbackBackgroundColor; // Must have a background color.

  if (!currentBackgroundColor) {
    return null;
  }

  const currentTextColor = textColor || fallbackTextColor;
  const currentLinkColor = linkColor || fallbackLinkColor; // Must have at least one text color.

  if (!currentTextColor && !currentLinkColor) {
    return null;
  }

  const textColors = [{
    color: currentTextColor,
    description: (0,external_wp_i18n_namespaceObject.__)('text color')
  }, {
    color: currentLinkColor,
    description: (0,external_wp_i18n_namespaceObject.__)('link color')
  }];
  const colordBackgroundColor = w(currentBackgroundColor);
  const backgroundColorHasTransparency = colordBackgroundColor.alpha() < 1;
  const backgroundColorBrightness = colordBackgroundColor.brightness();
  const isReadableOptions = {
    level: 'AA',
    size: isLargeText || isLargeText !== false && fontSize >= 24 ? 'large' : 'small'
  };
  let message = '';
  let speakMessage = '';

  for (const item of textColors) {
    // If there is no color, go no further.
    if (!item.color) {
      continue;
    }

    const colordTextColor = w(item.color);
    const isColordTextReadable = colordTextColor.isReadable(colordBackgroundColor, isReadableOptions);
    const textHasTransparency = colordTextColor.alpha() < 1; // If the contrast is not readable.

    if (!isColordTextReadable) {
      // Don't show the message if the background or text is transparent.
      if (backgroundColorHasTransparency || textHasTransparency) {
        continue;
      }

      message = backgroundColorBrightness < colordTextColor.brightness() ? (0,external_wp_i18n_namespaceObject.sprintf)( // translators: %s is a type of text color, e.g., "text color" or "link color".
      (0,external_wp_i18n_namespaceObject.__)('This color combination may be hard for people to read. Try using a darker background color and/or a brighter %s.'), item.description) : (0,external_wp_i18n_namespaceObject.sprintf)( // translators: %s is a type of text color, e.g., "text color" or "link color".
      (0,external_wp_i18n_namespaceObject.__)('This color combination may be hard for people to read. Try using a brighter background color and/or a darker %s.'), item.description);
      speakMessage = (0,external_wp_i18n_namespaceObject.__)('This color combination may be hard for people to read.'); // Break from the loop when we have a contrast warning.
      // These messages take priority over the transparency warning.

      break;
    } // If there is no contrast warning and the text is transparent,
    // show the transparent warning if alpha check is enabled.


    if (textHasTransparency && enableAlphaChecker) {
      message = (0,external_wp_i18n_namespaceObject.__)('Transparent text may be hard for people to read.');
      speakMessage = (0,external_wp_i18n_namespaceObject.__)('Transparent text may be hard for people to read.');
    }
  }

  if (!message) {
    return null;
  } // Note: The `Notice` component can speak messages via its `spokenMessage`
  // prop, but the contrast checker requires granular control over when the
  // announcements are made. Notably, the message will be re-announced if a
  // new color combination is selected and the contrast is still insufficient.


  (0,external_wp_a11y_namespaceObject.speak)(speakMessage);
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-contrast-checker"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Notice, {
    spokenMessage: null,
    status: "warning",
    isDismissible: false
  }, message));
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/contrast-checker/README.md
 */


/* harmony default export */ var contrast_checker = (ContrastChecker);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/contrast-checker.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




function getComputedStyle(node) {
  return node.ownerDocument.defaultView.getComputedStyle(node);
}

function BlockColorContrastChecker({
  clientId
}) {
  const [detectedBackgroundColor, setDetectedBackgroundColor] = (0,external_wp_element_namespaceObject.useState)();
  const [detectedColor, setDetectedColor] = (0,external_wp_element_namespaceObject.useState)();
  const [detectedLinkColor, setDetectedLinkColor] = (0,external_wp_element_namespaceObject.useState)();
  const ref = useBlockRef(clientId); // There are so many things that can change the color of a block
  // So we perform this check on every render.
  // eslint-disable-next-line react-hooks/exhaustive-deps

  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!ref.current) {
      return;
    }

    setDetectedColor(getComputedStyle(ref.current).color);
    const firstLinkElement = ref.current?.querySelector('a');

    if (firstLinkElement && !!firstLinkElement.innerText) {
      setDetectedLinkColor(getComputedStyle(firstLinkElement).color);
    }

    let backgroundColorNode = ref.current;
    let backgroundColor = getComputedStyle(backgroundColorNode).backgroundColor;

    while (backgroundColor === 'rgba(0, 0, 0, 0)' && backgroundColorNode.parentNode && backgroundColorNode.parentNode.nodeType === backgroundColorNode.parentNode.ELEMENT_NODE) {
      backgroundColorNode = backgroundColorNode.parentNode;
      backgroundColor = getComputedStyle(backgroundColorNode).backgroundColor;
    }

    setDetectedBackgroundColor(backgroundColor);
  });
  return (0,external_wp_element_namespaceObject.createElement)(contrast_checker, {
    backgroundColor: detectedBackgroundColor,
    textColor: detectedColor,
    enableAlphaChecker: true,
    linkColor: detectedLinkColor
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/color.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */








const COLOR_SUPPORT_KEY = 'color';

const hasColorSupport = blockType => {
  const colorSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, COLOR_SUPPORT_KEY);
  return colorSupport && (colorSupport.link === true || colorSupport.gradient === true || colorSupport.background !== false || colorSupport.text !== false);
};

const hasLinkColorSupport = blockType => {
  if (external_wp_element_namespaceObject.Platform.OS !== 'web') {
    return false;
  }

  const colorSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, COLOR_SUPPORT_KEY);
  return colorSupport !== null && typeof colorSupport === 'object' && !!colorSupport.link;
};

const hasGradientSupport = blockType => {
  const colorSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, COLOR_SUPPORT_KEY);
  return colorSupport !== null && typeof colorSupport === 'object' && !!colorSupport.gradients;
};

const hasBackgroundColorSupport = blockType => {
  const colorSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, COLOR_SUPPORT_KEY);
  return colorSupport && colorSupport.background !== false;
};

const hasTextColorSupport = blockType => {
  const colorSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, COLOR_SUPPORT_KEY);
  return colorSupport && colorSupport.text !== false;
};
/**
 * Filters registered block settings, extending attributes to include
 * `backgroundColor` and `textColor` attribute.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */


function color_addAttributes(settings) {
  if (!hasColorSupport(settings)) {
    return settings;
  } // Allow blocks to specify their own attribute definition with default values if needed.


  if (!settings.attributes.backgroundColor) {
    Object.assign(settings.attributes, {
      backgroundColor: {
        type: 'string'
      }
    });
  }

  if (!settings.attributes.textColor) {
    Object.assign(settings.attributes, {
      textColor: {
        type: 'string'
      }
    });
  }

  if (hasGradientSupport(settings) && !settings.attributes.gradient) {
    Object.assign(settings.attributes, {
      gradient: {
        type: 'string'
      }
    });
  }

  return settings;
}
/**
 * Override props assigned to save component to inject colors classnames.
 *
 * @param {Object} props      Additional props applied to save element.
 * @param {Object} blockType  Block type.
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */


function color_addSaveProps(props, blockType, attributes) {
  if (!hasColorSupport(blockType) || shouldSkipSerialization(blockType, COLOR_SUPPORT_KEY)) {
    return props;
  }

  const hasGradient = hasGradientSupport(blockType); // I'd have preferred to avoid the "style" attribute usage here

  const {
    backgroundColor,
    textColor,
    gradient,
    style
  } = attributes;

  const shouldSerialize = feature => !shouldSkipSerialization(blockType, COLOR_SUPPORT_KEY, feature); // Primary color classes must come before the `has-text-color`,
  // `has-background` and `has-link-color` classes to maintain backwards
  // compatibility and avoid block invalidations.


  const textClass = shouldSerialize('text') ? getColorClassName('color', textColor) : undefined;
  const gradientClass = shouldSerialize('gradients') ? __experimentalGetGradientClass(gradient) : undefined;
  const backgroundClass = shouldSerialize('background') ? getColorClassName('background-color', backgroundColor) : undefined;
  const serializeHasBackground = shouldSerialize('background') || shouldSerialize('gradients');
  const hasBackground = backgroundColor || style?.color?.background || hasGradient && (gradient || style?.color?.gradient);
  const newClassName = classnames_default()(props.className, textClass, gradientClass, {
    // Don't apply the background class if there's a custom gradient.
    [backgroundClass]: (!hasGradient || !style?.color?.gradient) && !!backgroundClass,
    'has-text-color': shouldSerialize('text') && (textColor || style?.color?.text),
    'has-background': serializeHasBackground && hasBackground,
    'has-link-color': shouldSerialize('link') && style?.elements?.link?.color
  });
  props.className = newClassName ? newClassName : undefined;
  return props;
}
/**
 * Filters registered block settings to extend the block edit wrapper
 * to apply the desired styles and classnames properly.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function color_addEditProps(settings) {
  if (!hasColorSupport(settings) || shouldSkipSerialization(settings, COLOR_SUPPORT_KEY)) {
    return settings;
  }

  const existingGetEditWrapperProps = settings.getEditWrapperProps;

  settings.getEditWrapperProps = attributes => {
    let props = {};

    if (existingGetEditWrapperProps) {
      props = existingGetEditWrapperProps(attributes);
    }

    return color_addSaveProps(props, settings, attributes);
  };

  return settings;
}

function color_styleToAttributes(style) {
  const textColorValue = style?.color?.text;
  const textColorSlug = textColorValue?.startsWith('var:preset|color|') ? textColorValue.substring('var:preset|color|'.length) : undefined;
  const backgroundColorValue = style?.color?.background;
  const backgroundColorSlug = backgroundColorValue?.startsWith('var:preset|color|') ? backgroundColorValue.substring('var:preset|color|'.length) : undefined;
  const gradientValue = style?.color?.gradient;
  const gradientSlug = gradientValue?.startsWith('var:preset|gradient|') ? gradientValue.substring('var:preset|gradient|'.length) : undefined;
  const updatedStyle = { ...style
  };
  updatedStyle.color = { ...updatedStyle.color,
    text: textColorSlug ? undefined : textColorValue,
    background: backgroundColorSlug ? undefined : backgroundColorValue,
    gradient: gradientSlug ? undefined : gradientValue
  };
  return {
    style: utils_cleanEmptyObject(updatedStyle),
    textColor: textColorSlug,
    backgroundColor: backgroundColorSlug,
    gradient: gradientSlug
  };
}

function color_attributesToStyle(attributes) {
  return { ...attributes.style,
    color: { ...attributes.style?.color,
      text: attributes.textColor ? 'var:preset|color|' + attributes.textColor : attributes.style?.color?.text,
      background: attributes.backgroundColor ? 'var:preset|color|' + attributes.backgroundColor : attributes.style?.color?.background,
      gradient: attributes.gradient ? 'var:preset|gradient|' + attributes.gradient : attributes.style?.color?.gradient
    }
  };
}

function ColorInspectorControl({
  children,
  resetAllFilter
}) {
  const attributesResetAllFilter = (0,external_wp_element_namespaceObject.useCallback)(attributes => {
    const existingStyle = color_attributesToStyle(attributes);
    const updatedStyle = resetAllFilter(existingStyle);
    return { ...attributes,
      ...color_styleToAttributes(updatedStyle)
    };
  }, [resetAllFilter]);
  return (0,external_wp_element_namespaceObject.createElement)(inspector_controls, {
    group: "color",
    resetAllFilter: attributesResetAllFilter
  }, children);
}

function ColorEdit(props) {
  const {
    clientId,
    name,
    attributes,
    setAttributes
  } = props;
  const settings = useBlockSettings(name);
  const isEnabled = useHasColorPanel(settings);
  const value = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return color_attributesToStyle({
      style: attributes.style,
      textColor: attributes.textColor,
      backgroundColor: attributes.backgroundColor,
      gradient: attributes.gradient
    });
  }, [attributes.style, attributes.textColor, attributes.backgroundColor, attributes.gradient]);

  const onChange = newStyle => {
    setAttributes(color_styleToAttributes(newStyle));
  };

  if (!isEnabled) {
    return null;
  }

  const defaultControls = (0,external_wp_blocks_namespaceObject.getBlockSupport)(props.name, [COLOR_SUPPORT_KEY, '__experimentalDefaultControls']);
  const enableContrastChecking = external_wp_element_namespaceObject.Platform.OS === 'web' && !value?.color?.gradient && (settings?.color?.text || settings?.color?.link) && // Contrast checking is enabled by default.
  // Deactivating it requires `enableContrastChecker` to have
  // an explicit value of `false`.
  false !== (0,external_wp_blocks_namespaceObject.getBlockSupport)(props.name, [COLOR_SUPPORT_KEY, 'enableContrastChecker']);
  return (0,external_wp_element_namespaceObject.createElement)(ColorPanel, {
    as: ColorInspectorControl,
    panelId: clientId,
    settings: settings,
    value: value,
    onChange: onChange,
    defaultControls: defaultControls,
    enableContrastChecker: false !== (0,external_wp_blocks_namespaceObject.getBlockSupport)(props.name, [COLOR_SUPPORT_KEY, 'enableContrastChecker'])
  }, enableContrastChecking && (0,external_wp_element_namespaceObject.createElement)(BlockColorContrastChecker, {
    clientId: clientId
  }));
}
/**
 * This adds inline styles for color palette colors.
 * Ideally, this is not needed and themes should load their palettes on the editor.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */

const withColorPaletteStyles = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(BlockListBlock => props => {
  const {
    name,
    attributes
  } = props;
  const {
    backgroundColor,
    textColor
  } = attributes;
  const userPalette = use_setting_useSetting('color.palette.custom');
  const themePalette = use_setting_useSetting('color.palette.theme');
  const defaultPalette = use_setting_useSetting('color.palette.default');
  const colors = (0,external_wp_element_namespaceObject.useMemo)(() => [...(userPalette || []), ...(themePalette || []), ...(defaultPalette || [])], [userPalette, themePalette, defaultPalette]);

  if (!hasColorSupport(name) || shouldSkipSerialization(name, COLOR_SUPPORT_KEY)) {
    return (0,external_wp_element_namespaceObject.createElement)(BlockListBlock, { ...props
    });
  }

  const extraStyles = {};

  if (textColor && !shouldSkipSerialization(name, COLOR_SUPPORT_KEY, 'text')) {
    extraStyles.color = getColorObjectByAttributeValues(colors, textColor)?.color;
  }

  if (backgroundColor && !shouldSkipSerialization(name, COLOR_SUPPORT_KEY, 'background')) {
    extraStyles.backgroundColor = getColorObjectByAttributeValues(colors, backgroundColor)?.color;
  }

  let wrapperProps = props.wrapperProps;
  wrapperProps = { ...props.wrapperProps,
    style: { ...extraStyles,
      ...props.wrapperProps?.style
    }
  };
  return (0,external_wp_element_namespaceObject.createElement)(BlockListBlock, { ...props,
    wrapperProps: wrapperProps
  });
}, 'withColorPaletteStyles');
const MIGRATION_PATHS = {
  linkColor: [['style', 'elements', 'link', 'color', 'text']],
  textColor: [['textColor'], ['style', 'color', 'text']],
  backgroundColor: [['backgroundColor'], ['style', 'color', 'background']],
  gradient: [['gradient'], ['style', 'color', 'gradient']]
};
function color_addTransforms(result, source, index, results) {
  const destinationBlockType = result.name;
  const activeSupports = {
    linkColor: hasLinkColorSupport(destinationBlockType),
    textColor: hasTextColorSupport(destinationBlockType),
    backgroundColor: hasBackgroundColorSupport(destinationBlockType),
    gradient: hasGradientSupport(destinationBlockType)
  };
  return transformStyles(activeSupports, MIGRATION_PATHS, result, source, index, results);
}
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/color/addAttribute', color_addAttributes);
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.getSaveContent.extraProps', 'core/color/addSaveProps', color_addSaveProps);
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/color/addEditProps', color_addEditProps);
(0,external_wp_hooks_namespaceObject.addFilter)('editor.BlockListBlock', 'core/color/with-color-palette-styles', withColorPaletteStyles);
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.switchToBlockType.transformedBlock', 'core/color/addTransforms', color_addTransforms);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/font-family/index.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function FontFamilyControl({
  value = '',
  onChange,
  fontFamilies,
  ...props
}) {
  const blockLevelFontFamilies = use_setting_useSetting('typography.fontFamilies');

  if (!fontFamilies) {
    fontFamilies = blockLevelFontFamilies;
  }

  if (!fontFamilies || fontFamilies.length === 0) {
    return null;
  }

  const options = [{
    value: '',
    label: (0,external_wp_i18n_namespaceObject.__)('Default')
  }, ...fontFamilies.map(({
    fontFamily,
    name
  }) => {
    return {
      value: fontFamily,
      label: name || fontFamily
    };
  })];
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SelectControl, {
    label: (0,external_wp_i18n_namespaceObject.__)('Font'),
    options: options,
    value: value,
    onChange: onChange,
    labelPosition: "top",
    ...props
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/font-appearance-control/index.js


/**
 * WordPress dependencies
 */



const FONT_STYLES = [{
  name: (0,external_wp_i18n_namespaceObject._x)('Regular', 'font style'),
  value: 'normal'
}, {
  name: (0,external_wp_i18n_namespaceObject._x)('Italic', 'font style'),
  value: 'italic'
}];
const FONT_WEIGHTS = [{
  name: (0,external_wp_i18n_namespaceObject._x)('Thin', 'font weight'),
  value: '100'
}, {
  name: (0,external_wp_i18n_namespaceObject._x)('Extra Light', 'font weight'),
  value: '200'
}, {
  name: (0,external_wp_i18n_namespaceObject._x)('Light', 'font weight'),
  value: '300'
}, {
  name: (0,external_wp_i18n_namespaceObject._x)('Regular', 'font weight'),
  value: '400'
}, {
  name: (0,external_wp_i18n_namespaceObject._x)('Medium', 'font weight'),
  value: '500'
}, {
  name: (0,external_wp_i18n_namespaceObject._x)('Semi Bold', 'font weight'),
  value: '600'
}, {
  name: (0,external_wp_i18n_namespaceObject._x)('Bold', 'font weight'),
  value: '700'
}, {
  name: (0,external_wp_i18n_namespaceObject._x)('Extra Bold', 'font weight'),
  value: '800'
}, {
  name: (0,external_wp_i18n_namespaceObject._x)('Black', 'font weight'),
  value: '900'
}];
/**
 * Adjusts font appearance field label in case either font styles or weights
 * are disabled.
 *
 * @param {boolean} hasFontStyles  Whether font styles are enabled and present.
 * @param {boolean} hasFontWeights Whether font weights are enabled and present.
 * @return {string} A label representing what font appearance is being edited.
 */

const getFontAppearanceLabel = (hasFontStyles, hasFontWeights) => {
  if (!hasFontStyles) {
    return (0,external_wp_i18n_namespaceObject.__)('Font weight');
  }

  if (!hasFontWeights) {
    return (0,external_wp_i18n_namespaceObject.__)('Font style');
  }

  return (0,external_wp_i18n_namespaceObject.__)('Appearance');
};
/**
 * Control to display unified font style and weight options.
 *
 * @param {Object} props Component props.
 *
 * @return {WPElement} Font appearance control.
 */


function FontAppearanceControl(props) {
  const {
    onChange,
    hasFontStyles = true,
    hasFontWeights = true,
    value: {
      fontStyle,
      fontWeight
    },
    ...otherProps
  } = props;
  const hasStylesOrWeights = hasFontStyles || hasFontWeights;
  const label = getFontAppearanceLabel(hasFontStyles, hasFontWeights);
  const defaultOption = {
    key: 'default',
    name: (0,external_wp_i18n_namespaceObject.__)('Default'),
    style: {
      fontStyle: undefined,
      fontWeight: undefined
    }
  }; // Combines both font style and weight options into a single dropdown.

  const combineOptions = () => {
    const combinedOptions = [defaultOption];
    FONT_STYLES.forEach(({
      name: styleName,
      value: styleValue
    }) => {
      FONT_WEIGHTS.forEach(({
        name: weightName,
        value: weightValue
      }) => {
        const optionName = styleValue === 'normal' ? weightName : (0,external_wp_i18n_namespaceObject.sprintf)(
        /* translators: 1: Font weight name. 2: Font style name. */
        (0,external_wp_i18n_namespaceObject.__)('%1$s %2$s'), weightName, styleName);
        combinedOptions.push({
          key: `${styleValue}-${weightValue}`,
          name: optionName,
          style: {
            fontStyle: styleValue,
            fontWeight: weightValue
          }
        });
      });
    });
    return combinedOptions;
  }; // Generates select options for font styles only.


  const styleOptions = () => {
    const combinedOptions = [defaultOption];
    FONT_STYLES.forEach(({
      name,
      value
    }) => {
      combinedOptions.push({
        key: value,
        name,
        style: {
          fontStyle: value,
          fontWeight: undefined
        }
      });
    });
    return combinedOptions;
  }; // Generates select options for font weights only.


  const weightOptions = () => {
    const combinedOptions = [defaultOption];
    FONT_WEIGHTS.forEach(({
      name,
      value
    }) => {
      combinedOptions.push({
        key: value,
        name,
        style: {
          fontStyle: undefined,
          fontWeight: value
        }
      });
    });
    return combinedOptions;
  }; // Map font styles and weights to select options.


  const selectOptions = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (hasFontStyles && hasFontWeights) {
      return combineOptions();
    }

    return hasFontStyles ? styleOptions() : weightOptions();
  }, [props.options]); // Find current selection by comparing font style & weight against options,
  // and fall back to the Default option if there is no matching option.

  const currentSelection = selectOptions.find(option => option.style.fontStyle === fontStyle && option.style.fontWeight === fontWeight) || selectOptions[0]; // Adjusts screen reader description based on styles or weights.

  const getDescribedBy = () => {
    if (!currentSelection) {
      return (0,external_wp_i18n_namespaceObject.__)('No selected font appearance');
    }

    if (!hasFontStyles) {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: %s: Currently selected font weight.
      (0,external_wp_i18n_namespaceObject.__)('Currently selected font weight: %s'), currentSelection.name);
    }

    if (!hasFontWeights) {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: %s: Currently selected font style.
      (0,external_wp_i18n_namespaceObject.__)('Currently selected font style: %s'), currentSelection.name);
    }

    return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: %s: Currently selected font appearance.
    (0,external_wp_i18n_namespaceObject.__)('Currently selected font appearance: %s'), currentSelection.name);
  };

  return hasStylesOrWeights && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.CustomSelectControl, { ...otherProps,
    className: "components-font-appearance-control",
    label: label,
    describedBy: getDescribedBy(),
    options: selectOptions,
    value: currentSelection,
    onChange: ({
      selectedItem
    }) => onChange(selectedItem.style),
    __nextUnconstrainedWidth: true
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/line-height-control/utils.js
const BASE_DEFAULT_VALUE = 1.5;
const STEP = 0.1;
/**
 * There are varying value types within LineHeightControl:
 *
 * {undefined} Initial value. No changes from the user.
 * {string} Input value. Value consumed/outputted by the input. Empty would be ''.
 * {number} Block attribute type. Input value needs to be converted for attribute setting.
 *
 * Note: If the value is undefined, the input requires it to be an empty string ('')
 * in order to be considered "controlled" by props (rather than internal state).
 */

const RESET_VALUE = '';
/**
 * Determines if the lineHeight attribute has been properly defined.
 *
 * @param {any} lineHeight The value to check.
 *
 * @return {boolean} Whether the lineHeight attribute is valid.
 */

function isLineHeightDefined(lineHeight) {
  return lineHeight !== undefined && lineHeight !== RESET_VALUE;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/line-height-control/index.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



const line_height_control_LineHeightControl = ({
  value: lineHeight,
  onChange,

  /** Start opting into the new margin-free styles that will become the default in a future version. */
  __nextHasNoMarginBottom = false,
  __unstableInputWidth = '60px',
  ...otherProps
}) => {
  const isDefined = isLineHeightDefined(lineHeight);

  const adjustNextValue = (nextValue, wasTypedOrPasted) => {
    // Set the next value without modification if lineHeight has been defined.
    if (isDefined) return nextValue;
    /**
     * The following logic handles the initial step up/down action
     * (from an undefined value state) so that the next values are better suited for
     * line-height rendering. For example, the first step up should immediately
     * go to 1.6, rather than the normally expected 0.1.
     *
     * Step up/down actions can be triggered by keydowns of the up/down arrow keys,
     * or by clicking the spin buttons.
     */

    switch (`${nextValue}`) {
      case `${STEP}`:
        // Increment by step value.
        return BASE_DEFAULT_VALUE + STEP;

      case '0':
        {
          // This means the user explicitly input '0', rather than stepped down
          // from an undefined value state.
          if (wasTypedOrPasted) return nextValue; // Decrement by step value.

          return BASE_DEFAULT_VALUE - STEP;
        }

      case '':
        return BASE_DEFAULT_VALUE;

      default:
        return nextValue;
    }
  };

  const stateReducer = (state, action) => {
    // Be careful when changing this — cross-browser behavior of the
    // `inputType` field in `input` events are inconsistent.
    // For example, Firefox emits an input event with inputType="insertReplacementText"
    // on spin button clicks, while other browsers do not even emit an input event.
    const wasTypedOrPasted = ['insertText', 'insertFromPaste'].includes(action.payload.event.nativeEvent?.inputType);
    const value = adjustNextValue(state.value, wasTypedOrPasted);
    return { ...state,
      value
    };
  };

  const value = isDefined ? lineHeight : RESET_VALUE;

  if (!__nextHasNoMarginBottom) {
    external_wp_deprecated_default()('Bottom margin styles for wp.blockEditor.LineHeightControl', {
      since: '6.0',
      version: '6.4',
      hint: 'Set the `__nextHasNoMarginBottom` prop to true to start opting into the new styles, which will become the default in a future version'
    });
  }

  const deprecatedStyles = __nextHasNoMarginBottom ? undefined : {
    marginBottom: 24
  };

  const handleOnChange = (nextValue, {
    event
  }) => {
    if (nextValue === '') {
      onChange();
      return;
    }

    if (event.type === 'click') {
      onChange(adjustNextValue(`${nextValue}`, false));
      return;
    }

    onChange(`${nextValue}`);
  };

  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-line-height-control",
    style: deprecatedStyles
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalNumberControl, { ...otherProps,
    __unstableInputWidth: __unstableInputWidth,
    __unstableStateReducer: stateReducer,
    onChange: handleOnChange,
    label: (0,external_wp_i18n_namespaceObject.__)('Line height'),
    placeholder: BASE_DEFAULT_VALUE,
    step: STEP,
    value: value,
    min: 0,
    spinControls: "custom"
  }));
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/line-height-control/README.md
 */


/* harmony default export */ var line_height_control = (line_height_control_LineHeightControl);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/letter-spacing-control/index.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Control for letter-spacing.
 *
 * @param {Object}                  props                      Component props.
 * @param {string}                  props.value                Currently selected letter-spacing.
 * @param {Function}                props.onChange             Handles change in letter-spacing selection.
 * @param {string|number|undefined} props.__unstableInputWidth Input width to pass through to inner UnitControl. Should be a valid CSS value.
 *
 * @return {WPElement} Letter-spacing control.
 */

function LetterSpacingControl({
  value,
  onChange,
  __unstableInputWidth = '60px',
  ...otherProps
}) {
  const units = (0,external_wp_components_namespaceObject.__experimentalUseCustomUnits)({
    availableUnits: use_setting_useSetting('spacing.units') || ['px', 'em', 'rem'],
    defaultValues: {
      px: 2,
      em: 0.2,
      rem: 0.2
    }
  });
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalUnitControl, { ...otherProps,
    label: (0,external_wp_i18n_namespaceObject.__)('Letter spacing'),
    value: value,
    __unstableInputWidth: __unstableInputWidth,
    units: units,
    onChange: onChange
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/reset.js


/**
 * WordPress dependencies
 */

const reset_reset = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M7 11.5h10V13H7z"
}));
/* harmony default export */ var library_reset = (reset_reset);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/format-uppercase.js


/**
 * WordPress dependencies
 */

const formatUppercase = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M6.1 6.8L2.1 18h1.6l1.1-3h4.3l1.1 3h1.6l-4-11.2H6.1zm-.8 6.8L7 8.9l1.7 4.7H5.3zm15.1-.7c-.4-.5-.9-.8-1.6-1 .4-.2.7-.5.8-.9.2-.4.3-.9.3-1.4 0-.9-.3-1.6-.8-2-.6-.5-1.3-.7-2.4-.7h-3.5V18h4.2c1.1 0 2-.3 2.6-.8.6-.6 1-1.4 1-2.4-.1-.8-.3-1.4-.6-1.9zm-5.7-4.7h1.8c.6 0 1.1.1 1.4.4.3.2.5.7.5 1.3 0 .6-.2 1.1-.5 1.3-.3.2-.8.4-1.4.4h-1.8V8.2zm4 8c-.4.3-.9.5-1.5.5h-2.6v-3.8h2.6c1.4 0 2 .6 2 1.9.1.6-.1 1-.5 1.4z"
}));
/* harmony default export */ var format_uppercase = (formatUppercase);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/format-lowercase.js


/**
 * WordPress dependencies
 */

const formatLowercase = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M11 16.8c-.1-.1-.2-.3-.3-.5v-2.6c0-.9-.1-1.7-.3-2.2-.2-.5-.5-.9-.9-1.2-.4-.2-.9-.3-1.6-.3-.5 0-1 .1-1.5.2s-.9.3-1.2.6l.2 1.2c.4-.3.7-.4 1.1-.5.3-.1.7-.2 1-.2.6 0 1 .1 1.3.4.3.2.4.7.4 1.4-1.2 0-2.3.2-3.3.7s-1.4 1.1-1.4 2.1c0 .7.2 1.2.7 1.6.4.4 1 .6 1.8.6.9 0 1.7-.4 2.4-1.2.1.3.2.5.4.7.1.2.3.3.6.4.3.1.6.1 1.1.1h.1l.2-1.2h-.1c-.4.1-.6 0-.7-.1zM9.2 16c-.2.3-.5.6-.9.8-.3.1-.7.2-1.1.2-.4 0-.7-.1-.9-.3-.2-.2-.3-.5-.3-.9 0-.6.2-1 .7-1.3.5-.3 1.3-.4 2.5-.5v2zm10.6-3.9c-.3-.6-.7-1.1-1.2-1.5-.6-.4-1.2-.6-1.9-.6-.5 0-.9.1-1.4.3-.4.2-.8.5-1.1.8V6h-1.4v12h1.3l.2-1c.2.4.6.6 1 .8.4.2.9.3 1.4.3.7 0 1.2-.2 1.8-.5.5-.4 1-.9 1.3-1.5.3-.6.5-1.3.5-2.1-.1-.6-.2-1.3-.5-1.9zm-1.7 4c-.4.5-.9.8-1.6.8s-1.2-.2-1.7-.7c-.4-.5-.7-1.2-.7-2.1 0-.9.2-1.6.7-2.1.4-.5 1-.7 1.7-.7s1.2.3 1.6.8c.4.5.6 1.2.6 2s-.2 1.4-.6 2z"
}));
/* harmony default export */ var format_lowercase = (formatLowercase);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/format-capitalize.js


/**
 * WordPress dependencies
 */

const formatCapitalize = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M7.1 6.8L3.1 18h1.6l1.1-3h4.3l1.1 3h1.6l-4-11.2H7.1zm-.8 6.8L8 8.9l1.7 4.7H6.3zm14.5-1.5c-.3-.6-.7-1.1-1.2-1.5-.6-.4-1.2-.6-1.9-.6-.5 0-.9.1-1.4.3-.4.2-.8.5-1.1.8V6h-1.4v12h1.3l.2-1c.2.4.6.6 1 .8.4.2.9.3 1.4.3.7 0 1.2-.2 1.8-.5.5-.4 1-.9 1.3-1.5.3-.6.5-1.3.5-2.1-.1-.6-.2-1.3-.5-1.9zm-1.7 4c-.4.5-.9.8-1.6.8s-1.2-.2-1.7-.7c-.4-.5-.7-1.2-.7-2.1 0-.9.2-1.6.7-2.1.4-.5 1-.7 1.7-.7s1.2.3 1.6.8c.4.5.6 1.2.6 2 .1.8-.2 1.4-.6 2z"
}));
/* harmony default export */ var format_capitalize = (formatCapitalize);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/text-transform-control/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




const TEXT_TRANSFORMS = [{
  name: (0,external_wp_i18n_namespaceObject.__)('None'),
  value: 'none',
  icon: library_reset
}, {
  name: (0,external_wp_i18n_namespaceObject.__)('Uppercase'),
  value: 'uppercase',
  icon: format_uppercase
}, {
  name: (0,external_wp_i18n_namespaceObject.__)('Lowercase'),
  value: 'lowercase',
  icon: format_lowercase
}, {
  name: (0,external_wp_i18n_namespaceObject.__)('Capitalize'),
  value: 'capitalize',
  icon: format_capitalize
}];
/**
 * Control to facilitate text transform selections.
 *
 * @param {Object}   props           Component props.
 * @param {string}   props.className Class name to add to the control.
 * @param {string}   props.value     Currently selected text transform.
 * @param {Function} props.onChange  Handles change in text transform selection.
 *
 * @return {WPElement} Text transform control.
 */

function TextTransformControl({
  className,
  value,
  onChange
}) {
  return (0,external_wp_element_namespaceObject.createElement)("fieldset", {
    className: classnames_default()('block-editor-text-transform-control', className)
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.BaseControl.VisualLabel, {
    as: "legend"
  }, (0,external_wp_i18n_namespaceObject.__)('Letter case')), (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-text-transform-control__buttons"
  }, TEXT_TRANSFORMS.map(textTransform => {
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
      key: textTransform.value,
      icon: textTransform.icon,
      label: textTransform.name,
      isPressed: textTransform.value === value,
      onClick: () => {
        onChange(textTransform.value === value ? undefined : textTransform.value);
      }
    });
  })));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/format-underline.js


/**
 * WordPress dependencies
 */

const formatUnderline = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M7 18v1h10v-1H7zm5-2c1.5 0 2.6-.4 3.4-1.2.8-.8 1.1-2 1.1-3.5V5H15v5.8c0 1.2-.2 2.1-.6 2.8-.4.7-1.2 1-2.4 1s-2-.3-2.4-1c-.4-.7-.6-1.6-.6-2.8V5H7.5v6.2c0 1.5.4 2.7 1.1 3.5.8.9 1.9 1.3 3.4 1.3z"
}));
/* harmony default export */ var format_underline = (formatUnderline);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/format-strikethrough.js


/**
 * WordPress dependencies
 */

const formatStrikethrough = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M9.1 9v-.5c0-.6.2-1.1.7-1.4.5-.3 1.2-.5 2-.5.7 0 1.4.1 2.1.3.7.2 1.4.5 2.1.9l.2-1.9c-.6-.3-1.2-.5-1.9-.7-.8-.1-1.6-.2-2.4-.2-1.5 0-2.7.3-3.6 1-.8.7-1.2 1.5-1.2 2.6V9h2zM20 12H4v1h8.3c.3.1.6.2.8.3.5.2.9.5 1.1.8.3.3.4.7.4 1.2 0 .7-.2 1.1-.8 1.5-.5.3-1.2.5-2.1.5-.8 0-1.6-.1-2.4-.3-.8-.2-1.5-.5-2.2-.8L7 18.1c.5.2 1.2.4 2 .6.8.2 1.6.3 2.4.3 1.7 0 3-.3 3.9-1 .9-.7 1.3-1.6 1.3-2.8 0-.9-.2-1.7-.7-2.2H20v-1z"
}));
/* harmony default export */ var format_strikethrough = (formatStrikethrough);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/text-decoration-control/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




const TEXT_DECORATIONS = [{
  name: (0,external_wp_i18n_namespaceObject.__)('None'),
  value: 'none',
  icon: library_reset
}, {
  name: (0,external_wp_i18n_namespaceObject.__)('Underline'),
  value: 'underline',
  icon: format_underline
}, {
  name: (0,external_wp_i18n_namespaceObject.__)('Strikethrough'),
  value: 'line-through',
  icon: format_strikethrough
}];
/**
 * Control to facilitate text decoration selections.
 *
 * @param {Object}   props             Component props.
 * @param {string}   props.value       Currently selected text decoration.
 * @param {Function} props.onChange    Handles change in text decoration selection.
 * @param {string}   [props.className] Additional class name to apply.
 *
 * @return {WPElement} Text decoration control.
 */

function TextDecorationControl({
  value,
  onChange,
  className
}) {
  return (0,external_wp_element_namespaceObject.createElement)("fieldset", {
    className: classnames_default()('block-editor-text-decoration-control', className)
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.BaseControl.VisualLabel, {
    as: "legend"
  }, (0,external_wp_i18n_namespaceObject.__)('Decoration')), (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-text-decoration-control__buttons"
  }, TEXT_DECORATIONS.map(textDecoration => {
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
      key: textDecoration.value,
      icon: textDecoration.icon,
      label: textDecoration.name,
      isPressed: textDecoration.value === value,
      onClick: () => {
        onChange(textDecoration.value === value ? undefined : textDecoration.value);
      }
    });
  })));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/global-styles/typography-panel.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */









const MIN_TEXT_COLUMNS = 1;
const MAX_TEXT_COLUMNS = 6;
function useHasTypographyPanel(settings) {
  const hasFontFamily = useHasFontFamilyControl(settings);
  const hasLineHeight = useHasLineHeightControl(settings);
  const hasFontAppearance = useHasAppearanceControl(settings);
  const hasLetterSpacing = useHasLetterSpacingControl(settings);
  const hasTextTransform = useHasTextTransformControl(settings);
  const hasTextDecoration = useHasTextDecorationControl(settings);
  const hasTextColumns = useHasTextColumnsControl(settings);
  const hasFontSize = useHasFontSizeControl(settings);
  return hasFontFamily || hasLineHeight || hasFontAppearance || hasLetterSpacing || hasTextTransform || hasFontSize || hasTextDecoration || hasTextColumns;
}

function useHasFontSizeControl(settings) {
  var _settings$typography$, _fontSizesPerOrigin$c, _fontSizesPerOrigin$t, _fontSizesPerOrigin$d;

  const disableCustomFontSizes = !settings?.typography?.customFontSize;
  const fontSizesPerOrigin = (_settings$typography$ = settings?.typography?.fontSizes) !== null && _settings$typography$ !== void 0 ? _settings$typography$ : {};
  const fontSizes = [].concat((_fontSizesPerOrigin$c = fontSizesPerOrigin?.custom) !== null && _fontSizesPerOrigin$c !== void 0 ? _fontSizesPerOrigin$c : []).concat((_fontSizesPerOrigin$t = fontSizesPerOrigin?.theme) !== null && _fontSizesPerOrigin$t !== void 0 ? _fontSizesPerOrigin$t : []).concat((_fontSizesPerOrigin$d = fontSizesPerOrigin.default) !== null && _fontSizesPerOrigin$d !== void 0 ? _fontSizesPerOrigin$d : []);
  return !!fontSizes?.length || !disableCustomFontSizes;
}

function useHasFontFamilyControl(settings) {
  var _fontFamiliesPerOrigi, _fontFamiliesPerOrigi2, _fontFamiliesPerOrigi3;

  const fontFamiliesPerOrigin = settings?.typography?.fontFamilies;
  const fontFamilies = [].concat((_fontFamiliesPerOrigi = fontFamiliesPerOrigin?.custom) !== null && _fontFamiliesPerOrigi !== void 0 ? _fontFamiliesPerOrigi : []).concat((_fontFamiliesPerOrigi2 = fontFamiliesPerOrigin?.theme) !== null && _fontFamiliesPerOrigi2 !== void 0 ? _fontFamiliesPerOrigi2 : []).concat((_fontFamiliesPerOrigi3 = fontFamiliesPerOrigin?.default) !== null && _fontFamiliesPerOrigi3 !== void 0 ? _fontFamiliesPerOrigi3 : []).sort((a, b) => (a?.name || a?.slug).localeCompare(b?.name || a?.slug));
  return !!fontFamilies?.length;
}

function useHasLineHeightControl(settings) {
  return settings?.typography?.lineHeight;
}

function useHasAppearanceControl(settings) {
  const hasFontStyles = settings?.typography?.fontStyle;
  const hasFontWeights = settings?.typography?.fontWeight;
  return hasFontStyles || hasFontWeights;
}

function useAppearanceControlLabel(settings) {
  const hasFontStyles = settings?.typography?.fontStyle;
  const hasFontWeights = settings?.typography?.fontWeight;

  if (!hasFontStyles) {
    return (0,external_wp_i18n_namespaceObject.__)('Font weight');
  }

  if (!hasFontWeights) {
    return (0,external_wp_i18n_namespaceObject.__)('Font style');
  }

  return (0,external_wp_i18n_namespaceObject.__)('Appearance');
}

function useHasLetterSpacingControl(settings) {
  return settings?.typography?.letterSpacing;
}

function useHasTextTransformControl(settings) {
  return settings?.typography?.textTransform;
}

function useHasTextDecorationControl(settings) {
  return settings?.typography?.textDecoration;
}

function useHasTextColumnsControl(settings) {
  return settings?.typography?.textColumns;
}

function TypographyToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children
}) {
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanel, {
    label: (0,external_wp_i18n_namespaceObject.__)('Typography'),
    resetAll: resetAll,
    panelId: panelId
  }, children);
}

const typography_panel_DEFAULT_CONTROLS = {
  fontFamily: true,
  fontSize: true,
  fontAppearance: true,
  lineHeight: true,
  letterSpacing: true,
  textTransform: true,
  textDecoration: true,
  textColumns: true
};
function TypographyPanel({
  as: Wrapper = TypographyToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  defaultControls = typography_panel_DEFAULT_CONTROLS
}) {
  var _fontFamiliesPerOrigi4, _fontFamiliesPerOrigi5, _fontFamiliesPerOrigi6, _settings$typography$2, _fontSizesPerOrigin$c2, _fontSizesPerOrigin$t2, _fontSizesPerOrigin$d2;

  const decodeValue = rawValue => getValueFromVariable({
    settings
  }, '', rawValue); // Font Family


  const hasFontFamilyEnabled = useHasFontFamilyControl(settings);
  const fontFamiliesPerOrigin = settings?.typography?.fontFamilies;
  const fontFamilies = [].concat((_fontFamiliesPerOrigi4 = fontFamiliesPerOrigin?.custom) !== null && _fontFamiliesPerOrigi4 !== void 0 ? _fontFamiliesPerOrigi4 : []).concat((_fontFamiliesPerOrigi5 = fontFamiliesPerOrigin?.theme) !== null && _fontFamiliesPerOrigi5 !== void 0 ? _fontFamiliesPerOrigi5 : []).concat((_fontFamiliesPerOrigi6 = fontFamiliesPerOrigin?.default) !== null && _fontFamiliesPerOrigi6 !== void 0 ? _fontFamiliesPerOrigi6 : []);
  const fontFamily = decodeValue(inheritedValue?.typography?.fontFamily);

  const setFontFamily = newValue => {
    const slug = fontFamilies?.find(({
      fontFamily: f
    }) => f === newValue)?.slug;
    onChange(setImmutably(value, ['typography', 'fontFamily'], slug ? `var:preset|font-family|${slug}` : newValue || undefined));
  };

  const hasFontFamily = () => !!value?.typography?.fontFamily;

  const resetFontFamily = () => setFontFamily(undefined); // Font Size


  const hasFontSizeEnabled = useHasFontSizeControl(settings);
  const disableCustomFontSizes = !settings?.typography?.customFontSize;
  const fontSizesPerOrigin = (_settings$typography$2 = settings?.typography?.fontSizes) !== null && _settings$typography$2 !== void 0 ? _settings$typography$2 : {};
  const fontSizes = [].concat((_fontSizesPerOrigin$c2 = fontSizesPerOrigin?.custom) !== null && _fontSizesPerOrigin$c2 !== void 0 ? _fontSizesPerOrigin$c2 : []).concat((_fontSizesPerOrigin$t2 = fontSizesPerOrigin?.theme) !== null && _fontSizesPerOrigin$t2 !== void 0 ? _fontSizesPerOrigin$t2 : []).concat((_fontSizesPerOrigin$d2 = fontSizesPerOrigin.default) !== null && _fontSizesPerOrigin$d2 !== void 0 ? _fontSizesPerOrigin$d2 : []);
  const fontSize = decodeValue(inheritedValue?.typography?.fontSize);

  const setFontSize = (newValue, metadata) => {
    const actualValue = !!metadata?.slug ? `var:preset|font-size|${metadata?.slug}` : newValue;
    onChange(setImmutably(value, ['typography', 'fontSize'], actualValue || undefined));
  };

  const hasFontSize = () => !!value?.typography?.fontSize;

  const resetFontSize = () => setFontSize(undefined); // Appearance


  const hasAppearanceControl = useHasAppearanceControl(settings);
  const appearanceControlLabel = useAppearanceControlLabel(settings);
  const hasFontStyles = settings?.typography?.fontStyle;
  const hasFontWeights = settings?.typography?.fontWeight;
  const fontStyle = decodeValue(inheritedValue?.typography?.fontStyle);
  const fontWeight = decodeValue(inheritedValue?.typography?.fontWeight);

  const setFontAppearance = ({
    fontStyle: newFontStyle,
    fontWeight: newFontWeight
  }) => {
    onChange({ ...value,
      typography: { ...value?.typography,
        fontStyle: newFontStyle || undefined,
        fontWeight: newFontWeight || undefined
      }
    });
  };

  const hasFontAppearance = () => !!value?.typography?.fontStyle || !!value?.typography?.fontWeight;

  const resetFontAppearance = () => {
    setFontAppearance({});
  }; // Line Height


  const hasLineHeightEnabled = useHasLineHeightControl(settings);
  const lineHeight = decodeValue(inheritedValue?.typography?.lineHeight);

  const setLineHeight = newValue => {
    onChange(setImmutably(value, ['typography', 'lineHeight'], newValue || undefined));
  };

  const hasLineHeight = () => value?.typography?.lineHeight !== undefined;

  const resetLineHeight = () => setLineHeight(undefined); // Letter Spacing


  const hasLetterSpacingControl = useHasLetterSpacingControl(settings);
  const letterSpacing = decodeValue(inheritedValue?.typography?.letterSpacing);

  const setLetterSpacing = newValue => {
    onChange(setImmutably(value, ['typography', 'letterSpacing'], newValue || undefined));
  };

  const hasLetterSpacing = () => !!value?.typography?.letterSpacing;

  const resetLetterSpacing = () => setLetterSpacing(undefined); // Text Columns


  const hasTextColumnsControl = useHasTextColumnsControl(settings);
  const textColumns = decodeValue(inheritedValue?.typography?.textColumns);

  const setTextColumns = newValue => {
    onChange(setImmutably(value, ['typography', 'textColumns'], newValue || undefined));
  };

  const hasTextColumns = () => !!value?.typography?.textColumns;

  const resetTextColumns = () => setTextColumns(undefined); // Text Transform


  const hasTextTransformControl = useHasTextTransformControl(settings);
  const textTransform = decodeValue(inheritedValue?.typography?.textTransform);

  const setTextTransform = newValue => {
    onChange(setImmutably(value, ['typography', 'textTransform'], newValue || undefined));
  };

  const hasTextTransform = () => !!value?.typography?.textTransform;

  const resetTextTransform = () => setTextTransform(undefined); // Text Decoration


  const hasTextDecorationControl = useHasTextDecorationControl(settings);
  const textDecoration = decodeValue(inheritedValue?.typography?.textDecoration);

  const setTextDecoration = newValue => {
    onChange(setImmutably(value, ['typography', 'textDecoration'], newValue || undefined));
  };

  const hasTextDecoration = () => !!value?.typography?.textDecoration;

  const resetTextDecoration = () => setTextDecoration(undefined);

  const resetAllFilter = (0,external_wp_element_namespaceObject.useCallback)(previousValue => {
    return { ...previousValue,
      typography: {}
    };
  }, []);
  return (0,external_wp_element_namespaceObject.createElement)(Wrapper, {
    resetAllFilter: resetAllFilter,
    value: value,
    onChange: onChange,
    panelId: panelId
  }, hasFontFamilyEnabled && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    label: (0,external_wp_i18n_namespaceObject.__)('Font family'),
    hasValue: hasFontFamily,
    onDeselect: resetFontFamily,
    isShownByDefault: defaultControls.fontFamily,
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(FontFamilyControl, {
    fontFamilies: fontFamilies,
    value: fontFamily,
    onChange: setFontFamily,
    size: "__unstable-large",
    __nextHasNoMarginBottom: true
  })), hasFontSizeEnabled && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    label: (0,external_wp_i18n_namespaceObject.__)('Font size'),
    hasValue: hasFontSize,
    onDeselect: resetFontSize,
    isShownByDefault: defaultControls.fontSize,
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FontSizePicker, {
    value: fontSize,
    onChange: setFontSize,
    fontSizes: fontSizes,
    disableCustomFontSizes: disableCustomFontSizes,
    withReset: false,
    withSlider: true,
    size: "__unstable-large",
    __nextHasNoMarginBottom: true
  })), hasAppearanceControl && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    className: "single-column",
    label: appearanceControlLabel,
    hasValue: hasFontAppearance,
    onDeselect: resetFontAppearance,
    isShownByDefault: defaultControls.fontAppearance,
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(FontAppearanceControl, {
    value: {
      fontStyle,
      fontWeight
    },
    onChange: setFontAppearance,
    hasFontStyles: hasFontStyles,
    hasFontWeights: hasFontWeights,
    size: "__unstable-large",
    __nextHasNoMarginBottom: true
  })), hasLineHeightEnabled && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    className: "single-column",
    label: (0,external_wp_i18n_namespaceObject.__)('Line height'),
    hasValue: hasLineHeight,
    onDeselect: resetLineHeight,
    isShownByDefault: defaultControls.lineHeight,
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(line_height_control, {
    __nextHasNoMarginBottom: true,
    __unstableInputWidth: "auto",
    value: lineHeight,
    onChange: setLineHeight,
    size: "__unstable-large"
  })), hasLetterSpacingControl && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    className: "single-column",
    label: (0,external_wp_i18n_namespaceObject.__)('Letter spacing'),
    hasValue: hasLetterSpacing,
    onDeselect: resetLetterSpacing,
    isShownByDefault: defaultControls.letterSpacing,
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(LetterSpacingControl, {
    value: letterSpacing,
    onChange: setLetterSpacing,
    size: "__unstable-large",
    __unstableInputWidth: "auto"
  })), hasTextColumnsControl && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    className: "single-column",
    label: (0,external_wp_i18n_namespaceObject.__)('Text columns'),
    hasValue: hasTextColumns,
    onDeselect: resetTextColumns,
    isShownByDefault: defaultControls.textColumns,
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalNumberControl, {
    label: (0,external_wp_i18n_namespaceObject.__)('Text columns'),
    max: MAX_TEXT_COLUMNS,
    min: MIN_TEXT_COLUMNS,
    onChange: setTextColumns,
    size: "__unstable-large",
    spinControls: "custom",
    value: textColumns,
    initialPosition: 1
  })), hasTextDecorationControl && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    className: "single-column",
    label: (0,external_wp_i18n_namespaceObject.__)('Text decoration'),
    hasValue: hasTextDecoration,
    onDeselect: resetTextDecoration,
    isShownByDefault: defaultControls.textDecoration,
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(TextDecorationControl, {
    value: textDecoration,
    onChange: setTextDecoration,
    size: "__unstable-large",
    __unstableInputWidth: "auto"
  })), hasTextTransformControl && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    label: (0,external_wp_i18n_namespaceObject.__)('Letter case'),
    hasValue: hasTextTransform,
    onDeselect: resetTextTransform,
    isShownByDefault: defaultControls.textTransform,
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(TextTransformControl, {
    value: textTransform,
    onChange: setTextTransform,
    showNone: true,
    isBlock: true,
    size: "__unstable-large",
    __nextHasNoMarginBottom: true
  })));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/line-height.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




const LINE_HEIGHT_SUPPORT_KEY = 'typography.lineHeight';
/**
 * Inspector control panel containing the line height related configuration
 *
 * @param {Object} props
 *
 * @return {WPElement} Line height edit element.
 */

function LineHeightEdit(props) {
  const {
    attributes: {
      style
    },
    setAttributes
  } = props;

  const onChange = newLineHeightValue => {
    const newStyle = { ...style,
      typography: { ...style?.typography,
        lineHeight: newLineHeightValue
      }
    };
    setAttributes({
      style: cleanEmptyObject(newStyle)
    });
  };

  return createElement(LineHeightControl, {
    __unstableInputWidth: "100%",
    __nextHasNoMarginBottom: true,
    value: style?.typography?.lineHeight,
    onChange: onChange,
    size: "__unstable-large"
  });
}
/**
 * Custom hook that checks if line-height settings have been disabled.
 *
 * @param {string} name The name of the block.
 * @return {boolean} Whether setting is disabled.
 */

function useIsLineHeightDisabled({
  name: blockName
} = {}) {
  const isDisabled = !useSetting('typography.lineHeight');
  return !hasBlockSupport(blockName, LINE_HEIGHT_SUPPORT_KEY) || isDisabled;
}

;// CONCATENATED MODULE: external ["wp","tokenList"]
var external_wp_tokenList_namespaceObject = window["wp"]["tokenList"];
var external_wp_tokenList_default = /*#__PURE__*/__webpack_require__.n(external_wp_tokenList_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/font-family.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




const FONT_FAMILY_SUPPORT_KEY = 'typography.__experimentalFontFamily';
/**
 * Filters registered block settings, extending attributes to include
 * the `fontFamily` attribute.
 *
 * @param {Object} settings Original block settings
 * @return {Object}         Filtered block settings
 */

function font_family_addAttributes(settings) {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, FONT_FAMILY_SUPPORT_KEY)) {
    return settings;
  } // Allow blocks to specify a default value if needed.


  if (!settings.attributes.fontFamily) {
    Object.assign(settings.attributes, {
      fontFamily: {
        type: 'string'
      }
    });
  }

  return settings;
}
/**
 * Override props assigned to save component to inject font family.
 *
 * @param {Object} props      Additional props applied to save element
 * @param {Object} blockType  Block type
 * @param {Object} attributes Block attributes
 * @return {Object}           Filtered props applied to save element
 */


function font_family_addSaveProps(props, blockType, attributes) {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, FONT_FAMILY_SUPPORT_KEY)) {
    return props;
  }

  if (shouldSkipSerialization(blockType, TYPOGRAPHY_SUPPORT_KEY, 'fontFamily')) {
    return props;
  }

  if (!attributes?.fontFamily) {
    return props;
  } // Use TokenList to dedupe classes.


  const classes = new (external_wp_tokenList_default())(props.className);
  classes.add(`has-${kebabCase(attributes?.fontFamily)}-font-family`);
  const newClassName = classes.value;
  props.className = newClassName ? newClassName : undefined;
  return props;
}
/**
 * Filters registered block settings to expand the block edit wrapper
 * by applying the desired styles and classnames.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */


function font_family_addEditProps(settings) {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, FONT_FAMILY_SUPPORT_KEY)) {
    return settings;
  }

  const existingGetEditWrapperProps = settings.getEditWrapperProps;

  settings.getEditWrapperProps = attributes => {
    let props = {};

    if (existingGetEditWrapperProps) {
      props = existingGetEditWrapperProps(attributes);
    }

    return font_family_addSaveProps(props, settings, attributes);
  };

  return settings;
}
/**
 * Resets the font family block support attribute. This can be used when
 * disabling the font family support controls for a block via a progressive
 * discovery panel.
 *
 * @param {Object} props               Block props.
 * @param {Object} props.setAttributes Function to set block's attributes.
 */


function resetFontFamily({
  setAttributes
}) {
  setAttributes({
    fontFamily: undefined
  });
}
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/fontFamily/addAttribute', font_family_addAttributes);
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.getSaveContent.extraProps', 'core/fontFamily/addSaveProps', font_family_addSaveProps);
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/fontFamily/addEditProps', font_family_addEditProps);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/font-sizes/utils.js
/**
 * Internal dependencies
 */

/**
 *  Returns the font size object based on an array of named font sizes and the namedFontSize and customFontSize values.
 * 	If namedFontSize is undefined or not found in fontSizes an object with just the size value based on customFontSize is returned.
 *
 * @param {Array}   fontSizes               Array of font size objects containing at least the "name" and "size" values as properties.
 * @param {?string} fontSizeAttribute       Content of the font size attribute (slug).
 * @param {?number} customFontSizeAttribute Contents of the custom font size attribute (value).
 *
 * @return {?Object} If fontSizeAttribute is set and an equal slug is found in fontSizes it returns the font size object for that slug.
 * 					 Otherwise, an object with just the size value based on customFontSize is returned.
 */

const utils_getFontSize = (fontSizes, fontSizeAttribute, customFontSizeAttribute) => {
  if (fontSizeAttribute) {
    const fontSizeObject = fontSizes?.find(({
      slug
    }) => slug === fontSizeAttribute);

    if (fontSizeObject) {
      return fontSizeObject;
    }
  }

  return {
    size: customFontSizeAttribute
  };
};
/**
 * Returns the corresponding font size object for a given value.
 *
 * @param {Array}  fontSizes Array of font size objects.
 * @param {number} value     Font size value.
 *
 * @return {Object} Font size object.
 */

function utils_getFontSizeObjectByValue(fontSizes, value) {
  const fontSizeObject = fontSizes?.find(({
    size
  }) => size === value);

  if (fontSizeObject) {
    return fontSizeObject;
  }

  return {
    size: value
  };
}
/**
 * Returns a class based on fontSizeName.
 *
 * @param {string} fontSizeSlug Slug of the fontSize.
 *
 * @return {string | undefined} String with the class corresponding to the fontSize passed.
 *                  The class is generated by appending 'has-' followed by fontSizeSlug in kebabCase and ending with '-font-size'.
 */

function getFontSizeClass(fontSizeSlug) {
  if (!fontSizeSlug) {
    return;
  }

  return `has-${kebabCase(fontSizeSlug)}-font-size`;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/font-size.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */







const FONT_SIZE_SUPPORT_KEY = 'typography.fontSize';
/**
 * Filters registered block settings, extending attributes to include
 * `fontSize` and `fontWeight` attributes.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function font_size_addAttributes(settings) {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, FONT_SIZE_SUPPORT_KEY)) {
    return settings;
  } // Allow blocks to specify a default value if needed.


  if (!settings.attributes.fontSize) {
    Object.assign(settings.attributes, {
      fontSize: {
        type: 'string'
      }
    });
  }

  return settings;
}
/**
 * Override props assigned to save component to inject font size.
 *
 * @param {Object} props      Additional props applied to save element.
 * @param {Object} blockType  Block type.
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */


function font_size_addSaveProps(props, blockType, attributes) {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, FONT_SIZE_SUPPORT_KEY)) {
    return props;
  }

  if (shouldSkipSerialization(blockType, TYPOGRAPHY_SUPPORT_KEY, 'fontSize')) {
    return props;
  } // Use TokenList to dedupe classes.


  const classes = new (external_wp_tokenList_default())(props.className);
  classes.add(getFontSizeClass(attributes.fontSize));
  const newClassName = classes.value;
  props.className = newClassName ? newClassName : undefined;
  return props;
}
/**
 * Filters registered block settings to expand the block edit wrapper
 * by applying the desired styles and classnames.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */


function font_size_addEditProps(settings) {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, FONT_SIZE_SUPPORT_KEY)) {
    return settings;
  }

  const existingGetEditWrapperProps = settings.getEditWrapperProps;

  settings.getEditWrapperProps = attributes => {
    let props = {};

    if (existingGetEditWrapperProps) {
      props = existingGetEditWrapperProps(attributes);
    }

    return font_size_addSaveProps(props, settings, attributes);
  };

  return settings;
}
/**
 * Inspector control panel containing the font size related configuration
 *
 * @param {Object} props
 *
 * @return {WPElement} Font size edit element.
 */


function FontSizeEdit(props) {
  const {
    attributes: {
      fontSize,
      style
    },
    setAttributes
  } = props;
  const fontSizes = useSetting('typography.fontSizes');

  const onChange = value => {
    const fontSizeSlug = getFontSizeObjectByValue(fontSizes, value).slug;
    setAttributes({
      style: cleanEmptyObject({ ...style,
        typography: { ...style?.typography,
          fontSize: fontSizeSlug ? undefined : value
        }
      }),
      fontSize: fontSizeSlug
    });
  };

  const fontSizeObject = getFontSize(fontSizes, fontSize, style?.typography?.fontSize);
  const fontSizeValue = fontSizeObject?.size || style?.typography?.fontSize || fontSize;
  return createElement(FontSizePicker, {
    onChange: onChange,
    value: fontSizeValue,
    withReset: false,
    withSlider: true,
    size: "__unstable-large",
    __nextHasNoMarginBottom: true
  });
}
/**
 * Custom hook that checks if font-size settings have been disabled.
 *
 * @param {string} name The name of the block.
 * @return {boolean} Whether setting is disabled.
 */

function useIsFontSizeDisabled({
  name: blockName
} = {}) {
  const fontSizes = useSetting('typography.fontSizes');
  const hasFontSizes = !!fontSizes?.length;
  return !hasBlockSupport(blockName, FONT_SIZE_SUPPORT_KEY) || !hasFontSizes;
}
/**
 * Add inline styles for font sizes.
 * Ideally, this is not needed and themes load the font-size classes on the
 * editor.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */

const withFontSizeInlineStyles = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(BlockListBlock => props => {
  const fontSizes = use_setting_useSetting('typography.fontSizes');
  const {
    name: blockName,
    attributes: {
      fontSize,
      style
    },
    wrapperProps
  } = props; // Only add inline styles if the block supports font sizes,
  // doesn't skip serialization of font sizes,
  // doesn't already have an inline font size,
  // and does have a class to extract the font size from.

  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockName, FONT_SIZE_SUPPORT_KEY) || shouldSkipSerialization(blockName, TYPOGRAPHY_SUPPORT_KEY, 'fontSize') || !fontSize || style?.typography?.fontSize) {
    return (0,external_wp_element_namespaceObject.createElement)(BlockListBlock, { ...props
    });
  }

  const fontSizeValue = utils_getFontSize(fontSizes, fontSize, style?.typography?.fontSize).size;
  const newProps = { ...props,
    wrapperProps: { ...wrapperProps,
      style: {
        fontSize: fontSizeValue,
        ...wrapperProps?.style
      }
    }
  };
  return (0,external_wp_element_namespaceObject.createElement)(BlockListBlock, { ...newProps
  });
}, 'withFontSizeInlineStyles');
const font_size_MIGRATION_PATHS = {
  fontSize: [['fontSize'], ['style', 'typography', 'fontSize']]
};

function font_size_addTransforms(result, source, index, results) {
  const destinationBlockType = result.name;
  const activeSupports = {
    fontSize: (0,external_wp_blocks_namespaceObject.hasBlockSupport)(destinationBlockType, FONT_SIZE_SUPPORT_KEY)
  };
  return transformStyles(activeSupports, font_size_MIGRATION_PATHS, result, source, index, results);
}
/**
 * Allow custom font sizes to appear fluid when fluid typography is enabled at
 * the theme level.
 *
 * Adds a custom getEditWrapperProps() callback to all block types that support
 * font sizes. Then, if fluid typography is enabled, this callback will swap any
 * custom font size in style.fontSize with a fluid font size (i.e. one that uses
 * clamp()).
 *
 * It's important that this hook runs after 'core/style/addEditProps' sets
 * style.fontSize as otherwise fontSize will be overwritten.
 *
 * @param {Object} blockType Block settings object.
 */


function addEditPropsForFluidCustomFontSizes(blockType) {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, FONT_SIZE_SUPPORT_KEY) || shouldSkipSerialization(blockType, TYPOGRAPHY_SUPPORT_KEY, 'fontSize')) {
    return blockType;
  }

  const existingGetEditWrapperProps = blockType.getEditWrapperProps;

  blockType.getEditWrapperProps = attributes => {
    const wrapperProps = existingGetEditWrapperProps ? existingGetEditWrapperProps(attributes) : {};
    const fontSize = wrapperProps?.style?.fontSize; // TODO: This sucks! We should be using useSetting( 'typography.fluid' )
    // or even useSelect( blockEditorStore ). We can't do either here
    // because getEditWrapperProps is a plain JavaScript function called by
    // BlockListBlock and not a React component rendered within
    // BlockListContext.Provider. If we set fontSize using editor.
    // BlockListBlock instead of using getEditWrapperProps then the value is
    // clobbered when the core/style/addEditProps filter runs.

    const fluidTypographySettings = getFluidTypographyOptionsFromSettings((0,external_wp_data_namespaceObject.select)(store).getSettings().__experimentalFeatures);
    const newFontSize = fontSize ? getTypographyFontSizeValue({
      size: fontSize
    }, fluidTypographySettings) : null;

    if (newFontSize === null) {
      return wrapperProps;
    }

    return { ...wrapperProps,
      style: { ...wrapperProps?.style,
        fontSize: newFontSize
      }
    };
  };

  return blockType;
}

(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/font/addAttribute', font_size_addAttributes);
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.getSaveContent.extraProps', 'core/font/addSaveProps', font_size_addSaveProps);
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/font/addEditProps', font_size_addEditProps);
(0,external_wp_hooks_namespaceObject.addFilter)('editor.BlockListBlock', 'core/font-size/with-font-size-inline-styles', withFontSizeInlineStyles);
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.switchToBlockType.transformedBlock', 'core/font-size/addTransforms', font_size_addTransforms);
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/font-size/addEditPropsForFluidCustomFontSizes', addEditPropsForFluidCustomFontSizes, // Run after 'core/style/addEditProps' so that the style object has already
// been translated into inline CSS.
11);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/typography.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */








function omit(object, keys) {
  return Object.fromEntries(Object.entries(object).filter(([key]) => !keys.includes(key)));
}

const LETTER_SPACING_SUPPORT_KEY = 'typography.__experimentalLetterSpacing';
const TEXT_TRANSFORM_SUPPORT_KEY = 'typography.__experimentalTextTransform';
const TEXT_DECORATION_SUPPORT_KEY = 'typography.__experimentalTextDecoration';
const TEXT_COLUMNS_SUPPORT_KEY = 'typography.textColumns';
const FONT_STYLE_SUPPORT_KEY = 'typography.__experimentalFontStyle';
const FONT_WEIGHT_SUPPORT_KEY = 'typography.__experimentalFontWeight';
const TYPOGRAPHY_SUPPORT_KEY = 'typography';
const TYPOGRAPHY_SUPPORT_KEYS = [LINE_HEIGHT_SUPPORT_KEY, FONT_SIZE_SUPPORT_KEY, FONT_STYLE_SUPPORT_KEY, FONT_WEIGHT_SUPPORT_KEY, FONT_FAMILY_SUPPORT_KEY, TEXT_COLUMNS_SUPPORT_KEY, TEXT_DECORATION_SUPPORT_KEY, TEXT_TRANSFORM_SUPPORT_KEY, LETTER_SPACING_SUPPORT_KEY];

function typography_styleToAttributes(style) {
  const updatedStyle = { ...omit(style, ['fontFamily'])
  };
  const fontSizeValue = style?.typography?.fontSize;
  const fontFamilyValue = style?.typography?.fontFamily;
  const fontSizeSlug = fontSizeValue?.startsWith('var:preset|font-size|') ? fontSizeValue.substring('var:preset|font-size|'.length) : undefined;
  const fontFamilySlug = fontFamilyValue?.startsWith('var:preset|font-family|') ? fontFamilyValue.substring('var:preset|font-family|'.length) : undefined;
  updatedStyle.typography = { ...omit(updatedStyle.typography, ['fontFamily']),
    fontSize: fontSizeSlug ? undefined : fontSizeValue
  };
  return {
    style: utils_cleanEmptyObject(updatedStyle),
    fontFamily: fontFamilySlug,
    fontSize: fontSizeSlug
  };
}

function typography_attributesToStyle(attributes) {
  return { ...attributes.style,
    typography: { ...attributes.style?.typography,
      fontFamily: attributes.fontFamily ? 'var:preset|font-family|' + attributes.fontFamily : undefined,
      fontSize: attributes.fontSize ? 'var:preset|font-size|' + attributes.fontSize : attributes.style?.typography?.fontSize
    }
  };
}

function TypographyInspectorControl({
  children,
  resetAllFilter
}) {
  const attributesResetAllFilter = (0,external_wp_element_namespaceObject.useCallback)(attributes => {
    const existingStyle = typography_attributesToStyle(attributes);
    const updatedStyle = resetAllFilter(existingStyle);
    return { ...attributes,
      ...typography_styleToAttributes(updatedStyle)
    };
  }, [resetAllFilter]);
  return (0,external_wp_element_namespaceObject.createElement)(inspector_controls, {
    group: "typography",
    resetAllFilter: attributesResetAllFilter
  }, children);
}

function typography_TypographyPanel({
  clientId,
  name,
  attributes,
  setAttributes,
  __unstableParentLayout
}) {
  const settings = useBlockSettings(name, __unstableParentLayout);
  const isEnabled = useHasTypographyPanel(settings);
  const value = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return typography_attributesToStyle({
      style: attributes.style,
      fontFamily: attributes.fontFamily,
      fontSize: attributes.fontSize
    });
  }, [attributes.style, attributes.fontSize, attributes.fontFamily]);

  const onChange = newStyle => {
    setAttributes(typography_styleToAttributes(newStyle));
  };

  if (!isEnabled) {
    return null;
  }

  const defaultControls = (0,external_wp_blocks_namespaceObject.getBlockSupport)(name, [TYPOGRAPHY_SUPPORT_KEY, '__experimentalDefaultControls']);
  return (0,external_wp_element_namespaceObject.createElement)(TypographyPanel, {
    as: TypographyInspectorControl,
    panelId: clientId,
    settings: settings,
    value: value,
    onChange: onChange,
    defaultControls: defaultControls
  });
}
const hasTypographySupport = blockName => {
  return TYPOGRAPHY_SUPPORT_KEYS.some(key => hasBlockSupport(blockName, key));
};

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/settings.js


/**
 * WordPress dependencies
 */

const settings_settings = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M14.5 13.8c-1.1 0-2.1.7-2.4 1.8H4V17h8.1c.3 1 1.3 1.8 2.4 1.8s2.1-.7 2.4-1.8H20v-1.5h-3.1c-.3-1-1.3-1.7-2.4-1.7zM11.9 7c-.3-1-1.3-1.8-2.4-1.8S7.4 6 7.1 7H4v1.5h3.1c.3 1 1.3 1.8 2.4 1.8s2.1-.7 2.4-1.8H20V7h-8.1z"
}));
/* harmony default export */ var library_settings = (settings_settings);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/input-controls/spacing-input-control.js


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




const CUSTOM_VALUE_SETTINGS = {
  px: {
    max: 300,
    steps: 1
  },
  '%': {
    max: 100,
    steps: 1
  },
  vw: {
    max: 100,
    steps: 1
  },
  vh: {
    max: 100,
    steps: 1
  },
  em: {
    max: 10,
    steps: 0.1
  },
  rm: {
    max: 10,
    steps: 0.1
  }
};
function SpacingInputControl({
  icon,
  isMixed = false,
  minimumCustomValue,
  onChange,
  onMouseOut,
  onMouseOver,
  showSideInLabel = true,
  side,
  spacingSizes,
  type,
  value
}) {
  var _CUSTOM_VALUE_SETTING, _CUSTOM_VALUE_SETTING2;

  // Treat value as a preset value if the passed in value matches the value of one of the spacingSizes.
  value = getPresetValueFromCustomValue(value, spacingSizes);
  let selectListSizes = spacingSizes;
  const showRangeControl = spacingSizes.length <= 8;
  const disableCustomSpacingSizes = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const editorSettings = select(store).getSettings();
    return editorSettings?.disableCustomSpacingSizes;
  });
  const [showCustomValueControl, setShowCustomValueControl] = (0,external_wp_element_namespaceObject.useState)(!disableCustomSpacingSizes && value !== undefined && !isValueSpacingPreset(value));
  const previousValue = (0,external_wp_compose_namespaceObject.usePrevious)(value);

  if (!!value && previousValue !== value && !isValueSpacingPreset(value) && showCustomValueControl !== true) {
    setShowCustomValueControl(true);
  }

  const units = (0,external_wp_components_namespaceObject.__experimentalUseCustomUnits)({
    availableUnits: use_setting_useSetting('spacing.units') || ['px', 'em', 'rem']
  });
  let currentValue = null;
  const showCustomValueInSelectList = !showRangeControl && !showCustomValueControl && value !== undefined && (!isValueSpacingPreset(value) || isValueSpacingPreset(value) && isMixed);

  if (showCustomValueInSelectList) {
    selectListSizes = [...spacingSizes, {
      name: !isMixed ? // translators: A custom measurement, eg. a number followed by a unit like 12px.
      (0,external_wp_i18n_namespaceObject.sprintf)((0,external_wp_i18n_namespaceObject.__)('Custom (%s)'), value) : (0,external_wp_i18n_namespaceObject.__)('Mixed'),
      slug: 'custom',
      size: value
    }];
    currentValue = selectListSizes.length - 1;
  } else if (!isMixed) {
    currentValue = !showCustomValueControl ? getSliderValueFromPreset(value, spacingSizes) : getCustomValueFromPreset(value, spacingSizes);
  }

  const selectedUnit = (0,external_wp_element_namespaceObject.useMemo)(() => (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(currentValue), [currentValue])[1] || units[0].value;

  const setInitialValue = () => {
    if (value === undefined) {
      onChange('0');
    }
  };

  const customTooltipContent = newValue => value === undefined ? undefined : spacingSizes[newValue]?.name;

  const customRangeValue = parseFloat(currentValue, 10);

  const getNewCustomValue = newSize => {
    const isNumeric = !isNaN(parseFloat(newSize));
    const nextValue = isNumeric ? newSize : undefined;
    return nextValue;
  };

  const getNewPresetValue = (newSize, controlType) => {
    const size = parseInt(newSize, 10);

    if (controlType === 'selectList') {
      if (size === 0) {
        return undefined;
      }

      if (size === 1) {
        return '0';
      }
    } else if (size === 0) {
      return '0';
    }

    return `var:preset|spacing|${spacingSizes[newSize]?.slug}`;
  };

  const handleCustomValueSliderChange = next => {
    onChange([next, selectedUnit].join(''));
  };

  const allPlaceholder = isMixed ? (0,external_wp_i18n_namespaceObject.__)('Mixed') : null;
  const options = selectListSizes.map((size, index) => ({
    key: index,
    name: size.name
  }));
  const marks = spacingSizes.map((_newValue, index) => ({
    value: index,
    label: undefined
  }));
  const sideLabel = ALL_SIDES.includes(side) && showSideInLabel ? LABELS[side] : '';
  const typeLabel = showSideInLabel ? type?.toLowerCase() : type;
  const ariaLabel = (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: The side of the block being modified (top, bottom, left, All sides etc.). 2. Type of spacing being modified (Padding, margin, etc)
  (0,external_wp_i18n_namespaceObject.__)('%1$s %2$s'), sideLabel, typeLabel).trim();
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHStack, {
    className: "spacing-sizes-control__wrapper"
  }, icon && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Icon, {
    className: "spacing-sizes-control__icon",
    icon: icon,
    size: 24
  }), showCustomValueControl && (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalUnitControl, {
    onMouseOver: onMouseOver,
    onMouseOut: onMouseOut,
    onFocus: onMouseOver,
    onBlur: onMouseOut,
    onChange: newSize => onChange(getNewCustomValue(newSize)),
    value: currentValue,
    units: units,
    min: minimumCustomValue,
    placeholder: allPlaceholder,
    disableUnits: isMixed,
    label: ariaLabel,
    hideLabelFromVision: true,
    className: "spacing-sizes-control__custom-value-input",
    size: '__unstable-large'
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.RangeControl, {
    onMouseOver: onMouseOver,
    onMouseOut: onMouseOut,
    onFocus: onMouseOver,
    onBlur: onMouseOut,
    value: customRangeValue,
    min: 0,
    max: (_CUSTOM_VALUE_SETTING = CUSTOM_VALUE_SETTINGS[selectedUnit]?.max) !== null && _CUSTOM_VALUE_SETTING !== void 0 ? _CUSTOM_VALUE_SETTING : 10,
    step: (_CUSTOM_VALUE_SETTING2 = CUSTOM_VALUE_SETTINGS[selectedUnit]?.steps) !== null && _CUSTOM_VALUE_SETTING2 !== void 0 ? _CUSTOM_VALUE_SETTING2 : 0.1,
    withInputField: false,
    onChange: handleCustomValueSliderChange,
    className: "spacing-sizes-control__custom-value-range",
    __nextHasNoMarginBottom: true
  })), showRangeControl && !showCustomValueControl && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.RangeControl, {
    onMouseOver: onMouseOver,
    onMouseOut: onMouseOut,
    className: "spacing-sizes-control__range-control",
    value: currentValue,
    onChange: newSize => onChange(getNewPresetValue(newSize)),
    onMouseDown: event => {
      // If mouse down is near start of range set initial value to 0, which
      // prevents the user have to drag right then left to get 0 setting.
      if (event?.nativeEvent?.offsetX < 35) {
        setInitialValue();
      }
    },
    withInputField: false,
    "aria-valuenow": currentValue,
    "aria-valuetext": spacingSizes[currentValue]?.name,
    renderTooltipContent: customTooltipContent,
    min: 0,
    max: spacingSizes.length - 1,
    marks: marks,
    label: ariaLabel,
    hideLabelFromVision: true,
    __nextHasNoMarginBottom: true,
    onFocus: onMouseOver,
    onBlur: onMouseOut
  }), !showRangeControl && !showCustomValueControl && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.CustomSelectControl, {
    className: "spacing-sizes-control__custom-select-control",
    value: options.find(option => option.key === currentValue) || '' // passing undefined here causes a downshift controlled/uncontrolled warning
    ,
    onChange: selection => {
      onChange(getNewPresetValue(selection.selectedItem.key, 'selectList'));
    },
    options: options,
    label: ariaLabel,
    hideLabelFromVision: true,
    __nextUnconstrainedWidth: true,
    size: '__unstable-large',
    onMouseOver: onMouseOver,
    onMouseOut: onMouseOut,
    onFocus: onMouseOver,
    onBlur: onMouseOut
  }), !disableCustomSpacingSizes && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    label: showCustomValueControl ? (0,external_wp_i18n_namespaceObject.__)('Use size preset') : (0,external_wp_i18n_namespaceObject.__)('Set custom size'),
    icon: library_settings,
    onClick: () => {
      setShowCustomValueControl(!showCustomValueControl);
    },
    isPressed: showCustomValueControl,
    isSmall: true,
    className: "spacing-sizes-control__custom-toggle",
    iconSize: 24
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/input-controls/axial.js


/**
 * Internal dependencies
 */


const groupedSides = ['vertical', 'horizontal'];
function AxialInputControls({
  minimumCustomValue,
  onChange,
  onMouseOut,
  onMouseOver,
  sides,
  spacingSizes,
  type,
  values
}) {
  const createHandleOnChange = side => next => {
    if (!onChange) {
      return;
    } // Encode the existing value into the preset value if the passed in value matches the value of one of the spacingSizes.


    const nextValues = { ...Object.keys(values).reduce((acc, key) => {
        acc[key] = getPresetValueFromCustomValue(values[key], spacingSizes);
        return acc;
      }, {})
    };

    if (side === 'vertical') {
      nextValues.top = next;
      nextValues.bottom = next;
    }

    if (side === 'horizontal') {
      nextValues.left = next;
      nextValues.right = next;
    }

    onChange(nextValues);
  }; // Filter sides if custom configuration provided, maintaining default order.


  const filteredSides = sides?.length ? groupedSides.filter(side => hasAxisSupport(sides, side)) : groupedSides;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, filteredSides.map(side => {
    const axisValue = side === 'vertical' ? values.top : values.left;
    return (0,external_wp_element_namespaceObject.createElement)(SpacingInputControl, {
      key: `spacing-sizes-control-${side}`,
      icon: ICONS[side],
      label: LABELS[side],
      minimumCustomValue: minimumCustomValue,
      onChange: createHandleOnChange(side),
      onMouseOut: onMouseOut,
      onMouseOver: onMouseOver,
      side: side,
      spacingSizes: spacingSizes,
      type: type,
      value: axisValue,
      withInputField: false
    });
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/input-controls/separated.js


/**
 * Internal dependencies
 */


function SeparatedInputControls({
  minimumCustomValue,
  onChange,
  onMouseOut,
  onMouseOver,
  sides,
  spacingSizes,
  type,
  values
}) {
  // Filter sides if custom configuration provided, maintaining default order.
  const filteredSides = sides?.length ? ALL_SIDES.filter(side => sides.includes(side)) : ALL_SIDES;

  const createHandleOnChange = side => next => {
    // Encode the existing value into the preset value if the passed in value matches the value of one of the spacingSizes.
    const nextValues = { ...Object.keys(values).reduce((acc, key) => {
        acc[key] = getPresetValueFromCustomValue(values[key], spacingSizes);
        return acc;
      }, {})
    };
    nextValues[side] = next;
    onChange(nextValues);
  };

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, filteredSides.map(side => {
    return (0,external_wp_element_namespaceObject.createElement)(SpacingInputControl, {
      key: `spacing-sizes-control-${side}`,
      icon: ICONS[side],
      label: LABELS[side],
      minimumCustomValue: minimumCustomValue,
      onChange: createHandleOnChange(side),
      onMouseOut: onMouseOut,
      onMouseOver: onMouseOver,
      side: side,
      spacingSizes: spacingSizes,
      type: type,
      value: values[side],
      withInputField: false
    });
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/input-controls/single.js


/**
 * Internal dependencies
 */


function SingleInputControl({
  minimumCustomValue,
  onChange,
  onMouseOut,
  onMouseOver,
  showSideInLabel,
  side,
  spacingSizes,
  type,
  values
}) {
  const createHandleOnChange = currentSide => next => {
    // Encode the existing value into the preset value if the passed in value matches the value of one of the spacingSizes.
    const nextValues = { ...Object.keys(values).reduce((acc, key) => {
        acc[key] = getPresetValueFromCustomValue(values[key], spacingSizes);
        return acc;
      }, {})
    };
    nextValues[currentSide] = next;
    onChange(nextValues);
  };

  return (0,external_wp_element_namespaceObject.createElement)(SpacingInputControl, {
    label: LABELS[side],
    minimumCustomValue: minimumCustomValue,
    onChange: createHandleOnChange(side),
    onMouseOut: onMouseOut,
    onMouseOver: onMouseOver,
    showSideInLabel: showSideInLabel,
    side: side,
    spacingSizes: spacingSizes,
    type: type,
    value: values[side],
    withInputField: false
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/check.js


/**
 * WordPress dependencies
 */

const check_check = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M16.7 7.1l-6.3 8.5-3.3-2.5-.9 1.2 4.5 3.4L17.9 8z"
}));
/* harmony default export */ var library_check = (check_check);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/sides-dropdown/index.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


const checkIcon = (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Icon, {
  icon: library_check,
  size: 24
});
function SidesDropdown({
  label: labelProp,
  onChange,
  sides,
  value
}) {
  if (!sides || !sides.length) {
    return;
  }

  const supportedItems = getSupportedMenuItems(sides);
  const sideIcon = supportedItems[value].icon;
  const {
    custom: customItem,
    ...menuItems
  } = supportedItems;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.DropdownMenu, {
    icon: sideIcon,
    label: labelProp,
    className: "spacing-sizes-control__dropdown",
    toggleProps: {
      isSmall: true
    }
  }, ({
    onClose
  }) => {
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuGroup, null, Object.entries(menuItems).map(([slug, {
      label,
      icon
    }]) => {
      const isSelected = value === slug;
      return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
        key: slug,
        icon: icon,
        iconPosition: "left",
        isSelected: isSelected,
        role: "menuitemradio",
        onClick: () => {
          onChange(slug);
          onClose();
        },
        suffix: isSelected ? checkIcon : undefined
      }, label);
    })), !!customItem && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuGroup, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
      icon: customItem.icon,
      iconPosition: "left",
      isSelected: value === VIEWS.custom,
      role: "menuitemradio",
      onClick: () => {
        onChange(VIEWS.custom);
        onClose();
      },
      suffix: value === VIEWS.custom ? checkIcon : undefined
    }, customItem.label)));
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/hooks/use-spacing-sizes.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


function useSpacingSizes() {
  const spacingSizes = [{
    name: 0,
    slug: '0',
    size: 0
  }, ...(use_setting_useSetting('spacing.spacingSizes') || [])];

  if (spacingSizes.length > 8) {
    spacingSizes.unshift({
      name: (0,external_wp_i18n_namespaceObject.__)('Default'),
      slug: 'default',
      size: undefined
    });
  }

  return spacingSizes;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/index.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */







function SpacingSizesControl({
  inputProps,
  label: labelProp,
  minimumCustomValue = 0,
  onChange,
  onMouseOut,
  onMouseOver,
  showSideInLabel = true,
  sides = ALL_SIDES,
  useSelect,
  values
}) {
  const spacingSizes = useSpacingSizes();
  const inputValues = values || DEFAULT_VALUES;
  const hasOneSide = sides?.length === 1;
  const hasOnlyAxialSides = sides?.includes('horizontal') && sides?.includes('vertical') && sides?.length === 2;
  const [view, setView] = (0,external_wp_element_namespaceObject.useState)(getInitialView(inputValues, sides));

  const handleOnChange = nextValue => {
    const newValues = { ...values,
      ...nextValue
    };
    onChange(newValues);
  };

  const inputControlProps = { ...inputProps,
    minimumCustomValue,
    onChange: handleOnChange,
    onMouseOut,
    onMouseOver,
    sides,
    spacingSizes,
    type: labelProp,
    useSelect,
    values: inputValues
  };

  const renderControls = () => {
    if (view === VIEWS.axial) {
      return (0,external_wp_element_namespaceObject.createElement)(AxialInputControls, { ...inputControlProps
      });
    }

    if (view === VIEWS.custom) {
      return (0,external_wp_element_namespaceObject.createElement)(SeparatedInputControls, { ...inputControlProps
      });
    }

    return (0,external_wp_element_namespaceObject.createElement)(SingleInputControl, {
      side: view,
      ...inputControlProps,
      showSideInLabel: showSideInLabel
    });
  };

  const sideLabel = ALL_SIDES.includes(view) && showSideInLabel ? LABELS[view] : '';
  const label = (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 2. Type of spacing being modified (Padding, margin, etc). 1: The side of the block being modified (top, bottom, left etc.).
  (0,external_wp_i18n_namespaceObject.__)('%1$s %2$s'), labelProp, sideLabel).trim();
  const dropdownLabelText = (0,external_wp_i18n_namespaceObject.sprintf)( // translators: %s: The current spacing property e.g. "Padding", "Margin".
  (0,external_wp_i18n_namespaceObject._x)('%s options', 'Button label to reveal side configuration options'), labelProp);
  return (0,external_wp_element_namespaceObject.createElement)("fieldset", {
    className: "spacing-sizes-control"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHStack, {
    className: "spacing-sizes-control__header"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.BaseControl.VisualLabel, {
    as: "legend",
    className: "spacing-sizes-control__label"
  }, label), !hasOneSide && !hasOnlyAxialSides && (0,external_wp_element_namespaceObject.createElement)(SidesDropdown, {
    label: dropdownLabelText,
    onChange: setView,
    sides: sides,
    value: view
  })), renderControls());
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/height-control/index.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


const RANGE_CONTROL_CUSTOM_SETTINGS = {
  px: {
    max: 1000,
    step: 1
  },
  '%': {
    max: 100,
    step: 1
  },
  vw: {
    max: 100,
    step: 1
  },
  vh: {
    max: 100,
    step: 1
  },
  em: {
    max: 50,
    step: 0.1
  },
  rem: {
    max: 50,
    step: 0.1
  }
};
/**
 * HeightControl renders a linked unit control and range control for adjusting the height of a block.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/height-control/README.md
 *
 * @param {Object}                     props
 * @param {?string}                    props.label    A label for the control.
 * @param {( value: string ) => void } props.onChange Called when the height changes.
 * @param {string}                     props.value    The current height value.
 *
 * @return {WPComponent} The component to be rendered.
 */

function HeightControl({
  label = (0,external_wp_i18n_namespaceObject.__)('Height'),
  onChange,
  value
}) {
  var _RANGE_CONTROL_CUSTOM, _RANGE_CONTROL_CUSTOM2;

  const customRangeValue = parseFloat(value);
  const units = (0,external_wp_components_namespaceObject.__experimentalUseCustomUnits)({
    availableUnits: use_setting_useSetting('spacing.units') || ['%', 'px', 'em', 'rem', 'vh', 'vw']
  });
  const selectedUnit = (0,external_wp_element_namespaceObject.useMemo)(() => (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(value), [value])[1] || units[0]?.value || 'px';

  const handleSliderChange = next => {
    onChange([next, selectedUnit].join(''));
  };

  const handleUnitChange = newUnit => {
    // Attempt to smooth over differences between currentUnit and newUnit.
    // This should slightly improve the experience of switching between unit types.
    const [currentValue, currentUnit] = (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(value);

    if (['em', 'rem'].includes(newUnit) && currentUnit === 'px') {
      // Convert pixel value to an approximate of the new unit, assuming a root size of 16px.
      onChange((currentValue / 16).toFixed(2) + newUnit);
    } else if (['em', 'rem'].includes(currentUnit) && newUnit === 'px') {
      // Convert to pixel value assuming a root size of 16px.
      onChange(Math.round(currentValue * 16) + newUnit);
    } else if (['vh', 'vw', '%'].includes(newUnit) && currentValue > 100) {
      // When converting to `vh`, `vw`, or `%` units, cap the new value at 100.
      onChange(100 + newUnit);
    }
  };

  return (0,external_wp_element_namespaceObject.createElement)("fieldset", {
    className: "block-editor-height-control"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.BaseControl.VisualLabel, {
    as: "legend"
  }, label), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Flex, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, {
    isBlock: true
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalUnitControl, {
    value: value,
    units: units,
    onChange: onChange,
    onUnitChange: handleUnitChange,
    min: 0,
    size: '__unstable-large'
  })), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, {
    isBlock: true
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalSpacer, {
    marginX: 2,
    marginBottom: 0
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.RangeControl, {
    value: customRangeValue,
    min: 0,
    max: (_RANGE_CONTROL_CUSTOM = RANGE_CONTROL_CUSTOM_SETTINGS[selectedUnit]?.max) !== null && _RANGE_CONTROL_CUSTOM !== void 0 ? _RANGE_CONTROL_CUSTOM : 100,
    step: (_RANGE_CONTROL_CUSTOM2 = RANGE_CONTROL_CUSTOM_SETTINGS[selectedUnit]?.step) !== null && _RANGE_CONTROL_CUSTOM2 !== void 0 ? _RANGE_CONTROL_CUSTOM2 : 0.1,
    withInputField: false,
    onChange: handleSliderChange,
    __nextHasNoMarginBottom: true
  })))));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/child-layout-control/index.js


/**
 * WordPress dependencies
 */




function helpText(selfStretch, parentLayout) {
  const {
    orientation = 'horizontal'
  } = parentLayout;

  if (selfStretch === 'fill') {
    return (0,external_wp_i18n_namespaceObject.__)('Stretch to fill available space.');
  }

  if (selfStretch === 'fixed' && orientation === 'horizontal') {
    return (0,external_wp_i18n_namespaceObject.__)('Specify a fixed width.');
  } else if (selfStretch === 'fixed') {
    return (0,external_wp_i18n_namespaceObject.__)('Specify a fixed height.');
  }

  return (0,external_wp_i18n_namespaceObject.__)('Fit contents.');
}
/**
 * Form to edit the child layout value.
 *
 * @param {Object}   props              Props.
 * @param {Object}   props.value        The child layout value.
 * @param {Function} props.onChange     Function to update the child layout value.
 * @param {Object}   props.parentLayout The parent layout value.
 *
 * @return {WPElement} child layout edit element.
 */


function ChildLayoutControl({
  value: childLayout = {},
  onChange,
  parentLayout
}) {
  const {
    selfStretch,
    flexSize
  } = childLayout;
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (selfStretch === 'fixed' && !flexSize) {
      onChange({ ...childLayout,
        selfStretch: 'fit'
      });
    }
  }, []);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToggleGroupControl, {
    __nextHasNoMarginBottom: true,
    size: '__unstable-large',
    label: childLayoutOrientation(parentLayout),
    value: selfStretch || 'fit',
    help: helpText(selfStretch, parentLayout),
    onChange: value => {
      const newFlexSize = value !== 'fixed' ? null : flexSize;
      onChange({ ...childLayout,
        selfStretch: value,
        flexSize: newFlexSize
      });
    },
    isBlock: true
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToggleGroupControlOption, {
    key: 'fit',
    value: 'fit',
    label: (0,external_wp_i18n_namespaceObject.__)('Fit')
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToggleGroupControlOption, {
    key: 'fill',
    value: 'fill',
    label: (0,external_wp_i18n_namespaceObject.__)('Fill')
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToggleGroupControlOption, {
    key: 'fixed',
    value: 'fixed',
    label: (0,external_wp_i18n_namespaceObject.__)('Fixed')
  })), selfStretch === 'fixed' && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalUnitControl, {
    size: '__unstable-large',
    onChange: value => {
      onChange({ ...childLayout,
        flexSize: value
      });
    },
    value: flexSize
  }));
}
function childLayoutOrientation(parentLayout) {
  const {
    orientation = 'horizontal'
  } = parentLayout;
  return orientation === 'horizontal' ? (0,external_wp_i18n_namespaceObject.__)('Width') : (0,external_wp_i18n_namespaceObject.__)('Height');
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/global-styles/dimensions-panel.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */







const AXIAL_SIDES = ['horizontal', 'vertical'];
function useHasDimensionsPanel(settings) {
  const hasContentSize = useHasContentSize(settings);
  const hasWideSize = useHasWideSize(settings);
  const hasPadding = useHasPadding(settings);
  const hasMargin = useHasMargin(settings);
  const hasGap = useHasGap(settings);
  const hasMinHeight = useHasMinHeight(settings);
  const hasChildLayout = useHasChildLayout(settings);
  return external_wp_element_namespaceObject.Platform.OS === 'web' && (hasContentSize || hasWideSize || hasPadding || hasMargin || hasGap || hasMinHeight || hasChildLayout);
}

function useHasContentSize(settings) {
  return settings?.layout?.contentSize;
}

function useHasWideSize(settings) {
  return settings?.layout?.wideSize;
}

function useHasPadding(settings) {
  return settings?.spacing?.padding;
}

function useHasMargin(settings) {
  return settings?.spacing?.margin;
}

function useHasGap(settings) {
  return settings?.spacing?.blockGap;
}

function useHasMinHeight(settings) {
  return settings?.dimensions?.minHeight;
}

function useHasChildLayout(settings) {
  var _settings$parentLayou;

  const {
    type: parentLayoutType = 'default',
    default: {
      type: defaultParentLayoutType = 'default'
    } = {},
    allowSizingOnChildren = false
  } = (_settings$parentLayou = settings?.parentLayout) !== null && _settings$parentLayou !== void 0 ? _settings$parentLayou : {};
  const support = (defaultParentLayoutType === 'flex' || parentLayoutType === 'flex') && allowSizingOnChildren;
  return !!settings?.layout && support;
}

function useHasSpacingPresets(settings) {
  var _ref, _ref2;

  const {
    custom,
    theme,
    default: defaultPresets
  } = settings?.spacing?.spacingSizes || {};
  const presets = (_ref = (_ref2 = custom !== null && custom !== void 0 ? custom : theme) !== null && _ref2 !== void 0 ? _ref2 : defaultPresets) !== null && _ref !== void 0 ? _ref : [];
  return presets.length > 0;
}

function filterValuesBySides(values, sides) {
  // If no custom side configuration, all sides are opted into by default.
  // Without any values, we have nothing to filter either.
  if (!sides || !values) {
    return values;
  } // Only include sides opted into within filtered values.


  const filteredValues = {};
  sides.forEach(side => {
    if (side === 'vertical') {
      filteredValues.top = values.top;
      filteredValues.bottom = values.bottom;
    }

    if (side === 'horizontal') {
      filteredValues.left = values.left;
      filteredValues.right = values.right;
    }

    filteredValues[side] = values?.[side];
  });
  return filteredValues;
}

function splitStyleValue(value) {
  // Check for shorthand value (a string value).
  if (value && typeof value === 'string') {
    // Convert to value for individual sides for BoxControl.
    return {
      top: value,
      right: value,
      bottom: value,
      left: value
    };
  }

  return value;
}

function splitGapValue(value) {
  // Check for shorthand value (a string value).
  if (value && typeof value === 'string') {
    // If the value is a string, treat it as a single side (top) for the spacing controls.
    return {
      top: value
    };
  }

  if (value) {
    return { ...value,
      right: value?.left,
      bottom: value?.top
    };
  }

  return value;
}

function DimensionsToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children
}) {
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanel, {
    label: (0,external_wp_i18n_namespaceObject.__)('Dimensions'),
    resetAll: resetAll,
    panelId: panelId
  }, children);
}

const dimensions_panel_DEFAULT_CONTROLS = {
  contentSize: true,
  wideSize: true,
  padding: true,
  margin: true,
  blockGap: true,
  minHeight: true,
  childLayout: true
};
function DimensionsPanel({
  as: Wrapper = DimensionsToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  defaultControls = dimensions_panel_DEFAULT_CONTROLS,
  onVisualize = () => {},
  // Special case because the layout controls are not part of the dimensions panel
  // in global styles but not in block inspector.
  includeLayoutControls = false
}) {
  var _settings$parentLayou2, _defaultControls$cont, _defaultControls$wide, _defaultControls$padd, _defaultControls$marg, _defaultControls$bloc, _defaultControls$minH, _defaultControls$chil;

  const {
    dimensions,
    spacing
  } = settings;

  const decodeValue = rawValue => {
    if (rawValue && typeof rawValue === 'object') {
      return Object.keys(rawValue).reduce((acc, key) => {
        acc[key] = getValueFromVariable({
          settings: {
            dimensions,
            spacing
          }
        }, '', rawValue[key]);
        return acc;
      }, {});
    }

    return getValueFromVariable({
      settings: {
        dimensions,
        spacing
      }
    }, '', rawValue);
  };

  const showSpacingPresetsControl = useHasSpacingPresets(settings);
  const units = (0,external_wp_components_namespaceObject.__experimentalUseCustomUnits)({
    availableUnits: settings?.spacing?.units || ['%', 'px', 'em', 'rem', 'vw']
  }); // Content Size

  const showContentSizeControl = useHasContentSize(settings) && includeLayoutControls;
  const contentSizeValue = decodeValue(inheritedValue?.layout?.contentSize);

  const setContentSizeValue = newValue => {
    onChange(setImmutably(value, ['layout', 'contentSize'], newValue || undefined));
  };

  const hasUserSetContentSizeValue = () => !!value?.layout?.contentSize;

  const resetContentSizeValue = () => setContentSizeValue(undefined); // Wide Size


  const showWideSizeControl = useHasWideSize(settings) && includeLayoutControls;
  const wideSizeValue = decodeValue(inheritedValue?.layout?.wideSize);

  const setWideSizeValue = newValue => {
    onChange(setImmutably(value, ['layout', 'wideSize'], newValue || undefined));
  };

  const hasUserSetWideSizeValue = () => !!value?.layout?.wideSize;

  const resetWideSizeValue = () => setWideSizeValue(undefined); // Padding


  const showPaddingControl = useHasPadding(settings);
  const rawPadding = decodeValue(inheritedValue?.spacing?.padding);
  const paddingValues = splitStyleValue(rawPadding);
  const paddingSides = Array.isArray(settings?.spacing?.padding) ? settings?.spacing?.padding : settings?.spacing?.padding?.sides;
  const isAxialPadding = paddingSides && paddingSides.some(side => AXIAL_SIDES.includes(side));

  const setPaddingValues = newPaddingValues => {
    const padding = filterValuesBySides(newPaddingValues, paddingSides);
    onChange(setImmutably(value, ['spacing', 'padding'], padding));
  };

  const hasPaddingValue = () => !!value?.spacing?.padding && Object.keys(value?.spacing?.padding).length;

  const resetPaddingValue = () => setPaddingValues(undefined);

  const onMouseOverPadding = () => onVisualize('padding'); // Margin


  const showMarginControl = useHasMargin(settings);
  const rawMargin = decodeValue(inheritedValue?.spacing?.margin);
  const marginValues = splitStyleValue(rawMargin);
  const marginSides = Array.isArray(settings?.spacing?.margin) ? settings?.spacing?.margin : settings?.spacing?.margin?.sides;
  const isAxialMargin = marginSides && marginSides.some(side => AXIAL_SIDES.includes(side));

  const setMarginValues = newMarginValues => {
    const margin = filterValuesBySides(newMarginValues, marginSides);
    onChange(setImmutably(value, ['spacing', 'margin'], margin));
  };

  const hasMarginValue = () => !!value?.spacing?.margin && Object.keys(value?.spacing?.margin).length;

  const resetMarginValue = () => setMarginValues(undefined);

  const onMouseOverMargin = () => onVisualize('margin'); // Block Gap


  const showGapControl = useHasGap(settings);
  const gapValue = decodeValue(inheritedValue?.spacing?.blockGap);
  const gapValues = splitGapValue(gapValue);
  const gapSides = Array.isArray(settings?.spacing?.blockGap) ? settings?.spacing?.blockGap : settings?.spacing?.blockGap?.sides;
  const isAxialGap = gapSides && gapSides.some(side => AXIAL_SIDES.includes(side));

  const setGapValue = newGapValue => {
    onChange(setImmutably(value, ['spacing', 'blockGap'], newGapValue));
  };

  const setGapValues = nextBoxGapValue => {
    if (!nextBoxGapValue) {
      setGapValue(null);
    } // If axial gap is not enabled, treat the 'top' value as the shorthand gap value.


    if (!isAxialGap && nextBoxGapValue?.hasOwnProperty('top')) {
      setGapValue(nextBoxGapValue.top);
    } else {
      setGapValue({
        top: nextBoxGapValue?.top,
        left: nextBoxGapValue?.left
      });
    }
  };

  const resetGapValue = () => setGapValue(undefined);

  const hasGapValue = () => !!value?.spacing?.blockGap; // Min Height


  const showMinHeightControl = useHasMinHeight(settings);
  const minHeightValue = decodeValue(inheritedValue?.dimensions?.minHeight);

  const setMinHeightValue = newValue => {
    onChange(setImmutably(value, ['dimensions', 'minHeight'], newValue));
  };

  const resetMinHeightValue = () => {
    setMinHeightValue(undefined);
  };

  const hasMinHeightValue = () => !!value?.dimensions?.minHeight; // Child Layout


  const showChildLayoutControl = useHasChildLayout(settings);
  const childLayout = inheritedValue?.layout;
  const {
    orientation = 'horizontal'
  } = (_settings$parentLayou2 = settings?.parentLayout) !== null && _settings$parentLayou2 !== void 0 ? _settings$parentLayou2 : {};
  const childLayoutOrientationLabel = orientation === 'horizontal' ? (0,external_wp_i18n_namespaceObject.__)('Width') : (0,external_wp_i18n_namespaceObject.__)('Height');

  const setChildLayout = newChildLayout => {
    onChange({ ...value,
      layout: { ...value?.layout,
        ...newChildLayout
      }
    });
  };

  const resetChildLayoutValue = () => {
    setChildLayout({
      selfStretch: undefined,
      flexSize: undefined
    });
  };

  const hasChildLayoutValue = () => !!value?.layout;

  const resetAllFilter = (0,external_wp_element_namespaceObject.useCallback)(previousValue => {
    return { ...previousValue,
      layout: utils_cleanEmptyObject({ ...previousValue?.layout,
        contentSize: undefined,
        wideSize: undefined,
        selfStretch: undefined,
        flexSize: undefined
      }),
      spacing: { ...previousValue?.spacing,
        padding: undefined,
        margin: undefined,
        blockGap: undefined
      },
      dimensions: { ...previousValue?.dimensions,
        minHeight: undefined
      }
    };
  }, []);

  const onMouseLeaveControls = () => onVisualize(false);

  return (0,external_wp_element_namespaceObject.createElement)(Wrapper, {
    resetAllFilter: resetAllFilter,
    value: value,
    onChange: onChange,
    panelId: panelId
  }, (showContentSizeControl || showWideSizeControl) && (0,external_wp_element_namespaceObject.createElement)("span", {
    className: "span-columns"
  }, (0,external_wp_i18n_namespaceObject.__)('Set the width of the main content area.')), showContentSizeControl && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    className: "single-column",
    label: (0,external_wp_i18n_namespaceObject.__)('Content size'),
    hasValue: hasUserSetContentSizeValue,
    onDeselect: resetContentSizeValue,
    isShownByDefault: (_defaultControls$cont = defaultControls.contentSize) !== null && _defaultControls$cont !== void 0 ? _defaultControls$cont : dimensions_panel_DEFAULT_CONTROLS.contentSize,
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHStack, {
    alignment: "flex-end",
    justify: "flex-start"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalUnitControl, {
    label: (0,external_wp_i18n_namespaceObject.__)('Content'),
    labelPosition: "top",
    __unstableInputWidth: "80px",
    value: contentSizeValue || '',
    onChange: nextContentSize => {
      setContentSizeValue(nextContentSize);
    },
    units: units
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalView, null, (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
    icon: position_center
  })))), showWideSizeControl && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    className: "single-column",
    label: (0,external_wp_i18n_namespaceObject.__)('Wide size'),
    hasValue: hasUserSetWideSizeValue,
    onDeselect: resetWideSizeValue,
    isShownByDefault: (_defaultControls$wide = defaultControls.wideSize) !== null && _defaultControls$wide !== void 0 ? _defaultControls$wide : dimensions_panel_DEFAULT_CONTROLS.wideSize,
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHStack, {
    alignment: "flex-end",
    justify: "flex-start"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalUnitControl, {
    label: (0,external_wp_i18n_namespaceObject.__)('Wide'),
    labelPosition: "top",
    __unstableInputWidth: "80px",
    value: wideSizeValue || '',
    onChange: nextWideSize => {
      setWideSizeValue(nextWideSize);
    },
    units: units
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalView, null, (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
    icon: stretch_wide
  })))), showPaddingControl && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    hasValue: hasPaddingValue,
    label: (0,external_wp_i18n_namespaceObject.__)('Padding'),
    onDeselect: resetPaddingValue,
    isShownByDefault: (_defaultControls$padd = defaultControls.padding) !== null && _defaultControls$padd !== void 0 ? _defaultControls$padd : dimensions_panel_DEFAULT_CONTROLS.padding,
    className: classnames_default()({
      'tools-panel-item-spacing': showSpacingPresetsControl
    }),
    panelId: panelId
  }, !showSpacingPresetsControl && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalBoxControl, {
    values: paddingValues,
    onChange: setPaddingValues,
    label: (0,external_wp_i18n_namespaceObject.__)('Padding'),
    sides: paddingSides,
    units: units,
    allowReset: false,
    splitOnAxis: isAxialPadding,
    onMouseOver: onMouseOverPadding,
    onMouseOut: onMouseLeaveControls
  }), showSpacingPresetsControl && (0,external_wp_element_namespaceObject.createElement)(SpacingSizesControl, {
    values: paddingValues,
    onChange: setPaddingValues,
    label: (0,external_wp_i18n_namespaceObject.__)('Padding'),
    sides: paddingSides,
    units: units,
    allowReset: false,
    onMouseOver: onMouseOverPadding,
    onMouseOut: onMouseLeaveControls
  })), showMarginControl && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    hasValue: hasMarginValue,
    label: (0,external_wp_i18n_namespaceObject.__)('Margin'),
    onDeselect: resetMarginValue,
    isShownByDefault: (_defaultControls$marg = defaultControls.margin) !== null && _defaultControls$marg !== void 0 ? _defaultControls$marg : dimensions_panel_DEFAULT_CONTROLS.margin,
    className: classnames_default()({
      'tools-panel-item-spacing': showSpacingPresetsControl
    }),
    panelId: panelId
  }, !showSpacingPresetsControl && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalBoxControl, {
    values: marginValues,
    onChange: setMarginValues,
    label: (0,external_wp_i18n_namespaceObject.__)('Margin'),
    sides: marginSides,
    units: units,
    allowReset: false,
    splitOnAxis: isAxialMargin,
    onMouseOver: onMouseOverMargin,
    onMouseOut: onMouseLeaveControls
  }), showSpacingPresetsControl && (0,external_wp_element_namespaceObject.createElement)(SpacingSizesControl, {
    values: marginValues,
    onChange: setMarginValues,
    label: (0,external_wp_i18n_namespaceObject.__)('Margin'),
    sides: marginSides,
    units: units,
    allowReset: false,
    onMouseOver: onMouseOverMargin,
    onMouseOut: onMouseLeaveControls
  })), showGapControl && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    hasValue: hasGapValue,
    label: (0,external_wp_i18n_namespaceObject.__)('Block spacing'),
    onDeselect: resetGapValue,
    isShownByDefault: (_defaultControls$bloc = defaultControls.blockGap) !== null && _defaultControls$bloc !== void 0 ? _defaultControls$bloc : dimensions_panel_DEFAULT_CONTROLS.blockGap,
    className: classnames_default()({
      'tools-panel-item-spacing': showSpacingPresetsControl
    }),
    panelId: panelId
  }, !showSpacingPresetsControl && (isAxialGap ? (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalBoxControl, {
    label: (0,external_wp_i18n_namespaceObject.__)('Block spacing'),
    min: 0,
    onChange: setGapValues,
    units: units,
    sides: gapSides,
    values: gapValues,
    allowReset: false,
    splitOnAxis: isAxialGap
  }) : (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalUnitControl, {
    label: (0,external_wp_i18n_namespaceObject.__)('Block spacing'),
    __unstableInputWidth: "80px",
    min: 0,
    onChange: setGapValue,
    units: units,
    value: gapValue
  })), showSpacingPresetsControl && (0,external_wp_element_namespaceObject.createElement)(SpacingSizesControl, {
    label: (0,external_wp_i18n_namespaceObject.__)('Block spacing'),
    min: 0,
    onChange: setGapValues,
    showSideInLabel: false,
    sides: isAxialGap ? gapSides : ['top'] // Use 'top' as the shorthand property in non-axial configurations.
    ,
    values: gapValues,
    allowReset: false
  })), showMinHeightControl && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    hasValue: hasMinHeightValue,
    label: (0,external_wp_i18n_namespaceObject.__)('Min. height'),
    onDeselect: resetMinHeightValue,
    isShownByDefault: (_defaultControls$minH = defaultControls.minHeight) !== null && _defaultControls$minH !== void 0 ? _defaultControls$minH : dimensions_panel_DEFAULT_CONTROLS.minHeight,
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(HeightControl, {
    label: (0,external_wp_i18n_namespaceObject.__)('Min. height'),
    value: minHeightValue,
    onChange: setMinHeightValue
  })), showChildLayoutControl && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalVStack, {
    as: external_wp_components_namespaceObject.__experimentalToolsPanelItem,
    spacing: 2,
    hasValue: hasChildLayoutValue,
    label: childLayoutOrientationLabel,
    onDeselect: resetChildLayoutValue,
    isShownByDefault: (_defaultControls$chil = defaultControls.childLayout) !== null && _defaultControls$chil !== void 0 ? _defaultControls$chil : dimensions_panel_DEFAULT_CONTROLS.childLayout,
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(ChildLayoutControl, {
    value: childLayout,
    onChange: setChildLayout,
    parentLayout: settings?.parentLayout
  })));
}

;// CONCATENATED MODULE: external ["wp","isShallowEqual"]
var external_wp_isShallowEqual_namespaceObject = window["wp"]["isShallowEqual"];
var external_wp_isShallowEqual_default = /*#__PURE__*/__webpack_require__.n(external_wp_isShallowEqual_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/margin.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function getComputedCSS(element, property) {
  return element.ownerDocument.defaultView.getComputedStyle(element).getPropertyValue(property);
}

function MarginVisualizer({
  clientId,
  attributes,
  forceShow
}) {
  const blockElement = useBlockElement(clientId);
  const [style, setStyle] = (0,external_wp_element_namespaceObject.useState)();
  const margin = attributes?.style?.spacing?.margin;
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!blockElement || null === blockElement.ownerDocument.defaultView) {
      return;
    }

    const top = getComputedCSS(blockElement, 'margin-top');
    const right = getComputedCSS(blockElement, 'margin-right');
    const bottom = getComputedCSS(blockElement, 'margin-bottom');
    const left = getComputedCSS(blockElement, 'margin-left');
    setStyle({
      borderTopWidth: top,
      borderRightWidth: right,
      borderBottomWidth: bottom,
      borderLeftWidth: left,
      top: top ? `-${top}` : 0,
      right: right ? `-${right}` : 0,
      bottom: bottom ? `-${bottom}` : 0,
      left: left ? `-${left}` : 0
    });
  }, [blockElement, margin]);
  const [isActive, setIsActive] = (0,external_wp_element_namespaceObject.useState)(false);
  const valueRef = (0,external_wp_element_namespaceObject.useRef)(margin);
  const timeoutRef = (0,external_wp_element_namespaceObject.useRef)();

  const clearTimer = () => {
    if (timeoutRef.current) {
      window.clearTimeout(timeoutRef.current);
    }
  };

  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!external_wp_isShallowEqual_default()(margin, valueRef.current) && !forceShow) {
      setIsActive(true);
      valueRef.current = margin;
      timeoutRef.current = setTimeout(() => {
        setIsActive(false);
      }, 400);
    }

    return () => {
      setIsActive(false);
      clearTimer();
    };
  }, [margin, forceShow]);

  if (!isActive && !forceShow) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(block_popover, {
    clientId: clientId,
    __unstableCoverTarget: true,
    __unstableRefreshSize: margin,
    __unstablePopoverSlot: "block-toolbar",
    shift: false
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor__padding-visualizer",
    style: style
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/padding.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function padding_getComputedCSS(element, property) {
  return element.ownerDocument.defaultView.getComputedStyle(element).getPropertyValue(property);
}

function PaddingVisualizer({
  clientId,
  attributes,
  forceShow
}) {
  const blockElement = useBlockElement(clientId);
  const [style, setStyle] = (0,external_wp_element_namespaceObject.useState)();
  const padding = attributes?.style?.spacing?.padding;
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!blockElement || null === blockElement.ownerDocument.defaultView) {
      return;
    }

    setStyle({
      borderTopWidth: padding_getComputedCSS(blockElement, 'padding-top'),
      borderRightWidth: padding_getComputedCSS(blockElement, 'padding-right'),
      borderBottomWidth: padding_getComputedCSS(blockElement, 'padding-bottom'),
      borderLeftWidth: padding_getComputedCSS(blockElement, 'padding-left')
    });
  }, [blockElement, padding]);
  const [isActive, setIsActive] = (0,external_wp_element_namespaceObject.useState)(false);
  const valueRef = (0,external_wp_element_namespaceObject.useRef)(padding);
  const timeoutRef = (0,external_wp_element_namespaceObject.useRef)();

  const clearTimer = () => {
    if (timeoutRef.current) {
      window.clearTimeout(timeoutRef.current);
    }
  };

  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!external_wp_isShallowEqual_default()(padding, valueRef.current) && !forceShow) {
      setIsActive(true);
      valueRef.current = padding;
      timeoutRef.current = setTimeout(() => {
        setIsActive(false);
      }, 400);
    }

    return () => {
      setIsActive(false);
      clearTimer();
    };
  }, [padding, forceShow]);

  if (!isActive && !forceShow) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(block_popover, {
    clientId: clientId,
    __unstableCoverTarget: true,
    __unstableRefreshSize: padding,
    __unstablePopoverSlot: "block-toolbar",
    shift: false
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor__padding-visualizer",
    style: style
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/dimensions.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */








const DIMENSIONS_SUPPORT_KEY = 'dimensions';
const SPACING_SUPPORT_KEY = 'spacing';
const dimensions_ALL_SIDES = (/* unused pure expression or super */ null && (['top', 'right', 'bottom', 'left']));
const dimensions_AXIAL_SIDES = (/* unused pure expression or super */ null && (['vertical', 'horizontal']));

function useVisualizer() {
  const [property, setProperty] = (0,external_wp_element_namespaceObject.useState)(false);
  const {
    hideBlockInterface,
    showBlockInterface
  } = unlock((0,external_wp_data_namespaceObject.useDispatch)(store));
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!property) {
      showBlockInterface();
    } else {
      hideBlockInterface();
    }
  }, [property, showBlockInterface, hideBlockInterface]);
  return [property, setProperty];
}

function DimensionsInspectorControl({
  children,
  resetAllFilter
}) {
  const attributesResetAllFilter = (0,external_wp_element_namespaceObject.useCallback)(attributes => {
    const existingStyle = attributes.style;
    const updatedStyle = resetAllFilter(existingStyle);
    return { ...attributes,
      style: updatedStyle
    };
  }, [resetAllFilter]);
  return (0,external_wp_element_namespaceObject.createElement)(inspector_controls, {
    group: "dimensions",
    resetAllFilter: attributesResetAllFilter
  }, children);
}

function dimensions_DimensionsPanel(props) {
  const {
    clientId,
    name,
    attributes,
    setAttributes,
    __unstableParentLayout
  } = props;
  const settings = useBlockSettings(name, __unstableParentLayout);
  const isEnabled = useHasDimensionsPanel(settings);
  const value = attributes.style;
  const [visualizedProperty, setVisualizedProperty] = useVisualizer();

  const onChange = newStyle => {
    setAttributes({
      style: utils_cleanEmptyObject(newStyle)
    });
  };

  if (!isEnabled) {
    return null;
  }

  const defaultDimensionsControls = (0,external_wp_blocks_namespaceObject.getBlockSupport)(props.name, [DIMENSIONS_SUPPORT_KEY, '__experimentalDefaultControls']);
  const defaultSpacingControls = (0,external_wp_blocks_namespaceObject.getBlockSupport)(props.name, [SPACING_SUPPORT_KEY, '__experimentalDefaultControls']);
  const defaultControls = { ...defaultDimensionsControls,
    ...defaultSpacingControls
  };
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(DimensionsPanel, {
    as: DimensionsInspectorControl,
    panelId: clientId,
    settings: settings,
    value: value,
    onChange: onChange,
    defaultControls: defaultControls,
    onVisualize: setVisualizedProperty
  }), !!settings?.spacing?.padding && (0,external_wp_element_namespaceObject.createElement)(PaddingVisualizer, {
    forceShow: visualizedProperty === 'padding',
    ...props
  }), !!settings?.spacing?.margin && (0,external_wp_element_namespaceObject.createElement)(MarginVisualizer, {
    forceShow: visualizedProperty === 'margin',
    ...props
  }));
}
/**
 * @deprecated
 */

function useCustomSides() {
  external_wp_deprecated_default()('wp.blockEditor.__experimentalUseCustomSides', {
    since: '6.3',
    version: '6.4'
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/style.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */









const styleSupportKeys = [...TYPOGRAPHY_SUPPORT_KEYS, BORDER_SUPPORT_KEY, COLOR_SUPPORT_KEY, DIMENSIONS_SUPPORT_KEY, SPACING_SUPPORT_KEY];

const hasStyleSupport = blockType => styleSupportKeys.some(key => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, key));
/**
 * Returns the inline styles to add depending on the style object
 *
 * @param {Object} styles Styles configuration.
 *
 * @return {Object} Flattened CSS variables declaration.
 */


function getInlineStyles(styles = {}) {
  const output = {}; // The goal is to move everything to server side generated engine styles
  // This is temporary as we absorb more and more styles into the engine.

  (0,external_wp_styleEngine_namespaceObject.getCSSRules)(styles).forEach(rule => {
    output[rule.key] = rule.value;
  });
  return output;
}
/**
 * Filters registered block settings, extending attributes to include `style` attribute.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function style_addAttribute(settings) {
  if (!hasStyleSupport(settings)) {
    return settings;
  } // Allow blocks to specify their own attribute definition with default values if needed.


  if (!settings.attributes.style) {
    Object.assign(settings.attributes, {
      style: {
        type: 'object'
      }
    });
  }

  return settings;
}
/**
 * A dictionary of paths to flag skipping block support serialization as the key,
 * with values providing the style paths to be omitted from serialization.
 *
 * @constant
 * @type {Record<string, string[]>}
 */


const skipSerializationPathsEdit = {
  [`${BORDER_SUPPORT_KEY}.__experimentalSkipSerialization`]: ['border'],
  [`${COLOR_SUPPORT_KEY}.__experimentalSkipSerialization`]: [COLOR_SUPPORT_KEY],
  [`${TYPOGRAPHY_SUPPORT_KEY}.__experimentalSkipSerialization`]: [TYPOGRAPHY_SUPPORT_KEY],
  [`${DIMENSIONS_SUPPORT_KEY}.__experimentalSkipSerialization`]: [DIMENSIONS_SUPPORT_KEY],
  [`${SPACING_SUPPORT_KEY}.__experimentalSkipSerialization`]: [SPACING_SUPPORT_KEY]
};
/**
 * A dictionary of paths to flag skipping block support serialization as the key,
 * with values providing the style paths to be omitted from serialization.
 *
 * Extends the Edit skip paths to enable skipping additional paths in just
 * the Save component. This allows a block support to be serialized within the
 * editor, while using an alternate approach, such as server-side rendering, when
 * the support is saved.
 *
 * @constant
 * @type {Record<string, string[]>}
 */

const skipSerializationPathsSave = { ...skipSerializationPathsEdit,
  [`${SPACING_SUPPORT_KEY}`]: ['spacing.blockGap']
};
/**
 * A dictionary used to normalize feature names between support flags, style
 * object properties and __experimentSkipSerialization configuration arrays.
 *
 * This allows not having to provide a migration for a support flag and possible
 * backwards compatibility bridges, while still achieving consistency between
 * the support flag and the skip serialization array.
 *
 * @constant
 * @type {Record<string, string>}
 */

const renamedFeatures = {
  gradients: 'gradient'
};
/**
 * A utility function used to remove one or more paths from a style object.
 * Works in a way similar to Lodash's `omit()`. See unit tests and examples below.
 *
 * It supports a single string path:
 *
 * ```
 * omitStyle( { color: 'red' }, 'color' ); // {}
 * ```
 *
 * or an array of paths:
 *
 * ```
 * omitStyle( { color: 'red', background: '#fff' }, [ 'color', 'background' ] ); // {}
 * ```
 *
 * It also allows you to specify paths at multiple levels in a string.
 *
 * ```
 * omitStyle( { typography: { textDecoration: 'underline' } }, 'typography.textDecoration' ); // {}
 * ```
 *
 * You can remove multiple paths at the same time:
 *
 * ```
 * omitStyle(
 * 		{
 * 			typography: {
 * 				textDecoration: 'underline',
 * 				textTransform: 'uppercase',
 * 			}
 *		},
 *		[
 * 			'typography.textDecoration',
 * 			'typography.textTransform',
 *		]
 * );
 * // {}
 * ```
 *
 * You can also specify nested paths as arrays:
 *
 * ```
 * omitStyle(
 * 		{
 * 			typography: {
 * 				textDecoration: 'underline',
 * 				textTransform: 'uppercase',
 * 			}
 *		},
 *		[
 * 			[ 'typography', 'textDecoration' ],
 * 			[ 'typography', 'textTransform' ],
 *		]
 * );
 * // {}
 * ```
 *
 * With regards to nesting of styles, infinite depth is supported:
 *
 * ```
 * omitStyle(
 * 		{
 * 			border: {
 * 				radius: {
 * 					topLeft: '10px',
 * 					topRight: '0.5rem',
 * 				}
 * 			}
 *		},
 *		[
 * 			[ 'border', 'radius', 'topRight' ],
 *		]
 * );
 * // { border: { radius: { topLeft: '10px' } } }
 * ```
 *
 * The third argument, `preserveReference`, defines how to treat the input style object.
 * It is mostly necessary to properly handle mutation when recursively handling the style object.
 * Defaulting to `false`, this will always create a new object, avoiding to mutate `style`.
 * However, when recursing, we change that value to `true` in order to work with a single copy
 * of the original style object.
 *
 * @see https://lodash.com/docs/4.17.15#omit
 *
 * @param {Object}       style             Styles object.
 * @param {Array|string} paths             Paths to remove.
 * @param {boolean}      preserveReference True to mutate the `style` object, false otherwise.
 * @return {Object}      Styles object with the specified paths removed.
 */

function omitStyle(style, paths, preserveReference = false) {
  if (!style) {
    return style;
  }

  let newStyle = style;

  if (!preserveReference) {
    newStyle = JSON.parse(JSON.stringify(style));
  }

  if (!Array.isArray(paths)) {
    paths = [paths];
  }

  paths.forEach(path => {
    if (!Array.isArray(path)) {
      path = path.split('.');
    }

    if (path.length > 1) {
      const [firstSubpath, ...restPath] = path;
      omitStyle(newStyle[firstSubpath], [restPath], true);
    } else if (path.length === 1) {
      delete newStyle[path[0]];
    }
  });
  return newStyle;
}
/**
 * Override props assigned to save component to inject the CSS variables definition.
 *
 * @param {Object}                    props      Additional props applied to save element.
 * @param {Object}                    blockType  Block type.
 * @param {Object}                    attributes Block attributes.
 * @param {?Record<string, string[]>} skipPaths  An object of keys and paths to skip serialization.
 *
 * @return {Object} Filtered props applied to save element.
 */

function style_addSaveProps(props, blockType, attributes, skipPaths = skipSerializationPathsSave) {
  if (!hasStyleSupport(blockType)) {
    return props;
  }

  let {
    style
  } = attributes;
  Object.entries(skipPaths).forEach(([indicator, path]) => {
    const skipSerialization = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, indicator);

    if (skipSerialization === true) {
      style = omitStyle(style, path);
    }

    if (Array.isArray(skipSerialization)) {
      skipSerialization.forEach(featureName => {
        const feature = renamedFeatures[featureName] || featureName;
        style = omitStyle(style, [[...path, feature]]);
      });
    }
  });
  props.style = { ...getInlineStyles(style),
    ...props.style
  };
  return props;
}
/**
 * Filters registered block settings to extend the block edit wrapper
 * to apply the desired styles and classnames properly.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object}.Filtered block settings.
 */

function style_addEditProps(settings) {
  if (!hasStyleSupport(settings)) {
    return settings;
  }

  const existingGetEditWrapperProps = settings.getEditWrapperProps;

  settings.getEditWrapperProps = attributes => {
    let props = {};

    if (existingGetEditWrapperProps) {
      props = existingGetEditWrapperProps(attributes);
    }

    return style_addSaveProps(props, settings, attributes, skipSerializationPathsEdit);
  };

  return settings;
}
/**
 * Override the default edit UI to include new inspector controls for
 * all the custom styles configs.
 *
 * @param {Function} BlockEdit Original component.
 *
 * @return {Function} Wrapped component.
 */

const withBlockControls = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(BlockEdit => props => {
  const shouldDisplayControls = useDisplayBlockControls();
  const blockEditingMode = useBlockEditingMode();
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, shouldDisplayControls && blockEditingMode === 'default' && (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(ColorEdit, { ...props
  }), (0,external_wp_element_namespaceObject.createElement)(typography_TypographyPanel, { ...props
  }), (0,external_wp_element_namespaceObject.createElement)(border_BorderPanel, { ...props
  }), (0,external_wp_element_namespaceObject.createElement)(dimensions_DimensionsPanel, { ...props
  })), (0,external_wp_element_namespaceObject.createElement)(BlockEdit, { ...props
  }));
}, 'withToolbarControls');
/**
 * Override the default block element to include elements styles.
 *
 * @param {Function} BlockListBlock Original component
 * @return {Function}                Wrapped component
 */

const withElementsStyles = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(BlockListBlock => props => {
  const blockElementsContainerIdentifier = `wp-elements-${(0,external_wp_compose_namespaceObject.useInstanceId)(BlockListBlock)}`;
  const skipLinkColorSerialization = shouldSkipSerialization(props.name, COLOR_SUPPORT_KEY, 'link');
  const styles = (0,external_wp_element_namespaceObject.useMemo)(() => {
    // The .editor-styles-wrapper selector is required on elements styles. As it is
    // added to all other editor styles, not providing it causes reset and global
    // styles to override element styles because of higher specificity.
    const elements = [{
      styles: !skipLinkColorSerialization ? props.attributes.style?.elements?.link : undefined,
      selector: `.editor-styles-wrapper .${blockElementsContainerIdentifier} ${external_wp_blocks_namespaceObject.__EXPERIMENTAL_ELEMENTS.link}`
    }, {
      styles: !skipLinkColorSerialization ? props.attributes.style?.elements?.link?.[':hover'] : undefined,
      selector: `.editor-styles-wrapper .${blockElementsContainerIdentifier} ${external_wp_blocks_namespaceObject.__EXPERIMENTAL_ELEMENTS.link}:hover`
    }];
    const elementCssRules = [];

    for (const {
      styles: elementStyles,
      selector
    } of elements) {
      if (elementStyles) {
        const cssRule = (0,external_wp_styleEngine_namespaceObject.compileCSS)(elementStyles, {
          selector
        });
        elementCssRules.push(cssRule);
      }
    }

    return elementCssRules.length > 0 ? elementCssRules.join('') : undefined;
  }, [props.attributes.style?.elements, blockElementsContainerIdentifier, skipLinkColorSerialization]);
  const element = (0,external_wp_element_namespaceObject.useContext)(BlockList.__unstableElementContext);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, styles && element && (0,external_wp_element_namespaceObject.createPortal)((0,external_wp_element_namespaceObject.createElement)("style", {
    dangerouslySetInnerHTML: {
      __html: styles
    }
  }), element), (0,external_wp_element_namespaceObject.createElement)(BlockListBlock, { ...props,
    className: props.attributes.style?.elements ? classnames_default()(props.className, blockElementsContainerIdentifier) : props.className
  }));
}, 'withElementsStyles');
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/style/addAttribute', style_addAttribute);
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.getSaveContent.extraProps', 'core/style/addSaveProps', style_addSaveProps);
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/style/addEditProps', style_addEditProps);
(0,external_wp_hooks_namespaceObject.addFilter)('editor.BlockEdit', 'core/style/with-block-controls', withBlockControls);
(0,external_wp_hooks_namespaceObject.addFilter)('editor.BlockListBlock', 'core/editor/with-elements-styles', withElementsStyles);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/settings.js
/**
 * WordPress dependencies
 */



const hasSettingsSupport = blockType => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, '__experimentalSettings', false);

function settings_addAttribute(settings) {
  if (!hasSettingsSupport(settings)) {
    return settings;
  } // Allow blocks to specify their own attribute definition with default values if needed.


  if (!settings?.attributes?.settings) {
    settings.attributes = { ...settings.attributes,
      settings: {
        type: 'object'
      }
    };
  }

  return settings;
}

(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/settings/addAttribute', settings_addAttribute);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/filter.js


/**
 * WordPress dependencies
 */

const filter = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M12 4 4 19h16L12 4zm0 3.2 5.5 10.3H12V7.2z"
}));
/* harmony default export */ var library_filter = (filter);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/duotone-control/index.js


/**
 * WordPress dependencies
 */





function DuotoneControl({
  colorPalette,
  duotonePalette,
  disableCustomColors,
  disableCustomDuotone,
  value,
  onChange
}) {
  let toolbarIcon;

  if (value === 'unset') {
    toolbarIcon = (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ColorIndicator, {
      className: "block-editor-duotone-control__unset-indicator"
    });
  } else if (value) {
    toolbarIcon = (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.DuotoneSwatch, {
      values: value
    });
  } else {
    toolbarIcon = (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
      icon: library_filter
    });
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Dropdown, {
    popoverProps: {
      className: 'block-editor-duotone-control__popover',
      headerTitle: (0,external_wp_i18n_namespaceObject.__)('Duotone')
    },
    renderToggle: ({
      isOpen,
      onToggle
    }) => {
      const openOnArrowDown = event => {
        if (!isOpen && event.keyCode === external_wp_keycodes_namespaceObject.DOWN) {
          event.preventDefault();
          onToggle();
        }
      };

      return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarButton, {
        showTooltip: true,
        onClick: onToggle,
        "aria-haspopup": "true",
        "aria-expanded": isOpen,
        onKeyDown: openOnArrowDown,
        label: (0,external_wp_i18n_namespaceObject.__)('Apply duotone filter'),
        icon: toolbarIcon
      });
    },
    renderContent: () => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuGroup, {
      label: (0,external_wp_i18n_namespaceObject.__)('Duotone')
    }, (0,external_wp_element_namespaceObject.createElement)("div", {
      className: "block-editor-duotone-control__description"
    }, (0,external_wp_i18n_namespaceObject.__)('Create a two-tone color effect without losing your original image.')), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.DuotonePicker, {
      colorPalette: colorPalette,
      duotonePalette: duotonePalette,
      disableCustomColors: disableCustomColors,
      disableCustomDuotone: disableCustomDuotone,
      value: value,
      onChange: onChange
    }))
  });
}

/* harmony default export */ var duotone_control = (DuotoneControl);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/duotone/utils.js
/**
 * External dependencies
 */

/**
 * Convert a list of colors to an object of R, G, and B values.
 *
 * @param {string[]} colors Array of RBG color strings.
 *
 * @return {Object} R, G, and B values.
 */

function getValuesFromColors(colors = []) {
  const values = {
    r: [],
    g: [],
    b: [],
    a: []
  };
  colors.forEach(color => {
    const rgbColor = w(color).toRgb();
    values.r.push(rgbColor.r / 255);
    values.g.push(rgbColor.g / 255);
    values.b.push(rgbColor.b / 255);
    values.a.push(rgbColor.a);
  });
  return values;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/duotone/components.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/**
 * SVG and stylesheet needed for rendering the duotone filter.
 *
 * @param {Object} props          Duotone props.
 * @param {string} props.selector Selector to apply the filter to.
 * @param {string} props.id       Unique id for this duotone filter.
 *
 * @return {WPElement} Duotone element.
 */

function DuotoneStylesheet({
  selector,
  id
}) {
  const css = `
${selector} {
	filter: url( #${id} );
}
`;
  return (0,external_wp_element_namespaceObject.createElement)("style", null, css);
}
/**
 * Stylesheet for disabling a global styles duotone filter.
 *
 * @param {Object} props          Duotone props.
 * @param {string} props.selector Selector to disable the filter for.
 *
 * @return {WPElement} Filter none style element.
 */

function DuotoneUnsetStylesheet({
  selector
}) {
  const css = `
${selector} {
	filter: none;
}
`;
  return (0,external_wp_element_namespaceObject.createElement)("style", null, css);
}
/**
 * The SVG part of the duotone filter.
 *
 * @param {Object}   props        Duotone props.
 * @param {string}   props.id     Unique id for this duotone filter.
 * @param {string[]} props.colors Color strings from dark to light.
 *
 * @return {WPElement} Duotone SVG.
 */

function DuotoneFilter({
  id,
  colors
}) {
  const values = getValuesFromColors(colors);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SVG, {
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    viewBox: "0 0 0 0",
    width: "0",
    height: "0",
    focusable: "false",
    role: "none",
    style: {
      visibility: 'hidden',
      position: 'absolute',
      left: '-9999px',
      overflow: 'hidden'
    }
  }, (0,external_wp_element_namespaceObject.createElement)("defs", null, (0,external_wp_element_namespaceObject.createElement)("filter", {
    id: id
  }, (0,external_wp_element_namespaceObject.createElement)("feColorMatrix", {
    // Use sRGB instead of linearRGB so transparency looks correct.
    colorInterpolationFilters: "sRGB",
    type: "matrix" // Use perceptual brightness to convert to grayscale.
    ,
    values: " .299 .587 .114 0 0 .299 .587 .114 0 0 .299 .587 .114 0 0 .299 .587 .114 0 0 "
  }), (0,external_wp_element_namespaceObject.createElement)("feComponentTransfer", {
    // Use sRGB instead of linearRGB to be consistent with how CSS gradients work.
    colorInterpolationFilters: "sRGB"
  }, (0,external_wp_element_namespaceObject.createElement)("feFuncR", {
    type: "table",
    tableValues: values.r.join(' ')
  }), (0,external_wp_element_namespaceObject.createElement)("feFuncG", {
    type: "table",
    tableValues: values.g.join(' ')
  }), (0,external_wp_element_namespaceObject.createElement)("feFuncB", {
    type: "table",
    tableValues: values.b.join(' ')
  }), (0,external_wp_element_namespaceObject.createElement)("feFuncA", {
    type: "table",
    tableValues: values.a.join(' ')
  })), (0,external_wp_element_namespaceObject.createElement)("feComposite", {
    // Re-mask the image with the original transparency since the feColorMatrix above loses that information.
    in2: "SourceGraphic",
    operator: "in"
  }))));
}
/**
 * SVG from a duotone preset
 *
 * @param {Object} props        Duotone props.
 * @param {Object} props.preset Duotone preset settings.
 *
 * @return {WPElement} Duotone element.
 */

function PresetDuotoneFilter({
  preset
}) {
  return (0,external_wp_element_namespaceObject.createElement)(DuotoneFilter, {
    id: `wp-duotone-${preset.slug}`,
    colors: preset.colors
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/global-styles/get-block-css-selector.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Determine the CSS selector for the block type and target provided, returning
 * it if available.
 *
 * @param {import('@wordpress/blocks').Block} blockType        The block's type.
 * @param {string|string[]}                   target           The desired selector's target e.g. `root`, delimited string, or array path.
 * @param {Object}                            options          Options object.
 * @param {boolean}                           options.fallback Whether or not to fallback to broader selector.
 *
 * @return {?string} The CSS selector or `null` if no selector available.
 */

function getBlockCSSSelector(blockType, target = 'root', options = {}) {
  if (!target) {
    return null;
  }

  const {
    fallback = false
  } = options;
  const {
    name,
    selectors,
    supports
  } = blockType;
  const hasSelectors = selectors && Object.keys(selectors).length > 0;
  const path = Array.isArray(target) ? target.join('.') : target; // Root selector.
  // Calculated before returning as it can be used as a fallback for feature
  // selectors later on.

  let rootSelector = null;

  if (hasSelectors && selectors.root) {
    // Use the selectors API if available.
    rootSelector = selectors?.root;
  } else if (supports?.__experimentalSelector) {
    // Use the old experimental selector supports property if set.
    rootSelector = supports.__experimentalSelector;
  } else {
    // If no root selector found, generate default block class selector.
    rootSelector = '.wp-block-' + name.replace('core/', '').replace('/', '-');
  } // Return selector if it's the root target we are looking for.


  if (path === 'root') {
    return rootSelector;
  } // If target is not `root` or `duotone` we have a feature or subfeature
  // as the target. If the target is a string convert to an array.


  const pathArray = Array.isArray(target) ? target : target.split('.'); // Feature selectors ( may fallback to root selector );

  if (pathArray.length === 1) {
    const fallbackSelector = fallback ? rootSelector : null; // Prefer the selectors API if available.

    if (hasSelectors) {
      // Get selector from either `feature.root` or shorthand path.
      const featureSelector = (0,external_lodash_namespaceObject.get)(selectors, `${path}.root`, null) || (0,external_lodash_namespaceObject.get)(selectors, path, null); // Return feature selector if found or any available fallback.

      return featureSelector || fallbackSelector;
    } // Try getting old experimental supports selector value.


    const featureSelector = (0,external_lodash_namespaceObject.get)(supports, `${path}.__experimentalSelector`, null); // If nothing to work with, provide fallback selector if available.

    if (!featureSelector) {
      return fallbackSelector;
    } // Scope the feature selector by the block's root selector.


    return scopeSelector(rootSelector, featureSelector);
  } // Subfeature selector.
  // This may fallback either to parent feature or root selector.


  let subfeatureSelector; // Use selectors API if available.

  if (hasSelectors) {
    subfeatureSelector = (0,external_lodash_namespaceObject.get)(selectors, path, null);
  } // Only return if we have a subfeature selector.


  if (subfeatureSelector) {
    return subfeatureSelector;
  } // To this point we don't have a subfeature selector. If a fallback has been
  // requested, remove subfeature from target path and return results of a
  // call for the parent feature's selector.


  if (fallback) {
    return getBlockCSSSelector(blockType, pathArray[0], options);
  } // We tried.


  return null;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/global-styles/filters-panel.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



const filters_panel_EMPTY_ARRAY = [];

function useMultiOriginColorPresets(settings, {
  presetSetting,
  defaultSetting
}) {
  const disableDefault = !settings?.color?.[defaultSetting];
  const userPresets = settings?.color?.[presetSetting]?.custom || filters_panel_EMPTY_ARRAY;
  const themePresets = settings?.color?.[presetSetting]?.theme || filters_panel_EMPTY_ARRAY;
  const defaultPresets = settings?.color?.[presetSetting]?.default || filters_panel_EMPTY_ARRAY;
  return (0,external_wp_element_namespaceObject.useMemo)(() => [...userPresets, ...themePresets, ...(disableDefault ? filters_panel_EMPTY_ARRAY : defaultPresets)], [disableDefault, userPresets, themePresets, defaultPresets]);
}

function useHasFiltersPanel(settings) {
  const hasDuotone = useHasDuotoneControl(settings);
  return hasDuotone;
}

function useHasDuotoneControl(settings) {
  return settings.color.customDuotone || settings.color.defaultDuotone;
}

function FiltersToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children
}) {
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanel, {
    label: (0,external_wp_i18n_namespaceObject._x)('Filters', 'Name for applying graphical effects'),
    resetAll: resetAll,
    panelId: panelId
  }, children);
}

const filters_panel_DEFAULT_CONTROLS = {
  duotone: true
};
const filters_panel_popoverProps = {
  placement: 'left-start',
  offset: 36,
  shift: true,
  className: 'block-editor-duotone-control__popover',
  headerTitle: (0,external_wp_i18n_namespaceObject.__)('Duotone')
};

const LabeledColorIndicator = ({
  indicator,
  label
}) => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHStack, {
  justify: "flex-start"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalZStack, {
  isLayered: false,
  offset: -8
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Flex, {
  expanded: false
}, indicator === 'unset' || !indicator ? (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ColorIndicator, {
  className: "block-editor-duotone-control__unset-indicator"
}) : (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.DuotoneSwatch, {
  values: indicator
}))), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, {
  title: label
}, label));

function FiltersPanel({
  as: Wrapper = FiltersToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  defaultControls = filters_panel_DEFAULT_CONTROLS
}) {
  const decodeValue = rawValue => getValueFromVariable({
    settings
  }, '', rawValue); // Duotone


  const hasDuotoneEnabled = useHasDuotoneControl(settings);
  const duotonePalette = useMultiOriginColorPresets(settings, {
    presetSetting: 'duotone',
    defaultSetting: 'defaultDuotone'
  });
  const colorPalette = useMultiOriginColorPresets(settings, {
    presetSetting: 'palette',
    defaultSetting: 'defaultPalette'
  });
  const duotone = decodeValue(inheritedValue?.filter?.duotone);

  const setDuotone = newValue => {
    const duotonePreset = duotonePalette.find(({
      colors
    }) => {
      return colors === newValue;
    });
    const settedValue = duotonePreset ? `var:preset|duotone|${duotonePreset.slug}` : newValue;
    onChange(setImmutably(value, ['filter', 'duotone'], settedValue));
  };

  const hasDuotone = () => !!value?.filter?.duotone;

  const resetDuotone = () => setDuotone(undefined);

  const disableCustomColors = !settings?.color?.custom;
  const disableCustomDuotone = !settings?.color?.customDuotone || colorPalette?.length === 0 && disableCustomColors;
  const resetAllFilter = (0,external_wp_element_namespaceObject.useCallback)(previousValue => {
    return { ...previousValue,
      filter: { ...previousValue.filter,
        duotone: undefined
      }
    };
  }, []);
  return (0,external_wp_element_namespaceObject.createElement)(Wrapper, {
    resetAllFilter: resetAllFilter,
    value: value,
    onChange: onChange,
    panelId: panelId
  }, hasDuotoneEnabled && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    label: (0,external_wp_i18n_namespaceObject.__)('Duotone'),
    hasValue: hasDuotone,
    onDeselect: resetDuotone,
    isShownByDefault: defaultControls.duotone,
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Dropdown, {
    popoverProps: filters_panel_popoverProps,
    className: "block-editor-global-styles-filters-panel__dropdown",
    renderToggle: ({
      onToggle,
      isOpen
    }) => {
      const toggleProps = {
        onClick: onToggle,
        className: classnames_default()({
          'is-open': isOpen
        }),
        'aria-expanded': isOpen
      };
      return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalItemGroup, {
        isBordered: true,
        isSeparated: true
      }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, { ...toggleProps
      }, (0,external_wp_element_namespaceObject.createElement)(LabeledColorIndicator, {
        indicator: duotone,
        label: (0,external_wp_i18n_namespaceObject.__)('Duotone')
      })));
    },
    renderContent: () => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalDropdownContentWrapper, {
      paddingSize: "medium"
    }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalVStack, null, (0,external_wp_element_namespaceObject.createElement)("p", null, (0,external_wp_i18n_namespaceObject.__)('Create a two-tone color effect without losing your original image.')), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.DuotonePicker, {
      colorPalette: colorPalette,
      duotonePalette: duotonePalette,
      disableCustomColors: disableCustomColors,
      disableCustomDuotone: disableCustomDuotone,
      value: duotone,
      onChange: setDuotone
    })))
  })));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/duotone.js


/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */









const duotone_EMPTY_ARRAY = [];
k([names]);
/**
 * SVG and stylesheet needed for rendering the duotone filter.
 *
 * @param {Object}           props          Duotone props.
 * @param {string}           props.selector Selector to apply the filter to.
 * @param {string}           props.id       Unique id for this duotone filter.
 * @param {string[]|"unset"} props.colors   Array of RGB color strings ordered from dark to light.
 *
 * @return {WPElement} Duotone element.
 */

function InlineDuotone({
  selector,
  id,
  colors
}) {
  if (colors === 'unset') {
    return (0,external_wp_element_namespaceObject.createElement)(DuotoneUnsetStylesheet, {
      selector: selector
    });
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(DuotoneFilter, {
    id: id,
    colors: colors
  }), (0,external_wp_element_namespaceObject.createElement)(DuotoneStylesheet, {
    id: id,
    selector: selector
  }));
}

function useMultiOriginPresets({
  presetSetting,
  defaultSetting
}) {
  const disableDefault = !use_setting_useSetting(defaultSetting);
  const userPresets = use_setting_useSetting(`${presetSetting}.custom`) || duotone_EMPTY_ARRAY;
  const themePresets = use_setting_useSetting(`${presetSetting}.theme`) || duotone_EMPTY_ARRAY;
  const defaultPresets = use_setting_useSetting(`${presetSetting}.default`) || duotone_EMPTY_ARRAY;
  return (0,external_wp_element_namespaceObject.useMemo)(() => [...userPresets, ...themePresets, ...(disableDefault ? duotone_EMPTY_ARRAY : defaultPresets)], [disableDefault, userPresets, themePresets, defaultPresets]);
}

function getColorsFromDuotonePreset(duotone, duotonePalette) {
  if (!duotone) {
    return;
  }

  const preset = duotonePalette?.find(({
    slug
  }) => {
    return duotone === `var:preset|duotone|${slug}`;
  });
  return preset ? preset.colors : undefined;
}
function getDuotonePresetFromColors(colors, duotonePalette) {
  if (!colors || !Array.isArray(colors)) {
    return;
  }

  const preset = duotonePalette?.find(duotonePreset => {
    return duotonePreset?.colors?.every((val, index) => val === colors[index]);
  });
  return preset ? `var:preset|duotone|${preset.slug}` : undefined;
}

function DuotonePanel({
  attributes,
  setAttributes,
  name
}) {
  const style = attributes?.style;
  const duotoneStyle = style?.color?.duotone;
  const settings = useBlockSettings(name);
  const duotonePalette = useMultiOriginPresets({
    presetSetting: 'color.duotone',
    defaultSetting: 'color.defaultDuotone'
  });
  const colorPalette = useMultiOriginPresets({
    presetSetting: 'color.palette',
    defaultSetting: 'color.defaultPalette'
  });
  const disableCustomColors = !use_setting_useSetting('color.custom');
  const disableCustomDuotone = !use_setting_useSetting('color.customDuotone') || colorPalette?.length === 0 && disableCustomColors;

  if (duotonePalette?.length === 0 && disableCustomDuotone) {
    return null;
  }

  const duotonePresetOrColors = !Array.isArray(duotoneStyle) ? getColorsFromDuotonePreset(duotoneStyle, duotonePalette) : duotoneStyle;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(inspector_controls, {
    group: "filter"
  }, (0,external_wp_element_namespaceObject.createElement)(FiltersPanel, {
    value: {
      filter: {
        duotone: duotonePresetOrColors
      }
    },
    onChange: newDuotone => {
      const newStyle = { ...style,
        color: { ...newDuotone?.filter
        }
      };
      setAttributes({
        style: newStyle
      });
    },
    settings: settings
  })), (0,external_wp_element_namespaceObject.createElement)(block_controls, {
    group: "block",
    __experimentalShareWithChildBlocks: true
  }, (0,external_wp_element_namespaceObject.createElement)(duotone_control, {
    duotonePalette: duotonePalette,
    colorPalette: colorPalette,
    disableCustomDuotone: disableCustomDuotone,
    disableCustomColors: disableCustomColors,
    value: duotonePresetOrColors,
    onChange: newDuotone => {
      const maybePreset = getDuotonePresetFromColors(newDuotone, duotonePalette);
      const newStyle = { ...style,
        color: { ...style?.color,
          duotone: maybePreset !== null && maybePreset !== void 0 ? maybePreset : newDuotone // use preset or fallback to custom colors.

        }
      };
      setAttributes({
        style: newStyle
      });
    },
    settings: settings
  })));
}
/**
 * Filters registered block settings, extending attributes to include
 * the `duotone` attribute.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */


function addDuotoneAttributes(settings) {
  // Previous `color.__experimentalDuotone` support flag is migrated via
  // block_type_metadata_settings filter in `lib/block-supports/duotone.php`.
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, 'filter.duotone')) {
    return settings;
  } // Allow blocks to specify their own attribute definition with default
  // values if needed.


  if (!settings.attributes.style) {
    Object.assign(settings.attributes, {
      style: {
        type: 'object'
      }
    });
  }

  return settings;
}
/**
 * Override the default edit UI to include toolbar controls for duotone if the
 * block supports duotone.
 *
 * @param {Function} BlockEdit Original component.
 *
 * @return {Function} Wrapped component.
 */


const withDuotoneControls = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(BlockEdit => props => {
  // Previous `color.__experimentalDuotone` support flag is migrated via
  // block_type_metadata_settings filter in `lib/block-supports/duotone.php`.
  const hasDuotoneSupport = (0,external_wp_blocks_namespaceObject.hasBlockSupport)(props.name, 'filter.duotone');
  const blockEditingMode = useBlockEditingMode(); // CAUTION: code added before this line will be executed
  // for all blocks, not just those that support duotone. Code added
  // above this line should be carefully evaluated for its impact on
  // performance.

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, hasDuotoneSupport && blockEditingMode === 'default' && (0,external_wp_element_namespaceObject.createElement)(DuotonePanel, { ...props
  }), (0,external_wp_element_namespaceObject.createElement)(BlockEdit, { ...props
  }));
}, 'withDuotoneControls');

function DuotoneStyles({
  id: filterId,
  selector: duotoneSelector,
  attribute: duotoneAttr
}) {
  const element = (0,external_wp_element_namespaceObject.useContext)(BlockList.__unstableElementContext);
  const duotonePalette = useMultiOriginPresets({
    presetSetting: 'color.duotone',
    defaultSetting: 'color.defaultDuotone'
  }); // Possible values for duotone attribute:
  // 1. Array of colors - e.g. ['#000000', '#ffffff'].
  // 2. Variable for an existing Duotone preset - e.g. 'var:preset|duotone|green-blue' or 'var(--wp--preset--duotone--green-blue)''
  // 3. A CSS string - e.g. 'unset' to remove globally applied duotone.

  const isCustom = Array.isArray(duotoneAttr);
  const duotonePreset = isCustom ? undefined : getColorsFromDuotonePreset(duotoneAttr, duotonePalette);
  const isPreset = typeof duotoneAttr === 'string' && duotonePreset;
  const isCSS = typeof duotoneAttr === 'string' && !isPreset; // Match the structure of WP_Duotone_Gutenberg::render_duotone_support() in PHP.

  let colors = null;

  if (isPreset) {
    // Array of colors.
    colors = duotonePreset;
  } else if (isCSS) {
    // CSS filter property string (e.g. 'unset').
    colors = duotoneAttr;
  } else if (isCustom) {
    // Array of colors.
    colors = duotoneAttr;
  } // Build the CSS selectors to which the filter will be applied.


  const selectors = duotoneSelector.split(',');
  const selectorsScoped = selectors.map(selectorPart => {
    // Extra .editor-styles-wrapper specificity is needed in the editor
    // since we're not using inline styles to apply the filter. We need to
    // override duotone applied by global styles and theme.json.
    // Assuming the selector part is a subclass selector (not a tag name)
    // so we can prepend the filter id class. If we want to support elements
    // such as `img` or namespaces, we'll need to add a case for that here.
    return `.editor-styles-wrapper .${filterId}${selectorPart.trim()}`;
  });
  const selector = selectorsScoped.join(', ');
  const isValidFilter = Array.isArray(colors) || colors === 'unset';
  return element && isValidFilter && (0,external_wp_element_namespaceObject.createPortal)((0,external_wp_element_namespaceObject.createElement)(InlineDuotone, {
    selector: selector,
    id: filterId,
    colors: colors
  }), element);
}
/**
 * Override the default block element to include duotone styles.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */


const withDuotoneStyles = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(BlockListBlock => props => {
  const id = (0,external_wp_compose_namespaceObject.useInstanceId)(BlockListBlock);
  const selector = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(props.name);

    if (blockType) {
      // Backwards compatibility for `supports.color.__experimentalDuotone`
      // is provided via the `block_type_metadata_settings` filter. If
      // `supports.filter.duotone` has not been set and the
      // experimental property has been, the experimental property
      // value is copied into `supports.filter.duotone`.
      const duotoneSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, 'filter.duotone', false);

      if (!duotoneSupport) {
        return null;
      } // If the experimental duotone support was set, that value is
      // to be treated as a selector and requires scoping.


      const experimentalDuotone = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, 'color.__experimentalDuotone', false);

      if (experimentalDuotone) {
        const rootSelector = getBlockCSSSelector(blockType);
        return typeof experimentalDuotone === 'string' ? scopeSelector(rootSelector, experimentalDuotone) : rootSelector;
      } // Regular filter.duotone support uses filter.duotone selectors with fallbacks.


      return getBlockCSSSelector(blockType, 'filter.duotone', {
        fallback: true
      });
    }
  }, [props.name]);
  const attribute = props?.attributes?.style?.color?.duotone;
  const filterClass = `wp-duotone-${id}`;
  const shouldRender = selector && attribute;
  const className = shouldRender ? classnames_default()(props?.className, filterClass) : props?.className; // CAUTION: code added before this line will be executed
  // for all blocks, not just those that support duotone. Code added
  // above this line should be carefully evaluated for its impact on
  // performance.

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, shouldRender && (0,external_wp_element_namespaceObject.createElement)(DuotoneStyles, {
    id: filterClass,
    selector: selector,
    attribute: attribute
  }), (0,external_wp_element_namespaceObject.createElement)(BlockListBlock, { ...props,
    className: className
  }));
}, 'withDuotoneStyles');
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/editor/duotone/add-attributes', addDuotoneAttributes);
(0,external_wp_hooks_namespaceObject.addFilter)('editor.BlockEdit', 'core/editor/duotone/with-editor-controls', withDuotoneControls);
(0,external_wp_hooks_namespaceObject.addFilter)('editor.BlockListBlock', 'core/editor/duotone/with-styles', withDuotoneStyles);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/use-block-display-information/index.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/** @typedef {import('@wordpress/blocks').WPIcon} WPIcon */

/**
 * Contains basic block's information for display reasons.
 *
 * @typedef {Object} WPBlockDisplayInformation
 *
 * @property {boolean} isSynced    True if is a reusable block or template part
 * @property {string}  title       Human-readable block type label.
 * @property {WPIcon}  icon        Block type icon.
 * @property {string}  description A detailed block type description.
 * @property {string}  anchor      HTML anchor.
 */

/**
 * Get the display label for a block's position type.
 *
 * @param {Object} attributes Block attributes.
 * @return {string} The position type label.
 */

function getPositionTypeLabel(attributes) {
  const positionType = attributes?.style?.position?.type;

  if (positionType === 'sticky') {
    return (0,external_wp_i18n_namespaceObject.__)('Sticky');
  }

  if (positionType === 'fixed') {
    return (0,external_wp_i18n_namespaceObject.__)('Fixed');
  }

  return null;
}
/**
 * Hook used to try to find a matching block variation and return
 * the appropriate information for display reasons. In order to
 * to try to find a match we need to things:
 * 1. Block's client id to extract it's current attributes.
 * 2. A block variation should have set `isActive` prop to a proper function.
 *
 * If for any reason a block variation match cannot be found,
 * the returned information come from the Block Type.
 * If no blockType is found with the provided clientId, returns null.
 *
 * @param {string} clientId Block's client id.
 * @return {?WPBlockDisplayInformation} Block's display information, or `null` when the block or its type not found.
 */


function useBlockDisplayInformation(clientId) {
  return (0,external_wp_data_namespaceObject.useSelect)(select => {
    if (!clientId) return null;
    const {
      getBlockName,
      getBlockAttributes,
      __experimentalGetReusableBlockTitle
    } = select(store);
    const {
      getBlockType,
      getActiveBlockVariation
    } = select(external_wp_blocks_namespaceObject.store);
    const blockName = getBlockName(clientId);
    const blockType = getBlockType(blockName);
    if (!blockType) return null;
    const attributes = getBlockAttributes(clientId);
    const match = getActiveBlockVariation(blockName, attributes);
    const isReusable = (0,external_wp_blocks_namespaceObject.isReusableBlock)(blockType);
    const resusableTitle = isReusable ? __experimentalGetReusableBlockTitle(attributes.ref) : undefined;
    const title = resusableTitle || blockType.title;
    const isSynced = isReusable || (0,external_wp_blocks_namespaceObject.isTemplatePart)(blockType);
    const positionLabel = getPositionTypeLabel(attributes);
    const blockTypeInfo = {
      isSynced,
      title,
      icon: blockType.icon,
      description: blockType.description,
      anchor: attributes?.anchor,
      positionLabel,
      positionType: attributes?.style?.position?.type
    };
    if (!match) return blockTypeInfo;
    return {
      isSynced,
      title: match.title || blockType.title,
      icon: match.icon || blockType.icon,
      description: match.description || blockType.description,
      anchor: attributes?.anchor,
      positionLabel,
      positionType: attributes?.style?.position?.type
    };
  }, [clientId]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/position.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */








/**
 * Internal dependencies
 */








const {
  CustomSelectControl
} = unlock(external_wp_components_namespaceObject.privateApis);
const POSITION_SUPPORT_KEY = 'position';
const OPTION_CLASSNAME = 'block-editor-hooks__position-selection__select-control__option';
const DEFAULT_OPTION = {
  key: 'default',
  value: '',
  name: (0,external_wp_i18n_namespaceObject.__)('Default'),
  className: OPTION_CLASSNAME
};
const STICKY_OPTION = {
  key: 'sticky',
  value: 'sticky',
  name: (0,external_wp_i18n_namespaceObject._x)('Sticky', 'Name for the value of the CSS position property'),
  className: OPTION_CLASSNAME,
  __experimentalHint: (0,external_wp_i18n_namespaceObject.__)('The block will stick to the top of the window instead of scrolling.')
};
const FIXED_OPTION = {
  key: 'fixed',
  value: 'fixed',
  name: (0,external_wp_i18n_namespaceObject._x)('Fixed', 'Name for the value of the CSS position property'),
  className: OPTION_CLASSNAME,
  __experimentalHint: (0,external_wp_i18n_namespaceObject.__)('The block will not move when the page is scrolled.')
};
const POSITION_SIDES = ['top', 'right', 'bottom', 'left'];
const VALID_POSITION_TYPES = ['sticky', 'fixed'];
/**
 * Get calculated position CSS.
 *
 * @param {Object} props          Component props.
 * @param {string} props.selector Selector to use.
 * @param {Object} props.style    Style object.
 * @return {string} The generated CSS rules.
 */

function getPositionCSS({
  selector,
  style
}) {
  let output = '';
  const {
    type: positionType
  } = style?.position || {};

  if (!VALID_POSITION_TYPES.includes(positionType)) {
    return output;
  }

  output += `${selector} {`;
  output += `position: ${positionType};`;
  POSITION_SIDES.forEach(side => {
    if (style?.position?.[side] !== undefined) {
      output += `${side}: ${style.position[side]};`;
    }
  });

  if (positionType === 'sticky' || positionType === 'fixed') {
    // TODO: Replace hard-coded z-index value with a z-index preset approach in theme.json.
    output += `z-index: 10`;
  }

  output += `}`;
  return output;
}
/**
 * Determines if there is sticky position support.
 *
 * @param {string|Object} blockType Block name or Block Type object.
 *
 * @return {boolean} Whether there is support.
 */

function hasStickyPositionSupport(blockType) {
  const support = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, POSITION_SUPPORT_KEY);
  return !!(true === support || support?.sticky);
}
/**
 * Determines if there is fixed position support.
 *
 * @param {string|Object} blockType Block name or Block Type object.
 *
 * @return {boolean} Whether there is support.
 */

function hasFixedPositionSupport(blockType) {
  const support = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, POSITION_SUPPORT_KEY);
  return !!(true === support || support?.fixed);
}
/**
 * Determines if there is position support.
 *
 * @param {string|Object} blockType Block name or Block Type object.
 *
 * @return {boolean} Whether there is support.
 */

function hasPositionSupport(blockType) {
  const support = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, POSITION_SUPPORT_KEY);
  return !!support;
}
/**
 * Checks if there is a current value in the position block support attributes.
 *
 * @param {Object} props Block props.
 * @return {boolean} Whether or not the block has a position value set.
 */

function hasPositionValue(props) {
  return props.attributes.style?.position?.type !== undefined;
}
/**
 * Checks if the block is currently set to a sticky or fixed position.
 * This check is helpful for determining how to position block toolbars or other elements.
 *
 * @param {Object} attributes Block attributes.
 * @return {boolean} Whether or not the block is set to a sticky or fixed position.
 */

function hasStickyOrFixedPositionValue(attributes) {
  const positionType = attributes.style?.position?.type;
  return positionType === 'sticky' || positionType === 'fixed';
}
/**
 * Resets the position block support attributes. This can be used when disabling
 * the position support controls for a block via a `ToolsPanel`.
 *
 * @param {Object} props               Block props.
 * @param {Object} props.attributes    Block's attributes.
 * @param {Object} props.setAttributes Function to set block's attributes.
 */

function resetPosition({
  attributes = {},
  setAttributes
}) {
  const {
    style = {}
  } = attributes;
  setAttributes({
    style: cleanEmptyObject({ ...style,
      position: { ...style?.position,
        type: undefined,
        top: undefined,
        right: undefined,
        bottom: undefined,
        left: undefined
      }
    })
  });
}
/**
 * Custom hook that checks if position settings have been disabled.
 *
 * @param {string} name The name of the block.
 *
 * @return {boolean} Whether padding setting is disabled.
 */

function useIsPositionDisabled({
  name: blockName
} = {}) {
  const allowFixed = use_setting_useSetting('position.fixed');
  const allowSticky = use_setting_useSetting('position.sticky');
  const isDisabled = !allowFixed && !allowSticky;
  return !hasPositionSupport(blockName) || isDisabled;
}
/*
 * Position controls rendered in an inspector control panel.
 *
 * @param {Object} props
 *
 * @return {WPElement} Position panel.
 */

function PositionPanel(props) {
  const {
    attributes: {
      style = {}
    },
    clientId,
    name: blockName,
    setAttributes
  } = props;
  const allowFixed = hasFixedPositionSupport(blockName);
  const allowSticky = hasStickyPositionSupport(blockName);
  const value = style?.position?.type;
  const {
    firstParentClientId
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockParents
    } = select(store);
    const parents = getBlockParents(clientId);
    return {
      firstParentClientId: parents[parents.length - 1]
    };
  }, [clientId]);
  const blockInformation = useBlockDisplayInformation(firstParentClientId);
  const stickyHelpText = allowSticky && value === STICKY_OPTION.value && blockInformation ? (0,external_wp_i18n_namespaceObject.sprintf)(
  /* translators: %s: the name of the parent block. */
  (0,external_wp_i18n_namespaceObject.__)('The block will stick to the scrollable area of the parent %s block.'), blockInformation.title) : null;
  const options = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const availableOptions = [DEFAULT_OPTION]; // Display options if they are allowed, or if a block already has a valid value set.
    // This allows for a block to be switched off from a position type that is not allowed.

    if (allowSticky || value === STICKY_OPTION.value) {
      availableOptions.push(STICKY_OPTION);
    }

    if (allowFixed || value === FIXED_OPTION.value) {
      availableOptions.push(FIXED_OPTION);
    }

    return availableOptions;
  }, [allowFixed, allowSticky, value]);

  const onChangeType = next => {
    // For now, use a hard-coded `0px` value for the position.
    // `0px` is preferred over `0` as it can be used in `calc()` functions.
    // In the future, it could be useful to allow for an offset value.
    const placementValue = '0px';
    const newStyle = { ...style,
      position: { ...style?.position,
        type: next,
        top: next === 'sticky' || next === 'fixed' ? placementValue : undefined
      }
    };
    setAttributes({
      style: utils_cleanEmptyObject(newStyle)
    });
  };

  const selectedOption = value ? options.find(option => option.value === value) || DEFAULT_OPTION : DEFAULT_OPTION; // Only display position controls if there is at least one option to choose from.

  return external_wp_element_namespaceObject.Platform.select({
    web: options.length > 1 ? (0,external_wp_element_namespaceObject.createElement)(inspector_controls, {
      group: "position"
    }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.BaseControl, {
      className: "block-editor-hooks__position-selection",
      __nextHasNoMarginBottom: true,
      help: stickyHelpText
    }, (0,external_wp_element_namespaceObject.createElement)(CustomSelectControl, {
      __nextUnconstrainedWidth: true,
      __next36pxDefaultSize: true,
      className: "block-editor-hooks__position-selection__select-control",
      label: (0,external_wp_i18n_namespaceObject.__)('Position'),
      hideLabelFromVision: true,
      describedBy: (0,external_wp_i18n_namespaceObject.sprintf)( // translators: %s: Currently selected position.
      (0,external_wp_i18n_namespaceObject.__)('Currently selected position: %s'), selectedOption.name),
      options: options,
      value: selectedOption,
      __experimentalShowSelectedHint: true,
      onChange: ({
        selectedItem
      }) => {
        onChangeType(selectedItem.value);
      },
      size: '__unstable-large'
    }))) : null,
    native: null
  });
}
/**
 * Override the default edit UI to include position controls.
 *
 * @param {Function} BlockEdit Original component.
 *
 * @return {Function} Wrapped component.
 */

const withInspectorControls = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(BlockEdit => props => {
  const {
    name: blockName
  } = props;
  const positionSupport = (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockName, POSITION_SUPPORT_KEY);
  const showPositionControls = positionSupport && !useIsPositionDisabled(props);
  return [showPositionControls && (0,external_wp_element_namespaceObject.createElement)(PositionPanel, {
    key: "position",
    ...props
  }), (0,external_wp_element_namespaceObject.createElement)(BlockEdit, {
    key: "edit",
    ...props
  })];
}, 'withInspectorControls');
/**
 * Override the default block element to add the position styles.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */

const withPositionStyles = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(BlockListBlock => props => {
  const {
    name,
    attributes
  } = props;
  const hasPositionBlockSupport = (0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, POSITION_SUPPORT_KEY);
  const allowPositionStyles = hasPositionBlockSupport && !useIsPositionDisabled(props);
  const id = (0,external_wp_compose_namespaceObject.useInstanceId)(BlockListBlock);
  const element = (0,external_wp_element_namespaceObject.useContext)(BlockList.__unstableElementContext); // Higher specificity to override defaults in editor UI.

  const positionSelector = `.wp-container-${id}.wp-container-${id}`; // Get CSS string for the current position values.

  let css;

  if (allowPositionStyles) {
    css = getPositionCSS({
      selector: positionSelector,
      style: attributes?.style
    }) || '';
  } // Attach a `wp-container-` id-based class name.


  const className = classnames_default()(props?.className, {
    [`wp-container-${id}`]: allowPositionStyles && !!css,
    // Only attach a container class if there is generated CSS to be attached.
    [`is-position-${attributes?.style?.position?.type}`]: allowPositionStyles && !!css && !!attributes?.style?.position?.type
  });
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, allowPositionStyles && element && !!css && (0,external_wp_element_namespaceObject.createPortal)((0,external_wp_element_namespaceObject.createElement)("style", null, css), element), (0,external_wp_element_namespaceObject.createElement)(BlockListBlock, { ...props,
    className: className
  }));
}, 'withPositionStyles');
(0,external_wp_hooks_namespaceObject.addFilter)('editor.BlockListBlock', 'core/editor/position/with-position-styles', withPositionStyles);
(0,external_wp_hooks_namespaceObject.addFilter)('editor.BlockEdit', 'core/editor/position/with-inspector-controls', withInspectorControls);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/layout.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */








/**
 * Internal dependencies
 */










const layoutBlockSupportKey = 'layout';

function hasLayoutBlockSupport(blockName) {
  return (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockName, 'layout') || (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockName, '__experimentalLayout');
}
/**
 * Generates the utility classnames for the given block's layout attributes.
 *
 * @param { Object } blockAttributes Block attributes.
 * @param { string } blockName       Block name.
 *
 * @return { Array } Array of CSS classname strings.
 */


function useLayoutClasses(blockAttributes = {}, blockName = '') {
  const rootPaddingAlignment = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getSettings
    } = select(store);
    return getSettings().__experimentalFeatures?.useRootPaddingAwareAlignments;
  }, []);
  const {
    layout
  } = blockAttributes;
  const {
    default: defaultBlockLayout
  } = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockName, layoutBlockSupportKey) || {};
  const usedLayout = layout?.inherit || layout?.contentSize || layout?.wideSize ? { ...layout,
    type: 'constrained'
  } : layout || defaultBlockLayout || {};
  const layoutClassnames = [];

  if (LAYOUT_DEFINITIONS[usedLayout?.type || 'default']?.className) {
    const baseClassName = LAYOUT_DEFINITIONS[usedLayout?.type || 'default']?.className;
    const compoundClassName = `wp-block-${blockName.split('/').pop()}-${baseClassName}`;
    layoutClassnames.push(baseClassName, compoundClassName);
  }

  if ((usedLayout?.inherit || usedLayout?.contentSize || usedLayout?.type === 'constrained') && rootPaddingAlignment) {
    layoutClassnames.push('has-global-padding');
  }

  if (usedLayout?.orientation) {
    layoutClassnames.push(`is-${kebabCase(usedLayout.orientation)}`);
  }

  if (usedLayout?.justifyContent) {
    layoutClassnames.push(`is-content-justification-${kebabCase(usedLayout.justifyContent)}`);
  }

  if (usedLayout?.flexWrap && usedLayout.flexWrap === 'nowrap') {
    layoutClassnames.push('is-nowrap');
  }

  return layoutClassnames;
}
/**
 * Generates a CSS rule with the given block's layout styles.
 *
 * @param { Object } blockAttributes Block attributes.
 * @param { string } blockName       Block name.
 * @param { string } selector        A selector to use in generating the CSS rule.
 *
 * @return { string } CSS rule.
 */

function useLayoutStyles(blockAttributes = {}, blockName, selector) {
  const {
    layout = {},
    style = {}
  } = blockAttributes; // Update type for blocks using legacy layouts.

  const usedLayout = layout?.inherit || layout?.contentSize || layout?.wideSize ? { ...layout,
    type: 'constrained'
  } : layout || {};
  const fullLayoutType = getLayoutType(usedLayout?.type || 'default');
  const blockGapSupport = use_setting_useSetting('spacing.blockGap');
  const hasBlockGapSupport = blockGapSupport !== null;
  const css = fullLayoutType?.getLayoutStyle?.({
    blockName,
    selector,
    layout,
    style,
    hasBlockGapSupport
  });
  return css;
}

function LayoutPanel({
  setAttributes,
  attributes,
  name: blockName
}) {
  const {
    layout
  } = attributes;
  const defaultThemeLayout = use_setting_useSetting('layout');
  const {
    themeSupportsLayout
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getSettings
    } = select(store);
    return {
      themeSupportsLayout: getSettings().supportsLayout
    };
  }, []);
  const blockEditingMode = useBlockEditingMode();
  const layoutBlockSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockName, layoutBlockSupportKey, {});
  const {
    allowSwitching,
    allowEditing = true,
    allowInheriting = true,
    default: defaultBlockLayout
  } = layoutBlockSupport;

  if (!allowEditing) {
    return null;
  } // Only show the inherit toggle if it's supported,
  // a default theme layout is set (e.g. one that provides `contentSize` and/or `wideSize` values),
  // and either the default / flow or the constrained layout type is in use, as the toggle switches from one to the other.


  const showInheritToggle = !!(allowInheriting && !!defaultThemeLayout && (!layout?.type || layout?.type === 'default' || layout?.type === 'constrained' || layout?.inherit));
  const usedLayout = layout || defaultBlockLayout || {};
  const {
    inherit = false,
    type = 'default',
    contentSize = null
  } = usedLayout;
  /**
   * `themeSupportsLayout` is only relevant to the `default/flow` or
   * `constrained` layouts and it should not be taken into account when other
   * `layout` types are used.
   */

  if ((type === 'default' || type === 'constrained') && !themeSupportsLayout) {
    return null;
  }

  const layoutType = getLayoutType(type);
  const constrainedType = getLayoutType('constrained');
  const displayControlsForLegacyLayouts = !usedLayout.type && (contentSize || inherit);
  const hasContentSizeOrLegacySettings = !!inherit || !!contentSize;

  const onChangeType = newType => setAttributes({
    layout: {
      type: newType
    }
  });

  const onChangeLayout = newLayout => setAttributes({
    layout: newLayout
  });

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(inspector_controls, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.PanelBody, {
    title: (0,external_wp_i18n_namespaceObject.__)('Layout')
  }, showInheritToggle && (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToggleControl, {
    __nextHasNoMarginBottom: true,
    className: "block-editor-hooks__toggle-control",
    label: (0,external_wp_i18n_namespaceObject.__)('Inner blocks use content width'),
    checked: layoutType?.name === 'constrained' || hasContentSizeOrLegacySettings,
    onChange: () => setAttributes({
      layout: {
        type: layoutType?.name === 'constrained' || hasContentSizeOrLegacySettings ? 'default' : 'constrained'
      }
    }),
    help: layoutType?.name === 'constrained' || hasContentSizeOrLegacySettings ? (0,external_wp_i18n_namespaceObject.__)('Nested blocks use content width with options for full and wide widths.') : (0,external_wp_i18n_namespaceObject.__)('Nested blocks will fill the width of this container. Toggle to constrain.')
  })), !inherit && allowSwitching && (0,external_wp_element_namespaceObject.createElement)(LayoutTypeSwitcher, {
    type: type,
    onChange: onChangeType
  }), layoutType && layoutType.name !== 'default' && (0,external_wp_element_namespaceObject.createElement)(layoutType.inspectorControls, {
    layout: usedLayout,
    onChange: onChangeLayout,
    layoutBlockSupport: layoutBlockSupport
  }), constrainedType && displayControlsForLegacyLayouts && (0,external_wp_element_namespaceObject.createElement)(constrainedType.inspectorControls, {
    layout: usedLayout,
    onChange: onChangeLayout,
    layoutBlockSupport: layoutBlockSupport
  }))), !inherit && blockEditingMode === 'default' && layoutType && (0,external_wp_element_namespaceObject.createElement)(layoutType.toolBarControls, {
    layout: usedLayout,
    onChange: onChangeLayout,
    layoutBlockSupport: layoutBlockSupport
  }));
}

function LayoutTypeSwitcher({
  type,
  onChange
}) {
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ButtonGroup, null, getLayoutTypes().map(({
    name,
    label
  }) => {
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
      key: name,
      isPressed: type === name,
      onClick: () => onChange(name)
    }, label);
  }));
}
/**
 * Filters registered block settings, extending attributes to include `layout`.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */


function layout_addAttribute(settings) {
  var _settings$attributes$;

  if ('type' in ((_settings$attributes$ = settings.attributes?.layout) !== null && _settings$attributes$ !== void 0 ? _settings$attributes$ : {})) {
    return settings;
  }

  if (hasLayoutBlockSupport(settings)) {
    settings.attributes = { ...settings.attributes,
      layout: {
        type: 'object'
      }
    };
  }

  return settings;
}
/**
 * Override the default edit UI to include layout controls
 *
 * @param {Function} BlockEdit Original component.
 *
 * @return {Function} Wrapped component.
 */

const layout_withInspectorControls = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(BlockEdit => props => {
  const {
    name: blockName
  } = props;
  const supportLayout = hasLayoutBlockSupport(blockName);
  const blockEditingMode = useBlockEditingMode();
  return [supportLayout && blockEditingMode === 'default' && (0,external_wp_element_namespaceObject.createElement)(LayoutPanel, {
    key: "layout",
    ...props
  }), (0,external_wp_element_namespaceObject.createElement)(BlockEdit, {
    key: "edit",
    ...props
  })];
}, 'withInspectorControls');
/**
 * Override the default block element to add the layout styles.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */

const withLayoutStyles = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(BlockListBlock => props => {
  const {
    name,
    attributes
  } = props;
  const blockSupportsLayout = hasLayoutBlockSupport(name);
  const disableLayoutStyles = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getSettings
    } = select(store);
    return !!getSettings().disableLayoutStyles;
  });
  const shouldRenderLayoutStyles = blockSupportsLayout && !disableLayoutStyles;
  const id = (0,external_wp_compose_namespaceObject.useInstanceId)(BlockListBlock);
  const element = (0,external_wp_element_namespaceObject.useContext)(BlockList.__unstableElementContext);
  const {
    layout
  } = attributes;
  const {
    default: defaultBlockLayout
  } = (0,external_wp_blocks_namespaceObject.getBlockSupport)(name, layoutBlockSupportKey) || {};
  const usedLayout = layout?.inherit || layout?.contentSize || layout?.wideSize ? { ...layout,
    type: 'constrained'
  } : layout || defaultBlockLayout || {};
  const layoutClasses = blockSupportsLayout ? useLayoutClasses(attributes, name) : null; // Higher specificity to override defaults from theme.json.

  const selector = `.wp-container-${id}.wp-container-${id}`;
  const blockGapSupport = use_setting_useSetting('spacing.blockGap');
  const hasBlockGapSupport = blockGapSupport !== null; // Get CSS string for the current layout type.
  // The CSS and `style` element is only output if it is not empty.

  let css;

  if (shouldRenderLayoutStyles) {
    const fullLayoutType = getLayoutType(usedLayout?.type || 'default');
    css = fullLayoutType?.getLayoutStyle?.({
      blockName: name,
      selector,
      layout: usedLayout,
      style: attributes?.style,
      hasBlockGapSupport
    });
  } // Attach a `wp-container-` id-based class name as well as a layout class name such as `is-layout-flex`.


  const layoutClassNames = classnames_default()({
    [`wp-container-${id}`]: shouldRenderLayoutStyles && !!css // Only attach a container class if there is generated CSS to be attached.

  }, layoutClasses);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, shouldRenderLayoutStyles && element && !!css && (0,external_wp_element_namespaceObject.createPortal)((0,external_wp_element_namespaceObject.createElement)(LayoutStyle, {
    blockName: name,
    selector: selector,
    css: css,
    layout: usedLayout,
    style: attributes?.style
  }), element), (0,external_wp_element_namespaceObject.createElement)(BlockListBlock, { ...props,
    __unstableLayoutClassNames: layoutClassNames
  }));
}, 'withLayoutStyles');
/**
 * Override the default block element to add the child layout styles.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */

const withChildLayoutStyles = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(BlockListBlock => props => {
  const {
    attributes
  } = props;
  const {
    style: {
      layout = {}
    } = {}
  } = attributes;
  const {
    selfStretch,
    flexSize
  } = layout;
  const hasChildLayout = selfStretch || flexSize;
  const disableLayoutStyles = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getSettings
    } = select(store);
    return !!getSettings().disableLayoutStyles;
  });
  const shouldRenderChildLayoutStyles = hasChildLayout && !disableLayoutStyles;
  const element = (0,external_wp_element_namespaceObject.useContext)(BlockList.__unstableElementContext);
  const id = (0,external_wp_compose_namespaceObject.useInstanceId)(BlockListBlock);
  const selector = `.wp-container-content-${id}`;
  let css = '';

  if (selfStretch === 'fixed' && flexSize) {
    css += `${selector} {
				flex-basis: ${flexSize};
				box-sizing: border-box;
			}`;
  } else if (selfStretch === 'fill') {
    css += `${selector} {
				flex-grow: 1;
			}`;
  } // Attach a `wp-container-content` id-based classname.


  const className = classnames_default()(props?.className, {
    [`wp-container-content-${id}`]: shouldRenderChildLayoutStyles && !!css // Only attach a container class if there is generated CSS to be attached.

  });
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, shouldRenderChildLayoutStyles && element && !!css && (0,external_wp_element_namespaceObject.createPortal)((0,external_wp_element_namespaceObject.createElement)("style", null, css), element), (0,external_wp_element_namespaceObject.createElement)(BlockListBlock, { ...props,
    className: className
  }));
}, 'withChildLayoutStyles');
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/layout/addAttribute', layout_addAttribute);
(0,external_wp_hooks_namespaceObject.addFilter)('editor.BlockListBlock', 'core/editor/layout/with-layout-styles', withLayoutStyles);
(0,external_wp_hooks_namespaceObject.addFilter)('editor.BlockListBlock', 'core/editor/layout/with-child-layout-styles', withChildLayoutStyles);
(0,external_wp_hooks_namespaceObject.addFilter)('editor.BlockEdit', 'core/editor/layout/with-inspector-controls', layout_withInspectorControls);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/convert-to-group-buttons/use-convert-to-group-button-props.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Contains the properties `ConvertToGroupButton` component needs.
 *
 * @typedef {Object} ConvertToGroupButtonProps
 * @property {string[]}  clientIds         An array of the selected client ids.
 * @property {boolean}   isGroupable       Indicates if the selected blocks can be grouped.
 * @property {boolean}   isUngroupable     Indicates if the selected blocks can be ungrouped.
 * @property {WPBlock[]} blocksSelection   An array of the selected blocks.
 * @property {string}    groupingBlockName The name of block used for handling grouping interactions.
 */

/**
 * Returns the properties `ConvertToGroupButton` component needs to work properly.
 * It is used in `BlockSettingsMenuControls` to know if `ConvertToGroupButton`
 * should be rendered, to avoid ending up with an empty MenuGroup.
 *
 * @param {?string[]} selectedClientIds An optional array of clientIds to group. The selected blocks
 *                                      from the block editor store are used if this is not provided.
 *
 * @return {ConvertToGroupButtonProps} Returns the properties needed by `ConvertToGroupButton`.
 */

function useConvertToGroupButtonProps(selectedClientIds) {
  return (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockRootClientId,
      getBlocksByClientId,
      canInsertBlockType,
      getSelectedBlockClientIds
    } = select(store);
    const {
      getGroupingBlockName,
      getBlockType
    } = select(external_wp_blocks_namespaceObject.store);
    const clientIds = selectedClientIds?.length ? selectedClientIds : getSelectedBlockClientIds();
    const groupingBlockName = getGroupingBlockName();
    const rootClientId = clientIds?.length ? getBlockRootClientId(clientIds[0]) : undefined;
    const groupingBlockAvailable = canInsertBlockType(groupingBlockName, rootClientId);
    const blocksSelection = getBlocksByClientId(clientIds);
    const isSingleBlockSelected = blocksSelection.length === 1;
    const [firstSelectedBlock] = blocksSelection; // A block is ungroupable if it is a single grouping block with inner blocks.
    // If a block has an `ungroup` transform, it is also ungroupable, without the
    // requirement of being the default grouping block.
    // Do we have a single grouping Block selected and does that group have inner blocks?

    const isUngroupable = isSingleBlockSelected && (firstSelectedBlock.name === groupingBlockName || getBlockType(firstSelectedBlock.name)?.transforms?.ungroup) && !!firstSelectedBlock.innerBlocks.length; // Do we have
    // 1. Grouping block available to be inserted?
    // 2. One or more blocks selected

    const isGroupable = groupingBlockAvailable && blocksSelection.length;
    return {
      clientIds,
      isGroupable,
      isUngroupable,
      blocksSelection,
      groupingBlockName,
      onUngroup: isUngroupable && getBlockType(firstSelectedBlock.name)?.transforms?.ungroup
    };
  }, [selectedClientIds]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/convert-to-group-buttons/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





function ConvertToGroupButton({
  clientIds,
  isGroupable,
  isUngroupable,
  onUngroup,
  blocksSelection,
  groupingBlockName,
  onClose = () => {}
}) {
  const {
    replaceBlocks
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);

  const onConvertToGroup = () => {
    // Activate the `transform` on the Grouping Block which does the conversion.
    const newBlocks = (0,external_wp_blocks_namespaceObject.switchToBlockType)(blocksSelection, groupingBlockName);

    if (newBlocks) {
      replaceBlocks(clientIds, newBlocks);
    }
  };

  const onConvertFromGroup = () => {
    let innerBlocks = blocksSelection[0].innerBlocks;

    if (!innerBlocks.length) {
      return;
    }

    if (onUngroup) {
      innerBlocks = onUngroup(blocksSelection[0].attributes, blocksSelection[0].innerBlocks);
    }

    replaceBlocks(clientIds, innerBlocks);
  };

  if (!isGroupable && !isUngroupable) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, isGroupable && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    onClick: () => {
      onConvertToGroup();
      onClose();
    }
  }, (0,external_wp_i18n_namespaceObject._x)('Group', 'verb')), isUngroupable && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    onClick: () => {
      onConvertFromGroup();
      onClose();
    }
  }, (0,external_wp_i18n_namespaceObject._x)('Ungroup', 'Ungrouping blocks from within a grouping block back into individual blocks within the Editor ')));
}



;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-lock/use-block-lock.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Return details about the block lock status.
 *
 * @param {string} clientId The block client Id.
 *
 * @return {Object} Block lock status
 */

function useBlockLock(clientId) {
  return (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      canEditBlock,
      canMoveBlock,
      canRemoveBlock,
      canLockBlockType,
      getBlockName,
      getBlockRootClientId,
      getTemplateLock
    } = select(store);
    const rootClientId = getBlockRootClientId(clientId);
    const canEdit = canEditBlock(clientId);
    const canMove = canMoveBlock(clientId, rootClientId);
    const canRemove = canRemoveBlock(clientId, rootClientId);
    return {
      canEdit,
      canMove,
      canRemove,
      canLock: canLockBlockType(getBlockName(clientId)),
      isContentLocked: getTemplateLock(clientId) === 'contentOnly',
      isLocked: !canEdit || !canMove || !canRemove
    };
  }, [clientId]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/unlock.js


/**
 * WordPress dependencies
 */

const unlock_unlock = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M17 10h-1.2V7c0-2.1-1.7-3.8-3.8-3.8-2.1 0-3.8 1.7-3.8 3.8h1.5c0-1.2 1-2.2 2.2-2.2s2.2 1 2.2 2.2v3H7c-.6 0-1 .4-1 1v8c0 .6.4 1 1 1h10c.6 0 1-.4 1-1v-8c0-.6-.4-1-1-1z"
}));
/* harmony default export */ var library_unlock = (unlock_unlock);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/lock-outline.js


/**
 * WordPress dependencies
 */

const lockOutline = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M17 10h-1.2V7c0-2.1-1.7-3.8-3.8-3.8-2.1 0-3.8 1.7-3.8 3.8v3H7c-.6 0-1 .4-1 1v8c0 .6.4 1 1 1h10c.6 0 1-.4 1-1v-8c0-.6-.4-1-1-1zM9.8 7c0-1.2 1-2.2 2.2-2.2 1.2 0 2.2 1 2.2 2.2v3H9.8V7zm6.7 11.5h-9v-7h9v7z"
}));
/* harmony default export */ var lock_outline = (lockOutline);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/lock.js


/**
 * WordPress dependencies
 */

const lock_lock = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M17 10h-1.2V7c0-2.1-1.7-3.8-3.8-3.8-2.1 0-3.8 1.7-3.8 3.8v3H7c-.6 0-1 .4-1 1v8c0 .6.4 1 1 1h10c.6 0 1-.4 1-1v-8c0-.6-.4-1-1-1zm-2.8 0H9.8V7c0-1.2 1-2.2 2.2-2.2s2.2 1 2.2 2.2v3z"
}));
/* harmony default export */ var library_lock = (lock_lock);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-lock/modal.js


/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */



 // Entity based blocks which allow edit locking

const ALLOWS_EDIT_LOCKING = ['core/block', 'core/navigation'];

function getTemplateLockValue(lock) {
  // Prevents all operations.
  if (lock.remove && lock.move) {
    return 'all';
  } // Prevents inserting or removing blocks, but allows moving existing blocks.


  if (lock.remove && !lock.move) {
    return 'insert';
  }

  return false;
}

function BlockLockModal({
  clientId,
  onClose
}) {
  const [lock, setLock] = (0,external_wp_element_namespaceObject.useState)({
    move: false,
    remove: false
  });
  const {
    canEdit,
    canMove,
    canRemove
  } = useBlockLock(clientId);
  const {
    allowsEditLocking,
    templateLock,
    hasTemplateLock
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockName,
      getBlockAttributes
    } = select(store);
    const blockName = getBlockName(clientId);
    const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockName);
    return {
      allowsEditLocking: ALLOWS_EDIT_LOCKING.includes(blockName),
      templateLock: getBlockAttributes(clientId)?.templateLock,
      hasTemplateLock: !!blockType?.attributes?.templateLock
    };
  }, [clientId]);
  const [applyTemplateLock, setApplyTemplateLock] = (0,external_wp_element_namespaceObject.useState)(!!templateLock);
  const {
    updateBlockAttributes
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const blockInformation = useBlockDisplayInformation(clientId);
  const instanceId = (0,external_wp_compose_namespaceObject.useInstanceId)(BlockLockModal, 'block-editor-block-lock-modal__options-title');
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    setLock({
      move: !canMove,
      remove: !canRemove,
      ...(allowsEditLocking ? {
        edit: !canEdit
      } : {})
    });
  }, [canEdit, canMove, canRemove, allowsEditLocking]);
  const isAllChecked = Object.values(lock).every(Boolean);
  const isMixed = Object.values(lock).some(Boolean) && !isAllChecked;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Modal, {
    title: (0,external_wp_i18n_namespaceObject.sprintf)(
    /* translators: %s: Name of the block. */
    (0,external_wp_i18n_namespaceObject.__)('Lock %s'), blockInformation.title),
    overlayClassName: "block-editor-block-lock-modal",
    onRequestClose: onClose
  }, (0,external_wp_element_namespaceObject.createElement)("p", null, (0,external_wp_i18n_namespaceObject.__)('Choose specific attributes to restrict or lock all available options.')), (0,external_wp_element_namespaceObject.createElement)("form", {
    onSubmit: event => {
      event.preventDefault();
      updateBlockAttributes([clientId], {
        lock,
        templateLock: applyTemplateLock ? getTemplateLockValue(lock) : undefined
      });
      onClose();
    }
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    role: "group",
    "aria-labelledby": instanceId,
    className: "block-editor-block-lock-modal__options"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.CheckboxControl, {
    __nextHasNoMarginBottom: true,
    className: "block-editor-block-lock-modal__options-title",
    label: (0,external_wp_element_namespaceObject.createElement)("span", {
      id: instanceId
    }, (0,external_wp_i18n_namespaceObject.__)('Lock all')),
    checked: isAllChecked,
    indeterminate: isMixed,
    onChange: newValue => setLock({
      move: newValue,
      remove: newValue,
      ...(allowsEditLocking ? {
        edit: newValue
      } : {})
    })
  }), (0,external_wp_element_namespaceObject.createElement)("ul", {
    className: "block-editor-block-lock-modal__checklist"
  }, allowsEditLocking && (0,external_wp_element_namespaceObject.createElement)("li", {
    className: "block-editor-block-lock-modal__checklist-item"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.CheckboxControl, {
    __nextHasNoMarginBottom: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Restrict editing'),
    checked: !!lock.edit,
    onChange: edit => setLock(prevLock => ({ ...prevLock,
      edit
    }))
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Icon, {
    className: "block-editor-block-lock-modal__lock-icon",
    icon: lock.edit ? library_lock : library_unlock
  })), (0,external_wp_element_namespaceObject.createElement)("li", {
    className: "block-editor-block-lock-modal__checklist-item"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.CheckboxControl, {
    __nextHasNoMarginBottom: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Disable movement'),
    checked: lock.move,
    onChange: move => setLock(prevLock => ({ ...prevLock,
      move
    }))
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Icon, {
    className: "block-editor-block-lock-modal__lock-icon",
    icon: lock.move ? library_lock : library_unlock
  })), (0,external_wp_element_namespaceObject.createElement)("li", {
    className: "block-editor-block-lock-modal__checklist-item"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.CheckboxControl, {
    __nextHasNoMarginBottom: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Prevent removal'),
    checked: lock.remove,
    onChange: remove => setLock(prevLock => ({ ...prevLock,
      remove
    }))
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Icon, {
    className: "block-editor-block-lock-modal__lock-icon",
    icon: lock.remove ? library_lock : library_unlock
  }))), hasTemplateLock && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToggleControl, {
    __nextHasNoMarginBottom: true,
    className: "block-editor-block-lock-modal__template-lock",
    label: (0,external_wp_i18n_namespaceObject.__)('Apply to all blocks inside'),
    checked: applyTemplateLock,
    disabled: lock.move && !lock.remove,
    onChange: () => setApplyTemplateLock(!applyTemplateLock)
  })), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Flex, {
    className: "block-editor-block-lock-modal__actions",
    justify: "flex-end",
    expanded: false
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    variant: "tertiary",
    onClick: onClose
  }, (0,external_wp_i18n_namespaceObject.__)('Cancel'))), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    variant: "primary",
    type: "submit"
  }, (0,external_wp_i18n_namespaceObject.__)('Apply'))))));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-lock/menu-item.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



function BlockLockMenuItem({
  clientId
}) {
  const {
    canLock,
    isLocked
  } = useBlockLock(clientId);
  const [isModalOpen, toggleModal] = (0,external_wp_element_namespaceObject.useReducer)(isActive => !isActive, false);

  if (!canLock) {
    return null;
  }

  const label = isLocked ? (0,external_wp_i18n_namespaceObject.__)('Unlock') : (0,external_wp_i18n_namespaceObject.__)('Lock');
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    icon: isLocked ? library_unlock : lock_outline,
    onClick: toggleModal
  }, label), isModalOpen && (0,external_wp_element_namespaceObject.createElement)(BlockLockModal, {
    clientId: clientId,
    onClose: toggleModal
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-mode-toggle.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



const block_mode_toggle_noop = () => {};

function BlockModeToggle({
  blockType,
  mode,
  onToggleMode,
  small = false,
  isCodeEditingEnabled = true
}) {
  if (!blockType || !(0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, 'html', true) || !isCodeEditingEnabled) {
    return null;
  }

  const label = mode === 'visual' ? (0,external_wp_i18n_namespaceObject.__)('Edit as HTML') : (0,external_wp_i18n_namespaceObject.__)('Edit visually');
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    onClick: onToggleMode
  }, !small && label);
}
/* harmony default export */ var block_mode_toggle = ((0,external_wp_compose_namespaceObject.compose)([(0,external_wp_data_namespaceObject.withSelect)((select, {
  clientId
}) => {
  const {
    getBlock,
    getBlockMode,
    getSettings
  } = select(store);
  const block = getBlock(clientId);
  const isCodeEditingEnabled = getSettings().codeEditingEnabled;
  return {
    mode: getBlockMode(clientId),
    blockType: block ? (0,external_wp_blocks_namespaceObject.getBlockType)(block.name) : null,
    isCodeEditingEnabled
  };
}), (0,external_wp_data_namespaceObject.withDispatch)((dispatch, {
  onToggle = block_mode_toggle_noop,
  clientId
}) => ({
  onToggleMode() {
    dispatch(store).toggleBlockMode(clientId);
    onToggle();
  }

}))])(BlockModeToggle));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu-controls/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





const {
  Fill,
  Slot: block_settings_menu_controls_Slot
} = (0,external_wp_components_namespaceObject.createSlotFill)('BlockSettingsMenuControls');

const BlockSettingsMenuControlsSlot = ({
  fillProps,
  clientIds = null,
  __unstableDisplayLocation
}) => {
  const {
    selectedBlocks,
    selectedClientIds,
    canRemove
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockNamesByClientId,
      getSelectedBlockClientIds,
      canRemoveBlocks
    } = select(store);
    const ids = clientIds !== null ? clientIds : getSelectedBlockClientIds();
    return {
      selectedBlocks: getBlockNamesByClientId(ids),
      selectedClientIds: ids,
      canRemove: canRemoveBlocks(ids)
    };
  }, [clientIds]);
  const {
    canLock
  } = useBlockLock(selectedClientIds[0]);
  const showLockButton = selectedClientIds.length === 1 && canLock; // Check if current selection of blocks is Groupable or Ungroupable
  // and pass this props down to ConvertToGroupButton.

  const convertToGroupButtonProps = useConvertToGroupButtonProps(selectedClientIds);
  const {
    isGroupable,
    isUngroupable
  } = convertToGroupButtonProps;
  const showConvertToGroupButton = (isGroupable || isUngroupable) && canRemove;
  return (0,external_wp_element_namespaceObject.createElement)(block_settings_menu_controls_Slot, {
    fillProps: { ...fillProps,
      __unstableDisplayLocation,
      selectedBlocks,
      selectedClientIds
    }
  }, fills => {
    if (!fills?.length > 0 && !showConvertToGroupButton && !showLockButton) {
      return null;
    }

    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuGroup, null, showConvertToGroupButton && (0,external_wp_element_namespaceObject.createElement)(ConvertToGroupButton, { ...convertToGroupButtonProps,
      onClose: fillProps?.onClose
    }), showLockButton && (0,external_wp_element_namespaceObject.createElement)(BlockLockMenuItem, {
      clientId: selectedClientIds[0]
    }), fills, fillProps?.canMove && !fillProps?.onlyBlock && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
      onClick: (0,external_wp_compose_namespaceObject.pipe)(fillProps?.onClose, fillProps?.onMoveTo)
    }, (0,external_wp_i18n_namespaceObject.__)('Move to')), fillProps?.count === 1 && (0,external_wp_element_namespaceObject.createElement)(block_mode_toggle, {
      clientId: fillProps?.firstBlockClientId,
      onToggle: fillProps?.onClose
    }));
  });
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-settings-menu-controls/README.md
 *
 * @param {Object} props Fill props.
 * @return {WPElement} Element.
 */


function BlockSettingsMenuControls({ ...props
}) {
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalStyleProvider, {
    document: document
  }, (0,external_wp_element_namespaceObject.createElement)(Fill, { ...props
  }));
}

BlockSettingsMenuControls.Slot = BlockSettingsMenuControlsSlot;
/* harmony default export */ var block_settings_menu_controls = (BlockSettingsMenuControls);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/content-lock-ui.js


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




function StopEditingAsBlocksOnOutsideSelect({
  clientId,
  stopEditingAsBlock
}) {
  const isBlockOrDescendantSelected = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      isBlockSelected,
      hasSelectedInnerBlock
    } = select(store);
    return isBlockSelected(clientId) || hasSelectedInnerBlock(clientId, true);
  }, [clientId]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!isBlockOrDescendantSelected) {
      stopEditingAsBlock();
    }
  }, [isBlockOrDescendantSelected, stopEditingAsBlock]);
  return null;
}

const content_lock_ui_withBlockControls = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(BlockEdit => props => {
  const {
    getBlockListSettings,
    getSettings
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const focusModeToRevert = (0,external_wp_element_namespaceObject.useRef)();
  const {
    templateLock,
    isLockedByParent,
    isEditingAsBlocks
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      __unstableGetContentLockingParent,
      getTemplateLock,
      __unstableGetTemporarilyEditingAsBlocks
    } = select(store);
    return {
      templateLock: getTemplateLock(props.clientId),
      isLockedByParent: !!__unstableGetContentLockingParent(props.clientId),
      isEditingAsBlocks: __unstableGetTemporarilyEditingAsBlocks() === props.clientId
    };
  }, [props.clientId]);
  const {
    updateSettings,
    updateBlockListSettings,
    __unstableSetTemporarilyEditingAsBlocks
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const isContentLocked = !isLockedByParent && templateLock === 'contentOnly';
  const {
    __unstableMarkNextChangeAsNotPersistent,
    updateBlockAttributes
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const stopEditingAsBlock = (0,external_wp_element_namespaceObject.useCallback)(() => {
    __unstableMarkNextChangeAsNotPersistent();

    updateBlockAttributes(props.clientId, {
      templateLock: 'contentOnly'
    });
    updateBlockListSettings(props.clientId, { ...getBlockListSettings(props.clientId),
      templateLock: 'contentOnly'
    });
    updateSettings({
      focusMode: focusModeToRevert.current
    });

    __unstableSetTemporarilyEditingAsBlocks();
  }, [props.clientId, updateSettings, updateBlockListSettings, getBlockListSettings, __unstableMarkNextChangeAsNotPersistent, updateBlockAttributes, __unstableSetTemporarilyEditingAsBlocks]);

  if (!isContentLocked && !isEditingAsBlocks) {
    return (0,external_wp_element_namespaceObject.createElement)(BlockEdit, {
      key: "edit",
      ...props
    });
  }

  const showStopEditingAsBlocks = isEditingAsBlocks && !isContentLocked;
  const showStartEditingAsBlocks = !isEditingAsBlocks && isContentLocked && props.isSelected;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, showStopEditingAsBlocks && (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(StopEditingAsBlocksOnOutsideSelect, {
    clientId: props.clientId,
    stopEditingAsBlock: stopEditingAsBlock
  }), (0,external_wp_element_namespaceObject.createElement)(block_controls, {
    group: "other"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarButton, {
    onClick: () => {
      stopEditingAsBlock();
    }
  }, (0,external_wp_i18n_namespaceObject.__)('Done')))), showStartEditingAsBlocks && (0,external_wp_element_namespaceObject.createElement)(block_settings_menu_controls, null, ({
    onClose
  }) => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    onClick: () => {
      __unstableMarkNextChangeAsNotPersistent();

      updateBlockAttributes(props.clientId, {
        templateLock: undefined
      });
      updateBlockListSettings(props.clientId, { ...getBlockListSettings(props.clientId),
        templateLock: false
      });
      focusModeToRevert.current = getSettings().focusMode;
      updateSettings({
        focusMode: true
      });

      __unstableSetTemporarilyEditingAsBlocks(props.clientId);

      onClose();
    }
  }, (0,external_wp_i18n_namespaceObject.__)('Modify'))), (0,external_wp_element_namespaceObject.createElement)(BlockEdit, {
    key: "edit",
    ...props
  }));
}, 'withToolbarControls');
(0,external_wp_hooks_namespaceObject.addFilter)('editor.BlockEdit', 'core/content-lock-ui/with-block-controls', content_lock_ui_withBlockControls);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/metadata.js
/**
 * WordPress dependencies
 */


const META_ATTRIBUTE_NAME = 'metadata';
function hasBlockMetadataSupport(blockType, feature = '') {
  // Only core blocks are allowed to use __experimentalMetadata until the fetaure is stablised.
  if (!blockType.name.startsWith('core/')) {
    return false;
  }

  const support = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, '__experimentalMetadata');
  return !!(true === support || support?.[feature]);
}
/**
 * Filters registered block settings, extending attributes to include `metadata`.
 *
 * see: https://github.com/WordPress/gutenberg/pull/40393/files#r864632012
 *
 * @param {Object} blockTypeSettings Original block settings.
 * @return {Object} Filtered block settings.
 */

function addMetaAttribute(blockTypeSettings) {
  // Allow blocks to specify their own attribute definition with default values if needed.
  if (blockTypeSettings?.attributes?.[META_ATTRIBUTE_NAME]?.type) {
    return blockTypeSettings;
  }

  const supportsBlockNaming = hasBlockMetadataSupport(blockTypeSettings, 'name');

  if (supportsBlockNaming) {
    blockTypeSettings.attributes = { ...blockTypeSettings.attributes,
      [META_ATTRIBUTE_NAME]: {
        type: 'object'
      }
    };
  }

  return blockTypeSettings;
}
function metadata_addSaveProps(extraProps, blockType, attributes) {
  if (hasBlockMetadataSupport(blockType)) {
    extraProps[META_ATTRIBUTE_NAME] = attributes[META_ATTRIBUTE_NAME];
  }

  return extraProps;
}
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/metadata/addMetaAttribute', addMetaAttribute);
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.getSaveContent.extraProps', 'core/metadata/save-props', metadata_addSaveProps);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/metadata-name.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Filters registered block settings, adding an `__experimentalLabel` callback if one does not already exist.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function addLabelCallback(settings) {
  // If blocks provide their own label callback, do not override it.
  if (settings.__experimentalLabel) {
    return settings;
  }

  const supportsBlockNaming = hasBlockMetadataSupport(settings, 'name', false // default value
  ); // Check whether block metadata is supported before using it.

  if (supportsBlockNaming) {
    settings.__experimentalLabel = (attributes, {
      context
    }) => {
      const {
        metadata
      } = attributes; // In the list view, use the block's name attribute as the label.

      if (context === 'list-view' && metadata?.name) {
        return metadata.name;
      }
    };
  }

  return settings;
}
(0,external_wp_hooks_namespaceObject.addFilter)('blocks.registerBlockType', 'core/metadata/addLabelCallback', addLabelCallback);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/behaviors.js


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




function BehaviorsControl({
  blockName,
  blockBehaviors,
  onChangeBehavior,
  onChangeAnimation,
  disabled = false
}) {
  const {
    settings,
    themeBehaviors
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBehaviors,
      getSettings
    } = select(store);
    return {
      settings: getSettings()?.__experimentalFeatures?.blocks?.[blockName]?.behaviors,
      themeBehaviors: getBehaviors()?.blocks?.[blockName]
    };
  }, [blockName]);
  const defaultBehaviors = {
    default: {
      value: 'default',
      label: (0,external_wp_i18n_namespaceObject.__)('Default')
    },
    noBehaviors: {
      value: '',
      label: (0,external_wp_i18n_namespaceObject.__)('No behaviors')
    }
  };
  const behaviorsOptions = Object.entries(settings).filter(([behaviorName, behaviorValue]) => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockName, `behaviors.${behaviorName}`) && behaviorValue) // Filter out behaviors that are disabled.
  .map(([behaviorName]) => ({
    value: behaviorName,
    // Capitalize the first letter of the behavior name.
    label: `${behaviorName.charAt(0).toUpperCase()}${behaviorName.slice(1).toLowerCase()}`
  }));
  const options = [...Object.values(defaultBehaviors), ...behaviorsOptions]; // If every behavior is disabled, do not show the behaviors inspector control.

  if (behaviorsOptions.length === 0) {
    return null;
  } // Block behaviors take precedence over theme behaviors.


  const behaviors = { ...themeBehaviors,
    ...(blockBehaviors || {})
  };
  const helpText = disabled ? (0,external_wp_i18n_namespaceObject.__)('The lightbox behavior is disabled for linked images.') : '';

  const value = () => {
    if (blockBehaviors === undefined) {
      return 'default';
    }

    if (behaviors?.lightbox.enabled) {
      return 'lightbox';
    }

    return '';
  };

  return (0,external_wp_element_namespaceObject.createElement)(inspector_controls, {
    group: "advanced"
  }, (0,external_wp_element_namespaceObject.createElement)("div", null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SelectControl, {
    label: (0,external_wp_i18n_namespaceObject.__)('Behaviors') // At the moment we are only supporting one behavior (Lightbox)
    ,
    value: value(),
    options: options,
    onChange: onChangeBehavior,
    hideCancelButton: true,
    help: helpText,
    size: "__unstable-large",
    disabled: disabled
  }), behaviors?.lightbox.enabled && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SelectControl, {
    label: (0,external_wp_i18n_namespaceObject.__)('Animation') // At the moment we are only supporting one behavior (Lightbox)
    ,
    value: behaviors?.lightbox.animation ? behaviors?.lightbox.animation : '',
    options: [{
      value: 'zoom',
      label: (0,external_wp_i18n_namespaceObject.__)('Zoom')
    }, {
      value: 'fade',
      label: 'Fade'
    }],
    onChange: onChangeAnimation,
    hideCancelButton: false,
    size: "__unstable-large",
    disabled: disabled
  })));
}
/**
 * Override the default edit UI to include a new block inspector control for
 * assigning behaviors to blocks if behaviors are enabled in the theme.json.
 *
 * Currently, only the `core/image` block is supported.
 *
 * @param {WPComponent} BlockEdit Original component.
 *
 * @return {WPComponent} Wrapped component.
 */


const withBehaviors = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(BlockEdit => {
  return props => {
    const blockEdit = (0,external_wp_element_namespaceObject.createElement)(BlockEdit, {
      key: "edit",
      ...props
    }); // Only add behaviors to blocks with support.

    if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(props.name, 'behaviors')) {
      return blockEdit;
    }

    const blockHasLink = typeof props.attributes?.linkDestination !== 'undefined' && props.attributes?.linkDestination !== 'none';
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, blockEdit, (0,external_wp_element_namespaceObject.createElement)(BehaviorsControl, {
      blockName: props.name,
      blockBehaviors: props.attributes.behaviors,
      onChangeBehavior: nextValue => {
        if (nextValue === 'default') {
          props.setAttributes({
            behaviors: undefined
          });
        } else {
          // If the user selects something, it means that they want to
          // change the default value (true) so we save it in the attributes.
          props.setAttributes({
            behaviors: {
              lightbox: {
                enabled: nextValue === 'lightbox',
                animation: nextValue === 'lightbox' ? 'zoom' : ''
              }
            }
          });
        }
      },
      onChangeAnimation: nextValue => {
        props.setAttributes({
          behaviors: {
            lightbox: {
              enabled: props.attributes.behaviors.lightbox.enabled,
              animation: nextValue
            }
          }
        });
      },
      disabled: blockHasLink
    }));
  };
}, 'withBehaviors');

if (window?.__experimentalInteractivityAPI) {
  (0,external_wp_hooks_namespaceObject.addFilter)('editor.BlockEdit', 'core/behaviors/with-inspector-control', withBehaviors);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/use-border-props.js
/**
 * Internal dependencies
 */


 // This utility is intended to assist where the serialization of the border
// block support is being skipped for a block but the border related CSS classes
// & styles still need to be generated so they can be applied to inner elements.

/**
 * Provides the CSS class names and inline styles for a block's border support
 * attributes.
 *
 * @param {Object} attributes Block attributes.
 * @return {Object} Border block support derived CSS classes & styles.
 */

function getBorderClassesAndStyles(attributes) {
  const border = attributes.style?.border || {};
  const className = getBorderClasses(attributes);
  return {
    className: className || undefined,
    style: getInlineStyles({
      border
    })
  };
}
/**
 * Derives the border related props for a block from its border block support
 * attributes.
 *
 * Inline styles are forced for named colors to ensure these selections are
 * reflected when themes do not load their color stylesheets in the editor.
 *
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} ClassName & style props from border block support.
 */

function useBorderProps(attributes) {
  const {
    colors
  } = useMultipleOriginColorsAndGradients();
  const borderProps = getBorderClassesAndStyles(attributes);
  const {
    borderColor
  } = attributes; // Force inline styles to apply named border colors when themes do not load
  // their color stylesheets in the editor.

  if (borderColor) {
    const borderColorObject = getMultiOriginColor({
      colors,
      namedColor: borderColor
    });
    borderProps.style.borderColor = borderColorObject.color;
  }

  return borderProps;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/use-color-props.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




 // The code in this file has largely been lifted from the color block support
// hook.
//
// This utility is intended to assist where the serialization of the colors
// block support is being skipped for a block but the color related CSS classes
// & styles still need to be generated so they can be applied to inner elements.

/**
 * Provides the CSS class names and inline styles for a block's color support
 * attributes.
 *
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} Color block support derived CSS classes & styles.
 */

function getColorClassesAndStyles(attributes) {
  const {
    backgroundColor,
    textColor,
    gradient,
    style
  } = attributes; // Collect color CSS classes.

  const backgroundClass = getColorClassName('background-color', backgroundColor);
  const textClass = getColorClassName('color', textColor);

  const gradientClass = __experimentalGetGradientClass(gradient);

  const hasGradient = gradientClass || style?.color?.gradient; // Determine color CSS class name list.

  const className = classnames_default()(textClass, gradientClass, {
    // Don't apply the background class if there's a gradient.
    [backgroundClass]: !hasGradient && !!backgroundClass,
    'has-text-color': textColor || style?.color?.text,
    'has-background': backgroundColor || style?.color?.background || gradient || style?.color?.gradient,
    'has-link-color': style?.elements?.link?.color
  }); // Collect inline styles for colors.

  const colorStyles = style?.color || {};
  const styleProp = getInlineStyles({
    color: colorStyles
  });
  return {
    className: className || undefined,
    style: styleProp
  };
}
const use_color_props_EMPTY_OBJECT = {};
/**
 * Determines the color related props for a block derived from its color block
 * support attributes.
 *
 * Inline styles are forced for named colors to ensure these selections are
 * reflected when themes do not load their color stylesheets in the editor.
 *
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} ClassName & style props from colors block support.
 */

function useColorProps(attributes) {
  const {
    backgroundColor,
    textColor,
    gradient
  } = attributes; // Some color settings have a special handling for deprecated flags in `useSetting`,
  // so we can't unwrap them by doing const { ... } = useSetting('color')
  // until https://github.com/WordPress/gutenberg/issues/37094 is fixed.

  const userPalette = use_setting_useSetting('color.palette.custom');
  const themePalette = use_setting_useSetting('color.palette.theme');
  const defaultPalette = use_setting_useSetting('color.palette.default');
  const gradientsPerOrigin = use_setting_useSetting('color.gradients') || use_color_props_EMPTY_OBJECT;
  const colors = (0,external_wp_element_namespaceObject.useMemo)(() => [...(userPalette || []), ...(themePalette || []), ...(defaultPalette || [])], [userPalette, themePalette, defaultPalette]);
  const gradients = (0,external_wp_element_namespaceObject.useMemo)(() => [...(gradientsPerOrigin?.custom || []), ...(gradientsPerOrigin?.theme || []), ...(gradientsPerOrigin?.default || [])], [gradientsPerOrigin]);
  const colorProps = getColorClassesAndStyles(attributes); // Force inline styles to apply colors when themes do not load their color
  // stylesheets in the editor.

  if (backgroundColor) {
    const backgroundColorObject = getColorObjectByAttributeValues(colors, backgroundColor);
    colorProps.style.backgroundColor = backgroundColorObject.color;
  }

  if (gradient) {
    colorProps.style.background = getGradientValueBySlug(gradients, gradient);
  }

  if (textColor) {
    const textColorObject = getColorObjectByAttributeValues(colors, textColor);
    colorProps.style.color = textColorObject.color;
  }

  return colorProps;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/use-spacing-props.js
/**
 * Internal dependencies
 */
 // This utility is intended to assist where the serialization of the spacing
// block support is being skipped for a block but the spacing related CSS
// styles still need to be generated so they can be applied to inner elements.

/**
 * Provides the CSS class names and inline styles for a block's spacing support
 * attributes.
 *
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} Spacing block support derived CSS classes & styles.
 */

function getSpacingClassesAndStyles(attributes) {
  const {
    style
  } = attributes; // Collect inline styles for spacing.

  const spacingStyles = style?.spacing || {};
  const styleProp = getInlineStyles({
    spacing: spacingStyles
  });
  return {
    style: styleProp
  };
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/use-typography-props.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */





/*
 * This utility is intended to assist where the serialization of the typography
 * block support is being skipped for a block but the typography related CSS
 * styles still need to be generated so they can be applied to inner elements.
 */

/**
 * Provides the CSS class names and inline styles for a block's typography support
 * attributes.
 *
 * @param {Object}         attributes Block attributes.
 * @param {Object|boolean} settings   Merged theme.json settings
 *
 * @return {Object} Typography block support derived CSS classes & styles.
 */

function getTypographyClassesAndStyles(attributes, settings) {
  let typographyStyles = attributes?.style?.typography || {};
  const fluidTypographySettings = getFluidTypographyOptionsFromSettings(settings);
  typographyStyles = { ...typographyStyles,
    fontSize: getTypographyFontSizeValue({
      size: attributes?.style?.typography?.fontSize
    }, fluidTypographySettings)
  };
  const style = getInlineStyles({
    typography: typographyStyles
  });
  const fontFamilyClassName = !!attributes?.fontFamily ? `has-${kebabCase(attributes.fontFamily)}-font-family` : '';
  const className = classnames_default()(fontFamilyClassName, getFontSizeClass(attributes?.fontSize));
  return {
    className,
    style
  };
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/use-cached-truthy.js
/**
 * WordPress dependencies
 */

/**
 * Keeps an up-to-date copy of the passed value and returns it. If value becomes falsy, it will return the last truthy copy.
 *
 * @param {any} value
 * @return {any} value
 */

function useCachedTruthy(value) {
  const [cachedValue, setCachedValue] = (0,external_wp_element_namespaceObject.useState)(value);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (value) {
      setCachedValue(value);
    }
  }, [value]);
  return cachedValue;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/index.js
/**
 * Internal dependencies
 */





























;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/colors/with-colors.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




/**
 * Capitalizes the first letter in a string.
 *
 * @param {string} str The string whose first letter the function will capitalize.
 *
 * @return {string} Capitalized string.
 */

const upperFirst = ([firstLetter, ...rest]) => firstLetter.toUpperCase() + rest.join('');
/**
 * Higher order component factory for injecting the `colorsArray` argument as
 * the colors prop in the `withCustomColors` HOC.
 *
 * @param {Array} colorsArray An array of color objects.
 *
 * @return {Function} The higher order component.
 */


const withCustomColorPalette = colorsArray => (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(WrappedComponent => props => (0,external_wp_element_namespaceObject.createElement)(WrappedComponent, { ...props,
  colors: colorsArray
}), 'withCustomColorPalette');
/**
 * Higher order component factory for injecting the editor colors as the
 * `colors` prop in the `withColors` HOC.
 *
 * @return {Function} The higher order component.
 */


const withEditorColorPalette = () => (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(WrappedComponent => props => {
  // Some color settings have a special handling for deprecated flags in `useSetting`,
  // so we can't unwrap them by doing const { ... } = useSetting('color')
  // until https://github.com/WordPress/gutenberg/issues/37094 is fixed.
  const userPalette = use_setting_useSetting('color.palette.custom');
  const themePalette = use_setting_useSetting('color.palette.theme');
  const defaultPalette = use_setting_useSetting('color.palette.default');
  const allColors = (0,external_wp_element_namespaceObject.useMemo)(() => [...(userPalette || []), ...(themePalette || []), ...(defaultPalette || [])], [userPalette, themePalette, defaultPalette]);
  return (0,external_wp_element_namespaceObject.createElement)(WrappedComponent, { ...props,
    colors: allColors
  });
}, 'withEditorColorPalette');
/**
 * Helper function used with `createHigherOrderComponent` to create
 * higher order components for managing color logic.
 *
 * @param {Array}    colorTypes       An array of color types (e.g. 'backgroundColor, borderColor).
 * @param {Function} withColorPalette A HOC for injecting the 'colors' prop into the WrappedComponent.
 *
 * @return {WPComponent} The component that can be used as a HOC.
 */


function createColorHOC(colorTypes, withColorPalette) {
  const colorMap = colorTypes.reduce((colorObject, colorType) => {
    return { ...colorObject,
      ...(typeof colorType === 'string' ? {
        [colorType]: kebabCase(colorType)
      } : colorType)
    };
  }, {});
  return (0,external_wp_compose_namespaceObject.compose)([withColorPalette, WrappedComponent => {
    return class extends external_wp_element_namespaceObject.Component {
      constructor(props) {
        super(props);
        this.setters = this.createSetters();
        this.colorUtils = {
          getMostReadableColor: this.getMostReadableColor.bind(this)
        };
        this.state = {};
      }

      getMostReadableColor(colorValue) {
        const {
          colors
        } = this.props;
        return getMostReadableColor(colors, colorValue);
      }

      createSetters() {
        return Object.keys(colorMap).reduce((settersAccumulator, colorAttributeName) => {
          const upperFirstColorAttributeName = upperFirst(colorAttributeName);
          const customColorAttributeName = `custom${upperFirstColorAttributeName}`;
          settersAccumulator[`set${upperFirstColorAttributeName}`] = this.createSetColor(colorAttributeName, customColorAttributeName);
          return settersAccumulator;
        }, {});
      }

      createSetColor(colorAttributeName, customColorAttributeName) {
        return colorValue => {
          const colorObject = getColorObjectByColorValue(this.props.colors, colorValue);
          this.props.setAttributes({
            [colorAttributeName]: colorObject && colorObject.slug ? colorObject.slug : undefined,
            [customColorAttributeName]: colorObject && colorObject.slug ? undefined : colorValue
          });
        };
      }

      static getDerivedStateFromProps({
        attributes,
        colors
      }, previousState) {
        return Object.entries(colorMap).reduce((newState, [colorAttributeName, colorContext]) => {
          const colorObject = getColorObjectByAttributeValues(colors, attributes[colorAttributeName], attributes[`custom${upperFirst(colorAttributeName)}`]);
          const previousColorObject = previousState[colorAttributeName];
          const previousColor = previousColorObject?.color;
          /**
           * The "and previousColorObject" condition checks that a previous color object was already computed.
           * At the start previousColorObject and colorValue are both equal to undefined
           * bus as previousColorObject does not exist we should compute the object.
           */

          if (previousColor === colorObject.color && previousColorObject) {
            newState[colorAttributeName] = previousColorObject;
          } else {
            newState[colorAttributeName] = { ...colorObject,
              class: getColorClassName(colorContext, colorObject.slug)
            };
          }

          return newState;
        }, {});
      }

      render() {
        return (0,external_wp_element_namespaceObject.createElement)(WrappedComponent, { ...this.props,
          colors: undefined,
          ...this.state,
          ...this.setters,
          colorUtils: this.colorUtils
        });
      }

    };
  }]);
}
/**
 * A higher-order component factory for creating a 'withCustomColors' HOC, which handles color logic
 * for class generation color value, retrieval and color attribute setting.
 *
 * Use this higher-order component to work with a custom set of colors.
 *
 * @example
 *
 * ```jsx
 * const CUSTOM_COLORS = [ { name: 'Red', slug: 'red', color: '#ff0000' }, { name: 'Blue', slug: 'blue', color: '#0000ff' } ];
 * const withCustomColors = createCustomColorsHOC( CUSTOM_COLORS );
 * // ...
 * export default compose(
 *     withCustomColors( 'backgroundColor', 'borderColor' ),
 *     MyColorfulComponent,
 * );
 * ```
 *
 * @param {Array} colorsArray The array of color objects (name, slug, color, etc... ).
 *
 * @return {Function} Higher-order component.
 */


function createCustomColorsHOC(colorsArray) {
  return (...colorTypes) => {
    const withColorPalette = withCustomColorPalette(colorsArray);
    return (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(createColorHOC(colorTypes, withColorPalette), 'withCustomColors');
  };
}
/**
 * A higher-order component, which handles color logic for class generation color value, retrieval and color attribute setting.
 *
 * For use with the default editor/theme color palette.
 *
 * @example
 *
 * ```jsx
 * export default compose(
 *     withColors( 'backgroundColor', { textColor: 'color' } ),
 *     MyColorfulComponent,
 * );
 * ```
 *
 * @param {...(Object|string)} colorTypes The arguments can be strings or objects. If the argument is an object,
 *                                        it should contain the color attribute name as key and the color context as value.
 *                                        If the argument is a string the value should be the color attribute name,
 *                                        the color context is computed by applying a kebab case transform to the value.
 *                                        Color context represents the context/place where the color is going to be used.
 *                                        The class name of the color is generated using 'has' followed by the color name
 *                                        and ending with the color context all in kebab case e.g: has-green-background-color.
 *
 * @return {Function} Higher-order component.
 */

function withColors(...colorTypes) {
  const withColorPalette = withEditorColorPalette();
  return (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(createColorHOC(colorTypes, withColorPalette), 'withColors');
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/colors/index.js



;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/gradients/index.js


;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/font-sizes/font-size-picker.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



function font_size_picker_FontSizePicker(props) {
  const fontSizes = use_setting_useSetting('typography.fontSizes');
  const disableCustomFontSizes = !use_setting_useSetting('typography.customFontSize');
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FontSizePicker, { ...props,
    fontSizes: fontSizes,
    disableCustomFontSizes: disableCustomFontSizes
  });
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/font-sizes/README.md
 */


/* harmony default export */ var font_size_picker = (font_size_picker_FontSizePicker);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/font-sizes/with-font-sizes.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const DEFAULT_FONT_SIZES = [];
/**
 * Capitalizes the first letter in a string.
 *
 * @param {string} str The string whose first letter the function will capitalize.
 *
 * @return {string} Capitalized string.
 */

const with_font_sizes_upperFirst = ([firstLetter, ...rest]) => firstLetter.toUpperCase() + rest.join('');
/**
 * Higher-order component, which handles font size logic for class generation,
 * font size value retrieval, and font size change handling.
 *
 * @param {...(Object|string)} fontSizeNames The arguments should all be strings.
 *                                           Each string contains the font size
 *                                           attribute name e.g: 'fontSize'.
 *
 * @return {Function} Higher-order component.
 */


/* harmony default export */ var with_font_sizes = ((...fontSizeNames) => {
  /*
   * Computes an object whose key is the font size attribute name as passed in the array,
   * and the value is the custom font size attribute name.
   * Custom font size is automatically compted by appending custom followed by the font size attribute name in with the first letter capitalized.
   */
  const fontSizeAttributeNames = fontSizeNames.reduce((fontSizeAttributeNamesAccumulator, fontSizeAttributeName) => {
    fontSizeAttributeNamesAccumulator[fontSizeAttributeName] = `custom${with_font_sizes_upperFirst(fontSizeAttributeName)}`;
    return fontSizeAttributeNamesAccumulator;
  }, {});
  return (0,external_wp_compose_namespaceObject.createHigherOrderComponent)((0,external_wp_compose_namespaceObject.compose)([(0,external_wp_compose_namespaceObject.createHigherOrderComponent)(WrappedComponent => props => {
    const fontSizes = use_setting_useSetting('typography.fontSizes') || DEFAULT_FONT_SIZES;
    return (0,external_wp_element_namespaceObject.createElement)(WrappedComponent, { ...props,
      fontSizes: fontSizes
    });
  }, 'withFontSizes'), WrappedComponent => {
    return class extends external_wp_element_namespaceObject.Component {
      constructor(props) {
        super(props);
        this.setters = this.createSetters();
        this.state = {};
      }

      createSetters() {
        return Object.entries(fontSizeAttributeNames).reduce((settersAccumulator, [fontSizeAttributeName, customFontSizeAttributeName]) => {
          const upperFirstFontSizeAttributeName = with_font_sizes_upperFirst(fontSizeAttributeName);
          settersAccumulator[`set${upperFirstFontSizeAttributeName}`] = this.createSetFontSize(fontSizeAttributeName, customFontSizeAttributeName);
          return settersAccumulator;
        }, {});
      }

      createSetFontSize(fontSizeAttributeName, customFontSizeAttributeName) {
        return fontSizeValue => {
          const fontSizeObject = this.props.fontSizes?.find(({
            size
          }) => size === Number(fontSizeValue));
          this.props.setAttributes({
            [fontSizeAttributeName]: fontSizeObject && fontSizeObject.slug ? fontSizeObject.slug : undefined,
            [customFontSizeAttributeName]: fontSizeObject && fontSizeObject.slug ? undefined : fontSizeValue
          });
        };
      }

      static getDerivedStateFromProps({
        attributes,
        fontSizes
      }, previousState) {
        const didAttributesChange = (customFontSizeAttributeName, fontSizeAttributeName) => {
          if (previousState[fontSizeAttributeName]) {
            // If new font size is name compare with the previous slug.
            if (attributes[fontSizeAttributeName]) {
              return attributes[fontSizeAttributeName] !== previousState[fontSizeAttributeName].slug;
            } // If font size is not named, update when the font size value changes.


            return previousState[fontSizeAttributeName].size !== attributes[customFontSizeAttributeName];
          } // In this case we need to build the font size object.


          return true;
        };

        if (!Object.values(fontSizeAttributeNames).some(didAttributesChange)) {
          return null;
        }

        const newState = Object.entries(fontSizeAttributeNames).filter(([key, value]) => didAttributesChange(value, key)).reduce((newStateAccumulator, [fontSizeAttributeName, customFontSizeAttributeName]) => {
          const fontSizeAttributeValue = attributes[fontSizeAttributeName];
          const fontSizeObject = utils_getFontSize(fontSizes, fontSizeAttributeValue, attributes[customFontSizeAttributeName]);
          newStateAccumulator[fontSizeAttributeName] = { ...fontSizeObject,
            class: getFontSizeClass(fontSizeAttributeValue)
          };
          return newStateAccumulator;
        }, {});
        return { ...previousState,
          ...newState
        };
      }

      render() {
        return (0,external_wp_element_namespaceObject.createElement)(WrappedComponent, { ...this.props,
          fontSizes: undefined,
          ...this.state,
          ...this.setters
        });
      }

    };
  }]), 'withFontSizes');
});

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/font-sizes/index.js





;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/duotone/index.js



;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/align-left.js


/**
 * WordPress dependencies
 */

const alignLeft = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M13 5.5H4V4h9v1.5Zm7 7H4V11h16v1.5Zm-7 7H4V18h9v1.5Z"
}));
/* harmony default export */ var align_left = (alignLeft);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/align-center.js


/**
 * WordPress dependencies
 */

const align_center_alignCenter = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M7.5 5.5h9V4h-9v1.5Zm-3.5 7h16V11H4v1.5Zm3.5 7h9V18h-9v1.5Z"
}));
/* harmony default export */ var align_center = (align_center_alignCenter);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/align-right.js


/**
 * WordPress dependencies
 */

const alignRight = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M11.111 5.5H20V4h-8.889v1.5ZM4 12.5h16V11H4v1.5Zm7.111 7H20V18h-8.889v1.5Z"
}));
/* harmony default export */ var align_right = (alignRight);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/alignment-control/ui.js


/**
 * WordPress dependencies
 */



const DEFAULT_ALIGNMENT_CONTROLS = [{
  icon: align_left,
  title: (0,external_wp_i18n_namespaceObject.__)('Align text left'),
  align: 'left'
}, {
  icon: align_center,
  title: (0,external_wp_i18n_namespaceObject.__)('Align text center'),
  align: 'center'
}, {
  icon: align_right,
  title: (0,external_wp_i18n_namespaceObject.__)('Align text right'),
  align: 'right'
}];
const ui_POPOVER_PROPS = {
  placement: 'bottom-start'
};

function AlignmentUI({
  value,
  onChange,
  alignmentControls = DEFAULT_ALIGNMENT_CONTROLS,
  label = (0,external_wp_i18n_namespaceObject.__)('Align text'),
  describedBy = (0,external_wp_i18n_namespaceObject.__)('Change text alignment'),
  isCollapsed = true,
  isToolbar
}) {
  function applyOrUnset(align) {
    return () => onChange(value === align ? undefined : align);
  }

  const activeAlignment = alignmentControls.find(control => control.align === value);

  function setIcon() {
    if (activeAlignment) return activeAlignment.icon;
    return (0,external_wp_i18n_namespaceObject.isRTL)() ? align_right : align_left;
  }

  const UIComponent = isToolbar ? external_wp_components_namespaceObject.ToolbarGroup : external_wp_components_namespaceObject.ToolbarDropdownMenu;
  const extraProps = isToolbar ? {
    isCollapsed
  } : {
    toggleProps: {
      describedBy
    },
    popoverProps: ui_POPOVER_PROPS
  };
  return (0,external_wp_element_namespaceObject.createElement)(UIComponent, {
    icon: setIcon(),
    label: label,
    controls: alignmentControls.map(control => {
      const {
        align
      } = control;
      const isActive = value === align;
      return { ...control,
        isActive,
        role: isCollapsed ? 'menuitemradio' : undefined,
        onClick: applyOrUnset(align)
      };
    }),
    ...extraProps
  });
}

/* harmony default export */ var alignment_control_ui = (AlignmentUI);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/alignment-control/index.js


/**
 * Internal dependencies
 */


const AlignmentControl = props => {
  return (0,external_wp_element_namespaceObject.createElement)(alignment_control_ui, { ...props,
    isToolbar: false
  });
};

const AlignmentToolbar = props => {
  return (0,external_wp_element_namespaceObject.createElement)(alignment_control_ui, { ...props,
    isToolbar: true
  });
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/alignment-control/README.md
 */




;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/autocompleters/block.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */








const block_noop = () => {};

const block_SHOWN_BLOCK_TYPES = 9;
/** @typedef {import('@wordpress/components').WPCompleter} WPCompleter */

/**
 * Creates a blocks repeater for replacing the current block with a selected block type.
 *
 * @return {WPCompleter} A blocks completer.
 */

function createBlockCompleter() {
  return {
    name: 'blocks',
    className: 'block-editor-autocompleters__block',
    triggerPrefix: '/',

    useItems(filterValue) {
      const {
        rootClientId,
        selectedBlockName,
        prioritizedBlocks
      } = (0,external_wp_data_namespaceObject.useSelect)(select => {
        const {
          getSelectedBlockClientId,
          getBlockName,
          getBlockListSettings,
          getBlockRootClientId
        } = select(store);
        const selectedBlockClientId = getSelectedBlockClientId();

        const _rootClientId = getBlockRootClientId(selectedBlockClientId);

        return {
          selectedBlockName: selectedBlockClientId ? getBlockName(selectedBlockClientId) : null,
          rootClientId: _rootClientId,
          prioritizedBlocks: getBlockListSettings(_rootClientId)?.prioritizedInserterBlocks
        };
      }, []);
      const [items, categories, collections] = use_block_types_state(rootClientId, block_noop);
      const filteredItems = (0,external_wp_element_namespaceObject.useMemo)(() => {
        const initialFilteredItems = !!filterValue.trim() ? searchBlockItems(items, categories, collections, filterValue) : orderInserterBlockItems(orderBy(items, 'frecency', 'desc'), prioritizedBlocks);
        return initialFilteredItems.filter(item => item.name !== selectedBlockName).slice(0, block_SHOWN_BLOCK_TYPES);
      }, [filterValue, selectedBlockName, items, categories, collections, prioritizedBlocks]);
      const options = (0,external_wp_element_namespaceObject.useMemo)(() => filteredItems.map(blockItem => {
        const {
          title,
          icon,
          isDisabled
        } = blockItem;
        return {
          key: `block-${blockItem.id}`,
          value: blockItem,
          label: (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(block_icon, {
            key: "icon",
            icon: icon,
            showColors: true
          }), title),
          isDisabled
        };
      }), [filteredItems]);
      return [options];
    },

    allowContext(before, after) {
      return !(/\S/.test(before) || /\S/.test(after));
    },

    getOptionCompletion(inserterItem) {
      const {
        name,
        initialAttributes,
        innerBlocks
      } = inserterItem;
      return {
        action: 'replace',
        value: (0,external_wp_blocks_namespaceObject.createBlock)(name, initialAttributes, (0,external_wp_blocks_namespaceObject.createBlocksFromInnerBlocksTemplate)(innerBlocks))
      };
    }

  };
}
/**
 * Creates a blocks repeater for replacing the current block with a selected block type.
 *
 * @return {WPCompleter} A blocks completer.
 */


/* harmony default export */ var autocompleters_block = (createBlockCompleter());

;// CONCATENATED MODULE: external ["wp","apiFetch"]
var external_wp_apiFetch_namespaceObject = window["wp"]["apiFetch"];
var external_wp_apiFetch_default = /*#__PURE__*/__webpack_require__.n(external_wp_apiFetch_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/page.js


/**
 * WordPress dependencies
 */

const page = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M7 5.5h10a.5.5 0 01.5.5v12a.5.5 0 01-.5.5H7a.5.5 0 01-.5-.5V6a.5.5 0 01.5-.5zM17 4H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V6a2 2 0 00-2-2zm-1 3.75H8v1.5h8v-1.5zM8 11h8v1.5H8V11zm6 3.25H8v1.5h6v-1.5z"
}));
/* harmony default export */ var library_page = (page);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/post.js


/**
 * WordPress dependencies
 */

const post = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "m7.3 9.7 1.4 1.4c.2-.2.3-.3.4-.5 0 0 0-.1.1-.1.3-.5.4-1.1.3-1.6L12 7 9 4 7.2 6.5c-.6-.1-1.1 0-1.6.3 0 0-.1 0-.1.1-.3.1-.4.2-.6.4l1.4 1.4L4 11v1h1l2.3-2.3zM4 20h9v-1.5H4V20zm0-5.5V16h16v-1.5H4z"
}));
/* harmony default export */ var library_post = (post);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/autocompleters/link.js


/**
 * WordPress dependencies
 */
// Disable Reason: Needs to be refactored.
// eslint-disable-next-line no-restricted-imports



const SHOWN_SUGGESTIONS = 10;
/** @typedef {import('@wordpress/components').WPCompleter} WPCompleter */

/**
 * Creates a suggestion list for links to posts or pages.
 *
 * @return {WPCompleter} A links completer.
 */

function createLinkCompleter() {
  return {
    name: 'links',
    className: 'block-editor-autocompleters__link',
    triggerPrefix: '[[',
    options: async letters => {
      let options = await external_wp_apiFetch_default()({
        path: (0,external_wp_url_namespaceObject.addQueryArgs)('/wp/v2/search', {
          per_page: SHOWN_SUGGESTIONS,
          search: letters,
          type: 'post',
          order_by: 'menu_order'
        })
      });
      options = options.filter(option => option.title !== '');
      return options;
    },

    getOptionKeywords(item) {
      const expansionWords = item.title.split(/\s+/);
      return [...expansionWords];
    },

    getOptionLabel(item) {
      return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
        key: "icon",
        icon: item.subtype === 'page' ? library_page : library_post
      }), item.title);
    },

    getOptionCompletion(item) {
      return (0,external_wp_element_namespaceObject.createElement)("a", {
        href: item.url
      }, item.title);
    }

  };
}
/**
 * Creates a suggestion list for links to posts or pages..
 *
 * @return {WPCompleter} A link completer.
 */


/* harmony default export */ var autocompleters_link = (createLinkCompleter());

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/autocomplete/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




/**
 * Shared reference to an empty array for cases where it is important to avoid
 * returning a new array reference on every invocation.
 *
 * @type {Array}
 */

const autocomplete_EMPTY_ARRAY = [];

function useCompleters({
  completers = autocomplete_EMPTY_ARRAY
}) {
  const {
    name
  } = useBlockEditContext();
  return (0,external_wp_element_namespaceObject.useMemo)(() => {
    let filteredCompleters = [...completers, autocompleters_link];

    if (name === (0,external_wp_blocks_namespaceObject.getDefaultBlockName)() || (0,external_wp_blocks_namespaceObject.getBlockSupport)(name, '__experimentalSlashInserter', false)) {
      filteredCompleters = [...filteredCompleters, autocompleters_block];
    }

    if ((0,external_wp_hooks_namespaceObject.hasFilter)('editor.Autocomplete.completers')) {
      // Provide copies so filters may directly modify them.
      if (filteredCompleters === completers) {
        filteredCompleters = filteredCompleters.map(completer => ({ ...completer
        }));
      }

      filteredCompleters = (0,external_wp_hooks_namespaceObject.applyFilters)('editor.Autocomplete.completers', filteredCompleters, name);
    }

    return filteredCompleters;
  }, [completers, name]);
}

function useBlockEditorAutocompleteProps(props) {
  return (0,external_wp_components_namespaceObject.__unstableUseAutocompleteProps)({ ...props,
    completers: useCompleters(props)
  });
}
/**
 * Wrap the default Autocomplete component with one that supports a filter hook
 * for customizing its list of autocompleters.
 *
 * @type {import('react').FC}
 */

function BlockEditorAutocomplete(props) {
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Autocomplete, { ...props,
    completers: useCompleters(props)
  });
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/autocomplete/README.md
 */


/* harmony default export */ var autocomplete = (BlockEditorAutocomplete);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/fullscreen.js


/**
 * WordPress dependencies
 */

const fullscreen = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M4.2 9h1.5V5.8H9V4.2H4.2V9zm14 9.2H15v1.5h4.8V15h-1.5v3.2zM15 4.2v1.5h3.2V9h1.5V4.2H15zM5.8 15H4.2v4.8H9v-1.5H5.8V15z"
}));
/* harmony default export */ var library_fullscreen = (fullscreen);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-full-height-alignment-control/index.js


/**
 * WordPress dependencies
 */




function BlockFullHeightAlignmentControl({
  isActive,
  label = (0,external_wp_i18n_namespaceObject.__)('Toggle full height'),
  onToggle,
  isDisabled
}) {
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarButton, {
    isActive: isActive,
    icon: library_fullscreen,
    label: label,
    onClick: () => onToggle(!isActive),
    disabled: isDisabled
  });
}

/* harmony default export */ var block_full_height_alignment_control = (BlockFullHeightAlignmentControl);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-alignment-matrix-control/index.js


/**
 * WordPress dependencies
 */




const block_alignment_matrix_control_noop = () => {};

function BlockAlignmentMatrixControl(props) {
  const {
    label = (0,external_wp_i18n_namespaceObject.__)('Change matrix alignment'),
    onChange = block_alignment_matrix_control_noop,
    value = 'center',
    isDisabled
  } = props;
  const icon = (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalAlignmentMatrixControl.Icon, {
    value: value
  });
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Dropdown, {
    popoverProps: {
      placement: 'bottom-start'
    },
    renderToggle: ({
      onToggle,
      isOpen
    }) => {
      const openOnArrowDown = event => {
        if (!isOpen && event.keyCode === external_wp_keycodes_namespaceObject.DOWN) {
          event.preventDefault();
          onToggle();
        }
      };

      return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarButton, {
        onClick: onToggle,
        "aria-haspopup": "true",
        "aria-expanded": isOpen,
        onKeyDown: openOnArrowDown,
        label: label,
        icon: icon,
        showTooltip: true,
        disabled: isDisabled
      });
    },
    renderContent: () => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalAlignmentMatrixControl, {
      hasFocusBorder: false,
      onChange: onChange,
      value: value
    })
  });
}

/* harmony default export */ var block_alignment_matrix_control = (BlockAlignmentMatrixControl);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/chevron-right-small.js


/**
 * WordPress dependencies
 */

const chevronRightSmall = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M10.8622 8.04053L14.2805 12.0286L10.8622 16.0167L9.72327 15.0405L12.3049 12.0286L9.72327 9.01672L10.8622 8.04053Z"
}));
/* harmony default export */ var chevron_right_small = (chevronRightSmall);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-title/use-block-display-title.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/**
 * Returns the block's configured title as a string, or empty if the title
 * cannot be determined.
 *
 * @example
 *
 * ```js
 * useBlockDisplayTitle( { clientId: 'afd1cb17-2c08-4e7a-91be-007ba7ddc3a1', maximumLength: 17 } );
 * ```
 *
 * @param {Object}           props
 * @param {string}           props.clientId      Client ID of block.
 * @param {number|undefined} props.maximumLength The maximum length that the block title string may be before truncated.
 * @param {string|undefined} props.context       The context to pass to `getBlockLabel`.
 * @return {?string} Block title.
 */

function useBlockDisplayTitle({
  clientId,
  maximumLength,
  context
}) {
  const {
    attributes,
    name,
    reusableBlockTitle
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    if (!clientId) {
      return {};
    }

    const {
      getBlockName,
      getBlockAttributes,
      __experimentalGetReusableBlockTitle
    } = select(store);
    const blockName = getBlockName(clientId);

    if (!blockName) {
      return {};
    }

    const isReusable = (0,external_wp_blocks_namespaceObject.isReusableBlock)((0,external_wp_blocks_namespaceObject.getBlockType)(blockName));
    return {
      attributes: getBlockAttributes(clientId),
      name: blockName,
      reusableBlockTitle: isReusable && __experimentalGetReusableBlockTitle(getBlockAttributes(clientId).ref)
    };
  }, [clientId]);
  const blockInformation = useBlockDisplayInformation(clientId);

  if (!name || !blockInformation) {
    return null;
  }

  const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(name);
  const blockLabel = blockType ? (0,external_wp_blocks_namespaceObject.__experimentalGetBlockLabel)(blockType, attributes, context) : null;
  const label = reusableBlockTitle || blockLabel; // Label will fallback to the title if no label is defined for the current
  // label context. If the label is defined we prioritize it over a
  // possible block variation title match.

  const blockTitle = label && label !== blockType.title ? label : blockInformation.title;

  if (maximumLength && maximumLength > 0 && blockTitle.length > maximumLength) {
    const omission = '...';
    return blockTitle.slice(0, maximumLength - omission.length) + omission;
  }

  return blockTitle;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-title/index.js
/**
 * Internal dependencies
 */

/**
 * Renders the block's configured title as a string, or empty if the title
 * cannot be determined.
 *
 * @example
 *
 * ```jsx
 * <BlockTitle clientId="afd1cb17-2c08-4e7a-91be-007ba7ddc3a1" maximumLength={ 17 }/>
 * ```
 *
 * @param {Object}           props
 * @param {string}           props.clientId      Client ID of block.
 * @param {number|undefined} props.maximumLength The maximum length that the block title string may be before truncated.
 * @param {string|undefined} props.context       The context to pass to `getBlockLabel`.
 *
 * @return {JSX.Element} Block title.
 */

function BlockTitle({
  clientId,
  maximumLength,
  context
}) {
  return useBlockDisplayTitle({
    clientId,
    maximumLength,
    context
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-breadcrumb/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




/**
 * Block breadcrumb component, displaying the hierarchy of the current block selection as a breadcrumb.
 *
 * @param {Object} props               Component props.
 * @param {string} props.rootLabelText Translated label for the root element of the breadcrumb trail.
 * @return {WPElement}                 Block Breadcrumb.
 */

function BlockBreadcrumb({
  rootLabelText
}) {
  const {
    selectBlock,
    clearSelectedBlock
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const {
    clientId,
    parents,
    hasSelection
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getSelectionStart,
      getSelectedBlockClientId,
      getEnabledBlockParents
    } = unlock(select(store));
    const selectedBlockClientId = getSelectedBlockClientId();
    return {
      parents: getEnabledBlockParents(selectedBlockClientId),
      clientId: selectedBlockClientId,
      hasSelection: !!getSelectionStart().clientId
    };
  }, []);

  const rootLabel = rootLabelText || (0,external_wp_i18n_namespaceObject.__)('Document');
  /*
   * Disable reason: The `list` ARIA role is redundant but
   * Safari+VoiceOver won't announce the list otherwise.
   */

  /* eslint-disable jsx-a11y/no-redundant-roles */


  return (0,external_wp_element_namespaceObject.createElement)("ul", {
    className: "block-editor-block-breadcrumb",
    role: "list",
    "aria-label": (0,external_wp_i18n_namespaceObject.__)('Block breadcrumb')
  }, (0,external_wp_element_namespaceObject.createElement)("li", {
    className: !hasSelection ? 'block-editor-block-breadcrumb__current' : undefined,
    "aria-current": !hasSelection ? 'true' : undefined
  }, hasSelection && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    className: "block-editor-block-breadcrumb__button",
    variant: "tertiary",
    onClick: clearSelectedBlock
  }, rootLabel), !hasSelection && rootLabel, !!clientId && (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
    icon: chevron_right_small,
    className: "block-editor-block-breadcrumb__separator"
  })), parents.map(parentClientId => (0,external_wp_element_namespaceObject.createElement)("li", {
    key: parentClientId
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    className: "block-editor-block-breadcrumb__button",
    variant: "tertiary",
    onClick: () => selectBlock(parentClientId)
  }, (0,external_wp_element_namespaceObject.createElement)(BlockTitle, {
    clientId: parentClientId,
    maximumLength: 35
  })), (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
    icon: chevron_right_small,
    className: "block-editor-block-breadcrumb__separator"
  }))), !!clientId && (0,external_wp_element_namespaceObject.createElement)("li", {
    className: "block-editor-block-breadcrumb__current",
    "aria-current": "true"
  }, (0,external_wp_element_namespaceObject.createElement)(BlockTitle, {
    clientId: clientId,
    maximumLength: 35
  })))
  /* eslint-enable jsx-a11y/no-redundant-roles */
  ;
}

/* harmony default export */ var block_breadcrumb = (BlockBreadcrumb);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/color-style-selector/index.js


/**
 * WordPress dependencies
 */





const ColorSelectorSVGIcon = () => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SVG, {
  xmlns: "https://www.w3.org/2000/svg",
  viewBox: "0 0 20 20"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Path, {
  d: "M7.434 5l3.18 9.16H8.538l-.692-2.184H4.628l-.705 2.184H2L5.18 5h2.254zm-1.13 1.904h-.115l-1.148 3.593H7.44L6.304 6.904zM14.348 7.006c1.853 0 2.9.876 2.9 2.374v4.78h-1.79v-.914h-.114c-.362.64-1.123 1.022-2.031 1.022-1.346 0-2.292-.826-2.292-2.108 0-1.27.972-2.006 2.71-2.107l1.696-.102V9.38c0-.584-.42-.914-1.18-.914-.667 0-1.112.228-1.264.647h-1.701c.12-1.295 1.307-2.107 3.066-2.107zm1.079 4.1l-1.416.09c-.793.056-1.18.342-1.18.844 0 .52.45.837 1.091.837.857 0 1.505-.545 1.505-1.256v-.515z"
}));
/**
 * Color Selector Icon component.
 *
 * @param {Object} props           Component properties.
 * @param {Object} props.style     Style object.
 * @param {string} props.className Class name for component.
 *
 * @return {*} React Icon component.
 */


const ColorSelectorIcon = ({
  style,
  className
}) => {
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-library-colors-selector__icon-container"
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: `${className} block-library-colors-selector__state-selection`,
    style: style
  }, (0,external_wp_element_namespaceObject.createElement)(ColorSelectorSVGIcon, null)));
};
/**
 * Renders the Colors Selector Toolbar with the icon button.
 *
 * @param {Object} props                 Component properties.
 * @param {Object} props.TextColor       Text color component that wraps icon.
 * @param {Object} props.BackgroundColor Background color component that wraps icon.
 *
 * @return {*} React toggle button component.
 */


const renderToggleComponent = ({
  TextColor,
  BackgroundColor
}) => ({
  onToggle,
  isOpen
}) => {
  const openOnArrowDown = event => {
    if (!isOpen && event.keyCode === external_wp_keycodes_namespaceObject.DOWN) {
      event.preventDefault();
      onToggle();
    }
  };

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarGroup, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarButton, {
    className: "components-toolbar__control block-library-colors-selector__toggle",
    label: (0,external_wp_i18n_namespaceObject.__)('Open Colors Selector'),
    onClick: onToggle,
    onKeyDown: openOnArrowDown,
    icon: (0,external_wp_element_namespaceObject.createElement)(BackgroundColor, null, (0,external_wp_element_namespaceObject.createElement)(TextColor, null, (0,external_wp_element_namespaceObject.createElement)(ColorSelectorIcon, null)))
  }));
};

const BlockColorsStyleSelector = ({
  children,
  ...other
}) => {
  external_wp_deprecated_default()(`wp.blockEditor.BlockColorsStyleSelector`, {
    alternative: 'block supports API',
    since: '6.1',
    version: '6.3'
  });
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Dropdown, {
    popoverProps: {
      placement: 'bottom-start'
    },
    className: "block-library-colors-selector",
    contentClassName: "block-library-colors-selector__popover",
    renderToggle: renderToggleComponent(other),
    renderContent: () => children
  });
};

/* harmony default export */ var color_style_selector = (BlockColorsStyleSelector);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/list-view.js


/**
 * WordPress dependencies
 */

const listView = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M3 6h11v1.5H3V6Zm3.5 5.5h11V13h-11v-1.5ZM21 17H10v1.5h11V17Z"
}));
/* harmony default export */ var list_view = (listView);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/list-view/context.js
/**
 * WordPress dependencies
 */

const ListViewContext = (0,external_wp_element_namespaceObject.createContext)({});
const useListViewContext = () => (0,external_wp_element_namespaceObject.useContext)(ListViewContext);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/list-view/aria-referenced-text.js


/**
 * WordPress dependencies
 */

/**
 * A component specifically designed to be used as an element referenced
 * by ARIA attributes such as `aria-labelledby` or `aria-describedby`.
 *
 * @param {Object}                    props          Props.
 * @param {import('react').ReactNode} props.children
 */

function AriaReferencedText({
  children,
  ...props
}) {
  const ref = (0,external_wp_element_namespaceObject.useRef)();
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (ref.current) {
      // This seems like a no-op, but it fixes a bug in Firefox where
      // it fails to recompute the text when only the text node changes.
      // @see https://github.com/WordPress/gutenberg/pull/51035
      ref.current.textContent = ref.current.textContent;
    }
  }, [children]);
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    hidden: true,
    ...props,
    ref: ref
  }, children);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/list-view/appender.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */






const Appender = (0,external_wp_element_namespaceObject.forwardRef)(({
  nestingLevel,
  blockCount,
  clientId,
  ...props
}, ref) => {
  const {
    insertedBlock,
    setInsertedBlock
  } = useListViewContext();
  const instanceId = (0,external_wp_compose_namespaceObject.useInstanceId)(Appender);
  const {
    hideInserter
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getTemplateLock,
      __unstableGetEditorMode
    } = select(store);
    return {
      hideInserter: !!getTemplateLock(clientId) || __unstableGetEditorMode() === 'zoom-out'
    };
  }, [clientId]);
  const blockTitle = useBlockDisplayTitle({
    clientId,
    context: 'list-view'
  });
  const insertedBlockTitle = useBlockDisplayTitle({
    clientId: insertedBlock?.clientId,
    context: 'list-view'
  });
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!insertedBlockTitle?.length) {
      return;
    }

    (0,external_wp_a11y_namespaceObject.speak)((0,external_wp_i18n_namespaceObject.sprintf)( // translators: %s: name of block being inserted (i.e. Paragraph, Image, Group etc)
    (0,external_wp_i18n_namespaceObject.__)('%s block inserted'), insertedBlockTitle), 'assertive');
  }, [insertedBlockTitle]);

  if (hideInserter) {
    return null;
  }

  const descriptionId = `list-view-appender__${instanceId}`;
  const description = (0,external_wp_i18n_namespaceObject.sprintf)(
  /* translators: 1: The name of the block. 2: The numerical position of the block. 3: The level of nesting for the block. */
  (0,external_wp_i18n_namespaceObject.__)('Append to %1$s block at position %2$d, Level %3$d'), blockTitle, blockCount + 1, nestingLevel);
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "list-view-appender"
  }, (0,external_wp_element_namespaceObject.createElement)(inserter, {
    ref: ref,
    rootClientId: clientId,
    position: "bottom right",
    isAppender: true,
    selectBlockOnInsert: false,
    shouldDirectInsert: false,
    __experimentalIsQuick: true,
    ...props,
    toggleProps: {
      'aria-describedby': descriptionId
    },
    onSelectOrClose: maybeInsertedBlock => {
      if (maybeInsertedBlock?.clientId) {
        setInsertedBlock(maybeInsertedBlock);
      }
    }
  }), (0,external_wp_element_namespaceObject.createElement)(AriaReferencedText, {
    id: descriptionId
  }, description));
});

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/list-view/leaf.js


/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


const AnimatedTreeGridRow = animated(external_wp_components_namespaceObject.__experimentalTreeGridRow);
const ListViewLeaf = (0,external_wp_element_namespaceObject.forwardRef)(({
  isSelected,
  position,
  level,
  rowCount,
  children,
  className,
  path,
  ...props
}, ref) => {
  const animationRef = use_moving_animation({
    isSelected,
    adjustScrolling: false,
    enableAnimation: true,
    triggerAnimationOnChange: path
  });
  const mergedRef = (0,external_wp_compose_namespaceObject.useMergeRefs)([ref, animationRef]);
  return (0,external_wp_element_namespaceObject.createElement)(AnimatedTreeGridRow, {
    ref: mergedRef,
    className: classnames_default()('block-editor-list-view-leaf', className),
    level: level,
    positionInSet: position,
    setSize: rowCount,
    isExpanded: undefined,
    ...props
  }, children);
});
/* harmony default export */ var leaf = (ListViewLeaf);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/list-view/use-list-view-scroll-into-view.js
/**
 * WordPress dependencies
 */


function useListViewScrollIntoView({
  isSelected,
  selectedClientIds,
  rowItemRef
}) {
  const isSingleSelection = selectedClientIds.length === 1;
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    // Skip scrolling into view if this particular block isn't selected,
    // or if more than one block is selected overall. This is to avoid
    // scrolling the view in a multi selection where the user has intentionally
    // selected multiple blocks within the list view, but the initially
    // selected block may be out of view.
    if (!isSelected || !isSingleSelection || !rowItemRef.current) {
      return;
    }

    const scrollContainer = (0,external_wp_dom_namespaceObject.getScrollContainer)(rowItemRef.current);
    const {
      ownerDocument
    } = rowItemRef.current;
    const windowScroll = scrollContainer === ownerDocument.body || scrollContainer === ownerDocument.documentElement; // If the there is no scroll container, of if the scroll container is the window,
    // do not scroll into view, as the block is already in view.

    if (windowScroll || !scrollContainer) {
      return;
    }

    const rowRect = rowItemRef.current.getBoundingClientRect();
    const scrollContainerRect = scrollContainer.getBoundingClientRect(); // If the selected block is not currently visible, scroll to it.

    if (rowRect.top < scrollContainerRect.top || rowRect.bottom > scrollContainerRect.bottom) {
      rowItemRef.current.scrollIntoView();
    }
  }, [isSelected, isSingleSelection, rowItemRef]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/chevron-up.js


/**
 * WordPress dependencies
 */

const chevronUp = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M6.5 12.4L12 8l5.5 4.4-.9 1.2L12 10l-4.5 3.6-1-1.2z"
}));
/* harmony default export */ var chevron_up = (chevronUp);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/chevron-down.js


/**
 * WordPress dependencies
 */

const chevronDown = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M17.5 11.6L12 16l-5.5-4.4.9-1.2L12 14l4.5-3.6 1 1.2z"
}));
/* harmony default export */ var chevron_down = (chevronDown);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-mover/mover-description.js
/**
 * WordPress dependencies
 */


const getMovementDirection = (moveDirection, orientation) => {
  if (moveDirection === 'up') {
    if (orientation === 'horizontal') {
      return (0,external_wp_i18n_namespaceObject.isRTL)() ? 'right' : 'left';
    }

    return 'up';
  } else if (moveDirection === 'down') {
    if (orientation === 'horizontal') {
      return (0,external_wp_i18n_namespaceObject.isRTL)() ? 'left' : 'right';
    }

    return 'down';
  }

  return null;
};
/**
 * Return a label for the block movement controls depending on block position.
 *
 * @param {number}  selectedCount Number of blocks selected.
 * @param {string}  type          Block type - in the case of a single block, should
 *                                define its 'type'. I.e. 'Text', 'Heading', 'Image' etc.
 * @param {number}  firstIndex    The index (position - 1) of the first block selected.
 * @param {boolean} isFirst       This is the first block.
 * @param {boolean} isLast        This is the last block.
 * @param {number}  dir           Direction of movement (> 0 is considered to be going
 *                                down, < 0 is up).
 * @param {string}  orientation   The orientation of the block movers, vertical or
 *                                horizontal.
 *
 * @return {string | undefined} Label for the block movement controls.
 */


function getBlockMoverDescription(selectedCount, type, firstIndex, isFirst, isLast, dir, orientation) {
  const position = firstIndex + 1;

  if (selectedCount > 1) {
    return getMultiBlockMoverDescription(selectedCount, firstIndex, isFirst, isLast, dir, orientation);
  }

  if (isFirst && isLast) {
    return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: %s: Type of block (i.e. Text, Image etc)
    (0,external_wp_i18n_namespaceObject.__)('Block %s is the only block, and cannot be moved'), type);
  }

  if (dir > 0 && !isLast) {
    // Moving down.
    const movementDirection = getMovementDirection('down', orientation);

    if (movementDirection === 'down') {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      (0,external_wp_i18n_namespaceObject.__)('Move %1$s block from position %2$d down to position %3$d'), type, position, position + 1);
    }

    if (movementDirection === 'left') {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      (0,external_wp_i18n_namespaceObject.__)('Move %1$s block from position %2$d left to position %3$d'), type, position, position + 1);
    }

    if (movementDirection === 'right') {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      (0,external_wp_i18n_namespaceObject.__)('Move %1$s block from position %2$d right to position %3$d'), type, position, position + 1);
    }
  }

  if (dir > 0 && isLast) {
    // Moving down, and is the last item.
    const movementDirection = getMovementDirection('down', orientation);

    if (movementDirection === 'down') {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: Type of block (i.e. Text, Image etc)
      (0,external_wp_i18n_namespaceObject.__)('Block %1$s is at the end of the content and can’t be moved down'), type);
    }

    if (movementDirection === 'left') {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: Type of block (i.e. Text, Image etc)
      (0,external_wp_i18n_namespaceObject.__)('Block %1$s is at the end of the content and can’t be moved left'), type);
    }

    if (movementDirection === 'right') {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: Type of block (i.e. Text, Image etc)
      (0,external_wp_i18n_namespaceObject.__)('Block %1$s is at the end of the content and can’t be moved right'), type);
    }
  }

  if (dir < 0 && !isFirst) {
    // Moving up.
    const movementDirection = getMovementDirection('up', orientation);

    if (movementDirection === 'up') {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      (0,external_wp_i18n_namespaceObject.__)('Move %1$s block from position %2$d up to position %3$d'), type, position, position - 1);
    }

    if (movementDirection === 'left') {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      (0,external_wp_i18n_namespaceObject.__)('Move %1$s block from position %2$d left to position %3$d'), type, position, position - 1);
    }

    if (movementDirection === 'right') {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      (0,external_wp_i18n_namespaceObject.__)('Move %1$s block from position %2$d right to position %3$d'), type, position, position - 1);
    }
  }

  if (dir < 0 && isFirst) {
    // Moving up, and is the first item.
    const movementDirection = getMovementDirection('up', orientation);

    if (movementDirection === 'up') {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: Type of block (i.e. Text, Image etc)
      (0,external_wp_i18n_namespaceObject.__)('Block %1$s is at the beginning of the content and can’t be moved up'), type);
    }

    if (movementDirection === 'left') {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: Type of block (i.e. Text, Image etc)
      (0,external_wp_i18n_namespaceObject.__)('Block %1$s is at the beginning of the content and can’t be moved left'), type);
    }

    if (movementDirection === 'right') {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: Type of block (i.e. Text, Image etc)
      (0,external_wp_i18n_namespaceObject.__)('Block %1$s is at the beginning of the content and can’t be moved right'), type);
    }
  }
}
/**
 * Return a label for the block movement controls depending on block position.
 *
 * @param {number}  selectedCount Number of blocks selected.
 * @param {number}  firstIndex    The index (position - 1) of the first block selected.
 * @param {boolean} isFirst       This is the first block.
 * @param {boolean} isLast        This is the last block.
 * @param {number}  dir           Direction of movement (> 0 is considered to be going
 *                                down, < 0 is up).
 * @param {string}  orientation   The orientation of the block movers, vertical or
 *                                horizontal.
 *
 * @return {string | undefined} Label for the block movement controls.
 */

function getMultiBlockMoverDescription(selectedCount, firstIndex, isFirst, isLast, dir, orientation) {
  const position = firstIndex + 1;

  if (isFirst && isLast) {
    // All blocks are selected
    return (0,external_wp_i18n_namespaceObject.__)('All blocks are selected, and cannot be moved');
  }

  if (dir > 0 && !isLast) {
    // moving down
    const movementDirection = getMovementDirection('down', orientation);

    if (movementDirection === 'down') {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: Number of selected blocks, 2: Position of selected blocks
      (0,external_wp_i18n_namespaceObject.__)('Move %1$d blocks from position %2$d down by one place'), selectedCount, position);
    }

    if (movementDirection === 'left') {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: Number of selected blocks, 2: Position of selected blocks
      (0,external_wp_i18n_namespaceObject.__)('Move %1$d blocks from position %2$d left by one place'), selectedCount, position);
    }

    if (movementDirection === 'right') {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: Number of selected blocks, 2: Position of selected blocks
      (0,external_wp_i18n_namespaceObject.__)('Move %1$d blocks from position %2$d right by one place'), selectedCount, position);
    }
  }

  if (dir > 0 && isLast) {
    // moving down, and the selected blocks are the last item
    const movementDirection = getMovementDirection('down', orientation);

    if (movementDirection === 'down') {
      return (0,external_wp_i18n_namespaceObject.__)('Blocks cannot be moved down as they are already at the bottom');
    }

    if (movementDirection === 'left') {
      return (0,external_wp_i18n_namespaceObject.__)('Blocks cannot be moved left as they are already are at the leftmost position');
    }

    if (movementDirection === 'right') {
      return (0,external_wp_i18n_namespaceObject.__)('Blocks cannot be moved right as they are already are at the rightmost position');
    }
  }

  if (dir < 0 && !isFirst) {
    // moving up
    const movementDirection = getMovementDirection('up', orientation);

    if (movementDirection === 'up') {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: Number of selected blocks, 2: Position of selected blocks
      (0,external_wp_i18n_namespaceObject.__)('Move %1$d blocks from position %2$d up by one place'), selectedCount, position);
    }

    if (movementDirection === 'left') {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: Number of selected blocks, 2: Position of selected blocks
      (0,external_wp_i18n_namespaceObject.__)('Move %1$d blocks from position %2$d left by one place'), selectedCount, position);
    }

    if (movementDirection === 'right') {
      return (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: Number of selected blocks, 2: Position of selected blocks
      (0,external_wp_i18n_namespaceObject.__)('Move %1$d blocks from position %2$d right by one place'), selectedCount, position);
    }
  }

  if (dir < 0 && isFirst) {
    // moving up, and the selected blocks are the first item
    const movementDirection = getMovementDirection('up', orientation);

    if (movementDirection === 'up') {
      return (0,external_wp_i18n_namespaceObject.__)('Blocks cannot be moved up as they are already at the top');
    }

    if (movementDirection === 'left') {
      return (0,external_wp_i18n_namespaceObject.__)('Blocks cannot be moved left as they are already are at the leftmost position');
    }

    if (movementDirection === 'right') {
      return (0,external_wp_i18n_namespaceObject.__)('Blocks cannot be moved right as they are already are at the rightmost position');
    }
  }
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-mover/button.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */





const getArrowIcon = (direction, orientation) => {
  if (direction === 'up') {
    if (orientation === 'horizontal') {
      return (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_right : chevron_left;
    }

    return chevron_up;
  } else if (direction === 'down') {
    if (orientation === 'horizontal') {
      return (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_left : chevron_right;
    }

    return chevron_down;
  }

  return null;
};

const getMovementDirectionLabel = (moveDirection, orientation) => {
  if (moveDirection === 'up') {
    if (orientation === 'horizontal') {
      return (0,external_wp_i18n_namespaceObject.isRTL)() ? (0,external_wp_i18n_namespaceObject.__)('Move right') : (0,external_wp_i18n_namespaceObject.__)('Move left');
    }

    return (0,external_wp_i18n_namespaceObject.__)('Move up');
  } else if (moveDirection === 'down') {
    if (orientation === 'horizontal') {
      return (0,external_wp_i18n_namespaceObject.isRTL)() ? (0,external_wp_i18n_namespaceObject.__)('Move left') : (0,external_wp_i18n_namespaceObject.__)('Move right');
    }

    return (0,external_wp_i18n_namespaceObject.__)('Move down');
  }

  return null;
};

const BlockMoverButton = (0,external_wp_element_namespaceObject.forwardRef)(({
  clientIds,
  direction,
  orientation: moverOrientation,
  ...props
}, ref) => {
  const instanceId = (0,external_wp_compose_namespaceObject.useInstanceId)(BlockMoverButton);
  const normalizedClientIds = Array.isArray(clientIds) ? clientIds : [clientIds];
  const blocksCount = normalizedClientIds.length;
  const {
    blockType,
    isDisabled,
    rootClientId,
    isFirst,
    isLast,
    firstIndex,
    orientation = 'vertical'
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockIndex,
      getBlockRootClientId,
      getBlockOrder,
      getBlock,
      getBlockListSettings
    } = select(store);
    const firstClientId = normalizedClientIds[0];
    const blockRootClientId = getBlockRootClientId(firstClientId);
    const firstBlockIndex = getBlockIndex(firstClientId);
    const lastBlockIndex = getBlockIndex(normalizedClientIds[normalizedClientIds.length - 1]);
    const blockOrder = getBlockOrder(blockRootClientId);
    const block = getBlock(firstClientId);
    const isFirstBlock = firstBlockIndex === 0;
    const isLastBlock = lastBlockIndex === blockOrder.length - 1;
    const {
      orientation: blockListOrientation
    } = getBlockListSettings(blockRootClientId) || {};
    return {
      blockType: block ? (0,external_wp_blocks_namespaceObject.getBlockType)(block.name) : null,
      isDisabled: direction === 'up' ? isFirstBlock : isLastBlock,
      rootClientId: blockRootClientId,
      firstIndex: firstBlockIndex,
      isFirst: isFirstBlock,
      isLast: isLastBlock,
      orientation: moverOrientation || blockListOrientation
    };
  }, [clientIds, direction]);
  const {
    moveBlocksDown,
    moveBlocksUp
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const moverFunction = direction === 'up' ? moveBlocksUp : moveBlocksDown;

  const onClick = event => {
    moverFunction(clientIds, rootClientId);

    if (props.onClick) {
      props.onClick(event);
    }
  };

  const descriptionId = `block-editor-block-mover-button__description-${instanceId}`;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    ref: ref,
    className: classnames_default()('block-editor-block-mover-button', `is-${direction}-button`),
    icon: getArrowIcon(direction, orientation),
    label: getMovementDirectionLabel(direction, orientation),
    "aria-describedby": descriptionId,
    ...props,
    onClick: isDisabled ? null : onClick,
    disabled: isDisabled,
    __experimentalIsFocusable: true
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.VisuallyHidden, {
    id: descriptionId
  }, getBlockMoverDescription(blocksCount, blockType && blockType.title, firstIndex, isFirst, isLast, direction === 'up' ? -1 : 1, orientation)));
});
const BlockMoverUpButton = (0,external_wp_element_namespaceObject.forwardRef)((props, ref) => {
  return (0,external_wp_element_namespaceObject.createElement)(BlockMoverButton, {
    direction: "up",
    ref: ref,
    ...props
  });
});
const BlockMoverDownButton = (0,external_wp_element_namespaceObject.forwardRef)((props, ref) => {
  return (0,external_wp_element_namespaceObject.createElement)(BlockMoverButton, {
    direction: "down",
    ref: ref,
    ...props
  });
});

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/pin-small.js


/**
 * WordPress dependencies
 */

const pinSmall = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M10.97 10.159a3.382 3.382 0 0 0-2.857.955l1.724 1.723-2.836 2.913L7 17h1.25l2.913-2.837 1.723 1.723a3.38 3.38 0 0 0 .606-.825c.33-.63.446-1.343.35-2.032L17 10.695 13.305 7l-2.334 3.159Z"
}));
/* harmony default export */ var pin_small = (pinSmall);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/lock-small.js


/**
 * WordPress dependencies
 */

const lockSmall = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M15 11h-.2V9c0-1.5-1.2-2.8-2.8-2.8S9.2 7.5 9.2 9v2H9c-.6 0-1 .4-1 1v4c0 .6.4 1 1 1h6c.6 0 1-.4 1-1v-4c0-.6-.4-1-1-1zm-1.8 0h-2.5V9c0-.7.6-1.2 1.2-1.2s1.2.6 1.2 1.2v2z"
}));
/* harmony default export */ var lock_small = (lockSmall);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/chevron-left-small.js


/**
 * WordPress dependencies
 */

const chevronLeftSmall = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "m13.1 16-3.4-4 3.4-4 1.1 1-2.6 3 2.6 3-1.1 1z"
}));
/* harmony default export */ var chevron_left_small = (chevronLeftSmall);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/list-view/expander.js


/**
 * WordPress dependencies
 */


function ListViewExpander({
  onClick
}) {
  return (// Keyboard events are handled by TreeGrid see: components/src/tree-grid/index.js
    //
    // The expander component is implemented as a pseudo element in the w3 example
    // https://www.w3.org/TR/wai-aria-practices/examples/treegrid/treegrid-1.html
    //
    // We've mimicked this by adding an icon with aria-hidden set to true to hide this from the accessibility tree.
    // For the current tree grid implementation, please do not try to make this a button.
    //
    // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
    (0,external_wp_element_namespaceObject.createElement)("span", {
      className: "block-editor-list-view__expander",
      onClick: event => onClick(event, {
        forceToggle: true
      }),
      "aria-hidden": "true",
      "data-testid": "list-view-expander"
    }, (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
      icon: (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_left_small : chevron_right_small
    }))
  );
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/list-view/block-select-button.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */








/**
 * Internal dependencies
 */








function ListViewBlockSelectButton({
  className,
  block: {
    clientId
  },
  onClick,
  onToggleExpanded,
  tabIndex,
  onFocus,
  onDragStart,
  onDragEnd,
  draggable,
  isExpanded,
  ariaLabel,
  ariaDescribedBy,
  updateFocusAndSelection
}, ref) {
  const blockInformation = useBlockDisplayInformation(clientId);
  const blockTitle = useBlockDisplayTitle({
    clientId,
    context: 'list-view'
  });
  const {
    isLocked
  } = useBlockLock(clientId);
  const {
    getSelectedBlockClientIds,
    getPreviousBlockClientId,
    getBlockRootClientId,
    getBlockOrder,
    canRemoveBlocks
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    removeBlocks
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const isMatch = (0,external_wp_keyboardShortcuts_namespaceObject.__unstableUseShortcutEventMatch)();
  const isSticky = blockInformation?.positionType === 'sticky';
  const positionLabel = blockInformation?.positionLabel ? (0,external_wp_i18n_namespaceObject.sprintf)( // translators: 1: Position of selected block, e.g. "Sticky" or "Fixed".
  (0,external_wp_i18n_namespaceObject.__)('Position: %1$s'), blockInformation.positionLabel) : ''; // The `href` attribute triggers the browser's native HTML drag operations.
  // When the link is dragged, the element's outerHTML is set in DataTransfer object as text/html.
  // We need to clear any HTML drag data to prevent `pasteHandler` from firing
  // inside the `useOnBlockDrop` hook.

  const onDragStartHandler = event => {
    event.dataTransfer.clearData();
    onDragStart?.(event);
  };
  /**
   * @param {KeyboardEvent} event
   */


  function onKeyDownHandler(event) {
    if (event.keyCode === external_wp_keycodes_namespaceObject.ENTER || event.keyCode === external_wp_keycodes_namespaceObject.SPACE) {
      onClick(event);
    } else if (event.keyCode === external_wp_keycodes_namespaceObject.BACKSPACE || event.keyCode === external_wp_keycodes_namespaceObject.DELETE || isMatch('core/block-editor/remove', event)) {
      var _getPreviousBlockClie;

      const selectedBlockClientIds = getSelectedBlockClientIds();
      const isDeletingSelectedBlocks = selectedBlockClientIds.includes(clientId);
      const firstBlockClientId = isDeletingSelectedBlocks ? selectedBlockClientIds[0] : clientId;
      const firstBlockRootClientId = getBlockRootClientId(firstBlockClientId);
      const blocksToDelete = isDeletingSelectedBlocks ? selectedBlockClientIds : [clientId]; // Don't update the selection if the blocks cannot be deleted.

      if (!canRemoveBlocks(blocksToDelete, firstBlockRootClientId)) {
        return;
      }

      let blockToFocus = (_getPreviousBlockClie = getPreviousBlockClientId(firstBlockClientId)) !== null && _getPreviousBlockClie !== void 0 ? _getPreviousBlockClie : // If the previous block is not found (when the first block is deleted),
      // fallback to focus the parent block.
      firstBlockRootClientId;
      removeBlocks(blocksToDelete, false); // Update the selection if the original selection has been removed.

      const shouldUpdateSelection = selectedBlockClientIds.length > 0 && getSelectedBlockClientIds().length === 0; // If there's no previous block nor parent block, focus the first block.

      if (!blockToFocus) {
        blockToFocus = getBlockOrder()[0];
      }

      updateFocusAndSelection(blockToFocus, shouldUpdateSelection);
    }
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    className: classnames_default()('block-editor-list-view-block-select-button', className),
    onClick: onClick,
    onKeyDown: onKeyDownHandler,
    ref: ref,
    tabIndex: tabIndex,
    onFocus: onFocus,
    onDragStart: onDragStartHandler,
    onDragEnd: onDragEnd,
    draggable: draggable,
    href: `#block-${clientId}`,
    "aria-label": ariaLabel,
    "aria-describedby": ariaDescribedBy,
    "aria-expanded": isExpanded
  }, (0,external_wp_element_namespaceObject.createElement)(ListViewExpander, {
    onClick: onToggleExpanded
  }), (0,external_wp_element_namespaceObject.createElement)(block_icon, {
    icon: blockInformation?.icon,
    showColors: true,
    context: "list-view"
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHStack, {
    alignment: "center",
    className: "block-editor-list-view-block-select-button__label-wrapper",
    justify: "flex-start",
    spacing: 1
  }, (0,external_wp_element_namespaceObject.createElement)("span", {
    className: "block-editor-list-view-block-select-button__title"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalTruncate, {
    ellipsizeMode: "auto"
  }, blockTitle)), blockInformation?.anchor && (0,external_wp_element_namespaceObject.createElement)("span", {
    className: "block-editor-list-view-block-select-button__anchor-wrapper"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalTruncate, {
    className: "block-editor-list-view-block-select-button__anchor",
    ellipsizeMode: "auto"
  }, blockInformation.anchor)), positionLabel && isSticky && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Tooltip, {
    text: positionLabel
  }, (0,external_wp_element_namespaceObject.createElement)("span", {
    className: "block-editor-list-view-block-select-button__sticky"
  }, (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
    icon: pin_small
  }))), isLocked && (0,external_wp_element_namespaceObject.createElement)("span", {
    className: "block-editor-list-view-block-select-button__lock"
  }, (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
    icon: lock_small
  })))));
}

/* harmony default export */ var block_select_button = ((0,external_wp_element_namespaceObject.forwardRef)(ListViewBlockSelectButton));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-draggable/use-scroll-when-dragging.js
/**
 * WordPress dependencies
 */


const SCROLL_INACTIVE_DISTANCE_PX = 50;
const SCROLL_INTERVAL_MS = 25;
const PIXELS_PER_SECOND_PER_PERCENTAGE = 1000;
const VELOCITY_MULTIPLIER = PIXELS_PER_SECOND_PER_PERCENTAGE * (SCROLL_INTERVAL_MS / 1000);
/**
 * React hook that scrolls the scroll container when a block is being dragged.
 *
 * @return {Function[]} `startScrolling`, `scrollOnDragOver`, `stopScrolling`
 *                      functions to be called in `onDragStart`, `onDragOver`
 *                      and `onDragEnd` events respectively.
 */

function useScrollWhenDragging() {
  const dragStartY = (0,external_wp_element_namespaceObject.useRef)(null);
  const velocityY = (0,external_wp_element_namespaceObject.useRef)(null);
  const scrollParentY = (0,external_wp_element_namespaceObject.useRef)(null);
  const scrollEditorInterval = (0,external_wp_element_namespaceObject.useRef)(null); // Clear interval when unmounting.

  (0,external_wp_element_namespaceObject.useEffect)(() => () => {
    if (scrollEditorInterval.current) {
      clearInterval(scrollEditorInterval.current);
      scrollEditorInterval.current = null;
    }
  }, []);
  const startScrolling = (0,external_wp_element_namespaceObject.useCallback)(event => {
    dragStartY.current = event.clientY; // Find nearest parent(s) to scroll.

    scrollParentY.current = (0,external_wp_dom_namespaceObject.getScrollContainer)(event.target);
    scrollEditorInterval.current = setInterval(() => {
      if (scrollParentY.current && velocityY.current) {
        const newTop = scrollParentY.current.scrollTop + velocityY.current; // Setting `behavior: 'smooth'` as a scroll property seems to hurt performance.
        // Better to use a small scroll interval.

        scrollParentY.current.scroll({
          top: newTop
        });
      }
    }, SCROLL_INTERVAL_MS);
  }, []);
  const scrollOnDragOver = (0,external_wp_element_namespaceObject.useCallback)(event => {
    if (!scrollParentY.current) {
      return;
    }

    const scrollParentHeight = scrollParentY.current.offsetHeight;
    const offsetDragStartPosition = dragStartY.current - scrollParentY.current.offsetTop;
    const offsetDragPosition = event.clientY - scrollParentY.current.offsetTop;

    if (event.clientY > offsetDragStartPosition) {
      // User is dragging downwards.
      const moveableDistance = Math.max(scrollParentHeight - offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
      const dragDistance = Math.max(offsetDragPosition - offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
      const distancePercentage = moveableDistance === 0 || dragDistance === 0 ? 0 : dragDistance / moveableDistance;
      velocityY.current = VELOCITY_MULTIPLIER * distancePercentage;
    } else if (event.clientY < offsetDragStartPosition) {
      // User is dragging upwards.
      const moveableDistance = Math.max(offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
      const dragDistance = Math.max(offsetDragStartPosition - offsetDragPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
      const distancePercentage = moveableDistance === 0 || dragDistance === 0 ? 0 : dragDistance / moveableDistance;
      velocityY.current = -VELOCITY_MULTIPLIER * distancePercentage;
    } else {
      velocityY.current = 0;
    }
  }, []);

  const stopScrolling = () => {
    dragStartY.current = null;
    scrollParentY.current = null;

    if (scrollEditorInterval.current) {
      clearInterval(scrollEditorInterval.current);
      scrollEditorInterval.current = null;
    }
  };

  return [startScrolling, scrollOnDragOver, stopScrolling];
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-draggable/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





const BlockDraggable = ({
  children,
  clientIds,
  cloneClassname,
  onDragStart,
  onDragEnd
}) => {
  const {
    srcRootClientId,
    isDraggable,
    icon
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      canMoveBlocks,
      getBlockRootClientId,
      getBlockName,
      getBlockAttributes
    } = select(store);
    const {
      getBlockType,
      getActiveBlockVariation
    } = select(external_wp_blocks_namespaceObject.store);
    const rootClientId = getBlockRootClientId(clientIds[0]);
    const blockName = getBlockName(clientIds[0]);
    const variation = getActiveBlockVariation(blockName, getBlockAttributes(clientIds[0]));
    return {
      srcRootClientId: rootClientId,
      isDraggable: canMoveBlocks(clientIds, rootClientId),
      icon: variation?.icon || getBlockType(blockName)?.icon
    };
  }, [clientIds]);
  const isDragging = (0,external_wp_element_namespaceObject.useRef)(false);
  const [startScrolling, scrollOnDragOver, stopScrolling] = useScrollWhenDragging();
  const {
    startDraggingBlocks,
    stopDraggingBlocks
  } = (0,external_wp_data_namespaceObject.useDispatch)(store); // Stop dragging blocks if the block draggable is unmounted.

  (0,external_wp_element_namespaceObject.useEffect)(() => {
    return () => {
      if (isDragging.current) {
        stopDraggingBlocks();
      }
    };
  }, []);

  if (!isDraggable) {
    return children({
      draggable: false
    });
  }

  const transferData = {
    type: 'block',
    srcClientIds: clientIds,
    srcRootClientId
  };
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Draggable, {
    cloneClassname: cloneClassname,
    __experimentalTransferDataType: "wp-blocks",
    transferData: transferData,
    onDragStart: event => {
      // Defer hiding the dragged source element to the next
      // frame to enable dragging.
      window.requestAnimationFrame(() => {
        startDraggingBlocks(clientIds);
        isDragging.current = true;
        startScrolling(event);

        if (onDragStart) {
          onDragStart();
        }
      });
    },
    onDragOver: scrollOnDragOver,
    onDragEnd: () => {
      stopDraggingBlocks();
      isDragging.current = false;
      stopScrolling();

      if (onDragEnd) {
        onDragEnd();
      }
    },
    __experimentalDragComponent: (0,external_wp_element_namespaceObject.createElement)(BlockDraggableChip, {
      count: clientIds.length,
      icon: icon
    })
  }, ({
    onDraggableStart,
    onDraggableEnd
  }) => {
    return children({
      draggable: true,
      onDragStart: onDraggableStart,
      onDragEnd: onDraggableEnd
    });
  });
};

/* harmony default export */ var block_draggable = (BlockDraggable);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/list-view/block-contents.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */





const ListViewBlockContents = (0,external_wp_element_namespaceObject.forwardRef)(({
  onClick,
  onToggleExpanded,
  block,
  isSelected,
  position,
  siblingBlockCount,
  level,
  isExpanded,
  selectedClientIds,
  ...props
}, ref) => {
  const {
    clientId
  } = block;
  const {
    blockMovingClientId,
    selectedBlockInBlockEditor
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      hasBlockMovingClientId,
      getSelectedBlockClientId
    } = select(store);
    return {
      blockMovingClientId: hasBlockMovingClientId(),
      selectedBlockInBlockEditor: getSelectedBlockClientId()
    };
  }, []);
  const {
    AdditionalBlockContent,
    insertedBlock,
    setInsertedBlock
  } = useListViewContext();
  const isBlockMoveTarget = blockMovingClientId && selectedBlockInBlockEditor === clientId;
  const className = classnames_default()('block-editor-list-view-block-contents', {
    'is-dropping-before': isBlockMoveTarget
  }); // Only include all selected blocks if the currently clicked on block
  // is one of the selected blocks. This ensures that if a user attempts
  // to drag a block that isn't part of the selection, they're still able
  // to drag it and rearrange its position.

  const draggableClientIds = selectedClientIds.includes(clientId) ? selectedClientIds : [clientId];
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, AdditionalBlockContent && (0,external_wp_element_namespaceObject.createElement)(AdditionalBlockContent, {
    block: block,
    insertedBlock: insertedBlock,
    setInsertedBlock: setInsertedBlock
  }), (0,external_wp_element_namespaceObject.createElement)(block_draggable, {
    clientIds: draggableClientIds
  }, ({
    draggable,
    onDragStart,
    onDragEnd
  }) => (0,external_wp_element_namespaceObject.createElement)(block_select_button, {
    ref: ref,
    className: className,
    block: block,
    onClick: onClick,
    onToggleExpanded: onToggleExpanded,
    isSelected: isSelected,
    position: position,
    siblingBlockCount: siblingBlockCount,
    level: level,
    draggable: draggable,
    onDragStart: onDragStart,
    onDragEnd: onDragEnd,
    isExpanded: isExpanded,
    ...props
  })));
});
/* harmony default export */ var block_contents = (ListViewBlockContents);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/list-view/utils.js
/**
 * WordPress dependencies
 */

const getBlockPositionDescription = (position, siblingCount, level) => (0,external_wp_i18n_namespaceObject.sprintf)(
/* translators: 1: The numerical position of the block. 2: The total number of blocks. 3. The level of nesting for the block. */
(0,external_wp_i18n_namespaceObject.__)('Block %1$d of %2$d, Level %3$d'), position, siblingCount, level);
/**
 * Returns true if the client ID occurs within the block selection or multi-selection,
 * or false otherwise.
 *
 * @param {string}          clientId               Block client ID.
 * @param {string|string[]} selectedBlockClientIds Selected block client ID, or an array of multi-selected blocks client IDs.
 *
 * @return {boolean} Whether the block is in multi-selection set.
 */

const isClientIdSelected = (clientId, selectedBlockClientIds) => Array.isArray(selectedBlockClientIds) && selectedBlockClientIds.length ? selectedBlockClientIds.indexOf(clientId) !== -1 : selectedBlockClientIds === clientId;
/**
 * From a start and end clientId of potentially different nesting levels,
 * return the nearest-depth ids that have a common level of depth in the
 * nesting hierarchy. For multiple block selection, this ensure that the
 * selection is always at the same nesting level, and not split across
 * separate levels.
 *
 * @param {string}   startId      The first id of a selection.
 * @param {string}   endId        The end id of a selection, usually one that has been clicked on.
 * @param {string[]} startParents An array of ancestor ids for the start id, in descending order.
 * @param {string[]} endParents   An array of ancestor ids for the end id, in descending order.
 * @return {Object} An object containing the start and end ids.
 */

function getCommonDepthClientIds(startId, endId, startParents, endParents) {
  const startPath = [...startParents, startId];
  const endPath = [...endParents, endId];
  const depth = Math.min(startPath.length, endPath.length) - 1;
  const start = startPath[depth];
  const end = endPath[depth];
  return {
    start,
    end
  };
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/list-view/block.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */









/**
 * Internal dependencies
 */













function ListViewBlock({
  block: {
    clientId
  },
  isDragged,
  isSelected,
  isBranchSelected,
  selectBlock,
  position,
  level,
  rowCount,
  siblingBlockCount,
  showBlockMovers,
  path,
  isExpanded,
  selectedClientIds,
  isSyncedBranch
}) {
  const cellRef = (0,external_wp_element_namespaceObject.useRef)(null);
  const rowRef = (0,external_wp_element_namespaceObject.useRef)(null);
  const [isHovered, setIsHovered] = (0,external_wp_element_namespaceObject.useState)(false);
  const {
    isLocked,
    canEdit
  } = useBlockLock(clientId);
  const isFirstSelectedBlock = isSelected && selectedClientIds[0] === clientId;
  const isLastSelectedBlock = isSelected && selectedClientIds[selectedClientIds.length - 1] === clientId;
  const {
    toggleBlockHighlight
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const blockInformation = useBlockDisplayInformation(clientId);

  const blockTitle = blockInformation?.title || (0,external_wp_i18n_namespaceObject.__)('Untitled');

  const block = (0,external_wp_data_namespaceObject.useSelect)(select => select(store).getBlock(clientId), [clientId]);
  const blockName = (0,external_wp_data_namespaceObject.useSelect)(select => select(store).getBlockName(clientId), [clientId]);
  const blockEditingMode = (0,external_wp_data_namespaceObject.useSelect)(select => unlock(select(store)).getBlockEditingMode(clientId), [clientId]);
  const showBlockActions = // When a block hides its toolbar it also hides the block settings menu,
  // since that menu is part of the toolbar in the editor canvas.
  // List View respects this by also hiding the block settings menu.
  (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockName, '__experimentalToolbar', true) && // Don't show the settings menu if block is disabled or content only.
  blockEditingMode === 'default';
  const instanceId = (0,external_wp_compose_namespaceObject.useInstanceId)(ListViewBlock);
  const descriptionId = `list-view-block-select-button__${instanceId}`;
  const blockPositionDescription = getBlockPositionDescription(position, siblingBlockCount, level);
  const blockAriaLabel = isLocked ? (0,external_wp_i18n_namespaceObject.sprintf)( // translators: %s: The title of the block. This string indicates a link to select the locked block.
  (0,external_wp_i18n_namespaceObject.__)('%s (locked)'), blockTitle) : blockTitle;
  const settingsAriaLabel = (0,external_wp_i18n_namespaceObject.sprintf)( // translators: %s: The title of the block.
  (0,external_wp_i18n_namespaceObject.__)('Options for %s'), blockTitle);
  const {
    isTreeGridMounted,
    expand,
    collapse,
    BlockSettingsMenu,
    listViewInstanceId,
    expandedState,
    setInsertedBlock,
    treeGridElementRef
  } = useListViewContext();
  const hasSiblings = siblingBlockCount > 0;
  const hasRenderedMovers = showBlockMovers && hasSiblings;
  const moverCellClassName = classnames_default()('block-editor-list-view-block__mover-cell', {
    'is-visible': isHovered || isSelected
  });
  const listViewBlockSettingsClassName = classnames_default()('block-editor-list-view-block__menu-cell', {
    'is-visible': isHovered || isFirstSelectedBlock
  }); // If ListView has experimental features related to the Persistent List View,
  // only focus the selected list item on mount; otherwise the list would always
  // try to steal the focus from the editor canvas.

  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!isTreeGridMounted && isSelected) {
      cellRef.current.focus();
    }
  }, []);
  const onMouseEnter = (0,external_wp_element_namespaceObject.useCallback)(() => {
    setIsHovered(true);
    toggleBlockHighlight(clientId, true);
  }, [clientId, setIsHovered, toggleBlockHighlight]);
  const onMouseLeave = (0,external_wp_element_namespaceObject.useCallback)(() => {
    setIsHovered(false);
    toggleBlockHighlight(clientId, false);
  }, [clientId, setIsHovered, toggleBlockHighlight]);
  const selectEditorBlock = (0,external_wp_element_namespaceObject.useCallback)(event => {
    selectBlock(event, clientId);
    event.preventDefault();
  }, [clientId, selectBlock]);
  const updateFocusAndSelection = (0,external_wp_element_namespaceObject.useCallback)((focusClientId, shouldSelectBlock) => {
    if (shouldSelectBlock) {
      selectBlock(undefined, focusClientId, null, null);
    }

    const getFocusElement = () => {
      const row = treeGridElementRef.current?.querySelector(`[role=row][data-block="${focusClientId}"]`);
      if (!row) return null; // Focus the first focusable in the row, which is the ListViewBlockSelectButton.

      return external_wp_dom_namespaceObject.focus.focusable.find(row)[0];
    };

    let focusElement = getFocusElement();

    if (focusElement) {
      focusElement.focus();
    } else {
      // The element hasn't been painted yet. Defer focusing on the next frame.
      // This could happen when all blocks have been deleted and the default block
      // hasn't been added to the editor yet.
      window.requestAnimationFrame(() => {
        focusElement = getFocusElement(); // Ignore if the element still doesn't exist.

        if (focusElement) {
          focusElement.focus();
        }
      });
    }
  }, [selectBlock, treeGridElementRef]);
  const toggleExpanded = (0,external_wp_element_namespaceObject.useCallback)(event => {
    // Prevent shift+click from opening link in a new window when toggling.
    event.preventDefault();
    event.stopPropagation();

    if (isExpanded === true) {
      collapse(clientId);
    } else if (isExpanded === false) {
      expand(clientId);
    }
  }, [clientId, expand, collapse, isExpanded]);
  let colSpan;

  if (hasRenderedMovers) {
    colSpan = 2;
  } else if (!showBlockActions) {
    colSpan = 3;
  }

  const classes = classnames_default()({
    'is-selected': isSelected,
    'is-first-selected': isFirstSelectedBlock,
    'is-last-selected': isLastSelectedBlock,
    'is-branch-selected': isBranchSelected,
    'is-synced-branch': isSyncedBranch,
    'is-dragging': isDragged,
    'has-single-cell': !showBlockActions,
    'is-synced': blockInformation?.isSynced
  }); // Only include all selected blocks if the currently clicked on block
  // is one of the selected blocks. This ensures that if a user attempts
  // to alter a block that isn't part of the selection, they're still able
  // to do so.

  const dropdownClientIds = selectedClientIds.includes(clientId) ? selectedClientIds : [clientId]; // Pass in a ref to the row, so that it can be scrolled
  // into view when selected. For long lists, the placeholder for the
  // selected block is also observed, within ListViewLeafPlaceholder.

  useListViewScrollIntoView({
    isSelected,
    rowItemRef: rowRef,
    selectedClientIds
  }); // Detect if there is a block in the canvas currently being edited and multi-selection is not happening.

  const currentlyEditingBlockInCanvas = isSelected && selectedClientIds.length === 1;
  return (0,external_wp_element_namespaceObject.createElement)(leaf, {
    className: classes,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    onFocus: onMouseEnter,
    onBlur: onMouseLeave,
    level: level,
    position: position,
    rowCount: rowCount,
    path: path,
    id: `list-view-${listViewInstanceId}-block-${clientId}`,
    "data-block": clientId,
    "data-expanded": canEdit ? isExpanded : undefined,
    ref: rowRef
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalTreeGridCell, {
    className: "block-editor-list-view-block__contents-cell",
    colSpan: colSpan,
    ref: cellRef,
    "aria-selected": !!isSelected
  }, ({
    ref,
    tabIndex,
    onFocus
  }) => (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-list-view-block__contents-container"
  }, (0,external_wp_element_namespaceObject.createElement)(block_contents, {
    block: block,
    onClick: selectEditorBlock,
    onToggleExpanded: toggleExpanded,
    isSelected: isSelected,
    position: position,
    siblingBlockCount: siblingBlockCount,
    level: level,
    ref: ref,
    tabIndex: currentlyEditingBlockInCanvas ? 0 : tabIndex,
    onFocus: onFocus,
    isExpanded: canEdit ? isExpanded : undefined,
    selectedClientIds: selectedClientIds,
    ariaLabel: blockAriaLabel,
    ariaDescribedBy: descriptionId,
    updateFocusAndSelection: updateFocusAndSelection
  }), (0,external_wp_element_namespaceObject.createElement)(AriaReferencedText, {
    id: descriptionId
  }, blockPositionDescription))), hasRenderedMovers && (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalTreeGridCell, {
    className: moverCellClassName,
    withoutGridItem: true
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalTreeGridItem, null, ({
    ref,
    tabIndex,
    onFocus
  }) => (0,external_wp_element_namespaceObject.createElement)(BlockMoverUpButton, {
    orientation: "vertical",
    clientIds: [clientId],
    ref: ref,
    tabIndex: tabIndex,
    onFocus: onFocus
  })), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalTreeGridItem, null, ({
    ref,
    tabIndex,
    onFocus
  }) => (0,external_wp_element_namespaceObject.createElement)(BlockMoverDownButton, {
    orientation: "vertical",
    clientIds: [clientId],
    ref: ref,
    tabIndex: tabIndex,
    onFocus: onFocus
  })))), showBlockActions && BlockSettingsMenu && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalTreeGridCell, {
    className: listViewBlockSettingsClassName,
    "aria-selected": !!isSelected
  }, ({
    ref,
    tabIndex,
    onFocus
  }) => (0,external_wp_element_namespaceObject.createElement)(BlockSettingsMenu, {
    clientIds: dropdownClientIds,
    block: block,
    icon: more_vertical,
    label: settingsAriaLabel,
    toggleProps: {
      ref,
      className: 'block-editor-list-view-block__menu',
      tabIndex,
      onFocus
    },
    disableOpenOnArrowDown: true,
    expand: expand,
    expandedState: expandedState,
    setInsertedBlock: setInsertedBlock,
    __experimentalSelectBlock: updateFocusAndSelection
  })));
}

/* harmony default export */ var list_view_block = ((0,external_wp_element_namespaceObject.memo)(ListViewBlock));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/list-view/branch.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */







/**
 * Given a block, returns the total number of blocks in that subtree. This is used to help determine
 * the list position of a block.
 *
 * When a block is collapsed, we do not count their children as part of that total. In the current drag
 * implementation dragged blocks and their children are not counted.
 *
 * @param {Object}  block               block tree
 * @param {Object}  expandedState       state that notes which branches are collapsed
 * @param {Array}   draggedClientIds    a list of dragged client ids
 * @param {boolean} isExpandedByDefault flag to determine the default fallback expanded state.
 * @return {number} block count
 */

function countBlocks(block, expandedState, draggedClientIds, isExpandedByDefault) {
  var _expandedState$block$;

  const isDragged = draggedClientIds?.includes(block.clientId);

  if (isDragged) {
    return 0;
  }

  const isExpanded = (_expandedState$block$ = expandedState[block.clientId]) !== null && _expandedState$block$ !== void 0 ? _expandedState$block$ : isExpandedByDefault;

  if (isExpanded) {
    return 1 + block.innerBlocks.reduce(countReducer(expandedState, draggedClientIds, isExpandedByDefault), 0);
  }

  return 1;
}

const countReducer = (expandedState, draggedClientIds, isExpandedByDefault) => (count, block) => {
  var _expandedState$block$2;

  const isDragged = draggedClientIds?.includes(block.clientId);

  if (isDragged) {
    return count;
  }

  const isExpanded = (_expandedState$block$2 = expandedState[block.clientId]) !== null && _expandedState$block$2 !== void 0 ? _expandedState$block$2 : isExpandedByDefault;

  if (isExpanded && block.innerBlocks.length > 0) {
    return count + countBlocks(block, expandedState, draggedClientIds, isExpandedByDefault);
  }

  return count + 1;
};

const branch_noop = () => {};

function ListViewBranch(props) {
  const {
    blocks,
    selectBlock = branch_noop,
    showBlockMovers,
    selectedClientIds,
    level = 1,
    path = '',
    isBranchDragged = false,
    isBranchSelected = false,
    listPosition = 0,
    fixedListWindow,
    isExpanded,
    parentId,
    shouldShowInnerBlocks = true,
    isSyncedBranch = false,
    showAppender: showAppenderProp = true
  } = props;
  const parentBlockInformation = useBlockDisplayInformation(parentId);
  const syncedBranch = isSyncedBranch || !!parentBlockInformation?.isSynced;
  const canParentExpand = (0,external_wp_data_namespaceObject.useSelect)(select => {
    if (!parentId) {
      return true;
    }

    return select(store).canEditBlock(parentId);
  }, [parentId]);
  const {
    expandedState,
    draggedClientIds
  } = useListViewContext();

  if (!canParentExpand) {
    return null;
  } // Only show the appender at the first level.


  const showAppender = showAppenderProp && level === 1;
  const filteredBlocks = blocks.filter(Boolean);
  const blockCount = filteredBlocks.length; // The appender means an extra row in List View, so add 1 to the row count.

  const rowCount = showAppender ? blockCount + 1 : blockCount;
  let nextPosition = listPosition;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, filteredBlocks.map((block, index) => {
    var _expandedState$client;

    const {
      clientId,
      innerBlocks
    } = block;

    if (index > 0) {
      nextPosition += countBlocks(filteredBlocks[index - 1], expandedState, draggedClientIds, isExpanded);
    }

    const {
      itemInView
    } = fixedListWindow;
    const blockInView = itemInView(nextPosition);
    const position = index + 1;
    const updatedPath = path.length > 0 ? `${path}_${position}` : `${position}`;
    const hasNestedBlocks = !!innerBlocks?.length;
    const shouldExpand = hasNestedBlocks && shouldShowInnerBlocks ? (_expandedState$client = expandedState[clientId]) !== null && _expandedState$client !== void 0 ? _expandedState$client : isExpanded : undefined;
    const isDragged = !!draggedClientIds?.includes(clientId); // Make updates to the selected or dragged blocks synchronous,
    // but asynchronous for any other block.

    const isSelected = isClientIdSelected(clientId, selectedClientIds);
    const isSelectedBranch = isBranchSelected || isSelected && hasNestedBlocks;
    const showBlock = isDragged || blockInView || isSelected || isBranchDragged;
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_data_namespaceObject.AsyncModeProvider, {
      key: clientId,
      value: !isSelected
    }, showBlock && (0,external_wp_element_namespaceObject.createElement)(list_view_block, {
      block: block,
      selectBlock: selectBlock,
      isSelected: isSelected,
      isBranchSelected: isSelectedBranch,
      isDragged: isDragged || isBranchDragged,
      level: level,
      position: position,
      rowCount: rowCount,
      siblingBlockCount: blockCount,
      showBlockMovers: showBlockMovers,
      path: updatedPath,
      isExpanded: shouldExpand,
      listPosition: nextPosition,
      selectedClientIds: selectedClientIds,
      isSyncedBranch: syncedBranch
    }), !showBlock && (0,external_wp_element_namespaceObject.createElement)("tr", null, (0,external_wp_element_namespaceObject.createElement)("td", {
      className: "block-editor-list-view-placeholder"
    })), hasNestedBlocks && shouldExpand && (0,external_wp_element_namespaceObject.createElement)(ListViewBranch, {
      parentId: clientId,
      blocks: innerBlocks,
      selectBlock: selectBlock,
      showBlockMovers: showBlockMovers,
      level: level + 1,
      path: updatedPath,
      listPosition: nextPosition + 1,
      fixedListWindow: fixedListWindow,
      isBranchSelected: isSelectedBranch,
      isBranchDragged: isDragged || isBranchDragged,
      selectedClientIds: selectedClientIds,
      isExpanded: isExpanded,
      isSyncedBranch: syncedBranch
    }));
  }), showAppender && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalTreeGridRow, {
    level: level,
    setSize: rowCount,
    positionInSet: rowCount,
    isExpanded: true
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalTreeGridCell, null, treeGridCellProps => (0,external_wp_element_namespaceObject.createElement)(Appender, {
    clientId: parentId,
    nestingLevel: level,
    blockCount: blockCount,
    ...treeGridCellProps
  }))));
}

/* harmony default export */ var branch = ((0,external_wp_element_namespaceObject.memo)(ListViewBranch));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/list-view/drop-indicator.js


/**
 * WordPress dependencies
 */




function ListViewDropIndicator({
  listViewRef,
  blockDropTarget
}) {
  const {
    rootClientId,
    clientId,
    dropPosition
  } = blockDropTarget || {};
  const [rootBlockElement, blockElement] = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (!listViewRef.current) {
      return [];
    } // The rootClientId will be defined whenever dropping into inner
    // block lists, but is undefined when dropping at the root level.


    const _rootBlockElement = rootClientId ? listViewRef.current.querySelector(`[data-block="${rootClientId}"]`) : undefined; // The clientId represents the sibling block, the dragged block will
    // usually be inserted adjacent to it. It will be undefined when
    // dropping a block into an empty block list.


    const _blockElement = clientId ? listViewRef.current.querySelector(`[data-block="${clientId}"]`) : undefined;

    return [_rootBlockElement, _blockElement];
  }, [rootClientId, clientId]); // The targetElement is the element that the drop indicator will appear
  // before or after. When dropping into an empty block list, blockElement
  // is undefined, so the indicator will appear after the rootBlockElement.

  const targetElement = blockElement || rootBlockElement;
  const rtl = (0,external_wp_i18n_namespaceObject.isRTL)();
  const getDropIndicatorIndent = (0,external_wp_element_namespaceObject.useCallback)(targetElementRect => {
    if (!rootBlockElement) {
      return 0;
    } // Calculate the indent using the block icon of the root block.
    // Using a classname selector here might be flaky and could be
    // improved.


    const rootBlockIconElement = rootBlockElement.querySelector('.block-editor-block-icon');
    const rootBlockIconRect = rootBlockIconElement.getBoundingClientRect();
    return rtl ? targetElementRect.right - rootBlockIconRect.left : rootBlockIconRect.right - targetElementRect.left;
  }, [rootBlockElement, rtl]);
  const getDropIndicatorWidth = (0,external_wp_element_namespaceObject.useCallback)((targetElementRect, indent) => {
    if (!targetElement) {
      return 0;
    } // Default to assuming that the width of the drop indicator
    // should be the same as the target element.


    let width = targetElement.offsetWidth; // In deeply nested lists, where a scrollbar is present,
    // the width of the drop indicator should be the width of
    // the scroll container, minus the distance from the left
    // edge of the scroll container to the left edge of the
    // target element.

    const scrollContainer = (0,external_wp_dom_namespaceObject.getScrollContainer)(targetElement, 'horizontal');
    const ownerDocument = targetElement.ownerDocument;
    const windowScroll = scrollContainer === ownerDocument.body || scrollContainer === ownerDocument.documentElement;

    if (scrollContainer && !windowScroll) {
      const scrollContainerRect = scrollContainer.getBoundingClientRect();
      const distanceBetweenContainerAndTarget = (0,external_wp_i18n_namespaceObject.isRTL)() ? scrollContainerRect.right - targetElementRect.right : targetElementRect.left - scrollContainerRect.left;
      const scrollContainerWidth = scrollContainer.clientWidth;

      if (scrollContainerWidth < width + distanceBetweenContainerAndTarget) {
        width = scrollContainerWidth - distanceBetweenContainerAndTarget;
      } // LTR logic for ensuring the drop indicator does not extend
      // beyond the right edge of the scroll container.


      if (!rtl && targetElementRect.left + indent < scrollContainerRect.left) {
        width -= scrollContainerRect.left - targetElementRect.left;
        return width;
      } // RTL logic for ensuring the drop indicator does not extend
      // beyond the right edge of the scroll container.


      if (rtl && targetElementRect.right - indent > scrollContainerRect.right) {
        width -= targetElementRect.right - scrollContainerRect.right;
        return width;
      }
    } // Subtract the indent from the final width of the indicator.


    return width - indent;
  }, [rtl, targetElement]);
  const style = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (!targetElement) {
      return {};
    }

    const targetElementRect = targetElement.getBoundingClientRect();
    const indent = getDropIndicatorIndent(targetElementRect);
    return {
      width: getDropIndicatorWidth(targetElementRect, indent)
    };
  }, [getDropIndicatorIndent, getDropIndicatorWidth, targetElement]);
  const popoverAnchor = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const isValidDropPosition = dropPosition === 'top' || dropPosition === 'bottom' || dropPosition === 'inside';

    if (!targetElement || !isValidDropPosition) {
      return undefined;
    }

    const ownerDocument = targetElement.ownerDocument;
    return {
      ownerDocument,

      getBoundingClientRect() {
        const rect = targetElement.getBoundingClientRect();
        const indent = getDropIndicatorIndent(rect); // In RTL languages, the drop indicator should be positioned
        // to the left of the target element, with the width of the
        // indicator determining the indent at the right edge of the
        // target element. In LTR languages, the drop indicator should
        // end at the right edge of the target element, with the indent
        // added to the position of the left edge of the target element.

        let left = rtl ? rect.left : rect.left + indent;
        let top = 0;
        let bottom = 0; // In deeply nested lists, where a scrollbar is present,
        // the width of the drop indicator should be the width of
        // the visible area of the scroll container. Additionally,
        // the left edge of the drop indicator line needs to be
        // offset by the distance the left edge of the target element
        // and the left edge of the scroll container. The ensures
        // that the drop indicator position never breaks out of the
        // visible area of the scroll container.

        const scrollContainer = (0,external_wp_dom_namespaceObject.getScrollContainer)(targetElement, 'horizontal');
        const windowScroll = scrollContainer === ownerDocument.body || scrollContainer === ownerDocument.documentElement; // If the scroll container is not the window, offset the left position, if need be.

        if (scrollContainer && !windowScroll) {
          const scrollContainerRect = scrollContainer.getBoundingClientRect(); // In RTL languages, a vertical scrollbar is present on the
          // left edge of the scroll container. The width of the
          // scrollbar needs to be accounted for when positioning the
          // drop indicator.

          const scrollbarWidth = rtl ? scrollContainer.offsetWidth - scrollContainer.clientWidth : 0;

          if (left < scrollContainerRect.left + scrollbarWidth) {
            left = scrollContainerRect.left + scrollbarWidth;
          }
        }

        if (dropPosition === 'top') {
          top = rect.top;
          bottom = rect.top;
        } else {
          // `dropPosition` is either `bottom` or `inside`
          top = rect.bottom;
          bottom = rect.bottom;
        }

        const width = getDropIndicatorWidth(rect, indent);
        const height = bottom - top;
        return new window.DOMRect(left, top, width, height);
      }

    };
  }, [targetElement, dropPosition, getDropIndicatorIndent, getDropIndicatorWidth, rtl]);

  if (!targetElement) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Popover, {
    animate: false,
    anchor: popoverAnchor,
    focusOnMount: false,
    className: "block-editor-list-view-drop-indicator",
    variant: "unstyled"
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    style: style,
    className: "block-editor-list-view-drop-indicator__line"
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/list-view/use-block-selection.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */



function useBlockSelection() {
  const {
    clearSelectedBlock,
    multiSelect,
    selectBlock
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const {
    getBlockName,
    getBlockParents,
    getBlockSelectionStart,
    getSelectedBlockClientIds,
    hasMultiSelection,
    hasSelectedBlock
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    getBlockType
  } = (0,external_wp_data_namespaceObject.useSelect)(external_wp_blocks_namespaceObject.store);
  const updateBlockSelection = (0,external_wp_element_namespaceObject.useCallback)(async (event, clientId, destinationClientId, focusPosition) => {
    if (!event?.shiftKey) {
      selectBlock(clientId, focusPosition);
      return;
    } // To handle multiple block selection via the `SHIFT` key, prevent
    // the browser default behavior of opening the link in a new window.


    event.preventDefault();
    const isKeyPress = event.type === 'keydown' && (event.keyCode === external_wp_keycodes_namespaceObject.UP || event.keyCode === external_wp_keycodes_namespaceObject.DOWN || event.keyCode === external_wp_keycodes_namespaceObject.HOME || event.keyCode === external_wp_keycodes_namespaceObject.END); // Handle clicking on a block when no blocks are selected, and return early.

    if (!isKeyPress && !hasSelectedBlock() && !hasMultiSelection()) {
      selectBlock(clientId, null);
      return;
    }

    const selectedBlocks = getSelectedBlockClientIds();
    const clientIdWithParents = [...getBlockParents(clientId), clientId];

    if (isKeyPress && !selectedBlocks.some(blockId => clientIdWithParents.includes(blockId))) {
      // Ensure that shift-selecting blocks via the keyboard only
      // expands the current selection if focusing over already
      // selected blocks. Otherwise, clear the selection so that
      // a user can create a new selection entirely by keyboard.
      await clearSelectedBlock();
    }

    let startTarget = getBlockSelectionStart();
    let endTarget = clientId; // Handle keyboard behavior for selecting multiple blocks.

    if (isKeyPress) {
      if (!hasSelectedBlock() && !hasMultiSelection()) {
        // Set the starting point of the selection to the currently
        // focused block, if there are no blocks currently selected.
        // This ensures that as the selection is expanded or contracted,
        // the starting point of the selection is anchored to that block.
        startTarget = clientId;
      }

      if (destinationClientId) {
        // If the user presses UP or DOWN, we want to ensure that the block they're
        // moving to is the target for selection, and not the currently focused one.
        endTarget = destinationClientId;
      }
    }

    const startParents = getBlockParents(startTarget);
    const endParents = getBlockParents(endTarget);
    const {
      start,
      end
    } = getCommonDepthClientIds(startTarget, endTarget, startParents, endParents);
    await multiSelect(start, end, null); // Announce deselected block, or number of deselected blocks if
    // the total number of blocks deselected is greater than one.

    const updatedSelectedBlocks = getSelectedBlockClientIds(); // If the selection is greater than 1 and the Home or End keys
    // were used to generate the selection, then skip announcing the
    // deselected blocks.

    if ((event.keyCode === external_wp_keycodes_namespaceObject.HOME || event.keyCode === external_wp_keycodes_namespaceObject.END) && updatedSelectedBlocks.length > 1) {
      return;
    }

    const selectionDiff = selectedBlocks.filter(blockId => !updatedSelectedBlocks.includes(blockId));
    let label;

    if (selectionDiff.length === 1) {
      const title = getBlockType(getBlockName(selectionDiff[0]))?.title;

      if (title) {
        label = (0,external_wp_i18n_namespaceObject.sprintf)(
        /* translators: %s: block name */
        (0,external_wp_i18n_namespaceObject.__)('%s deselected.'), title);
      }
    } else if (selectionDiff.length > 1) {
      label = (0,external_wp_i18n_namespaceObject.sprintf)(
      /* translators: %s: number of deselected blocks */
      (0,external_wp_i18n_namespaceObject.__)('%s blocks deselected.'), selectionDiff.length);
    }

    if (label) {
      (0,external_wp_a11y_namespaceObject.speak)(label, 'assertive');
    }
  }, [clearSelectedBlock, getBlockName, getBlockType, getBlockParents, getBlockSelectionStart, getSelectedBlockClientIds, hasMultiSelection, hasSelectedBlock, multiSelect, selectBlock]);
  return {
    updateBlockSelection
  };
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/list-view/use-list-view-client-ids.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



function useListViewClientIds({
  blocks,
  rootClientId
}) {
  return (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getDraggedBlockClientIds,
      getSelectedBlockClientIds,
      getEnabledClientIdsTree
    } = unlock(select(store));
    return {
      selectedClientIds: getSelectedBlockClientIds(),
      draggedClientIds: getDraggedBlockClientIds(),
      clientIdsTree: blocks !== null && blocks !== void 0 ? blocks : getEnabledClientIdsTree(rootClientId)
    };
  }, [blocks, rootClientId]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/list-view/use-list-view-drop-zone.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




/** @typedef {import('../../utils/math').WPPoint} WPPoint */

/**
 * The type of a drag event.
 *
 * @typedef {'default'|'file'|'html'} WPDragEventType
 */

/**
 * An object representing data for blocks in the DOM used by drag and drop.
 *
 * @typedef {Object} WPListViewDropZoneBlock
 * @property {string}  clientId                        The client id for the block.
 * @property {string}  rootClientId                    The root client id for the block.
 * @property {number}  blockIndex                      The block's index.
 * @property {Element} element                         The DOM element representing the block.
 * @property {number}  innerBlockCount                 The number of inner blocks the block has.
 * @property {boolean} isDraggedBlock                  Whether the block is currently being dragged.
 * @property {boolean} isExpanded                      Whether the block is expanded in the UI.
 * @property {boolean} canInsertDraggedBlocksAsSibling Whether the dragged block can be a sibling of this block.
 * @property {boolean} canInsertDraggedBlocksAsChild   Whether the dragged block can be a child of this block.
 */

/**
 * An array representing data for blocks in the DOM used by drag and drop.
 *
 * @typedef {WPListViewDropZoneBlock[]} WPListViewDropZoneBlocks
 */

/**
 * An object containing details of a drop target.
 *
 * @typedef {Object} WPListViewDropZoneTarget
 * @property {string}                  blockIndex   The insertion index.
 * @property {string}                  rootClientId The root client id for the block.
 * @property {string|undefined}        clientId     The client id for the block.
 * @property {'top'|'bottom'|'inside'} dropPosition The position relative to the block that the user is dropping to.
 *                                                  'inside' refers to nesting as an inner block.
 */
// When the indentation level, the corresponding left margin in `style.scss`
// must be updated as well to ensure the drop zone is aligned with the indentation.

const NESTING_LEVEL_INDENTATION = 28;
/**
 * Determines whether the user is positioning the dragged block to be
 * moved up to a parent level.
 *
 * Determined based on nesting level indentation of the current block.
 *
 * @param {WPPoint} point        The point representing the cursor position when dragging.
 * @param {DOMRect} rect         The rectangle.
 * @param {number}  nestingLevel The nesting level of the block.
 * @param {boolean} rtl          Whether the editor is in RTL mode.
 * @return {boolean} Whether the gesture is an upward gesture.
 */

function isUpGesture(point, rect, nestingLevel = 1, rtl = false) {
  // If the block is nested, and the user is dragging to the bottom
  // left of the block (or bottom right in RTL languages), then it is an upward gesture.
  const blockIndentPosition = rtl ? rect.right - nestingLevel * NESTING_LEVEL_INDENTATION : rect.left + nestingLevel * NESTING_LEVEL_INDENTATION;
  return rtl ? point.x > blockIndentPosition : point.x < blockIndentPosition;
}
/**
 * Returns how many nesting levels up the user is attempting to drag to.
 *
 * The relative parent level is calculated based on how far
 * the cursor is from the provided nesting level (e.g. of a candidate block
 * that the user is hovering over). The nesting level is considered "desired"
 * because it is not guaranteed that the user will be able to drag to the desired level.
 *
 * The returned integer can be used to access an ascending array
 * of parent blocks, where the first item is the block the user
 * is hovering over, and the last item is the root block.
 *
 * @param {WPPoint} point        The point representing the cursor position when dragging.
 * @param {DOMRect} rect         The rectangle.
 * @param {number}  nestingLevel The nesting level of the block.
 * @param {boolean} rtl          Whether the editor is in RTL mode.
 * @return {number} The desired relative parent level.
 */


function getDesiredRelativeParentLevel(point, rect, nestingLevel = 1, rtl = false) {
  // In RTL languages, the block indent position is from the right edge of the block.
  // In LTR languages, the block indent position is from the left edge of the block.
  const blockIndentPosition = rtl ? rect.right - nestingLevel * NESTING_LEVEL_INDENTATION : rect.left + nestingLevel * NESTING_LEVEL_INDENTATION;
  const distanceBetweenPointAndBlockIndentPosition = rtl ? blockIndentPosition - point.x : point.x - blockIndentPosition;
  const desiredParentLevel = Math.round(distanceBetweenPointAndBlockIndentPosition / NESTING_LEVEL_INDENTATION);
  return Math.abs(desiredParentLevel);
}
/**
 * Returns an array of the parent blocks of the block the user is dropping to.
 *
 * @param {WPListViewDropZoneBlock}  candidateBlockData The block the user is dropping to.
 * @param {WPListViewDropZoneBlocks} blocksData         Data about the blocks in list view.
 * @return {WPListViewDropZoneBlocks} An array of block parents, including the block the user is dropping to.
 */


function getCandidateBlockParents(candidateBlockData, blocksData) {
  const candidateBlockParents = [];
  let currentBlockData = candidateBlockData;

  while (currentBlockData) {
    candidateBlockParents.push({ ...currentBlockData
    });
    currentBlockData = blocksData.find(blockData => blockData.clientId === currentBlockData.rootClientId);
  }

  return candidateBlockParents;
}
/**
 * Given a list of blocks data and a block index, return the next non-dragged
 * block. This is used to determine the block that the user is dropping to,
 * while ignoring the dragged block.
 *
 * @param {WPListViewDropZoneBlocks} blocksData Data about the blocks in list view.
 * @param {number}                   index      The index to begin searching from.
 * @return {WPListViewDropZoneBlock | undefined} The next non-dragged block.
 */


function getNextNonDraggedBlock(blocksData, index) {
  const nextBlockData = blocksData[index + 1];

  if (nextBlockData && nextBlockData.isDraggedBlock) {
    return getNextNonDraggedBlock(blocksData, index + 1);
  }

  return nextBlockData;
}
/**
 * Determines whether the user positioning the dragged block to nest as an
 * inner block.
 *
 * Determined based on nesting level indentation of the current block, plus
 * the indentation of the next level of nesting. The vertical position of the
 * cursor must also be within the block.
 *
 * @param {WPPoint} point        The point representing the cursor position when dragging.
 * @param {DOMRect} rect         The rectangle.
 * @param {number}  nestingLevel The nesting level of the block.
 * @param {boolean} rtl          Whether the editor is in RTL mode.
 */


function isNestingGesture(point, rect, nestingLevel = 1, rtl = false) {
  const blockIndentPosition = rtl ? rect.right - nestingLevel * NESTING_LEVEL_INDENTATION : rect.left + nestingLevel * NESTING_LEVEL_INDENTATION;
  const isNestingHorizontalGesture = rtl ? point.x < blockIndentPosition - NESTING_LEVEL_INDENTATION : point.x > blockIndentPosition + NESTING_LEVEL_INDENTATION;
  return isNestingHorizontalGesture && point.y < rect.bottom;
} // Block navigation is always a vertical list, so only allow dropping
// to the above or below a block.


const ALLOWED_DROP_EDGES = ['top', 'bottom'];
/**
 * Given blocks data and the cursor position, compute the drop target.
 *
 * @param {WPListViewDropZoneBlocks} blocksData Data about the blocks in list view.
 * @param {WPPoint}                  position   The point representing the cursor position when dragging.
 * @param {boolean}                  rtl        Whether the editor is in RTL mode.
 *
 * @return {WPListViewDropZoneTarget | undefined} An object containing data about the drop target.
 */

function getListViewDropTarget(blocksData, position, rtl = false) {
  let candidateEdge;
  let candidateBlockData;
  let candidateDistance;
  let candidateRect;
  let candidateBlockIndex;

  for (let i = 0; i < blocksData.length; i++) {
    const blockData = blocksData[i];

    if (blockData.isDraggedBlock) {
      continue;
    }

    const rect = blockData.element.getBoundingClientRect();
    const [distance, edge] = getDistanceToNearestEdge(position, rect, ALLOWED_DROP_EDGES);
    const isCursorWithinBlock = isPointContainedByRect(position, rect);

    if (candidateDistance === undefined || distance < candidateDistance || isCursorWithinBlock) {
      candidateDistance = distance;
      const index = blocksData.indexOf(blockData);
      const previousBlockData = blocksData[index - 1]; // If dragging near the top of a block and the preceding block
      // is at the same level, use the preceding block as the candidate
      // instead, as later it makes determining a nesting drop easier.

      if (edge === 'top' && previousBlockData && previousBlockData.rootClientId === blockData.rootClientId && !previousBlockData.isDraggedBlock) {
        candidateBlockData = previousBlockData;
        candidateEdge = 'bottom';
        candidateRect = previousBlockData.element.getBoundingClientRect();
        candidateBlockIndex = index - 1;
      } else {
        candidateBlockData = blockData;
        candidateEdge = edge;
        candidateRect = rect;
        candidateBlockIndex = index;
      } // If the mouse position is within the block, break early
      // as the user would intend to drop either before or after
      // this block.
      //
      // This solves an issue where some rows in the list view
      // tree overlap slightly due to sub-pixel rendering.


      if (isCursorWithinBlock) {
        break;
      }
    }
  }

  if (!candidateBlockData) {
    return;
  }

  const candidateBlockParents = getCandidateBlockParents(candidateBlockData, blocksData);
  const isDraggingBelow = candidateEdge === 'bottom'; // If the user is dragging towards the bottom of the block check whether
  // they might be trying to nest the block as a child.
  // If the block already has inner blocks, and is expanded, this should be treated
  // as nesting since the next block in the tree will be the first child.
  // However, if the block is collapsed, dragging beneath the block should
  // still be allowed, as the next visible block in the tree will be a sibling.

  if (isDraggingBelow && candidateBlockData.canInsertDraggedBlocksAsChild && (candidateBlockData.innerBlockCount > 0 && candidateBlockData.isExpanded || isNestingGesture(position, candidateRect, candidateBlockParents.length, rtl))) {
    // If the block is expanded, insert the block as the first child.
    // Otherwise, for collapsed blocks, insert the block as the last child.
    const newBlockIndex = candidateBlockData.isExpanded ? 0 : candidateBlockData.innerBlockCount || 0;
    return {
      rootClientId: candidateBlockData.clientId,
      blockIndex: newBlockIndex,
      dropPosition: 'inside'
    };
  } // If the user is dragging towards the bottom of the block check whether
  // they might be trying to move the block to be at a parent level.


  if (isDraggingBelow && candidateBlockData.rootClientId && isUpGesture(position, candidateRect, candidateBlockParents.length, rtl)) {
    const nextBlock = getNextNonDraggedBlock(blocksData, candidateBlockIndex);
    const currentLevel = candidateBlockData.nestingLevel;
    const nextLevel = nextBlock ? nextBlock.nestingLevel : 1;

    if (currentLevel && nextLevel) {
      // Determine the desired relative level of the block to be dropped.
      const desiredRelativeLevel = getDesiredRelativeParentLevel(position, candidateRect, candidateBlockParents.length, rtl);
      const targetParentIndex = Math.max(Math.min(desiredRelativeLevel, currentLevel - nextLevel), 0);

      if (candidateBlockParents[targetParentIndex]) {
        // Default to the block index of the candidate block.
        let newBlockIndex = candidateBlockData.blockIndex; // If the next block is at the same level, use that as the default
        // block index. This ensures that the block is dropped in the correct
        // position when dragging to the bottom of a block.

        if (candidateBlockParents[targetParentIndex].nestingLevel === nextBlock?.nestingLevel) {
          newBlockIndex = nextBlock?.blockIndex;
        } else {
          // Otherwise, search from the current block index back
          // to find the last block index within the same target parent.
          for (let i = candidateBlockIndex; i >= 0; i--) {
            const blockData = blocksData[i];

            if (blockData.rootClientId === candidateBlockParents[targetParentIndex].rootClientId) {
              newBlockIndex = blockData.blockIndex + 1;
              break;
            }
          }
        }

        return {
          rootClientId: candidateBlockParents[targetParentIndex].rootClientId,
          clientId: candidateBlockData.clientId,
          blockIndex: newBlockIndex,
          dropPosition: candidateEdge
        };
      }
    }
  } // If dropping as a sibling, but block cannot be inserted in
  // this context, return early.


  if (!candidateBlockData.canInsertDraggedBlocksAsSibling) {
    return;
  }

  const offset = isDraggingBelow ? 1 : 0;
  return {
    rootClientId: candidateBlockData.rootClientId,
    clientId: candidateBlockData.clientId,
    blockIndex: candidateBlockData.blockIndex + offset,
    dropPosition: candidateEdge
  };
}
/**
 * A react hook for implementing a drop zone in list view.
 *
 * @param {Object}       props                   Named parameters.
 * @param {?HTMLElement} [props.dropZoneElement] Optional element to be used as the drop zone.
 *
 * @return {WPListViewDropZoneTarget} The drop target.
 */

function useListViewDropZone({
  dropZoneElement
}) {
  const {
    getBlockRootClientId,
    getBlockIndex,
    getBlockCount,
    getDraggedBlockClientIds,
    canInsertBlocks
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const [target, setTarget] = (0,external_wp_element_namespaceObject.useState)();
  const {
    rootClientId: targetRootClientId,
    blockIndex: targetBlockIndex
  } = target || {};
  const onBlockDrop = useOnBlockDrop(targetRootClientId, targetBlockIndex);
  const rtl = (0,external_wp_i18n_namespaceObject.isRTL)();
  const draggedBlockClientIds = getDraggedBlockClientIds();
  const throttled = (0,external_wp_compose_namespaceObject.useThrottle)((0,external_wp_element_namespaceObject.useCallback)((event, currentTarget) => {
    const position = {
      x: event.clientX,
      y: event.clientY
    };
    const isBlockDrag = !!draggedBlockClientIds?.length;
    const blockElements = Array.from(currentTarget.querySelectorAll('[data-block]'));
    const blocksData = blockElements.map(blockElement => {
      const clientId = blockElement.dataset.block;
      const isExpanded = blockElement.dataset.expanded === 'true';
      const isDraggedBlock = blockElement.classList.contains('is-dragging'); // Get nesting level from `aria-level` attribute because Firefox does not support `element.ariaLevel`.

      const nestingLevel = parseInt(blockElement.getAttribute('aria-level'), 10);
      const rootClientId = getBlockRootClientId(clientId);
      return {
        clientId,
        isExpanded,
        rootClientId,
        blockIndex: getBlockIndex(clientId),
        element: blockElement,
        nestingLevel: nestingLevel || undefined,
        isDraggedBlock: isBlockDrag ? isDraggedBlock : false,
        innerBlockCount: getBlockCount(clientId),
        canInsertDraggedBlocksAsSibling: isBlockDrag ? canInsertBlocks(draggedBlockClientIds, rootClientId) : true,
        canInsertDraggedBlocksAsChild: isBlockDrag ? canInsertBlocks(draggedBlockClientIds, clientId) : true
      };
    });
    const newTarget = getListViewDropTarget(blocksData, position, rtl);

    if (newTarget) {
      setTarget(newTarget);
    }
  }, [canInsertBlocks, draggedBlockClientIds, getBlockCount, getBlockIndex, getBlockRootClientId, rtl]), 200);
  const ref = (0,external_wp_compose_namespaceObject.__experimentalUseDropZone)({
    dropZoneElement,

    onDrop(event) {
      if (target) {
        onBlockDrop(event);
      }
    },

    onDragLeave() {
      throttled.cancel();
      setTarget(null);
    },

    onDragOver(event) {
      // `currentTarget` is only available while the event is being
      // handled, so get it now and pass it to the thottled function.
      // https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget
      throttled(event, event.currentTarget);
    },

    onDragEnd() {
      throttled.cancel();
      setTarget(null);
    }

  });
  return {
    ref,
    target
  };
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/list-view/use-list-view-expand-selected-item.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function useListViewExpandSelectedItem({
  firstSelectedBlockClientId,
  setExpandedState
}) {
  const [selectedTreeId, setSelectedTreeId] = (0,external_wp_element_namespaceObject.useState)(null);
  const {
    selectedBlockParentClientIds
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockParents
    } = select(store);
    return {
      selectedBlockParentClientIds: getBlockParents(firstSelectedBlockClientId, false)
    };
  }, [firstSelectedBlockClientId]);
  const parentClientIds = Array.isArray(selectedBlockParentClientIds) && selectedBlockParentClientIds.length ? selectedBlockParentClientIds : null; // Expand tree when a block is selected.

  (0,external_wp_element_namespaceObject.useEffect)(() => {
    // If the selectedTreeId is the same as the selected block,
    // it means that the block was selected using the block list tree.
    if (selectedTreeId === firstSelectedBlockClientId) {
      return;
    } // If the selected block has parents, get the top-level parent.


    if (parentClientIds) {
      // If the selected block has parents,
      // expand the tree branch.
      setExpandedState({
        type: 'expand',
        clientIds: selectedBlockParentClientIds
      });
    }
  }, [firstSelectedBlockClientId]);
  return {
    setSelectedTreeId
  };
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/pasting.js
/**
 * WordPress dependencies
 */

function getPasteEventData({
  clipboardData
}) {
  let plainText = '';
  let html = ''; // IE11 only supports `Text` as an argument for `getData` and will
  // otherwise throw an invalid argument error, so we try the standard
  // arguments first, then fallback to `Text` if they fail.

  try {
    plainText = clipboardData.getData('text/plain');
    html = clipboardData.getData('text/html');
  } catch (error1) {
    try {
      html = clipboardData.getData('Text');
    } catch (error2) {
      // Some browsers like UC Browser paste plain text by default and
      // don't support clipboardData at all, so allow default
      // behaviour.
      return;
    }
  }

  const files = (0,external_wp_dom_namespaceObject.getFilesFromDataTransfer)(clipboardData);

  if (files.length && !shouldDismissPastedFiles(files, html, plainText)) {
    return {
      files
    };
  }

  return {
    html,
    plainText,
    files: []
  };
}
/**
 * Given a collection of DataTransfer files and HTML and plain text strings,
 * determine whether the files are to be dismissed in favor of the HTML.
 *
 * Certain office-type programs, like Microsoft Word or Apple Numbers,
 * will, upon copy, generate a screenshot of the content being copied and
 * attach it to the clipboard alongside the actual rich text that the user
 * sought to copy. In those cases, we should let Gutenberg handle the rich text
 * content and not the screenshot, since this allows Gutenberg to insert
 * meaningful blocks, like paragraphs, lists or even tables.
 *
 * @param {File[]} files File objects obtained from a paste event
 * @param {string} html  HTML content obtained from a paste event
 * @return {boolean}     True if the files should be dismissed
 */

function shouldDismissPastedFiles(files, html
/*, plainText */
) {
  // The question is only relevant when there is actual HTML content and when
  // there is exactly one image file.
  if (html && files?.length === 1 && files[0].type.indexOf('image/') === 0) {
    // A single <img> tag found in the HTML source suggests that the
    // content being pasted revolves around an image. Sometimes there are
    // other elements found, like <figure>, but we assume that the user's
    // intention is to paste the actual image file.
    const IMAGE_TAG = /<\s*img\b/gi;
    if (html.match(IMAGE_TAG)?.length !== 1) return true; // Even when there is exactly one <img> tag in the HTML payload, we
    // choose to weed out local images, i.e. those whose source starts with
    // "file://". These payloads occur in specific configurations, such as
    // when copying an entire document from Microsoft Word, that contains
    // text and exactly one image, and pasting that content using Google
    // Chrome.

    const IMG_WITH_LOCAL_SRC = /<\s*img\b[^>]*\bsrc="file:\/\//i;
    if (html.match(IMG_WITH_LOCAL_SRC)) return true;
  }

  return false;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/copy-handler/index.js


/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */



function useNotifyCopy() {
  const {
    getBlockName
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    getBlockType
  } = (0,external_wp_data_namespaceObject.useSelect)(external_wp_blocks_namespaceObject.store);
  const {
    createSuccessNotice
  } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_notices_namespaceObject.store);
  return (0,external_wp_element_namespaceObject.useCallback)((eventType, selectedBlockClientIds) => {
    let notice = '';

    if (selectedBlockClientIds.length === 1) {
      const clientId = selectedBlockClientIds[0];
      const title = getBlockType(getBlockName(clientId))?.title;
      notice = eventType === 'copy' ? (0,external_wp_i18n_namespaceObject.sprintf)( // Translators: Name of the block being copied, e.g. "Paragraph".
      (0,external_wp_i18n_namespaceObject.__)('Copied "%s" to clipboard.'), title) : (0,external_wp_i18n_namespaceObject.sprintf)( // Translators: Name of the block being cut, e.g. "Paragraph".
      (0,external_wp_i18n_namespaceObject.__)('Moved "%s" to clipboard.'), title);
    } else {
      notice = eventType === 'copy' ? (0,external_wp_i18n_namespaceObject.sprintf)( // Translators: %d: Number of blocks being copied.
      (0,external_wp_i18n_namespaceObject._n)('Copied %d block to clipboard.', 'Copied %d blocks to clipboard.', selectedBlockClientIds.length), selectedBlockClientIds.length) : (0,external_wp_i18n_namespaceObject.sprintf)( // Translators: %d: Number of blocks being cut.
      (0,external_wp_i18n_namespaceObject._n)('Moved %d block to clipboard.', 'Moved %d blocks to clipboard.', selectedBlockClientIds.length), selectedBlockClientIds.length);
    }

    createSuccessNotice(notice, {
      type: 'snackbar'
    });
  }, []);
}
function useClipboardHandler() {
  const {
    getBlocksByClientId,
    getSelectedBlockClientIds,
    hasMultiSelection,
    getSettings,
    __unstableIsFullySelected,
    __unstableIsSelectionCollapsed,
    __unstableIsSelectionMergeable,
    __unstableGetSelectedBlocksWithPartialSelection,
    canInsertBlockType
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    flashBlock,
    removeBlocks,
    replaceBlocks,
    __unstableDeleteSelection,
    __unstableExpandSelection,
    insertBlocks
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const notifyCopy = useNotifyCopy();
  return (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    function handler(event) {
      if (event.defaultPrevented) {
        // This was likely already handled in rich-text/use-paste-handler.js.
        return;
      }

      const selectedBlockClientIds = getSelectedBlockClientIds();

      if (selectedBlockClientIds.length === 0) {
        return;
      } // Always handle multiple selected blocks.


      if (!hasMultiSelection()) {
        const {
          target
        } = event;
        const {
          ownerDocument
        } = target; // If copying, only consider actual text selection as selection.
        // Otherwise, any focus on an input field is considered.

        const hasSelection = event.type === 'copy' || event.type === 'cut' ? (0,external_wp_dom_namespaceObject.documentHasUncollapsedSelection)(ownerDocument) : (0,external_wp_dom_namespaceObject.documentHasSelection)(ownerDocument); // Let native copy behaviour take over in input fields.

        if (hasSelection) {
          return;
        }
      }

      if (!node.contains(event.target.ownerDocument.activeElement)) {
        return;
      }

      event.preventDefault();

      const isSelectionMergeable = __unstableIsSelectionMergeable();

      const shouldHandleWholeBlocks = __unstableIsSelectionCollapsed() || __unstableIsFullySelected();

      const expandSelectionIsNeeded = !shouldHandleWholeBlocks && !isSelectionMergeable;

      if (event.type === 'copy' || event.type === 'cut') {
        if (selectedBlockClientIds.length === 1) {
          flashBlock(selectedBlockClientIds[0]);
        } // If we have a partial selection that is not mergeable, just
        // expand the selection to the whole blocks.


        if (expandSelectionIsNeeded) {
          __unstableExpandSelection();
        } else {
          notifyCopy(event.type, selectedBlockClientIds);
          let blocks; // Check if we have partial selection.

          if (shouldHandleWholeBlocks) {
            blocks = getBlocksByClientId(selectedBlockClientIds);
          } else {
            const [head, tail] = __unstableGetSelectedBlocksWithPartialSelection();

            const inBetweenBlocks = getBlocksByClientId(selectedBlockClientIds.slice(1, selectedBlockClientIds.length - 1));
            blocks = [head, ...inBetweenBlocks, tail];
          }

          const wrapperBlockName = event.clipboardData.getData('__unstableWrapperBlockName');

          if (wrapperBlockName) {
            blocks = (0,external_wp_blocks_namespaceObject.createBlock)(wrapperBlockName, JSON.parse(event.clipboardData.getData('__unstableWrapperBlockAttributes')), blocks);
          }

          const serialized = (0,external_wp_blocks_namespaceObject.serialize)(blocks);
          event.clipboardData.setData('text/plain', toPlainText(serialized));
          event.clipboardData.setData('text/html', serialized);
        }
      }

      if (event.type === 'cut') {
        // We need to also check if at the start we needed to
        // expand the selection, as in this point we might have
        // programmatically fully selected the blocks above.
        if (shouldHandleWholeBlocks && !expandSelectionIsNeeded) {
          removeBlocks(selectedBlockClientIds);
        } else {
          event.target.ownerDocument.activeElement.contentEditable = false;

          __unstableDeleteSelection();
        }
      } else if (event.type === 'paste') {
        const {
          __experimentalCanUserUseUnfilteredHTML: canUserUseUnfilteredHTML
        } = getSettings();
        const {
          plainText,
          html,
          files
        } = getPasteEventData(event);
        let blocks = [];

        if (files.length) {
          const fromTransforms = (0,external_wp_blocks_namespaceObject.getBlockTransforms)('from');
          blocks = files.reduce((accumulator, file) => {
            const transformation = (0,external_wp_blocks_namespaceObject.findTransform)(fromTransforms, transform => transform.type === 'files' && transform.isMatch([file]));

            if (transformation) {
              accumulator.push(transformation.transform([file]));
            }

            return accumulator;
          }, []).flat();
        } else {
          blocks = (0,external_wp_blocks_namespaceObject.pasteHandler)({
            HTML: html,
            plainText,
            mode: 'BLOCKS',
            canUserUseUnfilteredHTML
          });
        }

        if (selectedBlockClientIds.length === 1) {
          const [selectedBlockClientId] = selectedBlockClientIds;

          if (blocks.every(block => canInsertBlockType(block.name, selectedBlockClientId))) {
            insertBlocks(blocks, undefined, selectedBlockClientId);
            return;
          }
        }

        replaceBlocks(selectedBlockClientIds, blocks, blocks.length - 1, -1);
      }
    }

    node.ownerDocument.addEventListener('copy', handler);
    node.ownerDocument.addEventListener('cut', handler);
    node.ownerDocument.addEventListener('paste', handler);
    return () => {
      node.ownerDocument.removeEventListener('copy', handler);
      node.ownerDocument.removeEventListener('cut', handler);
      node.ownerDocument.removeEventListener('paste', handler);
    };
  }, []);
}

function CopyHandler({
  children
}) {
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    ref: useClipboardHandler()
  }, children);
}
/**
 * Given a string of HTML representing serialized blocks, returns the plain
 * text extracted after stripping the HTML of any tags and fixing line breaks.
 *
 * @param {string} html Serialized blocks.
 * @return {string} The plain-text content with any html removed.
 */


function toPlainText(html) {
  // Manually handle BR tags as line breaks prior to `stripHTML` call
  html = html.replace(/<br>/g, '\n');
  const plainText = (0,external_wp_dom_namespaceObject.__unstableStripHTML)(html).trim(); // Merge any consecutive line breaks

  return plainText.replace(/\n\n+/g, '\n\n');
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/copy-handler/README.md
 */


/* harmony default export */ var copy_handler = (CopyHandler);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/supports.js
/**
 * WordPress dependencies
 */


const ALIGN_SUPPORT_KEY = 'align';
const ALIGN_WIDE_SUPPORT_KEY = 'alignWide';
const supports_BORDER_SUPPORT_KEY = '__experimentalBorder';
const supports_COLOR_SUPPORT_KEY = 'color';
const CUSTOM_CLASS_NAME_SUPPORT_KEY = 'customClassName';
const supports_FONT_FAMILY_SUPPORT_KEY = 'typography.__experimentalFontFamily';
const supports_FONT_SIZE_SUPPORT_KEY = 'typography.fontSize';
const supports_LINE_HEIGHT_SUPPORT_KEY = 'typography.lineHeight';
/**
 * Key within block settings' support array indicating support for font style.
 */

const supports_FONT_STYLE_SUPPORT_KEY = 'typography.__experimentalFontStyle';
/**
 * Key within block settings' support array indicating support for font weight.
 */

const supports_FONT_WEIGHT_SUPPORT_KEY = 'typography.__experimentalFontWeight';
/**
 * Key within block settings' supports array indicating support for text
 * columns e.g. settings found in `block.json`.
 */

const supports_TEXT_COLUMNS_SUPPORT_KEY = 'typography.textColumns';
/**
 * Key within block settings' supports array indicating support for text
 * decorations e.g. settings found in `block.json`.
 */

const supports_TEXT_DECORATION_SUPPORT_KEY = 'typography.__experimentalTextDecoration';
/**
 * Key within block settings' supports array indicating support for text
 * transforms e.g. settings found in `block.json`.
 */

const supports_TEXT_TRANSFORM_SUPPORT_KEY = 'typography.__experimentalTextTransform';
/**
 * Key within block settings' supports array indicating support for letter-spacing
 * e.g. settings found in `block.json`.
 */

const supports_LETTER_SPACING_SUPPORT_KEY = 'typography.__experimentalLetterSpacing';
const LAYOUT_SUPPORT_KEY = 'layout';
const supports_TYPOGRAPHY_SUPPORT_KEYS = [supports_LINE_HEIGHT_SUPPORT_KEY, supports_FONT_SIZE_SUPPORT_KEY, supports_FONT_STYLE_SUPPORT_KEY, supports_FONT_WEIGHT_SUPPORT_KEY, supports_FONT_FAMILY_SUPPORT_KEY, supports_TEXT_COLUMNS_SUPPORT_KEY, supports_TEXT_DECORATION_SUPPORT_KEY, supports_TEXT_TRANSFORM_SUPPORT_KEY, supports_LETTER_SPACING_SUPPORT_KEY];
const supports_SPACING_SUPPORT_KEY = 'spacing';
const supports_styleSupportKeys = [...supports_TYPOGRAPHY_SUPPORT_KEYS, supports_BORDER_SUPPORT_KEY, supports_COLOR_SUPPORT_KEY, supports_SPACING_SUPPORT_KEY];
/**
 * Returns true if the block defines support for align.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */

const hasAlignSupport = nameOrType => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(nameOrType, ALIGN_SUPPORT_KEY);
/**
 * Returns the block support value for align, if defined.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {unknown} The block support value.
 */

const getAlignSupport = nameOrType => getBlockSupport(nameOrType, ALIGN_SUPPORT_KEY);
/**
 * Returns true if the block defines support for align wide.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */

const hasAlignWideSupport = nameOrType => hasBlockSupport(nameOrType, ALIGN_WIDE_SUPPORT_KEY);
/**
 * Returns the block support value for align wide, if defined.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {unknown} The block support value.
 */

const getAlignWideSupport = nameOrType => getBlockSupport(nameOrType, ALIGN_WIDE_SUPPORT_KEY);
/**
 * Determine whether there is block support for border properties.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @param {string}        feature    Border feature to check support for.
 *
 * @return {boolean} Whether there is support.
 */

function supports_hasBorderSupport(nameOrType, feature = 'any') {
  if (external_wp_element_namespaceObject.Platform.OS !== 'web') {
    return false;
  }

  const support = (0,external_wp_blocks_namespaceObject.getBlockSupport)(nameOrType, supports_BORDER_SUPPORT_KEY);

  if (support === true) {
    return true;
  }

  if (feature === 'any') {
    return !!(support?.color || support?.radius || support?.width || support?.style);
  }

  return !!support?.[feature];
}
/**
 * Get block support for border properties.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @param {string}        feature    Border feature to get.
 *
 * @return {unknown} The block support.
 */

const getBorderSupport = (nameOrType, feature) => getBlockSupport(nameOrType, [supports_BORDER_SUPPORT_KEY, feature]);
/**
 * Returns true if the block defines support for color.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */

const supports_hasColorSupport = nameOrType => {
  const colorSupport = getBlockSupport(nameOrType, supports_COLOR_SUPPORT_KEY);
  return colorSupport && (colorSupport.link === true || colorSupport.gradient === true || colorSupport.background !== false || colorSupport.text !== false);
};
/**
 * Returns true if the block defines support for link color.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */

const supports_hasLinkColorSupport = nameOrType => {
  if (Platform.OS !== 'web') {
    return false;
  }

  const colorSupport = getBlockSupport(nameOrType, supports_COLOR_SUPPORT_KEY);
  return colorSupport !== null && typeof colorSupport === 'object' && !!colorSupport.link;
};
/**
 * Returns true if the block defines support for gradient color.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */

const supports_hasGradientSupport = nameOrType => {
  const colorSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(nameOrType, supports_COLOR_SUPPORT_KEY);
  return colorSupport !== null && typeof colorSupport === 'object' && !!colorSupport.gradients;
};
/**
 * Returns true if the block defines support for background color.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */

const supports_hasBackgroundColorSupport = nameOrType => {
  const colorSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(nameOrType, supports_COLOR_SUPPORT_KEY);
  return colorSupport && colorSupport.background !== false;
};
/**
 * Returns true if the block defines support for background color.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */

const supports_hasTextColorSupport = nameOrType => {
  const colorSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(nameOrType, supports_COLOR_SUPPORT_KEY);
  return colorSupport && colorSupport.text !== false;
};
/**
 * Get block support for color properties.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @param {string}        feature    Color feature to get.
 *
 * @return {unknown} The block support.
 */

const getColorSupport = (nameOrType, feature) => getBlockSupport(nameOrType, [supports_COLOR_SUPPORT_KEY, feature]);
/**
 * Returns true if the block defines support for custom class name.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */

const hasCustomClassNameSupport = nameOrType => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(nameOrType, CUSTOM_CLASS_NAME_SUPPORT_KEY, true);
/**
 * Returns the block support value for custom class name, if defined.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {unknown} The block support value.
 */

const getCustomClassNameSupport = nameOrType => getBlockSupport(nameOrType, CUSTOM_CLASS_NAME_SUPPORT_KEY, true);
/**
 * Returns true if the block defines support for font family.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */

const hasFontFamilySupport = nameOrType => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(nameOrType, supports_FONT_FAMILY_SUPPORT_KEY);
/**
 * Returns the block support value for font family, if defined.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {unknown} The block support value.
 */

const getFontFamilySupport = nameOrType => getBlockSupport(nameOrType, supports_FONT_FAMILY_SUPPORT_KEY);
/**
 * Returns true if the block defines support for font size.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */

const hasFontSizeSupport = nameOrType => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(nameOrType, supports_FONT_SIZE_SUPPORT_KEY);
/**
 * Returns the block support value for font size, if defined.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {unknown} The block support value.
 */

const getFontSizeSupport = nameOrType => getBlockSupport(nameOrType, supports_FONT_SIZE_SUPPORT_KEY);
/**
 * Returns true if the block defines support for layout.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */

const hasLayoutSupport = nameOrType => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(nameOrType, LAYOUT_SUPPORT_KEY);
/**
 * Returns the block support value for layout, if defined.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {unknown} The block support value.
 */

const getLayoutSupport = nameOrType => getBlockSupport(nameOrType, LAYOUT_SUPPORT_KEY);
/**
 * Returns true if the block defines support for style.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */

const supports_hasStyleSupport = nameOrType => supports_styleSupportKeys.some(key => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(nameOrType, key));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/use-paste-styles/index.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



/**
 * Determine if the copied text looks like serialized blocks or not.
 * Since plain text will always get parsed into a freeform block,
 * we check that if the parsed blocks is anything other than that.
 *
 * @param {string} text The copied text.
 * @return {boolean} True if the text looks like serialized blocks, false otherwise.
 */

function hasSerializedBlocks(text) {
  try {
    const blocks = (0,external_wp_blocks_namespaceObject.parse)(text, {
      __unstableSkipMigrationLogs: true,
      __unstableSkipAutop: true
    });

    if (blocks.length === 1 && blocks[0].name === 'core/freeform') {
      // It's likely that the text is just plain text and not serialized blocks.
      return false;
    }

    return true;
  } catch (err) {
    // Parsing error, the text is not serialized blocks.
    // (Even though that it technically won't happen)
    return false;
  }
}
/**
 * Style attributes are attributes being added in `block-editor/src/hooks/*`.
 * (Except for some unrelated to style like `anchor` or `settings`.)
 * They generally represent the default block supports.
 */


const STYLE_ATTRIBUTES = {
  align: hasAlignSupport,
  borderColor: nameOrType => supports_hasBorderSupport(nameOrType, 'color'),
  backgroundColor: supports_hasBackgroundColorSupport,
  textColor: supports_hasTextColorSupport,
  gradient: supports_hasGradientSupport,
  className: hasCustomClassNameSupport,
  fontFamily: hasFontFamilySupport,
  fontSize: hasFontSizeSupport,
  layout: hasLayoutSupport,
  style: supports_hasStyleSupport
};
/**
 * Get the "style attributes" from a given block to a target block.
 *
 * @param {WPBlock} sourceBlock The source block.
 * @param {WPBlock} targetBlock The target block.
 * @return {Object} the filtered attributes object.
 */

function getStyleAttributes(sourceBlock, targetBlock) {
  return Object.entries(STYLE_ATTRIBUTES).reduce((attributes, [attributeKey, hasSupport]) => {
    // Only apply the attribute if both blocks support it.
    if (hasSupport(sourceBlock.name) && hasSupport(targetBlock.name)) {
      // Override attributes that are not present in the block to their defaults.
      attributes[attributeKey] = sourceBlock.attributes[attributeKey];
    }

    return attributes;
  }, {});
}
/**
 * Update the target blocks with style attributes recursively.
 *
 * @param {WPBlock[]} targetBlocks          The target blocks to be updated.
 * @param {WPBlock[]} sourceBlocks          The source blocks to get th style attributes from.
 * @param {Function}  updateBlockAttributes The function to update the attributes.
 */


function recursivelyUpdateBlockAttributes(targetBlocks, sourceBlocks, updateBlockAttributes) {
  for (let index = 0; index < Math.min(sourceBlocks.length, targetBlocks.length); index += 1) {
    updateBlockAttributes(targetBlocks[index].clientId, getStyleAttributes(sourceBlocks[index], targetBlocks[index]));
    recursivelyUpdateBlockAttributes(targetBlocks[index].innerBlocks, sourceBlocks[index].innerBlocks, updateBlockAttributes);
  }
}
/**
 * A hook to return a pasteStyles event function for handling pasting styles to blocks.
 *
 * @return {Function} A function to update the styles to the blocks.
 */


function usePasteStyles() {
  const registry = (0,external_wp_data_namespaceObject.useRegistry)();
  const {
    updateBlockAttributes
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const {
    createSuccessNotice,
    createWarningNotice,
    createErrorNotice
  } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_notices_namespaceObject.store);
  return (0,external_wp_element_namespaceObject.useCallback)(async targetBlocks => {
    let html = '';

    try {
      // `http:` sites won't have the clipboard property on navigator.
      // (with the exception of localhost.)
      if (!window.navigator.clipboard) {
        createErrorNotice((0,external_wp_i18n_namespaceObject.__)('Unable to paste styles. This feature is only available on secure (https) sites in supporting browsers.'), {
          type: 'snackbar'
        });
        return;
      }

      html = await window.navigator.clipboard.readText();
    } catch (error) {
      // Possibly the permission is denied.
      createErrorNotice((0,external_wp_i18n_namespaceObject.__)('Unable to paste styles. Please allow browser clipboard permissions before continuing.'), {
        type: 'snackbar'
      });
      return;
    } // Abort if the copied text is empty or doesn't look like serialized blocks.


    if (!html || !hasSerializedBlocks(html)) {
      createWarningNotice((0,external_wp_i18n_namespaceObject.__)("Unable to paste styles. Block styles couldn't be found within the copied content."), {
        type: 'snackbar'
      });
      return;
    }

    const copiedBlocks = (0,external_wp_blocks_namespaceObject.parse)(html);

    if (copiedBlocks.length === 1) {
      // Apply styles of the block to all the target blocks.
      registry.batch(() => {
        recursivelyUpdateBlockAttributes(targetBlocks, targetBlocks.map(() => copiedBlocks[0]), updateBlockAttributes);
      });
    } else {
      registry.batch(() => {
        recursivelyUpdateBlockAttributes(targetBlocks, copiedBlocks, updateBlockAttributes);
      });
    }

    if (targetBlocks.length === 1) {
      const title = (0,external_wp_blocks_namespaceObject.getBlockType)(targetBlocks[0].name)?.title;
      createSuccessNotice((0,external_wp_i18n_namespaceObject.sprintf)( // Translators: Name of the block being pasted, e.g. "Paragraph".
      (0,external_wp_i18n_namespaceObject.__)('Pasted styles to %s.'), title), {
        type: 'snackbar'
      });
    } else {
      createSuccessNotice((0,external_wp_i18n_namespaceObject.sprintf)( // Translators: The number of the blocks.
      (0,external_wp_i18n_namespaceObject.__)('Pasted styles to %d blocks.'), targetBlocks.length), {
        type: 'snackbar'
      });
    }
  }, [registry.batch, updateBlockAttributes, createSuccessNotice, createWarningNotice, createErrorNotice]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-actions/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function BlockActions({
  clientIds,
  children,
  __experimentalUpdateSelection: updateSelection
}) {
  const {
    canInsertBlockType,
    getBlockRootClientId,
    getBlocksByClientId,
    canMoveBlocks,
    canRemoveBlocks
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    getDefaultBlockName,
    getGroupingBlockName
  } = (0,external_wp_data_namespaceObject.useSelect)(external_wp_blocks_namespaceObject.store);
  const blocks = getBlocksByClientId(clientIds);
  const rootClientId = getBlockRootClientId(clientIds[0]);
  const canCopyStyles = blocks.every(block => {
    return !!block && ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(block.name, 'color') || (0,external_wp_blocks_namespaceObject.hasBlockSupport)(block.name, 'typography'));
  });
  const canDuplicate = blocks.every(block => {
    return !!block && (0,external_wp_blocks_namespaceObject.hasBlockSupport)(block.name, 'multiple', true) && canInsertBlockType(block.name, rootClientId);
  });
  const canInsertDefaultBlock = canInsertBlockType(getDefaultBlockName(), rootClientId);
  const canMove = canMoveBlocks(clientIds, rootClientId);
  const canRemove = canRemoveBlocks(clientIds, rootClientId);
  const {
    removeBlocks,
    replaceBlocks,
    duplicateBlocks,
    insertAfterBlock,
    insertBeforeBlock,
    flashBlock,
    setBlockMovingClientId,
    setNavigationMode,
    selectBlock
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const notifyCopy = useNotifyCopy();
  const pasteStyles = usePasteStyles();
  return children({
    canCopyStyles,
    canDuplicate,
    canInsertDefaultBlock,
    canMove,
    canRemove,
    rootClientId,
    blocks,

    onDuplicate() {
      return duplicateBlocks(clientIds, updateSelection);
    },

    onRemove() {
      return removeBlocks(clientIds, updateSelection);
    },

    onInsertBefore() {
      const clientId = Array.isArray(clientIds) ? clientIds[0] : clientId;
      insertBeforeBlock(clientId);
    },

    onInsertAfter() {
      const clientId = Array.isArray(clientIds) ? clientIds[clientIds.length - 1] : clientId;
      insertAfterBlock(clientId);
    },

    onMoveTo() {
      setNavigationMode(true);
      selectBlock(clientIds[0]);
      setBlockMovingClientId(clientIds[0]);
    },

    onGroup() {
      if (!blocks.length) {
        return;
      }

      const groupingBlockName = getGroupingBlockName(); // Activate the `transform` on `core/group` which does the conversion.

      const newBlocks = (0,external_wp_blocks_namespaceObject.switchToBlockType)(blocks, groupingBlockName);

      if (!newBlocks) {
        return;
      }

      replaceBlocks(clientIds, newBlocks);
    },

    onUngroup() {
      if (!blocks.length) {
        return;
      }

      const innerBlocks = blocks[0].innerBlocks;

      if (!innerBlocks.length) {
        return;
      }

      replaceBlocks(clientIds, innerBlocks);
    },

    onCopy() {
      const selectedBlockClientIds = blocks.map(({
        clientId
      }) => clientId);

      if (blocks.length === 1) {
        flashBlock(selectedBlockClientIds[0]);
      }

      notifyCopy('copy', selectedBlockClientIds);
    },

    async onPasteStyles() {
      await pasteStyles(blocks);
    }

  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-convert-button.js


/**
 * WordPress dependencies
 */


function BlockConvertButton({
  shouldRender,
  onClick,
  small
}) {
  if (!shouldRender) {
    return null;
  }

  const label = (0,external_wp_i18n_namespaceObject.__)('Convert to Blocks');

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    onClick: onClick
  }, !small && label);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-html-convert-button.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/* harmony default export */ var block_html_convert_button = ((0,external_wp_compose_namespaceObject.compose)((0,external_wp_data_namespaceObject.withSelect)((select, {
  clientId
}) => {
  const block = select(store).getBlock(clientId);
  return {
    block,
    shouldRender: block && block.name === 'core/html'
  };
}), (0,external_wp_data_namespaceObject.withDispatch)((dispatch, {
  block
}) => ({
  onClick: () => dispatch(store).replaceBlocks(block.clientId, (0,external_wp_blocks_namespaceObject.rawHandler)({
    HTML: (0,external_wp_blocks_namespaceObject.getBlockContent)(block)
  }))
})))(BlockConvertButton));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-settings-menu-first-item.js
/**
 * WordPress dependencies
 */

const {
  Fill: __unstableBlockSettingsMenuFirstItem,
  Slot: block_settings_menu_first_item_Slot
} = (0,external_wp_components_namespaceObject.createSlotFill)('__unstableBlockSettingsMenuFirstItem');
__unstableBlockSettingsMenuFirstItem.Slot = block_settings_menu_first_item_Slot;
/* harmony default export */ var block_settings_menu_first_item = (__unstableBlockSettingsMenuFirstItem);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-toolbar/utils.js
/**
 * WordPress dependencies
 */

const {
  clearTimeout: utils_clearTimeout,
  setTimeout: utils_setTimeout
} = window;

const utils_noop = () => {};

const DEBOUNCE_TIMEOUT = 200;
/**
 * Hook that creates a showMover state, as well as debounced show/hide callbacks.
 *
 * @param {Object}   props                       Component props.
 * @param {Object}   props.ref                   Element reference.
 * @param {boolean}  props.isFocused             Whether the component has current focus.
 * @param {number}   [props.debounceTimeout=250] Debounce timeout in milliseconds.
 * @param {Function} [props.onChange=noop]       Callback function.
 */

function useDebouncedShowMovers({
  ref,
  isFocused,
  debounceTimeout = DEBOUNCE_TIMEOUT,
  onChange = utils_noop
}) {
  const [showMovers, setShowMovers] = (0,external_wp_element_namespaceObject.useState)(false);
  const timeoutRef = (0,external_wp_element_namespaceObject.useRef)();

  const handleOnChange = nextIsFocused => {
    if (ref?.current) {
      setShowMovers(nextIsFocused);
    }

    onChange(nextIsFocused);
  };

  const getIsHovered = () => {
    return ref?.current && ref.current.matches(':hover');
  };

  const shouldHideMovers = () => {
    const isHovered = getIsHovered();
    return !isFocused && !isHovered;
  };

  const clearTimeoutRef = () => {
    const timeout = timeoutRef.current;

    if (timeout && utils_clearTimeout) {
      utils_clearTimeout(timeout);
    }
  };

  const debouncedShowMovers = event => {
    if (event) {
      event.stopPropagation();
    }

    clearTimeoutRef();

    if (!showMovers) {
      handleOnChange(true);
    }
  };

  const debouncedHideMovers = event => {
    if (event) {
      event.stopPropagation();
    }

    clearTimeoutRef();
    timeoutRef.current = utils_setTimeout(() => {
      if (shouldHideMovers()) {
        handleOnChange(false);
      }
    }, debounceTimeout);
  };

  (0,external_wp_element_namespaceObject.useEffect)(() => () => {
    /**
     * We need to call the change handler with `isFocused`
     * set to false on unmount because we also clear the
     * timeout that would handle that.
     */
    handleOnChange(false);
    clearTimeoutRef();
  }, []);
  return {
    showMovers,
    debouncedShowMovers,
    debouncedHideMovers
  };
}
/**
 * Hook that provides a showMovers state and gesture events for DOM elements
 * that interact with the showMovers state.
 *
 * @param {Object}   props                       Component props.
 * @param {Object}   props.ref                   Element reference.
 * @param {number}   [props.debounceTimeout=250] Debounce timeout in milliseconds.
 * @param {Function} [props.onChange=noop]       Callback function.
 */

function useShowMoversGestures({
  ref,
  debounceTimeout = DEBOUNCE_TIMEOUT,
  onChange = utils_noop
}) {
  const [isFocused, setIsFocused] = (0,external_wp_element_namespaceObject.useState)(false);
  const {
    showMovers,
    debouncedShowMovers,
    debouncedHideMovers
  } = useDebouncedShowMovers({
    ref,
    debounceTimeout,
    isFocused,
    onChange
  });
  const registerRef = (0,external_wp_element_namespaceObject.useRef)(false);

  const isFocusedWithin = () => {
    return ref?.current && ref.current.contains(ref.current.ownerDocument.activeElement);
  };

  (0,external_wp_element_namespaceObject.useEffect)(() => {
    const node = ref.current;

    const handleOnFocus = () => {
      if (isFocusedWithin()) {
        setIsFocused(true);
        debouncedShowMovers();
      }
    };

    const handleOnBlur = () => {
      if (!isFocusedWithin()) {
        setIsFocused(false);
        debouncedHideMovers();
      }
    };
    /**
     * Events are added via DOM events (vs. React synthetic events),
     * as the child React components swallow mouse events.
     */


    if (node && !registerRef.current) {
      node.addEventListener('focus', handleOnFocus, true);
      node.addEventListener('blur', handleOnBlur, true);
      registerRef.current = true;
    }

    return () => {
      if (node) {
        node.removeEventListener('focus', handleOnFocus);
        node.removeEventListener('blur', handleOnBlur);
      }
    };
  }, [ref, registerRef, setIsFocused, debouncedShowMovers, debouncedHideMovers]);
  return {
    showMovers,
    gestures: {
      onMouseMove: debouncedShowMovers,
      onMouseLeave: debouncedHideMovers
    }
  };
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-settings-dropdown.js


/**
 * WordPress dependencies
 */








/**
 * Internal dependencies
 */








const block_settings_dropdown_POPOVER_PROPS = {
  className: 'block-editor-block-settings-menu__popover',
  placement: 'bottom-start'
};

function CopyMenuItem({
  blocks,
  onCopy,
  label
}) {
  const ref = (0,external_wp_compose_namespaceObject.useCopyToClipboard)(() => (0,external_wp_blocks_namespaceObject.serialize)(blocks), onCopy);
  const copyMenuItemBlocksLabel = blocks.length > 1 ? (0,external_wp_i18n_namespaceObject.__)('Copy blocks') : (0,external_wp_i18n_namespaceObject.__)('Copy');
  const copyMenuItemLabel = label ? label : copyMenuItemBlocksLabel;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    ref: ref
  }, copyMenuItemLabel);
}

function BlockSettingsDropdown({
  clientIds,
  __experimentalSelectBlock,
  children,
  __unstableDisplayLocation,
  ...props
}) {
  const blockClientIds = Array.isArray(clientIds) ? clientIds : [clientIds];
  const count = blockClientIds.length;
  const firstBlockClientId = blockClientIds[0];
  const {
    firstParentClientId,
    isDistractionFree,
    onlyBlock,
    parentBlockType,
    previousBlockClientId,
    selectedBlockClientIds
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockCount,
      getBlockName,
      getBlockRootClientId,
      getPreviousBlockClientId,
      getSelectedBlockClientIds,
      getSettings,
      getBlockAttributes
    } = select(store);
    const {
      getActiveBlockVariation
    } = select(external_wp_blocks_namespaceObject.store);

    const _firstParentClientId = getBlockRootClientId(firstBlockClientId);

    const parentBlockName = _firstParentClientId && getBlockName(_firstParentClientId);

    return {
      firstParentClientId: _firstParentClientId,
      isDistractionFree: getSettings().isDistractionFree,
      onlyBlock: 1 === getBlockCount(_firstParentClientId),
      parentBlockType: _firstParentClientId && (getActiveBlockVariation(parentBlockName, getBlockAttributes(_firstParentClientId)) || (0,external_wp_blocks_namespaceObject.getBlockType)(parentBlockName)),
      previousBlockClientId: getPreviousBlockClientId(firstBlockClientId),
      selectedBlockClientIds: getSelectedBlockClientIds()
    };
  }, [firstBlockClientId]);
  const {
    getBlockOrder,
    getSelectedBlockClientIds
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const shortcuts = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getShortcutRepresentation
    } = select(external_wp_keyboardShortcuts_namespaceObject.store);
    return {
      duplicate: getShortcutRepresentation('core/block-editor/duplicate'),
      remove: getShortcutRepresentation('core/block-editor/remove'),
      insertAfter: getShortcutRepresentation('core/block-editor/insert-after'),
      insertBefore: getShortcutRepresentation('core/block-editor/insert-before')
    };
  }, []);

  const isMatch = (0,external_wp_keyboardShortcuts_namespaceObject.__unstableUseShortcutEventMatch)();

  const {
    selectBlock,
    toggleBlockHighlight
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const hasSelectedBlocks = selectedBlockClientIds.length > 0;
  const updateSelectionAfterDuplicate = (0,external_wp_element_namespaceObject.useCallback)(async clientIdsPromise => {
    if (__experimentalSelectBlock) {
      const ids = await clientIdsPromise;

      if (ids && ids[0]) {
        __experimentalSelectBlock(ids[0], false);
      }
    }
  }, [__experimentalSelectBlock]);
  const updateSelectionAfterRemove = (0,external_wp_element_namespaceObject.useCallback)(() => {
    if (__experimentalSelectBlock) {
      let blockToFocus = previousBlockClientId || firstParentClientId; // Focus the first block if there's no previous block nor parent block.

      if (!blockToFocus) {
        blockToFocus = getBlockOrder()[0];
      } // Only update the selection if the original selection is removed.


      const shouldUpdateSelection = hasSelectedBlocks && getSelectedBlockClientIds().length === 0;

      __experimentalSelectBlock(blockToFocus, shouldUpdateSelection);
    }
  }, [__experimentalSelectBlock, previousBlockClientId, firstParentClientId, getBlockOrder, hasSelectedBlocks, getSelectedBlockClientIds]);
  const removeBlockLabel = count === 1 ? (0,external_wp_i18n_namespaceObject.__)('Delete') : (0,external_wp_i18n_namespaceObject.__)('Delete blocks'); // Allows highlighting the parent block outline when focusing or hovering
  // the parent block selector within the child.

  const selectParentButtonRef = (0,external_wp_element_namespaceObject.useRef)();
  const {
    gestures: showParentOutlineGestures
  } = useShowMoversGestures({
    ref: selectParentButtonRef,

    onChange(isFocused) {
      if (isFocused && isDistractionFree) {
        return;
      }

      toggleBlockHighlight(firstParentClientId, isFocused);
    }

  }); // This can occur when the selected block (the parent)
  // displays child blocks within a List View.

  const parentBlockIsSelected = selectedBlockClientIds?.includes(firstParentClientId);
  return (0,external_wp_element_namespaceObject.createElement)(BlockActions, {
    clientIds: clientIds,
    __experimentalUpdateSelection: !__experimentalSelectBlock
  }, ({
    canCopyStyles,
    canDuplicate,
    canInsertDefaultBlock,
    canMove,
    canRemove,
    onDuplicate,
    onInsertAfter,
    onInsertBefore,
    onRemove,
    onCopy,
    onPasteStyles,
    onMoveTo,
    blocks
  }) => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.DropdownMenu, {
    icon: more_vertical,
    label: (0,external_wp_i18n_namespaceObject.__)('Options'),
    className: "block-editor-block-settings-menu",
    popoverProps: block_settings_dropdown_POPOVER_PROPS,
    noIcons: true,
    menuProps: {
      /**
       * @param {KeyboardEvent} event
       */
      onKeyDown(event) {
        if (event.defaultPrevented) return;

        if (isMatch('core/block-editor/remove', event) && canRemove) {
          event.preventDefault();
          updateSelectionAfterRemove(onRemove());
        } else if (isMatch('core/block-editor/duplicate', event) && canDuplicate) {
          event.preventDefault();
          updateSelectionAfterDuplicate(onDuplicate());
        } else if (isMatch('core/block-editor/insert-after', event) && canInsertDefaultBlock) {
          event.preventDefault();
          onInsertAfter();
        } else if (isMatch('core/block-editor/insert-before', event) && canInsertDefaultBlock) {
          event.preventDefault();
          onInsertBefore();
        }
      }

    },
    ...props
  }, ({
    onClose
  }) => (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuGroup, null, (0,external_wp_element_namespaceObject.createElement)(block_settings_menu_first_item.Slot, {
    fillProps: {
      onClose
    }
  }), !parentBlockIsSelected && !!firstParentClientId && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, { ...showParentOutlineGestures,
    ref: selectParentButtonRef,
    icon: (0,external_wp_element_namespaceObject.createElement)(block_icon, {
      icon: parentBlockType.icon
    }),
    onClick: () => selectBlock(firstParentClientId)
  }, (0,external_wp_i18n_namespaceObject.sprintf)(
  /* translators: %s: Name of the block's parent. */
  (0,external_wp_i18n_namespaceObject.__)('Select parent block (%s)'), parentBlockType.title)), count === 1 && (0,external_wp_element_namespaceObject.createElement)(block_html_convert_button, {
    clientId: firstBlockClientId
  }), (0,external_wp_element_namespaceObject.createElement)(CopyMenuItem, {
    blocks: blocks,
    onCopy: onCopy
  }), canDuplicate && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    onClick: (0,external_wp_compose_namespaceObject.pipe)(onClose, onDuplicate, updateSelectionAfterDuplicate),
    shortcut: shortcuts.duplicate
  }, (0,external_wp_i18n_namespaceObject.__)('Duplicate')), canInsertDefaultBlock && (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    onClick: (0,external_wp_compose_namespaceObject.pipe)(onClose, onInsertBefore),
    shortcut: shortcuts.insertBefore
  }, (0,external_wp_i18n_namespaceObject.__)('Add before')), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    onClick: (0,external_wp_compose_namespaceObject.pipe)(onClose, onInsertAfter),
    shortcut: shortcuts.insertAfter
  }, (0,external_wp_i18n_namespaceObject.__)('Add after')))), canCopyStyles && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuGroup, null, (0,external_wp_element_namespaceObject.createElement)(CopyMenuItem, {
    blocks: blocks,
    onCopy: onCopy,
    label: (0,external_wp_i18n_namespaceObject.__)('Copy styles')
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    onClick: onPasteStyles
  }, (0,external_wp_i18n_namespaceObject.__)('Paste styles'))), (0,external_wp_element_namespaceObject.createElement)(block_settings_menu_controls.Slot, {
    fillProps: {
      onClose,
      canMove,
      onMoveTo,
      onlyBlock,
      count,
      firstBlockClientId
    },
    clientIds: clientIds,
    __unstableDisplayLocation: __unstableDisplayLocation
  }), typeof children === 'function' ? children({
    onClose
  }) : external_wp_element_namespaceObject.Children.map(child => (0,external_wp_element_namespaceObject.cloneElement)(child, {
    onClose
  })), canRemove && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuGroup, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    onClick: (0,external_wp_compose_namespaceObject.pipe)(onClose, onRemove, updateSelectionAfterRemove),
    shortcut: shortcuts.remove
  }, removeBlockLabel)))));
}
/* harmony default export */ var block_settings_dropdown = (BlockSettingsDropdown);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/list-view/index.js


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */











const expanded = (state, action) => {
  if (Array.isArray(action.clientIds)) {
    return { ...state,
      ...action.clientIds.reduce((newState, id) => ({ ...newState,
        [id]: action.type === 'expand'
      }), {})
    };
  }

  return state;
};

const BLOCK_LIST_ITEM_HEIGHT = 36;
/** @typedef {import('react').ComponentType} ComponentType */

/** @typedef {import('react').Ref<HTMLElement>} Ref */

/**
 * Show a hierarchical list of blocks.
 *
 * @param {Object}         props                        Components props.
 * @param {string}         props.id                     An HTML element id for the root element of ListView.
 * @param {Array}          props.blocks                 _deprecated_ Custom subset of block client IDs to be used instead of the default hierarchy.
 * @param {?HTMLElement}   props.dropZoneElement        Optional element to be used as the drop zone.
 * @param {?boolean}       props.showBlockMovers        Flag to enable block movers. Defaults to `false`.
 * @param {?boolean}       props.isExpanded             Flag to determine whether nested levels are expanded by default. Defaults to `false`.
 * @param {?boolean}       props.showAppender           Flag to show or hide the block appender. Defaults to `false`.
 * @param {?ComponentType} props.blockSettingsMenu      Optional more menu substitution. Defaults to the standard `BlockSettingsDropdown` component.
 * @param {string}         props.rootClientId           The client id of the root block from which we determine the blocks to show in the list.
 * @param {string}         props.description            Optional accessible description for the tree grid component.
 * @param {?Function}      props.onSelect               Optional callback to be invoked when a block is selected. Receives the block object that was selected.
 * @param {?ComponentType} props.additionalBlockContent Component that renders additional block content UI.
 * @param {Ref}            ref                          Forwarded ref
 */

function ListViewComponent({
  id,
  blocks,
  dropZoneElement,
  showBlockMovers = false,
  isExpanded = false,
  showAppender = false,
  blockSettingsMenu: BlockSettingsMenu = BlockSettingsDropdown,
  rootClientId,
  description,
  onSelect,
  additionalBlockContent: AdditionalBlockContent
}, ref) {
  // This can be removed once we no longer need to support the blocks prop.
  if (blocks) {
    external_wp_deprecated_default()('`blocks` property in `wp.blockEditor.__experimentalListView`', {
      since: '6.3',
      alternative: '`rootClientId` property'
    });
  }

  const instanceId = (0,external_wp_compose_namespaceObject.useInstanceId)(ListViewComponent);
  const {
    clientIdsTree,
    draggedClientIds,
    selectedClientIds
  } = useListViewClientIds({
    blocks,
    rootClientId
  });
  const {
    getBlock
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    visibleBlockCount,
    shouldShowInnerBlocks
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getGlobalBlockCount,
      getClientIdsOfDescendants,
      __unstableGetEditorMode
    } = select(store);
    const draggedBlockCount = draggedClientIds?.length > 0 ? getClientIdsOfDescendants(draggedClientIds).length + 1 : 0;
    return {
      visibleBlockCount: getGlobalBlockCount() - draggedBlockCount,
      shouldShowInnerBlocks: __unstableGetEditorMode() !== 'zoom-out'
    };
  }, [draggedClientIds]);
  const {
    updateBlockSelection
  } = useBlockSelection();
  const [expandedState, setExpandedState] = (0,external_wp_element_namespaceObject.useReducer)(expanded, {});
  const {
    ref: dropZoneRef,
    target: blockDropTarget
  } = useListViewDropZone({
    dropZoneElement
  });
  const elementRef = (0,external_wp_element_namespaceObject.useRef)();
  const treeGridRef = (0,external_wp_compose_namespaceObject.useMergeRefs)([elementRef, dropZoneRef, ref]);
  const isMounted = (0,external_wp_element_namespaceObject.useRef)(false);
  const [insertedBlock, setInsertedBlock] = (0,external_wp_element_namespaceObject.useState)(null);
  const {
    setSelectedTreeId
  } = useListViewExpandSelectedItem({
    firstSelectedBlockClientId: selectedClientIds[0],
    setExpandedState
  });
  const selectEditorBlock = (0,external_wp_element_namespaceObject.useCallback)(
  /**
   * @param {MouseEvent | KeyboardEvent | undefined} event
   * @param {string}                                 blockClientId
   * @param {null | undefined | -1 | 1}              focusPosition
   */
  (event, blockClientId, focusPosition) => {
    updateBlockSelection(event, blockClientId, null, focusPosition);
    setSelectedTreeId(blockClientId);

    if (onSelect) {
      onSelect(getBlock(blockClientId));
    }
  }, [setSelectedTreeId, updateBlockSelection, onSelect, getBlock]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    isMounted.current = true;
  }, []); // List View renders a fixed number of items and relies on each having a fixed item height of 36px.
  // If this value changes, we should also change the itemHeight value set in useFixedWindowList.
  // See: https://github.com/WordPress/gutenberg/pull/35230 for additional context.

  const [fixedListWindow] = (0,external_wp_compose_namespaceObject.__experimentalUseFixedWindowList)(elementRef, BLOCK_LIST_ITEM_HEIGHT, visibleBlockCount, {
    useWindowing: true,
    windowOverscan: 40
  });
  const expand = (0,external_wp_element_namespaceObject.useCallback)(clientId => {
    if (!clientId) {
      return;
    }

    setExpandedState({
      type: 'expand',
      clientIds: [clientId]
    });
  }, [setExpandedState]);
  const collapse = (0,external_wp_element_namespaceObject.useCallback)(clientId => {
    if (!clientId) {
      return;
    }

    setExpandedState({
      type: 'collapse',
      clientIds: [clientId]
    });
  }, [setExpandedState]);
  const expandRow = (0,external_wp_element_namespaceObject.useCallback)(row => {
    expand(row?.dataset?.block);
  }, [expand]);
  const collapseRow = (0,external_wp_element_namespaceObject.useCallback)(row => {
    collapse(row?.dataset?.block);
  }, [collapse]);
  const focusRow = (0,external_wp_element_namespaceObject.useCallback)((event, startRow, endRow) => {
    if (event.shiftKey) {
      updateBlockSelection(event, startRow?.dataset?.block, endRow?.dataset?.block);
    }
  }, [updateBlockSelection]);
  const contextValue = (0,external_wp_element_namespaceObject.useMemo)(() => ({
    isTreeGridMounted: isMounted.current,
    draggedClientIds,
    expandedState,
    expand,
    collapse,
    BlockSettingsMenu,
    listViewInstanceId: instanceId,
    AdditionalBlockContent,
    insertedBlock,
    setInsertedBlock,
    treeGridElementRef: elementRef
  }), [draggedClientIds, expandedState, expand, collapse, BlockSettingsMenu, instanceId, AdditionalBlockContent, insertedBlock, setInsertedBlock]); // If there are no blocks to show and we're not showing the appender, do not render the list view.

  if (!clientIdsTree.length && !showAppender) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_data_namespaceObject.AsyncModeProvider, {
    value: true
  }, (0,external_wp_element_namespaceObject.createElement)(ListViewDropIndicator, {
    listViewRef: elementRef,
    blockDropTarget: blockDropTarget
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalTreeGrid, {
    id: id,
    className: "block-editor-list-view-tree",
    "aria-label": (0,external_wp_i18n_namespaceObject.__)('Block navigation structure'),
    ref: treeGridRef,
    onCollapseRow: collapseRow,
    onExpandRow: expandRow,
    onFocusRow: focusRow,
    applicationAriaLabel: (0,external_wp_i18n_namespaceObject.__)('Block navigation structure') // eslint-disable-next-line jsx-a11y/aria-props
    ,
    "aria-description": description
  }, (0,external_wp_element_namespaceObject.createElement)(ListViewContext.Provider, {
    value: contextValue
  }, (0,external_wp_element_namespaceObject.createElement)(branch, {
    blocks: clientIdsTree,
    parentId: rootClientId,
    selectBlock: selectEditorBlock,
    showBlockMovers: showBlockMovers,
    fixedListWindow: fixedListWindow,
    selectedClientIds: selectedClientIds,
    isExpanded: isExpanded,
    shouldShowInnerBlocks: shouldShowInnerBlocks,
    showAppender: showAppender
  }))));
} // This is the private API for the ListView component.
// It allows access to all props, not just the public ones.


const PrivateListView = (0,external_wp_element_namespaceObject.forwardRef)(ListViewComponent); // This is the public API for the ListView component.
// We wrap the PrivateListView component to hide some props from the public API.

/* harmony default export */ var components_list_view = ((0,external_wp_element_namespaceObject.forwardRef)((props, ref) => {
  return (0,external_wp_element_namespaceObject.createElement)(PrivateListView, {
    ref: ref,
    ...props,
    showAppender: false,
    rootClientId: null,
    onSelect: null,
    additionalBlockContent: null,
    blockSettingsMenu: undefined
  });
}));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-navigation/dropdown.js


/**
 * WordPress dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




function BlockNavigationDropdownToggle({
  isEnabled,
  onToggle,
  isOpen,
  innerRef,
  ...props
}) {
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, { ...props,
    ref: innerRef,
    icon: list_view,
    "aria-expanded": isOpen,
    "aria-haspopup": "true",
    onClick: isEnabled ? onToggle : undefined
    /* translators: button label text should, if possible, be under 16 characters. */
    ,
    label: (0,external_wp_i18n_namespaceObject.__)('List view'),
    className: "block-editor-block-navigation",
    "aria-disabled": !isEnabled
  });
}

function BlockNavigationDropdown({
  isDisabled,
  ...props
}, ref) {
  external_wp_deprecated_default()('wp.blockEditor.BlockNavigationDropdown', {
    since: '6.1',
    alternative: 'wp.components.Dropdown and wp.blockEditor.ListView'
  });
  const hasBlocks = (0,external_wp_data_namespaceObject.useSelect)(select => !!select(store).getBlockCount(), []);
  const isEnabled = hasBlocks && !isDisabled;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Dropdown, {
    contentClassName: "block-editor-block-navigation__popover",
    popoverProps: {
      placement: 'bottom-start'
    },
    renderToggle: ({
      isOpen,
      onToggle
    }) => (0,external_wp_element_namespaceObject.createElement)(BlockNavigationDropdownToggle, { ...props,
      innerRef: ref,
      isOpen: isOpen,
      onToggle: onToggle,
      isEnabled: isEnabled
    }),
    renderContent: () => (0,external_wp_element_namespaceObject.createElement)("div", {
      className: "block-editor-block-navigation__container"
    }, (0,external_wp_element_namespaceObject.createElement)("p", {
      className: "block-editor-block-navigation__label"
    }, (0,external_wp_i18n_namespaceObject.__)('List view')), (0,external_wp_element_namespaceObject.createElement)(components_list_view, null))
  });
}

/* harmony default export */ var dropdown = ((0,external_wp_element_namespaceObject.forwardRef)(BlockNavigationDropdown));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-styles/utils.js
/**
 * WordPress dependencies
 */


/**
 * Returns the active style from the given className.
 *
 * @param {Array}  styles    Block styles.
 * @param {string} className Class name
 *
 * @return {Object?} The active style.
 */

function getActiveStyle(styles, className) {
  for (const style of new (external_wp_tokenList_default())(className).values()) {
    if (style.indexOf('is-style-') === -1) {
      continue;
    }

    const potentialStyleName = style.substring(9);
    const activeStyle = styles?.find(({
      name
    }) => name === potentialStyleName);

    if (activeStyle) {
      return activeStyle;
    }
  }

  return getDefaultStyle(styles);
}
/**
 * Replaces the active style in the block's className.
 *
 * @param {string}  className   Class name.
 * @param {Object?} activeStyle The replaced style.
 * @param {Object}  newStyle    The replacing style.
 *
 * @return {string} The updated className.
 */

function replaceActiveStyle(className, activeStyle, newStyle) {
  const list = new (external_wp_tokenList_default())(className);

  if (activeStyle) {
    list.remove('is-style-' + activeStyle.name);
  }

  list.add('is-style-' + newStyle.name);
  return list.value;
}
/**
 * Returns a collection of styles that can be represented on the frontend.
 * The function checks a style collection for a default style. If none is found, it adds one to
 * act as a fallback for when there is no active style applied to a block. The default item also serves
 * as a switch on the frontend to deactivate non-default styles.
 *
 * @param {Array} styles Block styles.
 *
 * @return {Array<Object?>}        The style collection.
 */

function getRenderedStyles(styles) {
  if (!styles || styles.length === 0) {
    return [];
  }

  return getDefaultStyle(styles) ? styles : [{
    name: 'default',
    label: (0,external_wp_i18n_namespaceObject._x)('Default', 'block style'),
    isDefault: true
  }, ...styles];
}
/**
 * Returns a style object from a collection of styles where that style object is the default block style.
 *
 * @param {Array} styles Block styles.
 *
 * @return {Object?}        The default style object, if found.
 */

function getDefaultStyle(styles) {
  return styles?.find(style => style.isDefault);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-styles/preview-panel.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function BlockStylesPreviewPanel({
  genericPreviewBlock,
  style,
  className,
  activeStyle
}) {
  const example = (0,external_wp_blocks_namespaceObject.getBlockType)(genericPreviewBlock.name)?.example;
  const styleClassName = replaceActiveStyle(className, activeStyle, style);
  const previewBlocks = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return { ...genericPreviewBlock,
      title: style.label || style.name,
      description: style.description,
      initialAttributes: { ...genericPreviewBlock.attributes,
        className: styleClassName + ' block-editor-block-styles__block-preview-container'
      },
      example
    };
  }, [genericPreviewBlock, styleClassName]);
  return (0,external_wp_element_namespaceObject.createElement)(preview_panel, {
    item: previewBlocks
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-styles/use-styles-for-block.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/**
 *
 * @param {WPBlock}     block Block object.
 * @param {WPBlockType} type  Block type settings.
 * @return {WPBlock}          A generic block ready for styles preview.
 */

function useGenericPreviewBlock(block, type) {
  return (0,external_wp_element_namespaceObject.useMemo)(() => {
    const example = type?.example;
    const blockName = type?.name;

    if (example && blockName) {
      return (0,external_wp_blocks_namespaceObject.getBlockFromExample)(blockName, {
        attributes: example.attributes,
        innerBlocks: example.innerBlocks
      });
    }

    if (block) {
      return (0,external_wp_blocks_namespaceObject.cloneBlock)(block);
    }
  }, [type?.example ? block?.name : block, type]);
}
/**
 * @typedef useStylesForBlocksArguments
 * @property {string}     clientId Block client ID.
 * @property {() => void} onSwitch Block style switch callback function.
 */

/**
 *
 * @param {useStylesForBlocksArguments} useStylesForBlocks arguments.
 * @return {Object}                                         Results of the select methods.
 */


function useStylesForBlocks({
  clientId,
  onSwitch
}) {
  const selector = select => {
    const {
      getBlock
    } = select(store);
    const block = getBlock(clientId);

    if (!block) {
      return {};
    }

    const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(block.name);
    const {
      getBlockStyles
    } = select(external_wp_blocks_namespaceObject.store);
    return {
      block,
      blockType,
      styles: getBlockStyles(block.name),
      className: block.attributes.className || ''
    };
  };

  const {
    styles,
    block,
    blockType,
    className
  } = (0,external_wp_data_namespaceObject.useSelect)(selector, [clientId]);
  const {
    updateBlockAttributes
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const stylesToRender = getRenderedStyles(styles);
  const activeStyle = getActiveStyle(stylesToRender, className);
  const genericPreviewBlock = useGenericPreviewBlock(block, blockType);

  const onSelect = style => {
    const styleClassName = replaceActiveStyle(className, activeStyle, style);
    updateBlockAttributes(clientId, {
      className: styleClassName
    });
    onSwitch();
  };

  return {
    onSelect,
    stylesToRender,
    activeStyle,
    genericPreviewBlock,
    className
  };
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-styles/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




const block_styles_noop = () => {}; // Block Styles component for the Settings Sidebar.


function BlockStyles({
  clientId,
  onSwitch = block_styles_noop,
  onHoverClassName = block_styles_noop
}) {
  const {
    onSelect,
    stylesToRender,
    activeStyle,
    genericPreviewBlock,
    className: previewClassName
  } = useStylesForBlocks({
    clientId,
    onSwitch
  });
  const [hoveredStyle, setHoveredStyle] = (0,external_wp_element_namespaceObject.useState)(null);
  const isMobileViewport = (0,external_wp_compose_namespaceObject.useViewportMatch)('medium', '<');

  if (!stylesToRender || stylesToRender.length === 0) {
    return null;
  }

  const debouncedSetHoveredStyle = (0,external_wp_compose_namespaceObject.debounce)(setHoveredStyle, 250);

  const onSelectStylePreview = style => {
    onSelect(style);
    onHoverClassName(null);
    setHoveredStyle(null);
    debouncedSetHoveredStyle.cancel();
  };

  const styleItemHandler = item => {
    var _item$name;

    if (hoveredStyle === item) {
      debouncedSetHoveredStyle.cancel();
      return;
    }

    debouncedSetHoveredStyle(item);
    onHoverClassName((_item$name = item?.name) !== null && _item$name !== void 0 ? _item$name : null);
  };

  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-styles"
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-styles__variants"
  }, stylesToRender.map(style => {
    const buttonText = style.isDefault ? (0,external_wp_i18n_namespaceObject.__)('Default') : style.label || style.name;
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
      className: classnames_default()('block-editor-block-styles__item', {
        'is-active': activeStyle.name === style.name
      }),
      key: style.name,
      variant: "secondary",
      label: buttonText,
      onMouseEnter: () => styleItemHandler(style),
      onFocus: () => styleItemHandler(style),
      onMouseLeave: () => styleItemHandler(null),
      onBlur: () => styleItemHandler(null),
      onClick: () => onSelectStylePreview(style),
      "aria-current": activeStyle.name === style.name
    }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalTruncate, {
      numberOfLines: 1,
      className: "block-editor-block-styles__item-text"
    }, buttonText));
  })), hoveredStyle && !isMobileViewport && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Popover, {
    placement: "left-start",
    offset: 20,
    focusOnMount: false
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-styles__preview-panel",
    onMouseLeave: () => styleItemHandler(null)
  }, (0,external_wp_element_namespaceObject.createElement)(BlockStylesPreviewPanel, {
    activeStyle: activeStyle,
    className: previewClassName,
    genericPreviewBlock: genericPreviewBlock,
    style: hoveredStyle
  }))));
}

/* harmony default export */ var block_styles = (BlockStyles);

BlockStyles.Slot = () => {
  external_wp_deprecated_default()('BlockStyles.Slot', {
    version: '6.4',
    since: '6.2'
  });
  return null;
};

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/paragraph.js


/**
 * WordPress dependencies
 */

const paragraph = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "m9.99609 14v-.2251l.00391.0001v6.225h1.5v-14.5h2.5v14.5h1.5v-14.5h3v-1.5h-8.50391c-2.76142 0-5 2.23858-5 5 0 2.7614 2.23858 5 5 5z"
}));
/* harmony default export */ var library_paragraph = (paragraph);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/heading-level-1.js


/**
 * WordPress dependencies
 */

const headingLevel1 = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M17.6 7c-.6.9-1.5 1.7-2.6 2v1h2v7h2V7h-1.4zM11 11H7V7H5v10h2v-4h4v4h2V7h-2v4z"
}));
/* harmony default export */ var heading_level_1 = (headingLevel1);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/heading-level-2.js


/**
 * WordPress dependencies
 */

const headingLevel2 = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M9 11.1H5v-4H3v10h2v-4h4v4h2v-10H9v4zm8 4c.5-.4.6-.6 1.1-1.1.4-.4.8-.8 1.2-1.3.3-.4.6-.8.9-1.3.2-.4.3-.8.3-1.3 0-.4-.1-.9-.3-1.3-.2-.4-.4-.7-.8-1-.3-.3-.7-.5-1.2-.6-.5-.2-1-.2-1.5-.2-.4 0-.7 0-1.1.1-.3.1-.7.2-1 .3-.3.1-.6.3-.9.5-.3.2-.6.4-.8.7l1.2 1.2c.3-.3.6-.5 1-.7.4-.2.7-.3 1.2-.3s.9.1 1.3.4c.3.3.5.7.5 1.1 0 .4-.1.8-.4 1.1-.3.5-.6.9-1 1.2-.4.4-1 .9-1.6 1.4-.6.5-1.4 1.1-2.2 1.6v1.5h8v-2H17z"
}));
/* harmony default export */ var heading_level_2 = (headingLevel2);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/heading-level-3.js


/**
 * WordPress dependencies
 */

const headingLevel3 = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M9 11H5V7H3v10h2v-4h4v4h2V7H9v4zm11.3 1.7c-.4-.4-1-.7-1.6-.8v-.1c.6-.2 1.1-.5 1.5-.9.3-.4.5-.8.5-1.3 0-.4-.1-.8-.3-1.1-.2-.3-.5-.6-.8-.8-.4-.2-.8-.4-1.2-.5-.6-.1-1.1-.2-1.6-.2-.6 0-1.3.1-1.8.3s-1.1.5-1.6.9l1.2 1.4c.4-.2.7-.4 1.1-.6.3-.2.7-.3 1.1-.3.4 0 .8.1 1.1.3.3.2.4.5.4.8 0 .4-.2.7-.6.9-.7.3-1.5.5-2.2.4v1.6c.5 0 1 0 1.5.1.3.1.7.2 1 .3.2.1.4.2.5.4s.1.4.1.6c0 .3-.2.7-.5.8-.4.2-.9.3-1.4.3s-1-.1-1.4-.3c-.4-.2-.8-.4-1.2-.7L13 15.6c.5.4 1 .8 1.6 1 .7.3 1.5.4 2.3.4.6 0 1.1-.1 1.6-.2.4-.1.9-.2 1.3-.5.4-.2.7-.5.9-.9.2-.4.3-.8.3-1.2 0-.6-.3-1.1-.7-1.5z"
}));
/* harmony default export */ var heading_level_3 = (headingLevel3);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/heading-level-4.js


/**
 * WordPress dependencies
 */

const headingLevel4 = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M20 13V7h-3l-4 6v2h5v2h2v-2h1v-2h-1zm-2 0h-2.8L18 9v4zm-9-2H5V7H3v10h2v-4h4v4h2V7H9v4z"
}));
/* harmony default export */ var heading_level_4 = (headingLevel4);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/heading-level-5.js


/**
 * WordPress dependencies
 */

const headingLevel5 = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M9 11H5V7H3v10h2v-4h4v4h2V7H9v4zm11.7 1.2c-.2-.3-.5-.7-.8-.9-.3-.3-.7-.5-1.1-.6-.5-.1-.9-.2-1.4-.2-.2 0-.5.1-.7.1-.2.1-.5.1-.7.2l.1-1.9h4.3V7H14l-.3 5 1 .6.5-.2.4-.1c.1-.1.3-.1.4-.1h.5c.5 0 1 .1 1.4.4.4.2.6.7.6 1.1 0 .4-.2.8-.6 1.1-.4.3-.9.4-1.4.4-.4 0-.9-.1-1.3-.3-.4-.2-.7-.4-1.1-.7 0 0-1.1 1.4-1 1.5.5.4 1 .8 1.6 1 .7.3 1.5.4 2.3.4.5 0 1-.1 1.5-.3s.9-.4 1.3-.7c.4-.3.7-.7.9-1.1s.3-.9.3-1.4-.1-1-.3-1.4z"
}));
/* harmony default export */ var heading_level_5 = (headingLevel5);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/heading-level-6.js


/**
 * WordPress dependencies
 */

const headingLevel6 = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M20.7 12.4c-.2-.3-.4-.6-.7-.9s-.6-.5-1-.6c-.4-.2-.8-.2-1.2-.2-.5 0-.9.1-1.3.3s-.8.5-1.2.8c0-.5 0-.9.2-1.4l.6-.9c.2-.2.5-.4.8-.5.6-.2 1.3-.2 1.9 0 .3.1.6.3.8.5 0 0 1.3-1.3 1.3-1.4-.4-.3-.9-.6-1.4-.8-.6-.2-1.3-.3-2-.3-.6 0-1.1.1-1.7.4-.5.2-1 .5-1.4.9-.4.4-.8 1-1 1.6-.3.7-.4 1.5-.4 2.3s.1 1.5.3 2.1c.2.6.6 1.1 1 1.5.4.4.9.7 1.4.9 1 .3 2 .3 3 0 .4-.1.8-.3 1.2-.6.3-.3.6-.6.8-1 .2-.5.3-.9.3-1.4s-.1-.9-.3-1.3zm-2 2.1c-.1.2-.3.4-.4.5-.1.1-.3.2-.5.2-.2.1-.4.1-.6.1-.2.1-.5 0-.7-.1-.2 0-.3-.2-.5-.3-.1-.2-.3-.4-.4-.6-.2-.3-.3-.7-.3-1 .3-.3.6-.5 1-.7.3-.1.7-.2 1-.2.4 0 .8.1 1.1.3.3.3.4.7.4 1.1 0 .2 0 .5-.1.7zM9 11H5V7H3v10h2v-4h4v4h2V7H9v4z"
}));
/* harmony default export */ var heading_level_6 = (headingLevel6);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-heading-level-dropdown/heading-level-icon.js
/**
 * WordPress dependencies
 */

/** @typedef {import('@wordpress/element').WPComponent} WPComponent */

/**
 * HeadingLevelIcon props.
 *
 * @typedef WPHeadingLevelIconProps
 *
 * @property {number} level The heading level to show an icon for.
 */

const LEVEL_TO_PATH = {
  0: library_paragraph,
  1: heading_level_1,
  2: heading_level_2,
  3: heading_level_3,
  4: heading_level_4,
  5: heading_level_5,
  6: heading_level_6
};
/**
 * Heading level icon.
 *
 * @param {WPHeadingLevelIconProps} props Component props.
 *
 * @return {?WPComponent} The icon.
 */

function HeadingLevelIcon({
  level
}) {
  var _LEVEL_TO_PATH$level;

  return (_LEVEL_TO_PATH$level = LEVEL_TO_PATH[level]) !== null && _LEVEL_TO_PATH$level !== void 0 ? _LEVEL_TO_PATH$level : null;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-heading-level-dropdown/index.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


const HEADING_LEVELS = [1, 2, 3, 4, 5, 6];
const block_heading_level_dropdown_POPOVER_PROPS = {
  className: 'block-library-heading-level-dropdown'
};
/** @typedef {import('@wordpress/element').WPComponent} WPComponent */

/**
 * HeadingLevelDropdown props.
 *
 * @typedef WPHeadingLevelDropdownProps
 *
 * @property {number}                 value    The chosen heading level.
 * @property {number[]}               options  An array of supported heading levels.
 * @property {(newValue:number)=>any} onChange Callback to run when
 *                                             toolbar value is changed.
 */

/**
 * Dropdown for selecting a heading level (1 through 6) or paragraph (0).
 *
 * @param {WPHeadingLevelDropdownProps} props Component props.
 *
 * @return {WPComponent} The toolbar.
 */

function HeadingLevelDropdown({
  options = HEADING_LEVELS,
  value,
  onChange
}) {
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarDropdownMenu, {
    popoverProps: block_heading_level_dropdown_POPOVER_PROPS,
    icon: (0,external_wp_element_namespaceObject.createElement)(HeadingLevelIcon, {
      level: value
    }),
    label: (0,external_wp_i18n_namespaceObject.__)('Change level'),
    controls: options.map(targetLevel => {
      {
        const isActive = targetLevel === value;
        return {
          icon: (0,external_wp_element_namespaceObject.createElement)(HeadingLevelIcon, {
            level: targetLevel,
            isPressed: isActive
          }),
          label: targetLevel === 0 ? (0,external_wp_i18n_namespaceObject.__)('Paragraph') : (0,external_wp_i18n_namespaceObject.sprintf)( // translators: %s: heading level e.g: "1", "2", "3"
          (0,external_wp_i18n_namespaceObject.__)('Heading %d'), targetLevel),
          isActive,

          onClick() {
            onChange(targetLevel);
          },

          role: 'menuitemradio'
        };
      }
    })
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/layout.js


/**
 * WordPress dependencies
 */

const layout = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M18 5.5H6a.5.5 0 00-.5.5v3h13V6a.5.5 0 00-.5-.5zm.5 5H10v8h8a.5.5 0 00.5-.5v-7.5zm-10 0h-3V18a.5.5 0 00.5.5h2.5v-8zM6 4h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V6a2 2 0 012-2z"
}));
/* harmony default export */ var library_layout = (layout);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-variation-picker/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





function BlockVariationPicker({
  icon = library_layout,
  label = (0,external_wp_i18n_namespaceObject.__)('Choose variation'),
  instructions = (0,external_wp_i18n_namespaceObject.__)('Select a variation to start with.'),
  variations,
  onSelect,
  allowSkip
}) {
  const classes = classnames_default()('block-editor-block-variation-picker', {
    'has-many-variations': variations.length > 4
  });
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Placeholder, {
    icon: icon,
    label: label,
    instructions: instructions,
    className: classes
  }, (0,external_wp_element_namespaceObject.createElement)("ul", {
    className: "block-editor-block-variation-picker__variations",
    role: "list",
    "aria-label": (0,external_wp_i18n_namespaceObject.__)('Block variations')
  }, variations.map(variation => (0,external_wp_element_namespaceObject.createElement)("li", {
    key: variation.name
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    variant: "secondary",
    icon: variation.icon && variation.icon.src ? variation.icon.src : variation.icon,
    iconSize: 48,
    onClick: () => onSelect(variation),
    className: "block-editor-block-variation-picker__variation",
    label: variation.description || variation.title
  }), (0,external_wp_element_namespaceObject.createElement)("span", {
    className: "block-editor-block-variation-picker__variation-label"
  }, variation.title)))), allowSkip && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-variation-picker__skip"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    variant: "link",
    onClick: () => onSelect()
  }, (0,external_wp_i18n_namespaceObject.__)('Skip'))));
}

/* harmony default export */ var block_variation_picker = (BlockVariationPicker);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/grid.js


/**
 * WordPress dependencies
 */

const grid_grid = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "m3 5c0-1.10457.89543-2 2-2h13.5c1.1046 0 2 .89543 2 2v13.5c0 1.1046-.8954 2-2 2h-13.5c-1.10457 0-2-.8954-2-2zm2-.5h6v6.5h-6.5v-6c0-.27614.22386-.5.5-.5zm-.5 8v6c0 .2761.22386.5.5.5h6v-6.5zm8 0v6.5h6c.2761 0 .5-.2239.5-.5v-6zm0-8v6.5h6.5v-6c0-.27614-.2239-.5-.5-.5z",
  fillRule: "evenodd",
  clipRule: "evenodd"
}));
/* harmony default export */ var library_grid = (grid_grid);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-pattern-setup/constants.js
const VIEWMODES = {
  carousel: 'carousel',
  grid: 'grid'
};

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-pattern-setup/setup-toolbar.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



const Actions = ({
  onBlockPatternSelect
}) => (0,external_wp_element_namespaceObject.createElement)("div", {
  className: "block-editor-block-pattern-setup__actions"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
  variant: "primary",
  onClick: onBlockPatternSelect
}, (0,external_wp_i18n_namespaceObject.__)('Choose')));

const CarouselNavigation = ({
  handlePrevious,
  handleNext,
  activeSlide,
  totalSlides
}) => (0,external_wp_element_namespaceObject.createElement)("div", {
  className: "block-editor-block-pattern-setup__navigation"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
  icon: chevron_left,
  label: (0,external_wp_i18n_namespaceObject.__)('Previous pattern'),
  onClick: handlePrevious,
  disabled: activeSlide === 0
}), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
  icon: chevron_right,
  label: (0,external_wp_i18n_namespaceObject.__)('Next pattern'),
  onClick: handleNext,
  disabled: activeSlide === totalSlides - 1
}));

const SetupToolbar = ({
  viewMode,
  setViewMode,
  handlePrevious,
  handleNext,
  activeSlide,
  totalSlides,
  onBlockPatternSelect
}) => {
  const isCarouselView = viewMode === VIEWMODES.carousel;
  const displayControls = (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-pattern-setup__display-controls"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    icon: stretch_full_width,
    label: (0,external_wp_i18n_namespaceObject.__)('Carousel view'),
    onClick: () => setViewMode(VIEWMODES.carousel),
    isPressed: isCarouselView
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    icon: library_grid,
    label: (0,external_wp_i18n_namespaceObject.__)('Grid view'),
    onClick: () => setViewMode(VIEWMODES.grid),
    isPressed: viewMode === VIEWMODES.grid
  }));
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-pattern-setup__toolbar"
  }, isCarouselView && (0,external_wp_element_namespaceObject.createElement)(CarouselNavigation, {
    handlePrevious: handlePrevious,
    handleNext: handleNext,
    activeSlide: activeSlide,
    totalSlides: totalSlides
  }), displayControls, isCarouselView && (0,external_wp_element_namespaceObject.createElement)(Actions, {
    onBlockPatternSelect: onBlockPatternSelect
  }));
};

/* harmony default export */ var setup_toolbar = (SetupToolbar);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-pattern-setup/use-patterns-setup.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



function usePatternsSetup(clientId, blockName, filterPatternsFn) {
  return (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockRootClientId,
      getPatternsByBlockTypes,
      __experimentalGetAllowedPatterns
    } = select(store);
    const rootClientId = getBlockRootClientId(clientId);

    if (filterPatternsFn) {
      return __experimentalGetAllowedPatterns(rootClientId).filter(filterPatternsFn);
    }

    return getPatternsByBlockTypes(blockName, rootClientId);
  }, [clientId, blockName, filterPatternsFn]);
}

/* harmony default export */ var use_patterns_setup = (usePatternsSetup);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-pattern-setup/index.js


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */







const SetupContent = ({
  viewMode,
  activeSlide,
  patterns,
  onBlockPatternSelect,
  showTitles
}) => {
  const composite = (0,external_wp_components_namespaceObject.__unstableUseCompositeState)();
  const containerClass = 'block-editor-block-pattern-setup__container';

  if (viewMode === VIEWMODES.carousel) {
    const slideClass = new Map([[activeSlide, 'active-slide'], [activeSlide - 1, 'previous-slide'], [activeSlide + 1, 'next-slide']]);
    return (0,external_wp_element_namespaceObject.createElement)("div", {
      className: "block-editor-block-pattern-setup__carousel"
    }, (0,external_wp_element_namespaceObject.createElement)("div", {
      className: containerClass
    }, (0,external_wp_element_namespaceObject.createElement)("ul", {
      className: "carousel-container"
    }, patterns.map((pattern, index) => (0,external_wp_element_namespaceObject.createElement)(BlockPatternSlide, {
      className: slideClass.get(index) || '',
      key: pattern.name,
      pattern: pattern
    })))));
  }

  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-pattern-setup__grid"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__unstableComposite, { ...composite,
    role: "listbox",
    className: containerClass,
    "aria-label": (0,external_wp_i18n_namespaceObject.__)('Patterns list')
  }, patterns.map(pattern => (0,external_wp_element_namespaceObject.createElement)(block_pattern_setup_BlockPattern, {
    key: pattern.name,
    pattern: pattern,
    onSelect: onBlockPatternSelect,
    composite: composite,
    showTitles: showTitles
  }))));
};

function block_pattern_setup_BlockPattern({
  pattern,
  onSelect,
  composite,
  showTitles
}) {
  const baseClassName = 'block-editor-block-pattern-setup-list';
  const {
    blocks,
    description,
    viewportWidth = 700
  } = pattern;
  const descriptionId = (0,external_wp_compose_namespaceObject.useInstanceId)(block_pattern_setup_BlockPattern, `${baseClassName}__item-description`);
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: `${baseClassName}__list-item`,
    "aria-label": pattern.title,
    "aria-describedby": pattern.description ? descriptionId : undefined
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__unstableCompositeItem, {
    role: "option",
    as: "div",
    ...composite,
    className: `${baseClassName}__item`,
    onClick: () => onSelect(blocks)
  }, (0,external_wp_element_namespaceObject.createElement)(block_preview, {
    blocks: blocks,
    viewportWidth: viewportWidth
  }), showTitles && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: `${baseClassName}__item-title`
  }, pattern.title), !!description && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.VisuallyHidden, {
    id: descriptionId
  }, description)));
}

function BlockPatternSlide({
  className,
  pattern,
  minHeight
}) {
  const {
    blocks,
    title,
    description
  } = pattern;
  const descriptionId = (0,external_wp_compose_namespaceObject.useInstanceId)(BlockPatternSlide, 'block-editor-block-pattern-setup-list__item-description');
  return (0,external_wp_element_namespaceObject.createElement)("li", {
    className: `pattern-slide ${className}`,
    "aria-label": title,
    "aria-describedby": description ? descriptionId : undefined
  }, (0,external_wp_element_namespaceObject.createElement)(block_preview, {
    blocks: blocks,
    minHeight: minHeight
  }), !!description && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.VisuallyHidden, {
    id: descriptionId
  }, description));
}

const BlockPatternSetup = ({
  clientId,
  blockName,
  filterPatternsFn,
  onBlockPatternSelect,
  initialViewMode = VIEWMODES.carousel,
  showTitles = false
}) => {
  const [viewMode, setViewMode] = (0,external_wp_element_namespaceObject.useState)(initialViewMode);
  const [activeSlide, setActiveSlide] = (0,external_wp_element_namespaceObject.useState)(0);
  const {
    replaceBlock
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const patterns = use_patterns_setup(clientId, blockName, filterPatternsFn);

  if (!patterns?.length) {
    return null;
  }

  const onBlockPatternSelectDefault = blocks => {
    const clonedBlocks = blocks.map(block => (0,external_wp_blocks_namespaceObject.cloneBlock)(block));
    replaceBlock(clientId, clonedBlocks);
  };

  const onPatternSelectCallback = onBlockPatternSelect || onBlockPatternSelectDefault;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: `block-editor-block-pattern-setup view-mode-${viewMode}`
  }, (0,external_wp_element_namespaceObject.createElement)(SetupContent, {
    viewMode: viewMode,
    activeSlide: activeSlide,
    patterns: patterns,
    onBlockPatternSelect: onPatternSelectCallback,
    showTitles: showTitles
  }), (0,external_wp_element_namespaceObject.createElement)(setup_toolbar, {
    viewMode: viewMode,
    setViewMode: setViewMode,
    activeSlide: activeSlide,
    totalSlides: patterns.length,
    handleNext: () => {
      setActiveSlide(active => active + 1);
    },
    handlePrevious: () => {
      setActiveSlide(active => active - 1);
    },
    onBlockPatternSelect: () => {
      onPatternSelectCallback(patterns[activeSlide].blocks);
    }
  })));
};

/* harmony default export */ var block_pattern_setup = (BlockPatternSetup);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-variation-transforms/index.js


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




function VariationsButtons({
  className,
  onSelectVariation,
  selectedValue,
  variations
}) {
  return (0,external_wp_element_namespaceObject.createElement)("fieldset", {
    className: className
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.VisuallyHidden, {
    as: "legend"
  }, (0,external_wp_i18n_namespaceObject.__)('Transform to variation')), variations.map(variation => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    key: variation.name,
    icon: (0,external_wp_element_namespaceObject.createElement)(block_icon, {
      icon: variation.icon,
      showColors: true
    }),
    isPressed: selectedValue === variation.name,
    label: selectedValue === variation.name ? variation.title : (0,external_wp_i18n_namespaceObject.sprintf)(
    /* translators: %s: Name of the block variation */
    (0,external_wp_i18n_namespaceObject.__)('Transform to %s'), variation.title),
    onClick: () => onSelectVariation(variation.name),
    "aria-label": variation.title,
    showTooltip: true
  })));
}

function VariationsDropdown({
  className,
  onSelectVariation,
  selectedValue,
  variations
}) {
  const selectOptions = variations.map(({
    name,
    title,
    description
  }) => ({
    value: name,
    label: title,
    info: description
  }));
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.DropdownMenu, {
    className: className,
    label: (0,external_wp_i18n_namespaceObject.__)('Transform to variation'),
    text: (0,external_wp_i18n_namespaceObject.__)('Transform to variation'),
    popoverProps: {
      position: 'bottom center',
      className: `${className}__popover`
    },
    icon: chevron_down,
    toggleProps: {
      iconPosition: 'right'
    }
  }, () => (0,external_wp_element_namespaceObject.createElement)("div", {
    className: `${className}__container`
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuGroup, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItemsChoice, {
    choices: selectOptions,
    value: selectedValue,
    onSelect: onSelectVariation
  }))));
}

function __experimentalBlockVariationTransforms({
  blockClientId
}) {
  const {
    updateBlockAttributes
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const {
    activeBlockVariation,
    variations
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getActiveBlockVariation,
      getBlockVariations
    } = select(external_wp_blocks_namespaceObject.store);
    const {
      getBlockName,
      getBlockAttributes
    } = select(store);
    const name = blockClientId && getBlockName(blockClientId);
    return {
      activeBlockVariation: getActiveBlockVariation(name, getBlockAttributes(blockClientId)),
      variations: name && getBlockVariations(name, 'transform')
    };
  }, [blockClientId]);
  const selectedValue = activeBlockVariation?.name; // Check if each variation has a unique icon.

  const hasUniqueIcons = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const variationIcons = new Set();

    if (!variations) {
      return false;
    }

    variations.forEach(variation => {
      if (variation.icon) {
        variationIcons.add(variation.icon?.src || variation.icon);
      }
    });
    return variationIcons.size === variations.length;
  }, [variations]);

  const onSelectVariation = variationName => {
    updateBlockAttributes(blockClientId, { ...variations.find(({
        name
      }) => name === variationName).attributes
    });
  };

  const baseClass = 'block-editor-block-variation-transforms'; // Skip rendering if there are no variations

  if (!variations?.length) return null;
  const Component = hasUniqueIcons ? VariationsButtons : VariationsDropdown;
  return (0,external_wp_element_namespaceObject.createElement)(Component, {
    className: baseClass,
    onSelectVariation: onSelectVariation,
    selectedValue: selectedValue,
    variations: variations
  });
}

/* harmony default export */ var block_variation_transforms = (__experimentalBlockVariationTransforms);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/color-palette/with-color-context.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/* harmony default export */ var with_color_context = ((0,external_wp_compose_namespaceObject.createHigherOrderComponent)(WrappedComponent => {
  return props => {
    const colorsFeature = use_setting_useSetting('color.palette');
    const disableCustomColorsFeature = !use_setting_useSetting('color.custom');
    const colors = props.colors === undefined ? colorsFeature : props.colors;
    const disableCustomColors = props.disableCustomColors === undefined ? disableCustomColorsFeature : props.disableCustomColors;
    const hasColorsToChoose = colors && colors.length > 0 || !disableCustomColors;
    return (0,external_wp_element_namespaceObject.createElement)(WrappedComponent, { ...props,
      colors,
      disableCustomColors,
      hasColorsToChoose
    });
  };
}, 'withColorContext'));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/color-palette/index.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/* harmony default export */ var color_palette = (with_color_context(external_wp_components_namespaceObject.ColorPalette));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/color-palette/control.js


/**
 * Internal dependencies
 */

function ColorPaletteControl({
  onChange,
  value,
  ...otherProps
}) {
  return (0,external_wp_element_namespaceObject.createElement)(control, { ...otherProps,
    onColorChange: onChange,
    colorValue: value,
    gradients: [],
    disableCustomGradients: true
  });
}

;// CONCATENATED MODULE: external ["wp","date"]
var external_wp_date_namespaceObject = window["wp"]["date"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/date-format-picker/index.js


/**
 * WordPress dependencies
 */



 // So that we can illustrate the different formats in the dropdown properly,
// show a date that has a day greater than 12 and a month with more than three
// letters. Here we're using 2022-01-25 which is when WordPress 5.9 was
// released.

const EXAMPLE_DATE = new Date(2022, 0, 25);
/**
 * The `DateFormatPicker` component renders controls that let the user choose a
 * _date format_. That is, how they want their dates to be formatted.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/date-format-picker/README.md
 *
 * @param {Object}                          props
 * @param {string|null}                     props.format        The selected date
 *                                                              format. If
 *                                                              `null`,
 *                                                              _Default_ is
 *                                                              selected.
 * @param {string}                          props.defaultFormat The date format that
 *                                                              will be used if the
 *                                                              user selects
 *                                                              'Default'.
 * @param {( format: string|null ) => void} props.onChange      Called when a
 *                                                              selection is
 *                                                              made. If `null`,
 *                                                              _Default_ is
 *                                                              selected.
 */

function DateFormatPicker({
  format,
  defaultFormat,
  onChange
}) {
  return (0,external_wp_element_namespaceObject.createElement)("fieldset", {
    className: "block-editor-date-format-picker"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.VisuallyHidden, {
    as: "legend"
  }, (0,external_wp_i18n_namespaceObject.__)('Date format')), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToggleControl, {
    __nextHasNoMarginBottom: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Default format'),
    help: `${(0,external_wp_i18n_namespaceObject.__)('Example:')}  ${(0,external_wp_date_namespaceObject.dateI18n)(defaultFormat, EXAMPLE_DATE)}`,
    checked: !format,
    onChange: checked => onChange(checked ? null : defaultFormat)
  }), format && (0,external_wp_element_namespaceObject.createElement)(NonDefaultControls, {
    format: format,
    onChange: onChange
  }));
}

function NonDefaultControls({
  format,
  onChange
}) {
  var _suggestedOptions$fin;

  // Suggest a short format, medium format, long format, and a standardised
  // (YYYY-MM-DD) format. The short, medium, and long formats are localised as
  // different languages have different ways of writing these. For example, 'F
  // j, Y' (April 20, 2022) in American English (en_US) is 'j. F Y' (20. April
  // 2022) in German (de). The resultant array is de-duplicated as some
  // languages will use the same format string for short, medium, and long
  // formats.
  const suggestedFormats = [...new Set(['Y-m-d', (0,external_wp_i18n_namespaceObject._x)('n/j/Y', 'short date format'), (0,external_wp_i18n_namespaceObject._x)('n/j/Y g:i A', 'short date format with time'), (0,external_wp_i18n_namespaceObject._x)('M j, Y', 'medium date format'), (0,external_wp_i18n_namespaceObject._x)('M j, Y g:i A', 'medium date format with time'), (0,external_wp_i18n_namespaceObject._x)('F j, Y', 'long date format'), (0,external_wp_i18n_namespaceObject._x)('M j', 'short date format without the year')])];
  const suggestedOptions = suggestedFormats.map((suggestedFormat, index) => ({
    key: `suggested-${index}`,
    name: (0,external_wp_date_namespaceObject.dateI18n)(suggestedFormat, EXAMPLE_DATE),
    format: suggestedFormat
  }));
  const customOption = {
    key: 'custom',
    name: (0,external_wp_i18n_namespaceObject.__)('Custom'),
    className: 'block-editor-date-format-picker__custom-format-select-control__custom-option',
    __experimentalHint: (0,external_wp_i18n_namespaceObject.__)('Enter your own date format')
  };
  const [isCustom, setIsCustom] = (0,external_wp_element_namespaceObject.useState)(() => !!format && !suggestedFormats.includes(format));
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalVStack, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.CustomSelectControl, {
    __nextUnconstrainedWidth: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Choose a format'),
    options: [...suggestedOptions, customOption],
    value: isCustom ? customOption : (_suggestedOptions$fin = suggestedOptions.find(option => option.format === format)) !== null && _suggestedOptions$fin !== void 0 ? _suggestedOptions$fin : customOption,
    onChange: ({
      selectedItem
    }) => {
      if (selectedItem === customOption) {
        setIsCustom(true);
      } else {
        setIsCustom(false);
        onChange(selectedItem.format);
      }
    }
  }), isCustom && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.TextControl, {
    __nextHasNoMarginBottom: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Custom format'),
    hideLabelFromVision: true,
    help: (0,external_wp_element_namespaceObject.createInterpolateElement)((0,external_wp_i18n_namespaceObject.__)('Enter a date or time <Link>format string</Link>.'), {
      Link: (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ExternalLink, {
        href: (0,external_wp_i18n_namespaceObject.__)('https://wordpress.org/documentation/article/customize-date-and-time-format/')
      })
    }),
    value: format,
    onChange: value => onChange(value)
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/colors-gradients/dropdown.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

 // When the `ColorGradientSettingsDropdown` controls are being rendered to a
// `ToolsPanel` they must be wrapped in a `ToolsPanelItem`.

const WithToolsPanelItem = ({
  setting,
  children,
  panelId,
  ...props
}) => {
  const clearValue = () => {
    if (setting.colorValue) {
      setting.onColorChange();
    } else if (setting.gradientValue) {
      setting.onGradientChange();
    }
  };

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    hasValue: () => {
      return !!setting.colorValue || !!setting.gradientValue;
    },
    label: setting.label,
    onDeselect: clearValue,
    isShownByDefault: setting.isShownByDefault !== undefined ? setting.isShownByDefault : true,
    ...props,
    className: "block-editor-tools-panel-color-gradient-settings__item",
    panelId: panelId // Pass resetAllFilter if supplied due to rendering via SlotFill
    // into parent ToolsPanel.
    ,
    resetAllFilter: setting.resetAllFilter
  }, children);
};

const dropdown_LabeledColorIndicator = ({
  colorValue,
  label
}) => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHStack, {
  justify: "flex-start"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ColorIndicator, {
  className: "block-editor-panel-color-gradient-settings__color-indicator",
  colorValue: colorValue
}), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, {
  className: "block-editor-panel-color-gradient-settings__color-name",
  title: label
}, label)); // Renders a color dropdown's toggle as an `Item` if it is within an `ItemGroup`
// or as a `Button` if it isn't e.g. the controls are being rendered in
// a `ToolsPanel`.


const renderToggle = settings => ({
  onToggle,
  isOpen
}) => {
  const {
    colorValue,
    label
  } = settings;
  const toggleProps = {
    onClick: onToggle,
    className: classnames_default()('block-editor-panel-color-gradient-settings__dropdown', {
      'is-open': isOpen
    }),
    'aria-expanded': isOpen
  };
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, { ...toggleProps
  }, (0,external_wp_element_namespaceObject.createElement)(dropdown_LabeledColorIndicator, {
    colorValue: colorValue,
    label: label
  }));
}; // Renders a collection of color controls as dropdowns. Depending upon the
// context in which these dropdowns are being rendered, they may be wrapped
// in an `ItemGroup` with each dropdown's toggle as an `Item`, or alternatively,
// the may be individually wrapped in a `ToolsPanelItem` with the toggle as
// a regular `Button`.
//
// For more context see: https://github.com/WordPress/gutenberg/pull/40084


function ColorGradientSettingsDropdown({
  colors,
  disableCustomColors,
  disableCustomGradients,
  enableAlpha,
  gradients,
  settings,
  __experimentalIsRenderedInSidebar,
  ...props
}) {
  let popoverProps;

  if (__experimentalIsRenderedInSidebar) {
    popoverProps = {
      placement: 'left-start',
      offset: 36,
      shift: true
    };
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, settings.map((setting, index) => {
    var _setting$gradientValu;

    const controlProps = {
      clearable: false,
      colorValue: setting.colorValue,
      colors,
      disableCustomColors,
      disableCustomGradients,
      enableAlpha,
      gradientValue: setting.gradientValue,
      gradients,
      label: setting.label,
      onColorChange: setting.onColorChange,
      onGradientChange: setting.onGradientChange,
      showTitle: false,
      __experimentalIsRenderedInSidebar,
      ...setting
    };
    const toggleSettings = {
      colorValue: (_setting$gradientValu = setting.gradientValue) !== null && _setting$gradientValu !== void 0 ? _setting$gradientValu : setting.colorValue,
      label: setting.label
    };
    return setting && // If not in an `ItemGroup` wrap the dropdown in a
    // `ToolsPanelItem`
    (0,external_wp_element_namespaceObject.createElement)(WithToolsPanelItem, {
      key: index,
      setting: setting,
      ...props
    }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Dropdown, {
      popoverProps: popoverProps,
      className: "block-editor-tools-panel-color-gradient-settings__dropdown",
      renderToggle: renderToggle(toggleSettings),
      renderContent: () => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalDropdownContentWrapper, {
        paddingSize: "none"
      }, (0,external_wp_element_namespaceObject.createElement)("div", {
        className: "block-editor-panel-color-gradient-settings__dropdown-content"
      }, (0,external_wp_element_namespaceObject.createElement)(control, { ...controlProps
      })))
    }));
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/colors-gradients/panel-color-gradient-settings.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



const panel_color_gradient_settings_colorsAndGradientKeys = ['colors', 'disableCustomColors', 'gradients', 'disableCustomGradients'];
const PanelColorGradientSettingsInner = ({
  className,
  colors,
  gradients,
  disableCustomColors,
  disableCustomGradients,
  children,
  settings,
  title,
  showTitle = true,
  __experimentalIsRenderedInSidebar,
  enableAlpha
}) => {
  const panelId = (0,external_wp_compose_namespaceObject.useInstanceId)(PanelColorGradientSettingsInner);
  const {
    batch
  } = (0,external_wp_data_namespaceObject.useRegistry)();

  if ((!colors || colors.length === 0) && (!gradients || gradients.length === 0) && disableCustomColors && disableCustomGradients && settings?.every(setting => (!setting.colors || setting.colors.length === 0) && (!setting.gradients || setting.gradients.length === 0) && (setting.disableCustomColors === undefined || setting.disableCustomColors) && (setting.disableCustomGradients === undefined || setting.disableCustomGradients))) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanel, {
    className: classnames_default()('block-editor-panel-color-gradient-settings', className),
    label: showTitle ? title : undefined,
    resetAll: () => {
      batch(() => {
        settings.forEach(({
          colorValue,
          gradientValue,
          onColorChange,
          onGradientChange
        }) => {
          if (colorValue) {
            onColorChange();
          } else if (gradientValue) {
            onGradientChange();
          }
        });
      });
    },
    panelId: panelId,
    __experimentalFirstVisibleItemClass: "first",
    __experimentalLastVisibleItemClass: "last"
  }, (0,external_wp_element_namespaceObject.createElement)(ColorGradientSettingsDropdown, {
    settings: settings,
    panelId: panelId,
    colors,
    gradients,
    disableCustomColors,
    disableCustomGradients,
    __experimentalIsRenderedInSidebar,
    enableAlpha
  }), !!children && (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalSpacer, {
    marginY: 4
  }), " ", children));
};

const PanelColorGradientSettingsSelect = props => {
  const colorGradientSettings = useMultipleOriginColorsAndGradients();
  return (0,external_wp_element_namespaceObject.createElement)(PanelColorGradientSettingsInner, { ...colorGradientSettings,
    ...props
  });
};

const PanelColorGradientSettings = props => {
  if (panel_color_gradient_settings_colorsAndGradientKeys.every(key => props.hasOwnProperty(key))) {
    return (0,external_wp_element_namespaceObject.createElement)(PanelColorGradientSettingsInner, { ...props
    });
  }

  return (0,external_wp_element_namespaceObject.createElement)(PanelColorGradientSettingsSelect, { ...props
  });
};

/* harmony default export */ var panel_color_gradient_settings = (PanelColorGradientSettings);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/image-editor/use-save-image.js
/**
 * WordPress dependencies
 */
// Disable Reason: Needs to be refactored.
// eslint-disable-next-line no-restricted-imports






function useSaveImage({
  crop,
  rotation,
  height,
  width,
  aspect,
  url,
  id,
  onSaveImage,
  onFinishEditing
}) {
  const {
    createErrorNotice
  } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_notices_namespaceObject.store);
  const [isInProgress, setIsInProgress] = (0,external_wp_element_namespaceObject.useState)(false);
  const cancel = (0,external_wp_element_namespaceObject.useCallback)(() => {
    setIsInProgress(false);
    onFinishEditing();
  }, [setIsInProgress, onFinishEditing]);
  const apply = (0,external_wp_element_namespaceObject.useCallback)(() => {
    setIsInProgress(true);
    const modifiers = [];

    if (rotation > 0) {
      modifiers.push({
        type: 'rotate',
        args: {
          angle: rotation
        }
      });
    } // The crop script may return some very small, sub-pixel values when the image was not cropped.
    // Crop only when the new size has changed by more than 0.1%.


    if (crop.width < 99.9 || crop.height < 99.9) {
      modifiers.push({
        type: 'crop',
        args: {
          left: crop.x,
          top: crop.y,
          width: crop.width,
          height: crop.height
        }
      });
    }

    external_wp_apiFetch_default()({
      path: `/wp/v2/media/${id}/edit`,
      method: 'POST',
      data: {
        src: url,
        modifiers
      }
    }).then(response => {
      onSaveImage({
        id: response.id,
        url: response.source_url
      });
    }).catch(error => {
      createErrorNotice((0,external_wp_i18n_namespaceObject.sprintf)(
      /* translators: 1. Error message */
      (0,external_wp_i18n_namespaceObject.__)('Could not edit image. %s'), (0,external_wp_dom_namespaceObject.__unstableStripHTML)(error.message)), {
        id: 'image-editing-error',
        type: 'snackbar'
      });
    }).finally(() => {
      setIsInProgress(false);
      onFinishEditing();
    });
  }, [setIsInProgress, crop, rotation, height, width, aspect, url, onSaveImage, createErrorNotice, setIsInProgress, onFinishEditing]);
  return (0,external_wp_element_namespaceObject.useMemo)(() => ({
    isInProgress,
    apply,
    cancel
  }), [isInProgress, apply, cancel]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/image-editor/use-transform-image.js
/**
 * WordPress dependencies
 */


function useTransformImage({
  url,
  naturalWidth,
  naturalHeight
}) {
  const [editedUrl, setEditedUrl] = (0,external_wp_element_namespaceObject.useState)();
  const [crop, setCrop] = (0,external_wp_element_namespaceObject.useState)();
  const [position, setPosition] = (0,external_wp_element_namespaceObject.useState)({
    x: 0,
    y: 0
  });
  const [zoom, setZoom] = (0,external_wp_element_namespaceObject.useState)(100);
  const [rotation, setRotation] = (0,external_wp_element_namespaceObject.useState)(0);
  const defaultAspect = naturalWidth / naturalHeight;
  const [aspect, setAspect] = (0,external_wp_element_namespaceObject.useState)(defaultAspect);
  const rotateClockwise = (0,external_wp_element_namespaceObject.useCallback)(() => {
    const angle = (rotation + 90) % 360;
    let naturalAspectRatio = defaultAspect;

    if (rotation % 180 === 90) {
      naturalAspectRatio = 1 / defaultAspect;
    }

    if (angle === 0) {
      setEditedUrl();
      setRotation(angle);
      setAspect(defaultAspect);
      setPosition({
        x: -(position.y * naturalAspectRatio),
        y: position.x * naturalAspectRatio
      });
      return;
    }

    function editImage(event) {
      const canvas = document.createElement('canvas');
      let translateX = 0;
      let translateY = 0;

      if (angle % 180) {
        canvas.width = event.target.height;
        canvas.height = event.target.width;
      } else {
        canvas.width = event.target.width;
        canvas.height = event.target.height;
      }

      if (angle === 90 || angle === 180) {
        translateX = canvas.width;
      }

      if (angle === 270 || angle === 180) {
        translateY = canvas.height;
      }

      const context = canvas.getContext('2d');
      context.translate(translateX, translateY);
      context.rotate(angle * Math.PI / 180);
      context.drawImage(event.target, 0, 0);
      canvas.toBlob(blob => {
        setEditedUrl(URL.createObjectURL(blob));
        setRotation(angle);
        setAspect(canvas.width / canvas.height);
        setPosition({
          x: -(position.y * naturalAspectRatio),
          y: position.x * naturalAspectRatio
        });
      });
    }

    const el = new window.Image();
    el.src = url;
    el.onload = editImage;
    const imgCrossOrigin = (0,external_wp_hooks_namespaceObject.applyFilters)('media.crossOrigin', undefined, url);

    if (typeof imgCrossOrigin === 'string') {
      el.crossOrigin = imgCrossOrigin;
    }
  }, [rotation, defaultAspect]);
  return (0,external_wp_element_namespaceObject.useMemo)(() => ({
    editedUrl,
    setEditedUrl,
    crop,
    setCrop,
    position,
    setPosition,
    zoom,
    setZoom,
    rotation,
    setRotation,
    rotateClockwise,
    aspect,
    setAspect,
    defaultAspect
  }), [editedUrl, crop, position, zoom, rotation, rotateClockwise, aspect, defaultAspect]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/image-editor/context.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



const ImageEditingContext = (0,external_wp_element_namespaceObject.createContext)({});
const useImageEditingContext = () => (0,external_wp_element_namespaceObject.useContext)(ImageEditingContext);
function ImageEditingProvider({
  id,
  url,
  naturalWidth,
  naturalHeight,
  onFinishEditing,
  onSaveImage,
  children
}) {
  const transformImage = useTransformImage({
    url,
    naturalWidth,
    naturalHeight
  });
  const saveImage = useSaveImage({
    id,
    url,
    onSaveImage,
    onFinishEditing,
    ...transformImage
  });
  const providerValue = (0,external_wp_element_namespaceObject.useMemo)(() => ({ ...transformImage,
    ...saveImage
  }), [transformImage, saveImage]);
  return (0,external_wp_element_namespaceObject.createElement)(ImageEditingContext.Provider, {
    value: providerValue
  }, children);
}

;// CONCATENATED MODULE: ./node_modules/react-easy-crop/node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var tslib_es6_extendStatics = function(d, b) {
    tslib_es6_extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return tslib_es6_extendStatics(d, b);
};

function tslib_es6_extends(d, b) {
    tslib_es6_extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var tslib_es6_assign = function() {
    tslib_es6_assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return tslib_es6_assign.apply(this, arguments);
}

function tslib_es6_rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function tslib_es6_decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function tslib_es6_param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function tslib_es6_metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function tslib_es6_awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function tslib_es6_generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var tslib_es6_createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function tslib_es6_exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) tslib_es6_createBinding(o, m, p);
}

function tslib_es6_values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function tslib_es6_read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function tslib_es6_spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(tslib_es6_read(arguments[i]));
    return ar;
}

function tslib_es6_spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function tslib_es6_await(v) {
    return this instanceof tslib_es6_await ? (this.v = v, this) : new tslib_es6_await(v);
}

function tslib_es6_asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof tslib_es6_await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function tslib_es6_asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: tslib_es6_await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function tslib_es6_asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof tslib_es6_values === "function" ? tslib_es6_values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function tslib_es6_makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var tslib_es6_setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function tslib_es6_importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) tslib_es6_createBinding(result, mod, k);
    tslib_es6_setModuleDefault(result, mod);
    return result;
}

function tslib_es6_importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function tslib_es6_classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function tslib_es6_classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}

// EXTERNAL MODULE: ./node_modules/normalize-wheel/index.js
var normalize_wheel = __webpack_require__(7970);
var normalize_wheel_default = /*#__PURE__*/__webpack_require__.n(normalize_wheel);
;// CONCATENATED MODULE: ./node_modules/react-easy-crop/index.module.js




/**
 * Compute the dimension of the crop area based on media size,
 * aspect ratio and optionally rotation
 */
function getCropSize(mediaWidth, mediaHeight, containerWidth, containerHeight, aspect, rotation) {
  if (rotation === void 0) {
    rotation = 0;
  }
  var _a = rotateSize(mediaWidth, mediaHeight, rotation),
    width = _a.width,
    height = _a.height;
  var fittingWidth = Math.min(width, containerWidth);
  var fittingHeight = Math.min(height, containerHeight);
  if (fittingWidth > fittingHeight * aspect) {
    return {
      width: fittingHeight * aspect,
      height: fittingHeight
    };
  }
  return {
    width: fittingWidth,
    height: fittingWidth / aspect
  };
}
/**
 * Compute media zoom.
 * We fit the media into the container with "max-width: 100%; max-height: 100%;"
 */
function getMediaZoom(mediaSize) {
  // Take the axis with more pixels to improve accuracy
  return mediaSize.width > mediaSize.height ? mediaSize.width / mediaSize.naturalWidth : mediaSize.height / mediaSize.naturalHeight;
}
/**
 * Ensure a new media position stays in the crop area.
 */
function restrictPosition(position, mediaSize, cropSize, zoom, rotation) {
  if (rotation === void 0) {
    rotation = 0;
  }
  var _a = rotateSize(mediaSize.width, mediaSize.height, rotation),
    width = _a.width,
    height = _a.height;
  return {
    x: restrictPositionCoord(position.x, width, cropSize.width, zoom),
    y: restrictPositionCoord(position.y, height, cropSize.height, zoom)
  };
}
function restrictPositionCoord(position, mediaSize, cropSize, zoom) {
  var maxPosition = mediaSize * zoom / 2 - cropSize / 2;
  return index_module_clamp(position, -maxPosition, maxPosition);
}
function getDistanceBetweenPoints(pointA, pointB) {
  return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2));
}
function getRotationBetweenPoints(pointA, pointB) {
  return Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI;
}
/**
 * Compute the output cropped area of the media in percentages and pixels.
 * x/y are the top-left coordinates on the src media
 */
function computeCroppedArea(crop, mediaSize, cropSize, aspect, zoom, rotation, restrictPosition) {
  if (rotation === void 0) {
    rotation = 0;
  }
  if (restrictPosition === void 0) {
    restrictPosition = true;
  }
  // if the media is rotated by the user, we cannot limit the position anymore
  // as it might need to be negative.
  var limitAreaFn = restrictPosition ? limitArea : noOp;
  var mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation);
  var mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation);
  // calculate the crop area in percentages
  // in the rotated space
  var croppedAreaPercentages = {
    x: limitAreaFn(100, ((mediaBBoxSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / mediaBBoxSize.width * 100),
    y: limitAreaFn(100, ((mediaBBoxSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) / mediaBBoxSize.height * 100),
    width: limitAreaFn(100, cropSize.width / mediaBBoxSize.width * 100 / zoom),
    height: limitAreaFn(100, cropSize.height / mediaBBoxSize.height * 100 / zoom)
  };
  // we compute the pixels size naively
  var widthInPixels = Math.round(limitAreaFn(mediaNaturalBBoxSize.width, croppedAreaPercentages.width * mediaNaturalBBoxSize.width / 100));
  var heightInPixels = Math.round(limitAreaFn(mediaNaturalBBoxSize.height, croppedAreaPercentages.height * mediaNaturalBBoxSize.height / 100));
  var isImgWiderThanHigh = mediaNaturalBBoxSize.width >= mediaNaturalBBoxSize.height * aspect;
  // then we ensure the width and height exactly match the aspect (to avoid rounding approximations)
  // if the media is wider than high, when zoom is 0, the crop height will be equals to image height
  // thus we want to compute the width from the height and aspect for accuracy.
  // Otherwise, we compute the height from width and aspect.
  var sizePixels = isImgWiderThanHigh ? {
    width: Math.round(heightInPixels * aspect),
    height: heightInPixels
  } : {
    width: widthInPixels,
    height: Math.round(widthInPixels / aspect)
  };
  var croppedAreaPixels = tslib_es6_assign(tslib_es6_assign({}, sizePixels), {
    x: Math.round(limitAreaFn(mediaNaturalBBoxSize.width - sizePixels.width, croppedAreaPercentages.x * mediaNaturalBBoxSize.width / 100)),
    y: Math.round(limitAreaFn(mediaNaturalBBoxSize.height - sizePixels.height, croppedAreaPercentages.y * mediaNaturalBBoxSize.height / 100))
  });
  return {
    croppedAreaPercentages: croppedAreaPercentages,
    croppedAreaPixels: croppedAreaPixels
  };
}
/**
 * Ensure the returned value is between 0 and max
 */
function limitArea(max, value) {
  return Math.min(max, Math.max(0, value));
}
function noOp(_max, value) {
  return value;
}
/**
 * Compute crop and zoom from the croppedAreaPercentages.
 */
function getInitialCropFromCroppedAreaPercentages(croppedAreaPercentages, mediaSize, rotation, cropSize, minZoom, maxZoom) {
  var mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation);
  // This is the inverse process of computeCroppedArea
  var zoom = index_module_clamp(cropSize.width / mediaBBoxSize.width * (100 / croppedAreaPercentages.width), minZoom, maxZoom);
  var crop = {
    x: zoom * mediaBBoxSize.width / 2 - cropSize.width / 2 - mediaBBoxSize.width * zoom * (croppedAreaPercentages.x / 100),
    y: zoom * mediaBBoxSize.height / 2 - cropSize.height / 2 - mediaBBoxSize.height * zoom * (croppedAreaPercentages.y / 100)
  };
  return {
    crop: crop,
    zoom: zoom
  };
}
/**
 * Compute zoom from the croppedAreaPixels
 */
function getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize) {
  var mediaZoom = getMediaZoom(mediaSize);
  return cropSize.height > cropSize.width ? cropSize.height / (croppedAreaPixels.height * mediaZoom) : cropSize.width / (croppedAreaPixels.width * mediaZoom);
}
/**
 * Compute crop and zoom from the croppedAreaPixels
 */
function getInitialCropFromCroppedAreaPixels(croppedAreaPixels, mediaSize, rotation, cropSize, minZoom, maxZoom) {
  if (rotation === void 0) {
    rotation = 0;
  }
  var mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation);
  var zoom = index_module_clamp(getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize), minZoom, maxZoom);
  var cropZoom = cropSize.height > cropSize.width ? cropSize.height / croppedAreaPixels.height : cropSize.width / croppedAreaPixels.width;
  var crop = {
    x: ((mediaNaturalBBoxSize.width - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,
    y: ((mediaNaturalBBoxSize.height - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) * cropZoom
  };
  return {
    crop: crop,
    zoom: zoom
  };
}
/**
 * Return the point that is the center of point a and b
 */
function getCenter(a, b) {
  return {
    x: (b.x + a.x) / 2,
    y: (b.y + a.y) / 2
  };
}
function getRadianAngle(degreeValue) {
  return degreeValue * Math.PI / 180;
}
/**
 * Returns the new bounding area of a rotated rectangle.
 */
function rotateSize(width, height, rotation) {
  var rotRad = getRadianAngle(rotation);
  return {
    width: Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),
    height: Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height)
  };
}
/**
 * Clamp value between min and max
 */
function index_module_clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
/**
 * Combine multiple class names into a single string.
 */
function classNames() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return args.filter(function (value) {
    if (typeof value === 'string' && value.length > 0) {
      return true;
    }
    return false;
  }).join(' ').trim();
}

var css_248z = ".reactEasyCrop_Container {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  overflow: hidden;\n  user-select: none;\n  touch-action: none;\n  cursor: move;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.reactEasyCrop_Image,\n.reactEasyCrop_Video {\n  will-change: transform; /* this improves performances and prevent painting issues on iOS Chrome */\n}\n\n.reactEasyCrop_Contain {\n  max-width: 100%;\n  max-height: 100%;\n  margin: auto;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n.reactEasyCrop_Cover_Horizontal {\n  width: 100%;\n  height: auto;\n}\n.reactEasyCrop_Cover_Vertical {\n  width: auto;\n  height: 100%;\n}\n\n.reactEasyCrop_CropArea {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  border: 1px solid rgba(255, 255, 255, 0.5);\n  box-sizing: border-box;\n  box-shadow: 0 0 0 9999em;\n  color: rgba(0, 0, 0, 0.5);\n  overflow: hidden;\n}\n\n.reactEasyCrop_CropAreaRound {\n  border-radius: 50%;\n}\n\n.reactEasyCrop_CropAreaGrid::before {\n  content: ' ';\n  box-sizing: border-box;\n  position: absolute;\n  border: 1px solid rgba(255, 255, 255, 0.5);\n  top: 0;\n  bottom: 0;\n  left: 33.33%;\n  right: 33.33%;\n  border-top: 0;\n  border-bottom: 0;\n}\n\n.reactEasyCrop_CropAreaGrid::after {\n  content: ' ';\n  box-sizing: border-box;\n  position: absolute;\n  border: 1px solid rgba(255, 255, 255, 0.5);\n  top: 33.33%;\n  bottom: 33.33%;\n  left: 0;\n  right: 0;\n  border-left: 0;\n  border-right: 0;\n}\n";

var MIN_ZOOM = 1;
var MAX_ZOOM = 3;
var Cropper = /** @class */function (_super) {
  tslib_es6_extends(Cropper, _super);
  function Cropper() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.imageRef = external_React_default().createRef();
    _this.videoRef = external_React_default().createRef();
    _this.containerRef = null;
    _this.styleRef = null;
    _this.containerRect = null;
    _this.mediaSize = {
      width: 0,
      height: 0,
      naturalWidth: 0,
      naturalHeight: 0
    };
    _this.dragStartPosition = {
      x: 0,
      y: 0
    };
    _this.dragStartCrop = {
      x: 0,
      y: 0
    };
    _this.gestureZoomStart = 0;
    _this.gestureRotationStart = 0;
    _this.isTouching = false;
    _this.lastPinchDistance = 0;
    _this.lastPinchRotation = 0;
    _this.rafDragTimeout = null;
    _this.rafPinchTimeout = null;
    _this.wheelTimer = null;
    _this.currentDoc = typeof document !== 'undefined' ? document : null;
    _this.currentWindow = typeof window !== 'undefined' ? window : null;
    _this.resizeObserver = null;
    _this.state = {
      cropSize: null,
      hasWheelJustStarted: false
    };
    _this.initResizeObserver = function () {
      if (typeof window.ResizeObserver === 'undefined' || !_this.containerRef) {
        return;
      }
      var isFirstResize = true;
      _this.resizeObserver = new window.ResizeObserver(function (entries) {
        if (isFirstResize) {
          isFirstResize = false; // observe() is called on mount, we don't want to trigger a recompute on mount
          return;
        }
        _this.computeSizes();
      });
      _this.resizeObserver.observe(_this.containerRef);
    };
    // this is to prevent Safari on iOS >= 10 to zoom the page
    _this.preventZoomSafari = function (e) {
      return e.preventDefault();
    };
    _this.cleanEvents = function () {
      if (!_this.currentDoc) return;
      _this.currentDoc.removeEventListener('mousemove', _this.onMouseMove);
      _this.currentDoc.removeEventListener('mouseup', _this.onDragStopped);
      _this.currentDoc.removeEventListener('touchmove', _this.onTouchMove);
      _this.currentDoc.removeEventListener('touchend', _this.onDragStopped);
      _this.currentDoc.removeEventListener('gesturemove', _this.onGestureMove);
      _this.currentDoc.removeEventListener('gestureend', _this.onGestureEnd);
    };
    _this.clearScrollEvent = function () {
      if (_this.containerRef) _this.containerRef.removeEventListener('wheel', _this.onWheel);
      if (_this.wheelTimer) {
        clearTimeout(_this.wheelTimer);
      }
    };
    _this.onMediaLoad = function () {
      var cropSize = _this.computeSizes();
      if (cropSize) {
        _this.emitCropData();
        _this.setInitialCrop(cropSize);
      }
      if (_this.props.onMediaLoaded) {
        _this.props.onMediaLoaded(_this.mediaSize);
      }
    };
    _this.setInitialCrop = function (cropSize) {
      if (_this.props.initialCroppedAreaPercentages) {
        var _a = getInitialCropFromCroppedAreaPercentages(_this.props.initialCroppedAreaPercentages, _this.mediaSize, _this.props.rotation, cropSize, _this.props.minZoom, _this.props.maxZoom),
          crop = _a.crop,
          zoom = _a.zoom;
        _this.props.onCropChange(crop);
        _this.props.onZoomChange && _this.props.onZoomChange(zoom);
      } else if (_this.props.initialCroppedAreaPixels) {
        var _b = getInitialCropFromCroppedAreaPixels(_this.props.initialCroppedAreaPixels, _this.mediaSize, _this.props.rotation, cropSize, _this.props.minZoom, _this.props.maxZoom),
          crop = _b.crop,
          zoom = _b.zoom;
        _this.props.onCropChange(crop);
        _this.props.onZoomChange && _this.props.onZoomChange(zoom);
      }
    };
    _this.computeSizes = function () {
      var _a, _b, _c, _d, _e, _f;
      var mediaRef = _this.imageRef.current || _this.videoRef.current;
      if (mediaRef && _this.containerRef) {
        _this.containerRect = _this.containerRef.getBoundingClientRect();
        var containerAspect = _this.containerRect.width / _this.containerRect.height;
        var naturalWidth = ((_a = _this.imageRef.current) === null || _a === void 0 ? void 0 : _a.naturalWidth) || ((_b = _this.videoRef.current) === null || _b === void 0 ? void 0 : _b.videoWidth) || 0;
        var naturalHeight = ((_c = _this.imageRef.current) === null || _c === void 0 ? void 0 : _c.naturalHeight) || ((_d = _this.videoRef.current) === null || _d === void 0 ? void 0 : _d.videoHeight) || 0;
        var isMediaScaledDown = mediaRef.offsetWidth < naturalWidth || mediaRef.offsetHeight < naturalHeight;
        var mediaAspect = naturalWidth / naturalHeight;
        // We do not rely on the offsetWidth/offsetHeight if the media is scaled down
        // as the values they report are rounded. That will result in precision losses
        // when calculating zoom. We use the fact that the media is positionned relative
        // to the container. That allows us to use the container's dimensions
        // and natural aspect ratio of the media to calculate accurate media size.
        // However, for this to work, the container should not be rotated
        var renderedMediaSize = void 0;
        if (isMediaScaledDown) {
          switch (_this.props.objectFit) {
            default:
            case 'contain':
              renderedMediaSize = containerAspect > mediaAspect ? {
                width: _this.containerRect.height * mediaAspect,
                height: _this.containerRect.height
              } : {
                width: _this.containerRect.width,
                height: _this.containerRect.width / mediaAspect
              };
              break;
            case 'horizontal-cover':
              renderedMediaSize = {
                width: _this.containerRect.width,
                height: _this.containerRect.width / mediaAspect
              };
              break;
            case 'vertical-cover':
              renderedMediaSize = {
                width: _this.containerRect.height * mediaAspect,
                height: _this.containerRect.height
              };
              break;
            case 'auto-cover':
              renderedMediaSize = naturalWidth > naturalHeight ? {
                width: _this.containerRect.width,
                height: _this.containerRect.width / mediaAspect
              } : {
                width: _this.containerRect.height * mediaAspect,
                height: _this.containerRect.height
              };
              break;
          }
        } else {
          renderedMediaSize = {
            width: mediaRef.offsetWidth,
            height: mediaRef.offsetHeight
          };
        }
        _this.mediaSize = tslib_es6_assign(tslib_es6_assign({}, renderedMediaSize), {
          naturalWidth: naturalWidth,
          naturalHeight: naturalHeight
        });
        // set media size in the parent
        if (_this.props.setMediaSize) {
          _this.props.setMediaSize(_this.mediaSize);
        }
        var cropSize = _this.props.cropSize ? _this.props.cropSize : getCropSize(_this.mediaSize.width, _this.mediaSize.height, _this.containerRect.width, _this.containerRect.height, _this.props.aspect, _this.props.rotation);
        if (((_e = _this.state.cropSize) === null || _e === void 0 ? void 0 : _e.height) !== cropSize.height || ((_f = _this.state.cropSize) === null || _f === void 0 ? void 0 : _f.width) !== cropSize.width) {
          _this.props.onCropSizeChange && _this.props.onCropSizeChange(cropSize);
        }
        _this.setState({
          cropSize: cropSize
        }, _this.recomputeCropPosition);
        // pass crop size to parent
        if (_this.props.setCropSize) {
          _this.props.setCropSize(cropSize);
        }
        return cropSize;
      }
    };
    _this.onMouseDown = function (e) {
      if (!_this.currentDoc) return;
      e.preventDefault();
      _this.currentDoc.addEventListener('mousemove', _this.onMouseMove);
      _this.currentDoc.addEventListener('mouseup', _this.onDragStopped);
      _this.onDragStart(Cropper.getMousePoint(e));
    };
    _this.onMouseMove = function (e) {
      return _this.onDrag(Cropper.getMousePoint(e));
    };
    _this.onTouchStart = function (e) {
      if (!_this.currentDoc) return;
      _this.isTouching = true;
      if (_this.props.onTouchRequest && !_this.props.onTouchRequest(e)) {
        return;
      }
      _this.currentDoc.addEventListener('touchmove', _this.onTouchMove, {
        passive: false
      }); // iOS 11 now defaults to passive: true
      _this.currentDoc.addEventListener('touchend', _this.onDragStopped);
      if (e.touches.length === 2) {
        _this.onPinchStart(e);
      } else if (e.touches.length === 1) {
        _this.onDragStart(Cropper.getTouchPoint(e.touches[0]));
      }
    };
    _this.onTouchMove = function (e) {
      // Prevent whole page from scrolling on iOS.
      e.preventDefault();
      if (e.touches.length === 2) {
        _this.onPinchMove(e);
      } else if (e.touches.length === 1) {
        _this.onDrag(Cropper.getTouchPoint(e.touches[0]));
      }
    };
    _this.onGestureStart = function (e) {
      if (!_this.currentDoc) return;
      e.preventDefault();
      _this.currentDoc.addEventListener('gesturechange', _this.onGestureMove);
      _this.currentDoc.addEventListener('gestureend', _this.onGestureEnd);
      _this.gestureZoomStart = _this.props.zoom;
      _this.gestureRotationStart = _this.props.rotation;
    };
    _this.onGestureMove = function (e) {
      e.preventDefault();
      if (_this.isTouching) {
        // this is to avoid conflict between gesture and touch events
        return;
      }
      var point = Cropper.getMousePoint(e);
      var newZoom = _this.gestureZoomStart - 1 + e.scale;
      _this.setNewZoom(newZoom, point, {
        shouldUpdatePosition: true
      });
      if (_this.props.onRotationChange) {
        var newRotation = _this.gestureRotationStart + e.rotation;
        _this.props.onRotationChange(newRotation);
      }
    };
    _this.onGestureEnd = function (e) {
      _this.cleanEvents();
    };
    _this.onDragStart = function (_a) {
      var _b, _c;
      var x = _a.x,
        y = _a.y;
      _this.dragStartPosition = {
        x: x,
        y: y
      };
      _this.dragStartCrop = tslib_es6_assign({}, _this.props.crop);
      (_c = (_b = _this.props).onInteractionStart) === null || _c === void 0 ? void 0 : _c.call(_b);
    };
    _this.onDrag = function (_a) {
      var x = _a.x,
        y = _a.y;
      if (!_this.currentWindow) return;
      if (_this.rafDragTimeout) _this.currentWindow.cancelAnimationFrame(_this.rafDragTimeout);
      _this.rafDragTimeout = _this.currentWindow.requestAnimationFrame(function () {
        if (!_this.state.cropSize) return;
        if (x === undefined || y === undefined) return;
        var offsetX = x - _this.dragStartPosition.x;
        var offsetY = y - _this.dragStartPosition.y;
        var requestedPosition = {
          x: _this.dragStartCrop.x + offsetX,
          y: _this.dragStartCrop.y + offsetY
        };
        var newPosition = _this.props.restrictPosition ? restrictPosition(requestedPosition, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : requestedPosition;
        _this.props.onCropChange(newPosition);
      });
    };
    _this.onDragStopped = function () {
      var _a, _b;
      _this.isTouching = false;
      _this.cleanEvents();
      _this.emitCropData();
      (_b = (_a = _this.props).onInteractionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    _this.onWheel = function (e) {
      if (!_this.currentWindow) return;
      if (_this.props.onWheelRequest && !_this.props.onWheelRequest(e)) {
        return;
      }
      e.preventDefault();
      var point = Cropper.getMousePoint(e);
      var pixelY = normalize_wheel_default()(e).pixelY;
      var newZoom = _this.props.zoom - pixelY * _this.props.zoomSpeed / 200;
      _this.setNewZoom(newZoom, point, {
        shouldUpdatePosition: true
      });
      if (!_this.state.hasWheelJustStarted) {
        _this.setState({
          hasWheelJustStarted: true
        }, function () {
          var _a, _b;
          return (_b = (_a = _this.props).onInteractionStart) === null || _b === void 0 ? void 0 : _b.call(_a);
        });
      }
      if (_this.wheelTimer) {
        clearTimeout(_this.wheelTimer);
      }
      _this.wheelTimer = _this.currentWindow.setTimeout(function () {
        return _this.setState({
          hasWheelJustStarted: false
        }, function () {
          var _a, _b;
          return (_b = (_a = _this.props).onInteractionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);
        });
      }, 250);
    };
    _this.getPointOnContainer = function (_a) {
      var x = _a.x,
        y = _a.y;
      if (!_this.containerRect) {
        throw new Error('The Cropper is not mounted');
      }
      return {
        x: _this.containerRect.width / 2 - (x - _this.containerRect.left),
        y: _this.containerRect.height / 2 - (y - _this.containerRect.top)
      };
    };
    _this.getPointOnMedia = function (_a) {
      var x = _a.x,
        y = _a.y;
      var _b = _this.props,
        crop = _b.crop,
        zoom = _b.zoom;
      return {
        x: (x + crop.x) / zoom,
        y: (y + crop.y) / zoom
      };
    };
    _this.setNewZoom = function (zoom, point, _a) {
      var _b = _a === void 0 ? {} : _a,
        _c = _b.shouldUpdatePosition,
        shouldUpdatePosition = _c === void 0 ? true : _c;
      if (!_this.state.cropSize || !_this.props.onZoomChange) return;
      var newZoom = index_module_clamp(zoom, _this.props.minZoom, _this.props.maxZoom);
      if (shouldUpdatePosition) {
        var zoomPoint = _this.getPointOnContainer(point);
        var zoomTarget = _this.getPointOnMedia(zoomPoint);
        var requestedPosition = {
          x: zoomTarget.x * newZoom - zoomPoint.x,
          y: zoomTarget.y * newZoom - zoomPoint.y
        };
        var newPosition = _this.props.restrictPosition ? restrictPosition(requestedPosition, _this.mediaSize, _this.state.cropSize, newZoom, _this.props.rotation) : requestedPosition;
        _this.props.onCropChange(newPosition);
      }
      _this.props.onZoomChange(newZoom);
    };
    _this.getCropData = function () {
      if (!_this.state.cropSize) {
        return null;
      }
      // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ValentinH/react-easy-crop/issues/6)
      var restrictedPosition = _this.props.restrictPosition ? restrictPosition(_this.props.crop, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;
      return computeCroppedArea(restrictedPosition, _this.mediaSize, _this.state.cropSize, _this.getAspect(), _this.props.zoom, _this.props.rotation, _this.props.restrictPosition);
    };
    _this.emitCropData = function () {
      var cropData = _this.getCropData();
      if (!cropData) return;
      var croppedAreaPercentages = cropData.croppedAreaPercentages,
        croppedAreaPixels = cropData.croppedAreaPixels;
      if (_this.props.onCropComplete) {
        _this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels);
      }
      if (_this.props.onCropAreaChange) {
        _this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels);
      }
    };
    _this.emitCropAreaChange = function () {
      var cropData = _this.getCropData();
      if (!cropData) return;
      var croppedAreaPercentages = cropData.croppedAreaPercentages,
        croppedAreaPixels = cropData.croppedAreaPixels;
      if (_this.props.onCropAreaChange) {
        _this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels);
      }
    };
    _this.recomputeCropPosition = function () {
      if (!_this.state.cropSize) return;
      var newPosition = _this.props.restrictPosition ? restrictPosition(_this.props.crop, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;
      _this.props.onCropChange(newPosition);
      _this.emitCropData();
    };
    return _this;
  }
  Cropper.prototype.componentDidMount = function () {
    if (!this.currentDoc || !this.currentWindow) return;
    if (this.containerRef) {
      if (this.containerRef.ownerDocument) {
        this.currentDoc = this.containerRef.ownerDocument;
      }
      if (this.currentDoc.defaultView) {
        this.currentWindow = this.currentDoc.defaultView;
      }
      this.initResizeObserver();
      // only add window resize listener if ResizeObserver is not supported. Otherwise, it would be redundant
      if (typeof window.ResizeObserver === 'undefined') {
        this.currentWindow.addEventListener('resize', this.computeSizes);
      }
      this.props.zoomWithScroll && this.containerRef.addEventListener('wheel', this.onWheel, {
        passive: false
      });
      this.containerRef.addEventListener('gesturestart', this.onGestureStart);
    }
    if (!this.props.disableAutomaticStylesInjection) {
      this.styleRef = this.currentDoc.createElement('style');
      this.styleRef.setAttribute('type', 'text/css');
      if (this.props.nonce) {
        this.styleRef.setAttribute('nonce', this.props.nonce);
      }
      this.styleRef.innerHTML = css_248z;
      this.currentDoc.head.appendChild(this.styleRef);
    }
    // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called
    if (this.imageRef.current && this.imageRef.current.complete) {
      this.onMediaLoad();
    }
    // set image and video refs in the parent if the callbacks exist
    if (this.props.setImageRef) {
      this.props.setImageRef(this.imageRef);
    }
    if (this.props.setVideoRef) {
      this.props.setVideoRef(this.videoRef);
    }
  };
  Cropper.prototype.componentWillUnmount = function () {
    var _a, _b;
    if (!this.currentDoc || !this.currentWindow) return;
    if (typeof window.ResizeObserver === 'undefined') {
      this.currentWindow.removeEventListener('resize', this.computeSizes);
    }
    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    if (this.containerRef) {
      this.containerRef.removeEventListener('gesturestart', this.preventZoomSafari);
    }
    if (this.styleRef) {
      (_b = this.styleRef.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(this.styleRef);
    }
    this.cleanEvents();
    this.props.zoomWithScroll && this.clearScrollEvent();
  };
  Cropper.prototype.componentDidUpdate = function (prevProps) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (prevProps.rotation !== this.props.rotation) {
      this.computeSizes();
      this.recomputeCropPosition();
    } else if (prevProps.aspect !== this.props.aspect) {
      this.computeSizes();
    } else if (prevProps.zoom !== this.props.zoom) {
      this.recomputeCropPosition();
    } else if (((_a = prevProps.cropSize) === null || _a === void 0 ? void 0 : _a.height) !== ((_b = this.props.cropSize) === null || _b === void 0 ? void 0 : _b.height) || ((_c = prevProps.cropSize) === null || _c === void 0 ? void 0 : _c.width) !== ((_d = this.props.cropSize) === null || _d === void 0 ? void 0 : _d.width)) {
      this.computeSizes();
    } else if (((_e = prevProps.crop) === null || _e === void 0 ? void 0 : _e.x) !== ((_f = this.props.crop) === null || _f === void 0 ? void 0 : _f.x) || ((_g = prevProps.crop) === null || _g === void 0 ? void 0 : _g.y) !== ((_h = this.props.crop) === null || _h === void 0 ? void 0 : _h.y)) {
      this.emitCropAreaChange();
    }
    if (prevProps.zoomWithScroll !== this.props.zoomWithScroll && this.containerRef) {
      this.props.zoomWithScroll ? this.containerRef.addEventListener('wheel', this.onWheel, {
        passive: false
      }) : this.clearScrollEvent();
    }
    if (prevProps.video !== this.props.video) {
      (_j = this.videoRef.current) === null || _j === void 0 ? void 0 : _j.load();
    }
  };
  Cropper.prototype.getAspect = function () {
    var _a = this.props,
      cropSize = _a.cropSize,
      aspect = _a.aspect;
    if (cropSize) {
      return cropSize.width / cropSize.height;
    }
    return aspect;
  };
  Cropper.prototype.onPinchStart = function (e) {
    var pointA = Cropper.getTouchPoint(e.touches[0]);
    var pointB = Cropper.getTouchPoint(e.touches[1]);
    this.lastPinchDistance = getDistanceBetweenPoints(pointA, pointB);
    this.lastPinchRotation = getRotationBetweenPoints(pointA, pointB);
    this.onDragStart(getCenter(pointA, pointB));
  };
  Cropper.prototype.onPinchMove = function (e) {
    var _this = this;
    if (!this.currentDoc || !this.currentWindow) return;
    var pointA = Cropper.getTouchPoint(e.touches[0]);
    var pointB = Cropper.getTouchPoint(e.touches[1]);
    var center = getCenter(pointA, pointB);
    this.onDrag(center);
    if (this.rafPinchTimeout) this.currentWindow.cancelAnimationFrame(this.rafPinchTimeout);
    this.rafPinchTimeout = this.currentWindow.requestAnimationFrame(function () {
      var distance = getDistanceBetweenPoints(pointA, pointB);
      var newZoom = _this.props.zoom * (distance / _this.lastPinchDistance);
      _this.setNewZoom(newZoom, center, {
        shouldUpdatePosition: false
      });
      _this.lastPinchDistance = distance;
      var rotation = getRotationBetweenPoints(pointA, pointB);
      var newRotation = _this.props.rotation + (rotation - _this.lastPinchRotation);
      _this.props.onRotationChange && _this.props.onRotationChange(newRotation);
      _this.lastPinchRotation = rotation;
    });
  };
  Cropper.prototype.render = function () {
    var _this = this;
    var _a = this.props,
      image = _a.image,
      video = _a.video,
      mediaProps = _a.mediaProps,
      transform = _a.transform,
      _b = _a.crop,
      x = _b.x,
      y = _b.y,
      rotation = _a.rotation,
      zoom = _a.zoom,
      cropShape = _a.cropShape,
      showGrid = _a.showGrid,
      _c = _a.style,
      containerStyle = _c.containerStyle,
      cropAreaStyle = _c.cropAreaStyle,
      mediaStyle = _c.mediaStyle,
      _d = _a.classes,
      containerClassName = _d.containerClassName,
      cropAreaClassName = _d.cropAreaClassName,
      mediaClassName = _d.mediaClassName,
      objectFit = _a.objectFit;
    return external_React_default().createElement("div", {
      onMouseDown: this.onMouseDown,
      onTouchStart: this.onTouchStart,
      ref: function ref(el) {
        return _this.containerRef = el;
      },
      "data-testid": "container",
      style: containerStyle,
      className: classNames('reactEasyCrop_Container', containerClassName)
    }, image ? external_React_default().createElement("img", tslib_es6_assign({
      alt: "",
      className: classNames('reactEasyCrop_Image', objectFit === 'contain' && 'reactEasyCrop_Contain', objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal', objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical', objectFit === 'auto-cover' && (this.mediaSize.naturalWidth > this.mediaSize.naturalHeight ? 'reactEasyCrop_Cover_Horizontal' : 'reactEasyCrop_Cover_Vertical'), mediaClassName)
    }, mediaProps, {
      src: image,
      ref: this.imageRef,
      style: tslib_es6_assign(tslib_es6_assign({}, mediaStyle), {
        transform: transform || "translate(".concat(x, "px, ").concat(y, "px) rotate(").concat(rotation, "deg) scale(").concat(zoom, ")")
      }),
      onLoad: this.onMediaLoad
    })) : video && external_React_default().createElement("video", tslib_es6_assign({
      autoPlay: true,
      loop: true,
      muted: true,
      className: classNames('reactEasyCrop_Video', objectFit === 'contain' && 'reactEasyCrop_Contain', objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal', objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical', objectFit === 'auto-cover' && (this.mediaSize.naturalWidth > this.mediaSize.naturalHeight ? 'reactEasyCrop_Cover_Horizontal' : 'reactEasyCrop_Cover_Vertical'), mediaClassName)
    }, mediaProps, {
      ref: this.videoRef,
      onLoadedMetadata: this.onMediaLoad,
      style: tslib_es6_assign(tslib_es6_assign({}, mediaStyle), {
        transform: transform || "translate(".concat(x, "px, ").concat(y, "px) rotate(").concat(rotation, "deg) scale(").concat(zoom, ")")
      }),
      controls: false
    }), (Array.isArray(video) ? video : [{
      src: video
    }]).map(function (item) {
      return external_React_default().createElement("source", tslib_es6_assign({
        key: item.src
      }, item));
    })), this.state.cropSize && external_React_default().createElement("div", {
      style: tslib_es6_assign(tslib_es6_assign({}, cropAreaStyle), {
        width: this.state.cropSize.width,
        height: this.state.cropSize.height
      }),
      "data-testid": "cropper",
      className: classNames('reactEasyCrop_CropArea', cropShape === 'round' && 'reactEasyCrop_CropAreaRound', showGrid && 'reactEasyCrop_CropAreaGrid', cropAreaClassName)
    }));
  };
  Cropper.defaultProps = {
    zoom: 1,
    rotation: 0,
    aspect: 4 / 3,
    maxZoom: MAX_ZOOM,
    minZoom: MIN_ZOOM,
    cropShape: 'rect',
    objectFit: 'contain',
    showGrid: true,
    style: {},
    classes: {},
    mediaProps: {},
    zoomSpeed: 1,
    restrictPosition: true,
    zoomWithScroll: true
  };
  Cropper.getMousePoint = function (e) {
    return {
      x: Number(e.clientX),
      y: Number(e.clientY)
    };
  };
  Cropper.getTouchPoint = function (touch) {
    return {
      x: Number(touch.clientX),
      y: Number(touch.clientY)
    };
  };
  return Cropper;
}((external_React_default()).Component);



;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/image-editor/constants.js
const constants_MIN_ZOOM = 100;
const constants_MAX_ZOOM = 300;
const constants_POPOVER_PROPS = {
  placement: 'bottom-start'
};

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/image-editor/cropper.js


/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function ImageCropper({
  url,
  width,
  height,
  clientWidth,
  naturalHeight,
  naturalWidth,
  borderProps
}) {
  const {
    isInProgress,
    editedUrl,
    position,
    zoom,
    aspect,
    setPosition,
    setCrop,
    setZoom,
    rotation
  } = useImageEditingContext();
  let editedHeight = height || clientWidth * naturalHeight / naturalWidth;

  if (rotation % 180 === 90) {
    editedHeight = clientWidth * naturalWidth / naturalHeight;
  }

  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: classnames_default()('wp-block-image__crop-area', borderProps?.className, {
      'is-applying': isInProgress
    }),
    style: { ...borderProps?.style,
      width: width || clientWidth,
      height: editedHeight
    }
  }, (0,external_wp_element_namespaceObject.createElement)(Cropper, {
    image: editedUrl || url,
    disabled: isInProgress,
    minZoom: constants_MIN_ZOOM / 100,
    maxZoom: constants_MAX_ZOOM / 100,
    crop: position,
    zoom: zoom / 100,
    aspect: aspect,
    onCropChange: pos => {
      setPosition(pos);
    },
    onCropComplete: newCropPercent => {
      setCrop(newCropPercent);
    },
    onZoomChange: newZoom => {
      setZoom(newZoom * 100);
    }
  }), isInProgress && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Spinner, null));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/search.js


/**
 * WordPress dependencies
 */

const search = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M13 5c-3.3 0-6 2.7-6 6 0 1.4.5 2.7 1.3 3.7l-3.8 3.8 1.1 1.1 3.8-3.8c1 .8 2.3 1.3 3.7 1.3 3.3 0 6-2.7 6-6S16.3 5 13 5zm0 10.5c-2.5 0-4.5-2-4.5-4.5s2-4.5 4.5-4.5 4.5 2 4.5 4.5-2 4.5-4.5 4.5z"
}));
/* harmony default export */ var library_search = (search);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/image-editor/zoom-dropdown.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function ZoomDropdown() {
  const {
    isInProgress,
    zoom,
    setZoom
  } = useImageEditingContext();
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Dropdown, {
    contentClassName: "wp-block-image__zoom",
    popoverProps: constants_POPOVER_PROPS,
    renderToggle: ({
      isOpen,
      onToggle
    }) => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarButton, {
      icon: library_search,
      label: (0,external_wp_i18n_namespaceObject.__)('Zoom'),
      onClick: onToggle,
      "aria-expanded": isOpen,
      disabled: isInProgress
    }),
    renderContent: () => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.RangeControl, {
      __nextHasNoMarginBottom: true,
      label: (0,external_wp_i18n_namespaceObject.__)('Zoom'),
      min: constants_MIN_ZOOM,
      max: constants_MAX_ZOOM,
      value: Math.round(zoom),
      onChange: setZoom
    })
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/aspect-ratio.js


/**
 * WordPress dependencies
 */

const aspectRatio = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M18.5 5.5h-13c-1.1 0-2 .9-2 2v9c0 1.1.9 2 2 2h13c1.1 0 2-.9 2-2v-9c0-1.1-.9-2-2-2zm.5 11c0 .3-.2.5-.5.5h-13c-.3 0-.5-.2-.5-.5v-9c0-.3.2-.5.5-.5h13c.3 0 .5.2.5.5v9zM6.5 12H8v-2h2V8.5H6.5V12zm9.5 2h-2v1.5h3.5V12H16v2z"
}));
/* harmony default export */ var aspect_ratio = (aspectRatio);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/image-editor/aspect-ratio-dropdown.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




function AspectGroup({
  aspectRatios,
  isDisabled,
  label,
  onClick,
  value
}) {
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuGroup, {
    label: label
  }, aspectRatios.map(({
    title,
    aspect
  }) => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    key: aspect,
    disabled: isDisabled,
    onClick: () => {
      onClick(aspect);
    },
    role: "menuitemradio",
    isSelected: aspect === value,
    icon: aspect === value ? library_check : undefined
  }, title)));
}

function AspectRatioDropdown({
  toggleProps
}) {
  const {
    isInProgress,
    aspect,
    setAspect,
    defaultAspect
  } = useImageEditingContext();
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.DropdownMenu, {
    icon: aspect_ratio,
    label: (0,external_wp_i18n_namespaceObject.__)('Aspect Ratio'),
    popoverProps: constants_POPOVER_PROPS,
    toggleProps: toggleProps,
    className: "wp-block-image__aspect-ratio"
  }, ({
    onClose
  }) => (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(AspectGroup, {
    isDisabled: isInProgress,
    onClick: newAspect => {
      setAspect(newAspect);
      onClose();
    },
    value: aspect,
    aspectRatios: [// All ratios should be mirrored in AspectRatioTool in @wordpress/block-editor.
    {
      title: (0,external_wp_i18n_namespaceObject.__)('Original'),
      aspect: defaultAspect
    }, {
      title: (0,external_wp_i18n_namespaceObject.__)('Square'),
      aspect: 1
    }]
  }), (0,external_wp_element_namespaceObject.createElement)(AspectGroup, {
    label: (0,external_wp_i18n_namespaceObject.__)('Landscape'),
    isDisabled: isInProgress,
    onClick: newAspect => {
      setAspect(newAspect);
      onClose();
    },
    value: aspect,
    aspectRatios: [{
      title: (0,external_wp_i18n_namespaceObject.__)('16:10'),
      aspect: 16 / 10
    }, {
      title: (0,external_wp_i18n_namespaceObject.__)('16:9'),
      aspect: 16 / 9
    }, {
      title: (0,external_wp_i18n_namespaceObject.__)('4:3'),
      aspect: 4 / 3
    }, {
      title: (0,external_wp_i18n_namespaceObject.__)('3:2'),
      aspect: 3 / 2
    }]
  }), (0,external_wp_element_namespaceObject.createElement)(AspectGroup, {
    label: (0,external_wp_i18n_namespaceObject.__)('Portrait'),
    isDisabled: isInProgress,
    onClick: newAspect => {
      setAspect(newAspect);
      onClose();
    },
    value: aspect,
    aspectRatios: [{
      title: (0,external_wp_i18n_namespaceObject.__)('10:16'),
      aspect: 10 / 16
    }, {
      title: (0,external_wp_i18n_namespaceObject.__)('9:16'),
      aspect: 9 / 16
    }, {
      title: (0,external_wp_i18n_namespaceObject.__)('3:4'),
      aspect: 3 / 4
    }, {
      title: (0,external_wp_i18n_namespaceObject.__)('2:3'),
      aspect: 2 / 3
    }]
  })));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/rotate-right.js


/**
 * WordPress dependencies
 */

const rotateRight = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M15.1 4.8l-3-2.5V4c-4.4 0-8 3.6-8 8 0 3.7 2.5 6.9 6 7.7.3.1.6.1 1 .2l.2-1.5c-.4 0-.7-.1-1.1-.2l-.1.2v-.2c-2.6-.8-4.5-3.3-4.5-6.2 0-3.6 2.9-6.5 6.5-6.5v1.8l3-2.5zM20 11c-.2-1.4-.7-2.7-1.6-3.8l-1.2.8c.7.9 1.1 2 1.3 3.1L20 11zm-1.5 1.8c-.1.5-.2 1.1-.4 1.6s-.5 1-.8 1.5l1.2.9c.4-.5.8-1.1 1-1.8s.5-1.3.5-2l-1.5-.2zm-5.6 5.6l.2 1.5c1.4-.2 2.7-.7 3.8-1.6l-.9-1.1c-.9.7-2 1.1-3.1 1.2z"
}));
/* harmony default export */ var rotate_right = (rotateRight);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/image-editor/rotation-button.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


function RotationButton() {
  const {
    isInProgress,
    rotateClockwise
  } = useImageEditingContext();
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarButton, {
    icon: rotate_right,
    label: (0,external_wp_i18n_namespaceObject.__)('Rotate'),
    onClick: rotateClockwise,
    disabled: isInProgress
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/image-editor/form-controls.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function FormControls() {
  const {
    isInProgress,
    apply,
    cancel
  } = useImageEditingContext();
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarButton, {
    onClick: apply,
    disabled: isInProgress
  }, (0,external_wp_i18n_namespaceObject.__)('Apply')), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarButton, {
    onClick: cancel
  }, (0,external_wp_i18n_namespaceObject.__)('Cancel')));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/image-editor/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */








function ImageEditor({
  id,
  url,
  width,
  height,
  clientWidth,
  naturalHeight,
  naturalWidth,
  onSaveImage,
  onFinishEditing,
  borderProps
}) {
  return (0,external_wp_element_namespaceObject.createElement)(ImageEditingProvider, {
    id: id,
    url: url,
    naturalWidth: naturalWidth,
    naturalHeight: naturalHeight,
    onSaveImage: onSaveImage,
    onFinishEditing: onFinishEditing
  }, (0,external_wp_element_namespaceObject.createElement)(ImageCropper, {
    borderProps: borderProps,
    url: url,
    width: width,
    height: height,
    clientWidth: clientWidth,
    naturalHeight: naturalHeight,
    naturalWidth: naturalWidth
  }), (0,external_wp_element_namespaceObject.createElement)(block_controls, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarGroup, null, (0,external_wp_element_namespaceObject.createElement)(ZoomDropdown, null), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarItem, null, toggleProps => (0,external_wp_element_namespaceObject.createElement)(AspectRatioDropdown, {
    toggleProps: toggleProps
  })), (0,external_wp_element_namespaceObject.createElement)(RotationButton, null)), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarGroup, null, (0,external_wp_element_namespaceObject.createElement)(FormControls, null))));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/image-size-control/use-dimension-handler.js
/**
 * WordPress dependencies
 */

function useDimensionHandler(customHeight, customWidth, defaultHeight, defaultWidth, onChange) {
  var _ref, _ref2;

  const [currentWidth, setCurrentWidth] = (0,external_wp_element_namespaceObject.useState)((_ref = customWidth !== null && customWidth !== void 0 ? customWidth : defaultWidth) !== null && _ref !== void 0 ? _ref : '');
  const [currentHeight, setCurrentHeight] = (0,external_wp_element_namespaceObject.useState)((_ref2 = customHeight !== null && customHeight !== void 0 ? customHeight : defaultHeight) !== null && _ref2 !== void 0 ? _ref2 : ''); // When an image is first inserted, the default dimensions are initially
  // undefined. This effect updates the dimensions when the default values
  // come through.

  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (customWidth === undefined && defaultWidth !== undefined) {
      setCurrentWidth(defaultWidth);
    }

    if (customHeight === undefined && defaultHeight !== undefined) {
      setCurrentHeight(defaultHeight);
    }
  }, [defaultWidth, defaultHeight]); // If custom values change, it means an outsider has resized the image using some other method (eg resize box)
  // this keeps track of these values too. We need to parse before comparing; custom values can be strings.

  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (customWidth !== undefined && Number.parseInt(customWidth) !== Number.parseInt(currentWidth)) {
      setCurrentWidth(customWidth);
    }

    if (customHeight !== undefined && Number.parseInt(customHeight) !== Number.parseInt(currentHeight)) {
      setCurrentHeight(customHeight);
    }
  }, [customWidth, customHeight]);

  const updateDimension = (dimension, value) => {
    const parsedValue = value === '' ? undefined : parseInt(value, 10);

    if (dimension === 'width') {
      setCurrentWidth(parsedValue);
    } else {
      setCurrentHeight(parsedValue);
    }

    onChange({
      [dimension]: parsedValue
    });
  };

  const updateDimensions = (nextHeight, nextWidth) => {
    setCurrentHeight(nextHeight !== null && nextHeight !== void 0 ? nextHeight : defaultHeight);
    setCurrentWidth(nextWidth !== null && nextWidth !== void 0 ? nextWidth : defaultWidth);
    onChange({
      height: nextHeight,
      width: nextWidth
    });
  };

  return {
    currentHeight,
    currentWidth,
    updateDimension,
    updateDimensions
  };
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/image-size-control/index.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


const IMAGE_SIZE_PRESETS = [25, 50, 75, 100];

const image_size_control_noop = () => {};

function ImageSizeControl({
  imageSizeHelp,
  imageWidth,
  imageHeight,
  imageSizeOptions = [],
  isResizable = true,
  slug,
  width,
  height,
  onChange,
  onChangeImage = image_size_control_noop
}) {
  external_wp_deprecated_default()('wp.blockEditor.__experimentalImageSizeControl', {
    since: '6.3',
    alternative: 'wp.blockEditor.privateApis.DimensionsTool and wp.blockEditor.privateApis.ResolutionTool'
  });
  const {
    currentHeight,
    currentWidth,
    updateDimension,
    updateDimensions
  } = useDimensionHandler(height, width, imageHeight, imageWidth, onChange);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, imageSizeOptions && imageSizeOptions.length > 0 && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SelectControl, {
    __nextHasNoMarginBottom: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Resolution'),
    value: slug,
    options: imageSizeOptions,
    onChange: onChangeImage,
    help: imageSizeHelp,
    size: "__unstable-large"
  }), isResizable && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-image-size-control"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHStack, {
    align: "baseline",
    spacing: "3"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalNumberControl, {
    className: "block-editor-image-size-control__width",
    label: (0,external_wp_i18n_namespaceObject.__)('Width'),
    value: currentWidth,
    min: 1,
    onChange: value => updateDimension('width', value),
    size: "__unstable-large"
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalNumberControl, {
    className: "block-editor-image-size-control__height",
    label: (0,external_wp_i18n_namespaceObject.__)('Height'),
    value: currentHeight,
    min: 1,
    onChange: value => updateDimension('height', value),
    size: "__unstable-large"
  })), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHStack, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ButtonGroup, {
    "aria-label": (0,external_wp_i18n_namespaceObject.__)('Image size presets')
  }, IMAGE_SIZE_PRESETS.map(scale => {
    const scaledWidth = Math.round(imageWidth * (scale / 100));
    const scaledHeight = Math.round(imageHeight * (scale / 100));
    const isCurrent = currentWidth === scaledWidth && currentHeight === scaledHeight;
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
      key: scale,
      isSmall: true,
      variant: isCurrent ? 'primary' : undefined,
      isPressed: isCurrent,
      onClick: () => updateDimensions(scaledHeight, scaledWidth)
    }, scale, "%");
  })), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    isSmall: true,
    onClick: () => updateDimensions()
  }, (0,external_wp_i18n_namespaceObject.__)('Reset')))));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/settings-drawer.js


/**
 * WordPress dependencies
 */






function LinkSettingsDrawer({
  children,
  settingsOpen,
  setSettingsOpen
}) {
  const prefersReducedMotion = (0,external_wp_compose_namespaceObject.useReducedMotion)();
  const MaybeAnimatePresence = prefersReducedMotion ? external_wp_element_namespaceObject.Fragment : external_wp_components_namespaceObject.__unstableAnimatePresence;
  const MaybeMotionDiv = prefersReducedMotion ? 'div' : external_wp_components_namespaceObject.__unstableMotion.div;
  const id = (0,external_wp_compose_namespaceObject.useInstanceId)(LinkSettingsDrawer);
  const settingsDrawerId = `link-control-settings-drawer-${id}`;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    className: "block-editor-link-control__drawer-toggle",
    "aria-expanded": settingsOpen,
    onClick: () => setSettingsOpen(!settingsOpen),
    icon: (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_left_small : chevron_right_small,
    "aria-controls": settingsDrawerId
  }, (0,external_wp_i18n_namespaceObject._x)('Advanced', 'Additional link settings')), (0,external_wp_element_namespaceObject.createElement)(MaybeAnimatePresence, null, settingsOpen && (0,external_wp_element_namespaceObject.createElement)(MaybeMotionDiv, {
    className: "block-editor-link-control__drawer",
    hidden: !settingsOpen,
    id: settingsDrawerId,
    initial: "collapsed",
    animate: "open",
    exit: "collapsed",
    variants: {
      open: {
        opacity: 1,
        height: 'auto'
      },
      collapsed: {
        opacity: 0,
        height: 0
      }
    },
    transition: {
      duration: 0.1
    }
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-link-control__drawer-inner"
  }, children))));
}

/* harmony default export */ var settings_drawer = (LinkSettingsDrawer);

// EXTERNAL MODULE: ./node_modules/dom-scroll-into-view/lib/index.js
var dom_scroll_into_view_lib = __webpack_require__(5425);
var lib_default = /*#__PURE__*/__webpack_require__.n(dom_scroll_into_view_lib);
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/url-input/index.js


/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */









/**
 * Internal dependencies
 */


/**
 * Whether the argument is a function.
 *
 * @param {*} maybeFunc The argument to check.
 * @return {boolean} True if the argument is a function, false otherwise.
 */

function isFunction(maybeFunc) {
  return typeof maybeFunc === 'function';
}

class URLInput extends external_wp_element_namespaceObject.Component {
  constructor(props) {
    super(props);
    this.onChange = this.onChange.bind(this);
    this.onFocus = this.onFocus.bind(this);
    this.onKeyDown = this.onKeyDown.bind(this);
    this.selectLink = this.selectLink.bind(this);
    this.handleOnClick = this.handleOnClick.bind(this);
    this.bindSuggestionNode = this.bindSuggestionNode.bind(this);
    this.autocompleteRef = props.autocompleteRef || (0,external_wp_element_namespaceObject.createRef)();
    this.inputRef = (0,external_wp_element_namespaceObject.createRef)();
    this.updateSuggestions = (0,external_wp_compose_namespaceObject.debounce)(this.updateSuggestions.bind(this), 200);
    this.suggestionNodes = [];
    this.suggestionsRequest = null;
    this.state = {
      suggestions: [],
      showSuggestions: false,
      isUpdatingSuggestions: false,
      suggestionsValue: null,
      selectedSuggestion: null,
      suggestionsListboxId: '',
      suggestionOptionIdPrefix: ''
    };
  }

  componentDidUpdate(prevProps) {
    const {
      showSuggestions,
      selectedSuggestion
    } = this.state;
    const {
      value,
      __experimentalShowInitialSuggestions = false
    } = this.props; // Only have to worry about scrolling selected suggestion into view
    // when already expanded.

    if (showSuggestions && selectedSuggestion !== null && this.suggestionNodes[selectedSuggestion] && !this.scrollingIntoView) {
      this.scrollingIntoView = true;
      lib_default()(this.suggestionNodes[selectedSuggestion], this.autocompleteRef.current, {
        onlyScrollIfNeeded: true
      });
      this.props.setTimeout(() => {
        this.scrollingIntoView = false;
      }, 100);
    } // Update suggestions when the value changes.


    if (prevProps.value !== value && !this.props.disableSuggestions && !this.state.isUpdatingSuggestions) {
      if (value?.length) {
        // If the new value is not empty we need to update with suggestions for it.
        this.updateSuggestions(value);
      } else if (__experimentalShowInitialSuggestions) {
        // If the new value is empty and we can show initial suggestions, then show initial suggestions.
        this.updateSuggestions();
      }
    }
  }

  componentDidMount() {
    if (this.shouldShowInitialSuggestions()) {
      this.updateSuggestions();
    }
  }

  componentWillUnmount() {
    this.suggestionsRequest?.cancel?.();
    this.suggestionsRequest = null;
  }

  bindSuggestionNode(index) {
    return ref => {
      this.suggestionNodes[index] = ref;
    };
  }

  shouldShowInitialSuggestions() {
    const {
      __experimentalShowInitialSuggestions = false,
      value
    } = this.props;
    return __experimentalShowInitialSuggestions && !(value && value.length);
  }

  updateSuggestions(value = '') {
    const {
      __experimentalFetchLinkSuggestions: fetchLinkSuggestions,
      __experimentalHandleURLSuggestions: handleURLSuggestions
    } = this.props;

    if (!fetchLinkSuggestions) {
      return;
    } // Initial suggestions may only show if there is no value
    // (note: this includes whitespace).


    const isInitialSuggestions = !value?.length; // Trim only now we've determined whether or not it originally had a "length"
    // (even if that value was all whitespace).

    value = value.trim(); // Allow a suggestions request if:
    // - there are at least 2 characters in the search input (except manual searches where
    //   search input length is not required to trigger a fetch)
    // - this is a direct entry (eg: a URL)

    if (!isInitialSuggestions && (value.length < 2 || !handleURLSuggestions && (0,external_wp_url_namespaceObject.isURL)(value))) {
      this.suggestionsRequest?.cancel?.();
      this.suggestionsRequest = null;
      this.setState({
        suggestions: [],
        showSuggestions: false,
        suggestionsValue: value,
        selectedSuggestion: null,
        loading: false
      });
      return;
    }

    this.setState({
      isUpdatingSuggestions: true,
      selectedSuggestion: null,
      loading: true
    });
    const request = fetchLinkSuggestions(value, {
      isInitialSuggestions
    });
    request.then(suggestions => {
      // A fetch Promise doesn't have an abort option. It's mimicked by
      // comparing the request reference in on the instance, which is
      // reset or deleted on subsequent requests or unmounting.
      if (this.suggestionsRequest !== request) {
        return;
      }

      this.setState({
        suggestions,
        isUpdatingSuggestions: false,
        suggestionsValue: value,
        loading: false,
        showSuggestions: !!suggestions.length
      });

      if (!!suggestions.length) {
        this.props.debouncedSpeak((0,external_wp_i18n_namespaceObject.sprintf)(
        /* translators: %s: number of results. */
        (0,external_wp_i18n_namespaceObject._n)('%d result found, use up and down arrow keys to navigate.', '%d results found, use up and down arrow keys to navigate.', suggestions.length), suggestions.length), 'assertive');
      } else {
        this.props.debouncedSpeak((0,external_wp_i18n_namespaceObject.__)('No results.'), 'assertive');
      }
    }).catch(() => {
      if (this.suggestionsRequest !== request) {
        return;
      }

      this.setState({
        isUpdatingSuggestions: false,
        loading: false
      });
    }); // Note that this assignment is handled *before* the async search request
    // as a Promise always resolves on the next tick of the event loop.

    this.suggestionsRequest = request;
  }

  onChange(event) {
    this.props.onChange(event.target.value);
  }

  onFocus() {
    const {
      suggestions
    } = this.state;
    const {
      disableSuggestions,
      value
    } = this.props; // When opening the link editor, if there's a value present, we want to load the suggestions pane with the results for this input search value
    // Don't re-run the suggestions on focus if there are already suggestions present (prevents searching again when tabbing between the input and buttons)

    if (value && !disableSuggestions && !this.state.isUpdatingSuggestions && !(suggestions && suggestions.length)) {
      // Ensure the suggestions are updated with the current input value.
      this.updateSuggestions(value);
    }
  }

  onKeyDown(event) {
    this.props.onKeyDown?.(event);
    const {
      showSuggestions,
      selectedSuggestion,
      suggestions,
      loading
    } = this.state; // If the suggestions are not shown or loading, we shouldn't handle the arrow keys
    // We shouldn't preventDefault to allow block arrow keys navigation.

    if (!showSuggestions || !suggestions.length || loading) {
      // In the Windows version of Firefox the up and down arrows don't move the caret
      // within an input field like they do for Mac Firefox/Chrome/Safari. This causes
      // a form of focus trapping that is disruptive to the user experience. This disruption
      // only happens if the caret is not in the first or last position in the text input.
      // See: https://github.com/WordPress/gutenberg/issues/5693#issuecomment-436684747
      switch (event.keyCode) {
        // When UP is pressed, if the caret is at the start of the text, move it to the 0
        // position.
        case external_wp_keycodes_namespaceObject.UP:
          {
            if (0 !== event.target.selectionStart) {
              event.preventDefault(); // Set the input caret to position 0.

              event.target.setSelectionRange(0, 0);
            }

            break;
          }
        // When DOWN is pressed, if the caret is not at the end of the text, move it to the
        // last position.

        case external_wp_keycodes_namespaceObject.DOWN:
          {
            if (this.props.value.length !== event.target.selectionStart) {
              event.preventDefault(); // Set the input caret to the last position.

              event.target.setSelectionRange(this.props.value.length, this.props.value.length);
            }

            break;
          }
        // Submitting while loading should trigger onSubmit.

        case external_wp_keycodes_namespaceObject.ENTER:
          {
            if (this.props.onSubmit) {
              event.preventDefault();
              this.props.onSubmit(null, event);
            }

            break;
          }
      }

      return;
    }

    const suggestion = this.state.suggestions[this.state.selectedSuggestion];

    switch (event.keyCode) {
      case external_wp_keycodes_namespaceObject.UP:
        {
          event.preventDefault();
          const previousIndex = !selectedSuggestion ? suggestions.length - 1 : selectedSuggestion - 1;
          this.setState({
            selectedSuggestion: previousIndex
          });
          break;
        }

      case external_wp_keycodes_namespaceObject.DOWN:
        {
          event.preventDefault();
          const nextIndex = selectedSuggestion === null || selectedSuggestion === suggestions.length - 1 ? 0 : selectedSuggestion + 1;
          this.setState({
            selectedSuggestion: nextIndex
          });
          break;
        }

      case external_wp_keycodes_namespaceObject.TAB:
        {
          if (this.state.selectedSuggestion !== null) {
            this.selectLink(suggestion); // Announce a link has been selected when tabbing away from the input field.

            this.props.speak((0,external_wp_i18n_namespaceObject.__)('Link selected.'));
          }

          break;
        }

      case external_wp_keycodes_namespaceObject.ENTER:
        {
          event.preventDefault();

          if (this.state.selectedSuggestion !== null) {
            this.selectLink(suggestion);

            if (this.props.onSubmit) {
              this.props.onSubmit(suggestion, event);
            }
          } else if (this.props.onSubmit) {
            this.props.onSubmit(null, event);
          }

          break;
        }
    }
  }

  selectLink(suggestion) {
    this.props.onChange(suggestion.url, suggestion);
    this.setState({
      selectedSuggestion: null,
      showSuggestions: false
    });
  }

  handleOnClick(suggestion) {
    this.selectLink(suggestion); // Move focus to the input field when a link suggestion is clicked.

    this.inputRef.current.focus();
  }

  static getDerivedStateFromProps({
    value,
    instanceId,
    disableSuggestions,
    __experimentalShowInitialSuggestions = false
  }, {
    showSuggestions
  }) {
    let shouldShowSuggestions = showSuggestions;
    const hasValue = value && value.length;

    if (!__experimentalShowInitialSuggestions && !hasValue) {
      shouldShowSuggestions = false;
    }

    if (disableSuggestions === true) {
      shouldShowSuggestions = false;
    }

    return {
      showSuggestions: shouldShowSuggestions,
      suggestionsListboxId: `block-editor-url-input-suggestions-${instanceId}`,
      suggestionOptionIdPrefix: `block-editor-url-input-suggestion-${instanceId}`
    };
  }

  render() {
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, this.renderControl(), this.renderSuggestions());
  }

  renderControl() {
    const {
      /** Start opting into the new margin-free styles that will become the default in a future version. */
      __nextHasNoMarginBottom = false,
      label = null,
      className,
      isFullWidth,
      instanceId,
      placeholder = (0,external_wp_i18n_namespaceObject.__)('Paste URL or type to search'),
      __experimentalRenderControl: renderControl,
      value = '',
      hideLabelFromVision = false
    } = this.props;
    const {
      loading,
      showSuggestions,
      selectedSuggestion,
      suggestionsListboxId,
      suggestionOptionIdPrefix
    } = this.state;
    const inputId = `url-input-control-${instanceId}`;
    const controlProps = {
      id: inputId,
      // Passes attribute to label for the for attribute
      label,
      className: classnames_default()('block-editor-url-input', className, {
        'is-full-width': isFullWidth
      }),
      hideLabelFromVision
    };
    const inputProps = {
      id: inputId,
      value,
      required: true,
      className: 'block-editor-url-input__input',
      type: 'text',
      onChange: this.onChange,
      onFocus: this.onFocus,
      placeholder,
      onKeyDown: this.onKeyDown,
      role: 'combobox',
      'aria-label': label ? undefined : (0,external_wp_i18n_namespaceObject.__)('URL'),
      // Ensure input always has an accessible label
      'aria-expanded': showSuggestions,
      'aria-autocomplete': 'list',
      'aria-owns': suggestionsListboxId,
      'aria-activedescendant': selectedSuggestion !== null ? `${suggestionOptionIdPrefix}-${selectedSuggestion}` : undefined,
      ref: this.inputRef
    };

    if (renderControl) {
      return renderControl(controlProps, inputProps, loading);
    }

    if (!__nextHasNoMarginBottom) {
      external_wp_deprecated_default()('Bottom margin styles for wp.blockEditor.URLInput', {
        since: '6.2',
        version: '6.5',
        hint: 'Set the `__nextHasNoMarginBottom` prop to true to start opting into the new styles, which will become the default in a future version'
      });
    }

    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.BaseControl, {
      __nextHasNoMarginBottom: __nextHasNoMarginBottom,
      ...controlProps
    }, (0,external_wp_element_namespaceObject.createElement)("input", { ...inputProps
    }), loading && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Spinner, null));
  }

  renderSuggestions() {
    const {
      className,
      __experimentalRenderSuggestions: renderSuggestions
    } = this.props;
    const {
      showSuggestions,
      suggestions,
      suggestionsValue,
      selectedSuggestion,
      suggestionsListboxId,
      suggestionOptionIdPrefix,
      loading
    } = this.state;

    if (!showSuggestions || suggestions.length === 0) {
      return null;
    }

    const suggestionsListProps = {
      id: suggestionsListboxId,
      ref: this.autocompleteRef,
      role: 'listbox'
    };

    const buildSuggestionItemProps = (suggestion, index) => {
      return {
        role: 'option',
        tabIndex: '-1',
        id: `${suggestionOptionIdPrefix}-${index}`,
        ref: this.bindSuggestionNode(index),
        'aria-selected': index === selectedSuggestion ? true : undefined
      };
    };

    if (isFunction(renderSuggestions)) {
      return renderSuggestions({
        suggestions,
        selectedSuggestion,
        suggestionsListProps,
        buildSuggestionItemProps,
        isLoading: loading,
        handleSuggestionClick: this.handleOnClick,
        isInitialSuggestions: !suggestionsValue?.length,
        currentInputValue: suggestionsValue
      });
    }

    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Popover, {
      placement: "bottom",
      focusOnMount: false
    }, (0,external_wp_element_namespaceObject.createElement)("div", { ...suggestionsListProps,
      className: classnames_default()('block-editor-url-input__suggestions', `${className}__suggestions`)
    }, suggestions.map((suggestion, index) => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, { ...buildSuggestionItemProps(suggestion, index),
      key: suggestion.id,
      className: classnames_default()('block-editor-url-input__suggestion', {
        'is-selected': index === selectedSuggestion
      }),
      onClick: () => this.handleOnClick(suggestion)
    }, suggestion.title))));
  }

}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/url-input/README.md
 */


/* harmony default export */ var url_input = ((0,external_wp_compose_namespaceObject.compose)(external_wp_compose_namespaceObject.withSafeTimeout, external_wp_components_namespaceObject.withSpokenMessages, external_wp_compose_namespaceObject.withInstanceId, (0,external_wp_data_namespaceObject.withSelect)((select, props) => {
  // If a link suggestions handler is already provided then
  // bail.
  if (isFunction(props.__experimentalFetchLinkSuggestions)) {
    return;
  }

  const {
    getSettings
  } = select(store);
  return {
    __experimentalFetchLinkSuggestions: getSettings().__experimentalFetchLinkSuggestions
  };
}))(URLInput));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/search-create-button.js


/**
 * WordPress dependencies
 */




const LinkControlSearchCreate = ({
  searchTerm,
  onClick,
  itemProps,
  buttonText
}) => {
  if (!searchTerm) {
    return null;
  }

  let text;

  if (buttonText) {
    text = typeof buttonText === 'function' ? buttonText(searchTerm) : buttonText;
  } else {
    text = (0,external_wp_element_namespaceObject.createInterpolateElement)((0,external_wp_i18n_namespaceObject.sprintf)(
    /* translators: %s: search term. */
    (0,external_wp_i18n_namespaceObject.__)('Create: <mark>%s</mark>'), searchTerm), {
      mark: (0,external_wp_element_namespaceObject.createElement)("mark", null)
    });
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, { ...itemProps,
    iconPosition: "left",
    icon: library_plus,
    className: "block-editor-link-control__search-item",
    onClick: onClick
  }, text);
};
/* harmony default export */ var search_create_button = (LinkControlSearchCreate);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/post-list.js


/**
 * WordPress dependencies
 */

const postList = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M18 4H6c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm.5 14c0 .3-.2.5-.5.5H6c-.3 0-.5-.2-.5-.5V6c0-.3.2-.5.5-.5h12c.3 0 .5.2.5.5v12zM7 11h2V9H7v2zm0 4h2v-2H7v2zm3-4h7V9h-7v2zm0 4h7v-2h-7v2z"
}));
/* harmony default export */ var post_list = (postList);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/tag.js


/**
 * WordPress dependencies
 */

const tag = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M20.1 11.2l-6.7-6.7c-.1-.1-.3-.2-.5-.2H5c-.4-.1-.8.3-.8.7v7.8c0 .2.1.4.2.5l6.7 6.7c.2.2.5.4.7.5s.6.2.9.2c.3 0 .6-.1.9-.2.3-.1.5-.3.8-.5l5.6-5.6c.4-.4.7-1 .7-1.6.1-.6-.2-1.2-.6-1.6zM19 13.4L13.4 19c-.1.1-.2.1-.3.2-.2.1-.4.1-.6 0-.1 0-.2-.1-.3-.2l-6.5-6.5V5.8h6.8l6.5 6.5c.2.2.2.4.2.6 0 .1 0 .3-.2.5zM9 8c-.6 0-1 .4-1 1s.4 1 1 1 1-.4 1-1-.4-1-1-1z"
}));
/* harmony default export */ var library_tag = (tag);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/category.js


/**
 * WordPress dependencies
 */

const category = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M6 5.5h3a.5.5 0 01.5.5v3a.5.5 0 01-.5.5H6a.5.5 0 01-.5-.5V6a.5.5 0 01.5-.5zM4 6a2 2 0 012-2h3a2 2 0 012 2v3a2 2 0 01-2 2H6a2 2 0 01-2-2V6zm11-.5h3a.5.5 0 01.5.5v3a.5.5 0 01-.5.5h-3a.5.5 0 01-.5-.5V6a.5.5 0 01.5-.5zM13 6a2 2 0 012-2h3a2 2 0 012 2v3a2 2 0 01-2 2h-3a2 2 0 01-2-2V6zm5 8.5h-3a.5.5 0 00-.5.5v3a.5.5 0 00.5.5h3a.5.5 0 00.5-.5v-3a.5.5 0 00-.5-.5zM15 13a2 2 0 00-2 2v3a2 2 0 002 2h3a2 2 0 002-2v-3a2 2 0 00-2-2h-3zm-9 1.5h3a.5.5 0 01.5.5v3a.5.5 0 01-.5.5H6a.5.5 0 01-.5-.5v-3a.5.5 0 01.5-.5zM4 15a2 2 0 012-2h3a2 2 0 012 2v3a2 2 0 01-2 2H6a2 2 0 01-2-2v-3z",
  fillRule: "evenodd",
  clipRule: "evenodd"
}));
/* harmony default export */ var library_category = (category);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/file.js


/**
 * WordPress dependencies
 */

const file = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M19 6.2h-5.9l-.6-1.1c-.3-.7-1-1.1-1.8-1.1H5c-1.1 0-2 .9-2 2v11.8c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V8.2c0-1.1-.9-2-2-2zm.5 11.6c0 .3-.2.5-.5.5H5c-.3 0-.5-.2-.5-.5V6c0-.3.2-.5.5-.5h5.8c.2 0 .4.1.4.3l1 2H19c.3 0 .5.2.5.5v9.5z"
}));
/* harmony default export */ var library_file = (file);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/globe.js


/**
 * WordPress dependencies
 */

const globe = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M12 3.3c-4.8 0-8.8 3.9-8.8 8.8 0 4.8 3.9 8.8 8.8 8.8 4.8 0 8.8-3.9 8.8-8.8s-4-8.8-8.8-8.8zm6.5 5.5h-2.6C15.4 7.3 14.8 6 14 5c2 .6 3.6 2 4.5 3.8zm.7 3.2c0 .6-.1 1.2-.2 1.8h-2.9c.1-.6.1-1.2.1-1.8s-.1-1.2-.1-1.8H19c.2.6.2 1.2.2 1.8zM12 18.7c-1-.7-1.8-1.9-2.3-3.5h4.6c-.5 1.6-1.3 2.9-2.3 3.5zm-2.6-4.9c-.1-.6-.1-1.1-.1-1.8 0-.6.1-1.2.1-1.8h5.2c.1.6.1 1.1.1 1.8s-.1 1.2-.1 1.8H9.4zM4.8 12c0-.6.1-1.2.2-1.8h2.9c-.1.6-.1 1.2-.1 1.8 0 .6.1 1.2.1 1.8H5c-.2-.6-.2-1.2-.2-1.8zM12 5.3c1 .7 1.8 1.9 2.3 3.5H9.7c.5-1.6 1.3-2.9 2.3-3.5zM10 5c-.8 1-1.4 2.3-1.8 3.8H5.5C6.4 7 8 5.6 10 5zM5.5 15.3h2.6c.4 1.5 1 2.8 1.8 3.7-1.8-.6-3.5-2-4.4-3.7zM14 19c.8-1 1.4-2.2 1.8-3.7h2.6C17.6 17 16 18.4 14 19z"
}));
/* harmony default export */ var library_globe = (globe);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/search-item.js


/**
 * WordPress dependencies
 */





const ICONS_MAP = {
  post: post_list,
  page: library_page,
  post_tag: library_tag,
  category: library_category,
  attachment: library_file
};

function SearchItemIcon({
  isURL,
  suggestion
}) {
  let icon = null;

  if (isURL) {
    icon = library_globe;
  } else if (suggestion.type in ICONS_MAP) {
    icon = ICONS_MAP[suggestion.type];
  }

  if (icon) {
    return (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
      className: "block-editor-link-control__search-item-icon",
      icon: icon
    });
  }

  return null;
}

const LinkControlSearchItem = ({
  itemProps,
  suggestion,
  searchTerm,
  onClick,
  isURL = false,
  shouldShowType = false
}) => {
  const info = isURL ? (0,external_wp_i18n_namespaceObject.__)('Press ENTER to add this link') : (0,external_wp_url_namespaceObject.filterURLForDisplay)((0,external_wp_url_namespaceObject.safeDecodeURI)(suggestion?.url));
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, { ...itemProps,
    info: info,
    iconPosition: "left",
    icon: (0,external_wp_element_namespaceObject.createElement)(SearchItemIcon, {
      suggestion: suggestion,
      isURL: isURL
    }),
    onClick: onClick,
    shortcut: shouldShowType && getVisualTypeName(suggestion),
    className: "block-editor-link-control__search-item"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.TextHighlight // The component expects a plain text string.
  , {
    text: (0,external_wp_dom_namespaceObject.__unstableStripHTML)(suggestion.title),
    highlight: searchTerm
  }));
};

function getVisualTypeName(suggestion) {
  if (suggestion.isFrontPage) {
    return 'front page';
  } // Rename 'post_tag' to 'tag'. Ideally, the API would return the localised CPT or taxonomy label.


  return suggestion.type === 'post_tag' ? 'tag' : suggestion.type;
}

/* harmony default export */ var search_item = (LinkControlSearchItem);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/constants.js
/**
 * WordPress dependencies
 */
 // Used as a unique identifier for the "Create" option within search results.
// Used to help distinguish the "Create" suggestion within the search results in
// order to handle it as a unique case.

const CREATE_TYPE = '__CREATE__';
const TEL_TYPE = 'tel';
const URL_TYPE = 'link';
const MAILTO_TYPE = 'mailto';
const INTERNAL_TYPE = 'internal';
const LINK_ENTRY_TYPES = [URL_TYPE, MAILTO_TYPE, TEL_TYPE, INTERNAL_TYPE];
const DEFAULT_LINK_SETTINGS = [{
  id: 'opensInNewTab',
  title: (0,external_wp_i18n_namespaceObject.__)('Open in new tab')
}];

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/search-results.js


/**
 * WordPress dependencies
 */


/**
 * External dependencies
 */


/**
 * Internal dependencies
 */




function LinkControlSearchResults({
  instanceId,
  withCreateSuggestion,
  currentInputValue,
  handleSuggestionClick,
  suggestionsListProps,
  buildSuggestionItemProps,
  suggestions,
  selectedSuggestion,
  isLoading,
  isInitialSuggestions,
  createSuggestionButtonText,
  suggestionsQuery
}) {
  const resultsListClasses = classnames_default()('block-editor-link-control__search-results', {
    'is-loading': isLoading
  });
  const isSingleDirectEntryResult = suggestions.length === 1 && LINK_ENTRY_TYPES.includes(suggestions[0].type);
  const shouldShowCreateSuggestion = withCreateSuggestion && !isSingleDirectEntryResult && !isInitialSuggestions; // If the query has a specified type, then we can skip showing them in the result. See #24839.

  const shouldShowSuggestionsTypes = !suggestionsQuery?.type; // According to guidelines aria-label should be added if the label
  // itself is not visible.
  // See: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/listbox_role

  const searchResultsLabelId = `block-editor-link-control-search-results-label-${instanceId}`;
  const labelText = isInitialSuggestions ? (0,external_wp_i18n_namespaceObject.__)('Suggestions') : (0,external_wp_i18n_namespaceObject.sprintf)(
  /* translators: %s: search term. */
  (0,external_wp_i18n_namespaceObject.__)('Search results for "%s"'), currentInputValue);
  const searchResultsLabel = (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.VisuallyHidden, {
    id: searchResultsLabelId
  }, labelText);
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-link-control__search-results-wrapper"
  }, searchResultsLabel, (0,external_wp_element_namespaceObject.createElement)("div", { ...suggestionsListProps,
    className: resultsListClasses,
    "aria-labelledby": searchResultsLabelId
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuGroup, null, suggestions.map((suggestion, index) => {
    if (shouldShowCreateSuggestion && CREATE_TYPE === suggestion.type) {
      return (0,external_wp_element_namespaceObject.createElement)(search_create_button, {
        searchTerm: currentInputValue,
        buttonText: createSuggestionButtonText,
        onClick: () => handleSuggestionClick(suggestion) // Intentionally only using `type` here as
        // the constant is enough to uniquely
        // identify the single "CREATE" suggestion.
        ,
        key: suggestion.type,
        itemProps: buildSuggestionItemProps(suggestion, index),
        isSelected: index === selectedSuggestion
      });
    } // If we're not handling "Create" suggestions above then
    // we don't want them in the main results so exit early.


    if (CREATE_TYPE === suggestion.type) {
      return null;
    }

    return (0,external_wp_element_namespaceObject.createElement)(search_item, {
      key: `${suggestion.id}-${suggestion.type}`,
      itemProps: buildSuggestionItemProps(suggestion, index),
      suggestion: suggestion,
      index: index,
      onClick: () => {
        handleSuggestionClick(suggestion);
      },
      isSelected: index === selectedSuggestion,
      isURL: LINK_ENTRY_TYPES.includes(suggestion.type),
      searchTerm: currentInputValue,
      shouldShowType: shouldShowSuggestionsTypes,
      isFrontPage: suggestion?.isFrontPage
    });
  }))));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/is-url-like.js
/**
 * WordPress dependencies
 */

/**
 * Determines whether a given value could be a URL. Note this does not
 * guarantee the value is a URL only that it looks like it might be one. For
 * example, just because a string has `www.` in it doesn't make it a URL,
 * but it does make it highly likely that it will be so in the context of
 * creating a link it makes sense to treat it like one.
 *
 * @param {string} val the candidate for being URL-like (or not).
 *
 * @return {boolean} whether or not the value is potentially a URL.
 */

function isURLLike(val) {
  const hasSpaces = val.includes(' ');

  if (hasSpaces) {
    return false;
  }

  const protocol = (0,external_wp_url_namespaceObject.getProtocol)(val);
  const protocolIsValid = (0,external_wp_url_namespaceObject.isValidProtocol)(protocol);
  const mayBeTLD = hasPossibleTLD(val);
  const isWWW = val?.startsWith('www.');
  const isInternal = val?.startsWith('#') && (0,external_wp_url_namespaceObject.isValidFragment)(val);
  return protocolIsValid || isWWW || isInternal || mayBeTLD;
}
/**
 * Checks if a given URL has a valid Top-Level Domain (TLD).
 *
 * @param {string} url       - The URL to check.
 * @param {number} maxLength - The maximum length of the TLD.
 * @return {boolean} Returns true if the URL has a valid TLD, false otherwise.
 */

function hasPossibleTLD(url, maxLength = 6) {
  // Clean the URL by removing anything after the first occurrence of "?" or "#".
  const cleanedURL = url.split(/[?#]/)[0]; // Regular expression explanation:
  // - (?<=\S)                  : Positive lookbehind assertion to ensure there is at least one non-whitespace character before the TLD
  // - \.                       : Matches a literal dot (.)
  // - [a-zA-Z_]{2,maxLength}   : Matches 2 to maxLength letters or underscores, representing the TLD
  // - (?:\/|$)                 : Non-capturing group that matches either a forward slash (/) or the end of the string

  const regex = new RegExp(`(?<=\\S)\\.(?:[a-zA-Z_]{2,${maxLength}})(?:\\/|$)`);
  return regex.test(cleanedURL);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/use-search-handler.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




const handleNoop = () => Promise.resolve([]);
const handleDirectEntry = val => {
  let type = URL_TYPE;
  const protocol = (0,external_wp_url_namespaceObject.getProtocol)(val) || '';

  if (protocol.includes('mailto')) {
    type = MAILTO_TYPE;
  }

  if (protocol.includes('tel')) {
    type = TEL_TYPE;
  }

  if (val?.startsWith('#')) {
    type = INTERNAL_TYPE;
  }

  return Promise.resolve([{
    id: val,
    title: val,
    url: type === 'URL' ? (0,external_wp_url_namespaceObject.prependHTTP)(val) : val,
    type
  }]);
};

const handleEntitySearch = async (val, suggestionsQuery, fetchSearchSuggestions, withCreateSuggestion, pageOnFront) => {
  const {
    isInitialSuggestions
  } = suggestionsQuery;
  const results = await fetchSearchSuggestions(val, suggestionsQuery); // Identify front page and update type to match.

  results.map(result => {
    if (Number(result.id) === pageOnFront) {
      result.isFrontPage = true;
      return result;
    }

    return result;
  }); // If displaying initial suggestions just return plain results.

  if (isInitialSuggestions) {
    return results;
  } // Here we append a faux suggestion to represent a "CREATE" option. This
  // is detected in the rendering of the search results and handled as a
  // special case. This is currently necessary because the suggestions
  // dropdown will only appear if there are valid suggestions and
  // therefore unless the create option is a suggestion it will not
  // display in scenarios where there are no results returned from the
  // API. In addition promoting CREATE to a first class suggestion affords
  // the a11y benefits afforded by `URLInput` to all suggestions (eg:
  // keyboard handling, ARIA roles...etc).
  //
  // Note also that the value of the `title` and `url` properties must correspond
  // to the text value of the `<input>`. This is because `title` is used
  // when creating the suggestion. Similarly `url` is used when using keyboard to select
  // the suggestion (the <form> `onSubmit` handler falls-back to `url`).


  return isURLLike(val) || !withCreateSuggestion ? results : results.concat({
    // the `id` prop is intentionally ommitted here because it
    // is never exposed as part of the component's public API.
    // see: https://github.com/WordPress/gutenberg/pull/19775#discussion_r378931316.
    title: val,
    // Must match the existing `<input>`s text value.
    url: val,
    // Must match the existing `<input>`s text value.
    type: CREATE_TYPE
  });
};

function useSearchHandler(suggestionsQuery, allowDirectEntry, withCreateSuggestion, withURLSuggestion) {
  const {
    fetchSearchSuggestions,
    pageOnFront
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getSettings
    } = select(store);
    return {
      pageOnFront: getSettings().pageOnFront,
      fetchSearchSuggestions: getSettings().__experimentalFetchLinkSuggestions
    };
  }, []);
  const directEntryHandler = allowDirectEntry ? handleDirectEntry : handleNoop;
  return (0,external_wp_element_namespaceObject.useCallback)((val, {
    isInitialSuggestions
  }) => {
    return isURLLike(val) ? directEntryHandler(val, {
      isInitialSuggestions
    }) : handleEntitySearch(val, { ...suggestionsQuery,
      isInitialSuggestions
    }, fetchSearchSuggestions, withCreateSuggestion, withURLSuggestion, pageOnFront);
  }, [directEntryHandler, fetchSearchSuggestions, pageOnFront, suggestionsQuery, withCreateSuggestion, withURLSuggestion]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/search-input.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




 // Must be a function as otherwise URLInput will default
// to the fetchLinkSuggestions passed in block editor settings
// which will cause an unintended http request.

const noopSearchHandler = () => Promise.resolve([]);

const search_input_noop = () => {};

const LinkControlSearchInput = (0,external_wp_element_namespaceObject.forwardRef)(({
  value,
  children,
  currentLink = {},
  className = null,
  placeholder = null,
  withCreateSuggestion = false,
  onCreateSuggestion = search_input_noop,
  onChange = search_input_noop,
  onSelect = search_input_noop,
  showSuggestions = true,
  renderSuggestions = props => (0,external_wp_element_namespaceObject.createElement)(LinkControlSearchResults, { ...props
  }),
  fetchSuggestions = null,
  allowDirectEntry = true,
  showInitialSuggestions = false,
  suggestionsQuery = {},
  withURLSuggestion = true,
  createSuggestionButtonText,
  hideLabelFromVision = false
}, ref) => {
  const genericSearchHandler = useSearchHandler(suggestionsQuery, allowDirectEntry, withCreateSuggestion, withURLSuggestion);
  const searchHandler = showSuggestions ? fetchSuggestions || genericSearchHandler : noopSearchHandler;
  const instanceId = (0,external_wp_compose_namespaceObject.useInstanceId)(LinkControlSearchInput);
  const [focusedSuggestion, setFocusedSuggestion] = (0,external_wp_element_namespaceObject.useState)();
  /**
   * Handles the user moving between different suggestions. Does not handle
   * choosing an individual item.
   *
   * @param {string} selection  the url of the selected suggestion.
   * @param {Object} suggestion the suggestion object.
   */

  const onInputChange = (selection, suggestion) => {
    onChange(selection);
    setFocusedSuggestion(suggestion);
  };

  const handleRenderSuggestions = props => renderSuggestions({ ...props,
    instanceId,
    withCreateSuggestion,
    createSuggestionButtonText,
    suggestionsQuery,
    handleSuggestionClick: suggestion => {
      if (props.handleSuggestionClick) {
        props.handleSuggestionClick(suggestion);
      }

      onSuggestionSelected(suggestion);
    }
  });

  const onSuggestionSelected = async selectedSuggestion => {
    let suggestion = selectedSuggestion;

    if (CREATE_TYPE === selectedSuggestion.type) {
      // Create a new page and call onSelect with the output from the onCreateSuggestion callback.
      try {
        suggestion = await onCreateSuggestion(selectedSuggestion.title);

        if (suggestion?.url) {
          onSelect(suggestion);
        }
      } catch (e) {}

      return;
    }

    if (allowDirectEntry || suggestion && Object.keys(suggestion).length >= 1) {
      const {
        id,
        url,
        ...restLinkProps
      } = currentLink !== null && currentLink !== void 0 ? currentLink : {};
      onSelect( // Some direct entries don't have types or IDs, and we still need to clear the previous ones.
      { ...restLinkProps,
        ...suggestion
      }, suggestion);
    }
  };

  const inputClasses = classnames_default()(className, {// 'has-no-label': ! hideLabelFromVision,
  });
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-link-control__search-input-container"
  }, (0,external_wp_element_namespaceObject.createElement)(url_input, {
    disableSuggestions: currentLink?.url === value,
    __nextHasNoMarginBottom: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Link'),
    hideLabelFromVision: hideLabelFromVision,
    className: inputClasses,
    value: value,
    onChange: onInputChange,
    placeholder: placeholder !== null && placeholder !== void 0 ? placeholder : (0,external_wp_i18n_namespaceObject.__)('Search or type url'),
    __experimentalRenderSuggestions: showSuggestions ? handleRenderSuggestions : null,
    __experimentalFetchLinkSuggestions: searchHandler,
    __experimentalHandleURLSuggestions: true,
    __experimentalShowInitialSuggestions: showInitialSuggestions,
    onSubmit: (suggestion, event) => {
      const hasSuggestion = suggestion || focusedSuggestion; // If there is no suggestion and the value (ie: any manually entered URL) is empty
      // then don't allow submission otherwise we get empty links.

      if (!hasSuggestion && !value?.trim()?.length) {
        event.preventDefault();
      } else {
        onSuggestionSelected(hasSuggestion || {
          url: value
        });
      }
    },
    ref: ref
  }), children);
});
/* harmony default export */ var search_input = (LinkControlSearchInput);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/info.js


/**
 * WordPress dependencies
 */

const info = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M12 3.2c-4.8 0-8.8 3.9-8.8 8.8 0 4.8 3.9 8.8 8.8 8.8 4.8 0 8.8-3.9 8.8-8.8 0-4.8-4-8.8-8.8-8.8zm0 16c-4 0-7.2-3.3-7.2-7.2C4.8 8 8 4.8 12 4.8s7.2 3.3 7.2 7.2c0 4-3.2 7.2-7.2 7.2zM11 17h2v-6h-2v6zm0-8h2V7h-2v2z"
}));
/* harmony default export */ var library_info = (info);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/pencil.js


/**
 * WordPress dependencies
 */

const pencil = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "m19 7-3-3-8.5 8.5-1 4 4-1L19 7Zm-7 11.5H5V20h7v-1.5Z"
}));
/* harmony default export */ var library_pencil = (pencil);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/edit.js
/**
 * Internal dependencies
 */

/* harmony default export */ var library_edit = (library_pencil);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/viewer-slot.js
/**
 * WordPress dependencies
 */

const {
  Slot: ViewerSlot,
  Fill: ViewerFill
} = (0,external_wp_components_namespaceObject.createSlotFill)('BlockEditorLinkControlViewer');

/* harmony default export */ var viewer_slot = ((/* unused pure expression or super */ null && (ViewerSlot)));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/use-rich-url-data.js
/**
 * Internal dependencies
 */

/**
 * WordPress dependencies
 */




function use_rich_url_data_reducer(state, action) {
  switch (action.type) {
    case 'RESOLVED':
      return { ...state,
        isFetching: false,
        richData: action.richData
      };

    case 'ERROR':
      return { ...state,
        isFetching: false,
        richData: null
      };

    case 'LOADING':
      return { ...state,
        isFetching: true
      };

    default:
      throw new Error(`Unexpected action type ${action.type}`);
  }
}

function useRemoteUrlData(url) {
  const [state, dispatch] = (0,external_wp_element_namespaceObject.useReducer)(use_rich_url_data_reducer, {
    richData: null,
    isFetching: false
  });
  const {
    fetchRichUrlData
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getSettings
    } = select(store);
    return {
      fetchRichUrlData: getSettings().__experimentalFetchRichUrlData
    };
  }, []);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    // Only make the request if we have an actual URL
    // and the fetching util is available. In some editors
    // there may not be such a util.
    if (url?.length && fetchRichUrlData && typeof AbortController !== 'undefined') {
      dispatch({
        type: 'LOADING'
      });
      const controller = new window.AbortController();
      const signal = controller.signal;
      fetchRichUrlData(url, {
        signal
      }).then(urlData => {
        dispatch({
          type: 'RESOLVED',
          richData: urlData
        });
      }).catch(() => {
        // Avoid setting state on unmounted component
        if (!signal.aborted) {
          dispatch({
            type: 'ERROR'
          });
        }
      }); // Cleanup: when the URL changes the abort the current request.

      return () => {
        controller.abort();
      };
    }
  }, [url]);
  return state;
}

/* harmony default export */ var use_rich_url_data = (useRemoteUrlData);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/link-preview.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */



function LinkPreview({
  value,
  onEditClick,
  hasRichPreviews = false,
  hasUnlinkControl = false,
  onRemove
}) {
  // Avoid fetching if rich previews are not desired.
  const showRichPreviews = hasRichPreviews ? value?.url : null;
  const {
    richData,
    isFetching
  } = use_rich_url_data(showRichPreviews); // Rich data may be an empty object so test for that.

  const hasRichData = richData && Object.keys(richData).length;
  const displayURL = value && (0,external_wp_url_namespaceObject.filterURLForDisplay)((0,external_wp_url_namespaceObject.safeDecodeURI)(value.url), 16) || '';
  const displayTitle = richData?.title || value?.title || displayURL; // url can be undefined if the href attribute is unset

  const isEmptyURL = !value?.url?.length;
  let icon;

  if (richData?.icon) {
    icon = (0,external_wp_element_namespaceObject.createElement)("img", {
      src: richData?.icon,
      alt: ""
    });
  } else if (isEmptyURL) {
    icon = (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
      icon: library_info,
      size: 32
    });
  } else {
    icon = (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
      icon: library_globe
    });
  }

  return (0,external_wp_element_namespaceObject.createElement)("div", {
    "aria-label": (0,external_wp_i18n_namespaceObject.__)('Currently selected'),
    className: classnames_default()('block-editor-link-control__search-item', {
      'is-current': true,
      'is-rich': hasRichData,
      'is-fetching': !!isFetching,
      'is-preview': true,
      'is-error': isEmptyURL
    })
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-link-control__search-item-top"
  }, (0,external_wp_element_namespaceObject.createElement)("span", {
    className: "block-editor-link-control__search-item-header"
  }, (0,external_wp_element_namespaceObject.createElement)("span", {
    className: classnames_default()('block-editor-link-control__search-item-icon', {
      'is-image': richData?.icon
    })
  }, icon), (0,external_wp_element_namespaceObject.createElement)("span", {
    className: "block-editor-link-control__search-item-details"
  }, !isEmptyURL ? (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ExternalLink, {
    className: "block-editor-link-control__search-item-title",
    href: value.url
  }, (0,external_wp_dom_namespaceObject.__unstableStripHTML)(displayTitle)), value?.url && (0,external_wp_element_namespaceObject.createElement)("span", {
    className: "block-editor-link-control__search-item-info"
  }, displayURL)) : (0,external_wp_element_namespaceObject.createElement)("span", {
    className: "block-editor-link-control__search-item-error-notice"
  }, (0,external_wp_i18n_namespaceObject.__)('Link is empty')))), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    icon: library_edit,
    label: (0,external_wp_i18n_namespaceObject.__)('Edit'),
    className: "block-editor-link-control__search-item-action",
    onClick: onEditClick,
    iconSize: 24
  }), hasUnlinkControl && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    icon: link_off,
    label: (0,external_wp_i18n_namespaceObject.__)('Unlink'),
    className: "block-editor-link-control__search-item-action block-editor-link-control__unlink",
    onClick: onRemove,
    iconSize: 24
  }), (0,external_wp_element_namespaceObject.createElement)(ViewerSlot, {
    fillProps: value
  })), !!(hasRichData && (richData?.image || richData?.description) || isFetching) && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-link-control__search-item-bottom"
  }, (richData?.image || isFetching) && (0,external_wp_element_namespaceObject.createElement)("div", {
    "aria-hidden": !richData?.image,
    className: classnames_default()('block-editor-link-control__search-item-image', {
      'is-placeholder': !richData?.image
    })
  }, richData?.image && (0,external_wp_element_namespaceObject.createElement)("img", {
    src: richData?.image,
    alt: ""
  })), (richData?.description || isFetching) && (0,external_wp_element_namespaceObject.createElement)("div", {
    "aria-hidden": !richData?.description,
    className: classnames_default()('block-editor-link-control__search-item-description', {
      'is-placeholder': !richData?.description
    })
  }, richData?.description && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalText, {
    truncate: true,
    numberOfLines: "2"
  }, richData.description))));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/settings.js


/**
 * WordPress dependencies
 */



const settings_noop = () => {};

const LinkControlSettings = ({
  value,
  onChange = settings_noop,
  settings
}) => {
  if (!settings || !settings.length) {
    return null;
  }

  const handleSettingChange = setting => newValue => {
    onChange({ ...value,
      [setting.id]: newValue
    });
  };

  const theSettings = settings.map(setting => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.CheckboxControl, {
    __nextHasNoMarginBottom: true,
    className: "block-editor-link-control__setting",
    key: setting.id,
    label: setting.title,
    onChange: handleSettingChange(setting),
    checked: value ? !!value[setting.id] : false
  }));
  return (0,external_wp_element_namespaceObject.createElement)("fieldset", {
    className: "block-editor-link-control__settings"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.VisuallyHidden, {
    as: "legend"
  }, (0,external_wp_i18n_namespaceObject.__)('Currently selected link settings')), theSettings);
};

/* harmony default export */ var link_control_settings = (LinkControlSettings);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/use-create-page.js
/**
 * WordPress dependencies
 */


function useCreatePage(handleCreatePage) {
  const cancelableCreateSuggestion = (0,external_wp_element_namespaceObject.useRef)();
  const [isCreatingPage, setIsCreatingPage] = (0,external_wp_element_namespaceObject.useState)(false);
  const [errorMessage, setErrorMessage] = (0,external_wp_element_namespaceObject.useState)(null);

  const createPage = async function (suggestionTitle) {
    setIsCreatingPage(true);
    setErrorMessage(null);

    try {
      // Make cancellable in order that we can avoid setting State
      // if the component unmounts during the call to `createSuggestion`
      cancelableCreateSuggestion.current = makeCancelable( // Using Promise.resolve to allow createSuggestion to return a
      // non-Promise based value.
      Promise.resolve(handleCreatePage(suggestionTitle)));
      return await cancelableCreateSuggestion.current.promise;
    } catch (error) {
      if (error && error.isCanceled) {
        return; // bail if canceled to avoid setting state
      }

      setErrorMessage(error.message || (0,external_wp_i18n_namespaceObject.__)('An unknown error occurred during creation. Please try again.'));
      throw error;
    } finally {
      setIsCreatingPage(false);
    }
  };
  /**
   * Handles cancelling any pending Promises that have been made cancelable.
   */


  (0,external_wp_element_namespaceObject.useEffect)(() => {
    return () => {
      // componentDidUnmount
      if (cancelableCreateSuggestion.current) {
        cancelableCreateSuggestion.current.cancel();
      }
    };
  }, []);
  return {
    createPage,
    isCreatingPage,
    errorMessage
  };
}
/**
 * Creates a wrapper around a promise which allows it to be programmatically
 * cancelled.
 * See: https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html
 *
 * @param {Promise} promise the Promise to make cancelable
 */

const makeCancelable = promise => {
  let hasCanceled_ = false;
  const wrappedPromise = new Promise((resolve, reject) => {
    promise.then(val => hasCanceled_ ? reject({
      isCanceled: true
    }) : resolve(val), error => hasCanceled_ ? reject({
      isCanceled: true
    }) : reject(error));
  });
  return {
    promise: wrappedPromise,

    cancel() {
      hasCanceled_ = true;
    }

  };
};

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/use-internal-value.js
/**
 * WordPress dependencies
 */

function useInternalValue(value) {
  const [internalValue, setInternalValue] = (0,external_wp_element_namespaceObject.useState)(value || {}); // If the value prop changes, update the internal state.

  (0,external_wp_element_namespaceObject.useEffect)(() => {
    setInternalValue(prevValue => {
      if (value && value !== prevValue) {
        return value;
      }

      return prevValue;
    });
  }, [value]);

  const setInternalURLInputValue = nextValue => {
    setInternalValue({ ...internalValue,
      url: nextValue
    });
  };

  const setInternalTextInputValue = nextValue => {
    setInternalValue({ ...internalValue,
      title: nextValue
    });
  };

  const createSetInternalSettingValueHandler = settingsKeys => nextValue => {
    // Only apply settings values which are defined in the settings prop.
    const settingsUpdates = Object.keys(nextValue).reduce((acc, key) => {
      if (settingsKeys.includes(key)) {
        acc[key] = nextValue[key];
      }

      return acc;
    }, {});
    setInternalValue({ ...internalValue,
      ...settingsUpdates
    });
  };

  return [internalValue, setInternalValue, setInternalURLInputValue, setInternalTextInputValue, createSetInternalSettingValueHandler];
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */









/**
 * Internal dependencies
 */









/**
 * Default properties associated with a link control value.
 *
 * @typedef WPLinkControlDefaultValue
 *
 * @property {string}   url           Link URL.
 * @property {string=}  title         Link title.
 * @property {boolean=} opensInNewTab Whether link should open in a new browser
 *                                    tab. This value is only assigned if not
 *                                    providing a custom `settings` prop.
 */

/* eslint-disable jsdoc/valid-types */

/**
 * Custom settings values associated with a link.
 *
 * @typedef {{[setting:string]:any}} WPLinkControlSettingsValue
 */

/* eslint-enable */

/**
 * Custom settings values associated with a link.
 *
 * @typedef WPLinkControlSetting
 *
 * @property {string} id    Identifier to use as property for setting value.
 * @property {string} title Human-readable label to show in user interface.
 */

/**
 * Properties associated with a link control value, composed as a union of the
 * default properties and any custom settings values.
 *
 * @typedef {WPLinkControlDefaultValue&WPLinkControlSettingsValue} WPLinkControlValue
 */

/** @typedef {(nextValue:WPLinkControlValue)=>void} WPLinkControlOnChangeProp */

/**
 * Properties associated with a search suggestion used within the LinkControl.
 *
 * @typedef WPLinkControlSuggestion
 *
 * @property {string} id    Identifier to use to uniquely identify the suggestion.
 * @property {string} type  Identifies the type of the suggestion (eg: `post`,
 *                          `page`, `url`...etc)
 * @property {string} title Human-readable label to show in user interface.
 * @property {string} url   A URL for the suggestion.
 */

/** @typedef {(title:string)=>WPLinkControlSuggestion} WPLinkControlCreateSuggestionProp */

/**
 * @typedef WPLinkControlProps
 *
 * @property {(WPLinkControlSetting[])=}  settings                   An array of settings objects. Each object will used to
 *                                                                   render a `ToggleControl` for that setting.
 * @property {boolean=}                   forceIsEditingLink         If passed as either `true` or `false`, controls the
 *                                                                   internal editing state of the component to respective
 *                                                                   show or not show the URL input field.
 * @property {WPLinkControlValue=}        value                      Current link value.
 * @property {WPLinkControlOnChangeProp=} onChange                   Value change handler, called with the updated value if
 *                                                                   the user selects a new link or updates settings.
 * @property {boolean=}                   noDirectEntry              Whether to allow turning a URL-like search query directly into a link.
 * @property {boolean=}                   showSuggestions            Whether to present suggestions when typing the URL.
 * @property {boolean=}                   showInitialSuggestions     Whether to present initial suggestions immediately.
 * @property {boolean=}                   withCreateSuggestion       Whether to allow creation of link value from suggestion.
 * @property {Object=}                    suggestionsQuery           Query parameters to pass along to wp.blockEditor.__experimentalFetchLinkSuggestions.
 * @property {boolean=}                   noURLSuggestion            Whether to add a fallback suggestion which treats the search query as a URL.
 * @property {boolean=}                   hasTextControl             Whether to add a text field to the UI to update the value.title.
 * @property {string|Function|undefined}  createSuggestionButtonText The text to use in the button that calls createSuggestion.
 * @property {Function}                   renderControlBottom        Optional controls to be rendered at the bottom of the component.
 */

const link_control_noop = () => {};

const PREFERENCE_SCOPE = 'core/block-editor';
const PREFERENCE_KEY = 'linkControlSettingsDrawer';
/**
 * Renders a link control. A link control is a controlled input which maintains
 * a value associated with a link (HTML anchor element) and relevant settings
 * for how that link is expected to behave.
 *
 * @param {WPLinkControlProps} props Component props.
 */

function LinkControl({
  searchInputPlaceholder,
  value,
  settings = DEFAULT_LINK_SETTINGS,
  onChange = link_control_noop,
  onRemove,
  onCancel,
  noDirectEntry = false,
  showSuggestions = true,
  showInitialSuggestions,
  forceIsEditingLink,
  createSuggestion,
  withCreateSuggestion,
  inputValue: propInputValue = '',
  suggestionsQuery = {},
  noURLSuggestion = false,
  createSuggestionButtonText,
  hasRichPreviews = false,
  hasTextControl = false,
  renderControlBottom = null
}) {
  if (withCreateSuggestion === undefined && createSuggestion) {
    withCreateSuggestion = true;
  }

  const [settingsOpen, setSettingsOpen] = (0,external_wp_element_namespaceObject.useState)(false);
  const {
    advancedSettingsPreference
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    var _prefsStore$get;

    const prefsStore = select(external_wp_preferences_namespaceObject.store);
    return {
      advancedSettingsPreference: (_prefsStore$get = prefsStore.get(PREFERENCE_SCOPE, PREFERENCE_KEY)) !== null && _prefsStore$get !== void 0 ? _prefsStore$get : false
    };
  }, []);
  const {
    set: setPreference
  } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_preferences_namespaceObject.store);
  /**
   * Sets the open/closed state of the Advanced Settings Drawer,
   * optionlly persisting the state to the user's preferences.
   *
   * Note that Block Editor components can be consumed by non-WordPress
   * environments which may not have preferences setup.
   * Therefore a local state is also  used as a fallback.
   *
   * @param {boolean} prefVal the open/closed state of the Advanced Settings Drawer.
   */

  const setSettingsOpenWithPreference = prefVal => {
    if (setPreference) {
      setPreference(PREFERENCE_SCOPE, PREFERENCE_KEY, prefVal);
    }

    setSettingsOpen(prefVal);
  }; // Block Editor components can be consumed by non-WordPress environments
  // which may not have these preferences setup.
  // Therefore a local state is used as a fallback.


  const isSettingsOpen = advancedSettingsPreference || settingsOpen;
  const isMounting = (0,external_wp_element_namespaceObject.useRef)(true);
  const wrapperNode = (0,external_wp_element_namespaceObject.useRef)();
  const textInputRef = (0,external_wp_element_namespaceObject.useRef)();
  const isEndingEditWithFocus = (0,external_wp_element_namespaceObject.useRef)(false);
  const settingsKeys = settings.map(({
    id
  }) => id);
  const [internalControlValue, setInternalControlValue, setInternalURLInputValue, setInternalTextInputValue, createSetInternalSettingValueHandler] = useInternalValue(value);
  const valueHasChanges = value && !(0,external_wp_isShallowEqual_namespaceObject.isShallowEqualObjects)(internalControlValue, value);
  const [isEditingLink, setIsEditingLink] = (0,external_wp_element_namespaceObject.useState)(forceIsEditingLink !== undefined ? forceIsEditingLink : !value || !value.url);
  const {
    createPage,
    isCreatingPage,
    errorMessage
  } = useCreatePage(createSuggestion);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (forceIsEditingLink !== undefined && forceIsEditingLink !== isEditingLink) {
      setIsEditingLink(forceIsEditingLink);
    } // Todo: bug if the missing dep is introduced. Will need a fix.
    // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [forceIsEditingLink]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    // We don't auto focus into the Link UI on mount
    // because otherwise using the keyboard to select text
    // *within* the link format is not possible.
    if (isMounting.current) {
      isMounting.current = false;
      return;
    } // Scenario - when:
    // - switching between editable and non editable LinkControl
    // - clicking on a link
    // ...then move focus to the *first* element to avoid focus loss
    // and to ensure focus is *within* the Link UI.


    const nextFocusTarget = external_wp_dom_namespaceObject.focus.focusable.find(wrapperNode.current)[0] || wrapperNode.current;
    nextFocusTarget.focus();
    isEndingEditWithFocus.current = false;
  }, [isEditingLink, isCreatingPage]);
  const hasLinkValue = value?.url?.trim()?.length > 0;
  /**
   * Cancels editing state and marks that focus may need to be restored after
   * the next render, if focus was within the wrapper when editing finished.
   */

  const stopEditing = () => {
    isEndingEditWithFocus.current = !!wrapperNode.current?.contains(wrapperNode.current.ownerDocument.activeElement);
    setIsEditingLink(false);
  };

  const handleSelectSuggestion = updatedValue => {
    // Suggestions may contains "settings" values (e.g. `opensInNewTab`)
    // which should not overide any existing settings values set by the
    // user. This filters out any settings values from the suggestion.
    const nonSettingsChanges = Object.keys(updatedValue).reduce((acc, key) => {
      if (!settingsKeys.includes(key)) {
        acc[key] = updatedValue[key];
      }

      return acc;
    }, {});
    onChange({ ...internalControlValue,
      ...nonSettingsChanges,
      // As title is not a setting, it must be manually applied
      // in such a way as to preserve the users changes over
      // any "title" value provided by the "suggestion".
      title: internalControlValue?.title || updatedValue?.title
    });
    stopEditing();
  };

  const handleSubmit = () => {
    if (valueHasChanges) {
      // Submit the original value with new stored values applied
      // on top. URL is a special case as it may also be a prop.
      onChange({ ...value,
        ...internalControlValue,
        url: currentUrlInputValue
      });
    }

    stopEditing();
  };

  const handleSubmitWithEnter = event => {
    const {
      keyCode
    } = event;

    if (keyCode === external_wp_keycodes_namespaceObject.ENTER && !currentInputIsEmpty // Disallow submitting empty values.
    ) {
      event.preventDefault();
      handleSubmit();
    }
  };

  const resetInternalValues = () => {
    setInternalControlValue(value);
  };

  const handleCancel = event => {
    event.preventDefault();
    event.stopPropagation(); // Ensure that any unsubmitted input changes are reset.

    resetInternalValues();

    if (hasLinkValue) {
      // If there is a link then exist editing mode and show preview.
      stopEditing();
    } else {
      // If there is no link value, then remove the link entirely.
      onRemove?.();
    }

    onCancel?.();
  };

  const currentUrlInputValue = propInputValue || internalControlValue?.url || '';
  const currentInputIsEmpty = !currentUrlInputValue?.trim()?.length;
  const shownUnlinkControl = onRemove && value && !isEditingLink && !isCreatingPage;
  const showActions = isEditingLink && hasLinkValue; // Only show text control once a URL value has been committed
  // and it isn't just empty whitespace.
  // See https://github.com/WordPress/gutenberg/pull/33849/#issuecomment-932194927.

  const showTextControl = hasLinkValue && hasTextControl;
  const isEditing = (isEditingLink || !value) && !isCreatingPage;
  const isDisabled = !valueHasChanges || currentInputIsEmpty;
  const showSettings = !!settings?.length && isEditingLink && hasLinkValue;
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    tabIndex: -1,
    ref: wrapperNode,
    className: "block-editor-link-control"
  }, isCreatingPage && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-link-control__loading"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Spinner, null), " ", (0,external_wp_i18n_namespaceObject.__)('Creating'), "\u2026"), isEditing && (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: classnames_default()({
      'block-editor-link-control__search-input-wrapper': true,
      'has-text-control': showTextControl
    })
  }, showTextControl && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.TextControl, {
    __nextHasNoMarginBottom: true,
    ref: textInputRef,
    className: "block-editor-link-control__field block-editor-link-control__text-content",
    label: (0,external_wp_i18n_namespaceObject.__)('Text'),
    value: internalControlValue?.title,
    onChange: setInternalTextInputValue,
    onKeyDown: handleSubmitWithEnter,
    size: "__unstable-large"
  }), (0,external_wp_element_namespaceObject.createElement)(search_input, {
    currentLink: value,
    className: "block-editor-link-control__field block-editor-link-control__search-input",
    placeholder: searchInputPlaceholder,
    value: currentUrlInputValue,
    withCreateSuggestion: withCreateSuggestion,
    onCreateSuggestion: createPage,
    onChange: setInternalURLInputValue,
    onSelect: handleSelectSuggestion,
    showInitialSuggestions: showInitialSuggestions,
    allowDirectEntry: !noDirectEntry,
    showSuggestions: showSuggestions,
    suggestionsQuery: suggestionsQuery,
    withURLSuggestion: !noURLSuggestion,
    createSuggestionButtonText: createSuggestionButtonText,
    hideLabelFromVision: !showTextControl
  })), errorMessage && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Notice, {
    className: "block-editor-link-control__search-error",
    status: "error",
    isDismissible: false
  }, errorMessage)), value && !isEditingLink && !isCreatingPage && (0,external_wp_element_namespaceObject.createElement)(LinkPreview, {
    key: value?.url // force remount when URL changes to avoid race conditions for rich previews
    ,
    value: value,
    onEditClick: () => setIsEditingLink(true),
    hasRichPreviews: hasRichPreviews,
    hasUnlinkControl: shownUnlinkControl,
    onRemove: onRemove
  }), showSettings && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-link-control__tools"
  }, !currentInputIsEmpty && (0,external_wp_element_namespaceObject.createElement)(settings_drawer, {
    settingsOpen: isSettingsOpen,
    setSettingsOpen: setSettingsOpenWithPreference
  }, (0,external_wp_element_namespaceObject.createElement)(link_control_settings, {
    value: internalControlValue,
    settings: settings,
    onChange: createSetInternalSettingValueHandler(settingsKeys)
  }))), showActions && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-link-control__search-actions"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    variant: "primary",
    onClick: isDisabled ? link_control_noop : handleSubmit,
    className: "block-editor-link-control__search-submit",
    "aria-disabled": isDisabled
  }, (0,external_wp_i18n_namespaceObject.__)('Save')), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    variant: "tertiary",
    onClick: handleCancel
  }, (0,external_wp_i18n_namespaceObject.__)('Cancel'))), renderControlBottom && renderControlBottom());
}

LinkControl.ViewerFill = ViewerFill;
/* harmony default export */ var link_control = (LinkControl);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/media.js


/**
 * WordPress dependencies
 */

const media = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "m7 6.5 4 2.5-4 2.5z"
}), (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "m5 3c-1.10457 0-2 .89543-2 2v14c0 1.1046.89543 2 2 2h14c1.1046 0 2-.8954 2-2v-14c0-1.10457-.8954-2-2-2zm14 1.5h-14c-.27614 0-.5.22386-.5.5v10.7072l3.62953-2.6465c.25108-.1831.58905-.1924.84981-.0234l2.92666 1.8969 3.5712-3.4719c.2911-.2831.7545-.2831 1.0456 0l2.9772 2.8945v-9.3568c0-.27614-.2239-.5-.5-.5zm-14.5 14.5v-1.4364l4.09643-2.987 2.99567 1.9417c.2936.1903.6798.1523.9307-.0917l3.4772-3.3806 3.4772 3.3806.0228-.0234v2.5968c0 .2761-.2239.5-.5.5h-14c-.27614 0-.5-.2239-.5-.5z"
}));
/* harmony default export */ var library_media = (media);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/upload.js


/**
 * WordPress dependencies
 */

const upload = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M18.5 15v3.5H13V6.7l4.5 4.1 1-1.1-6.2-5.8-5.8 5.8 1 1.1 4-4v11.7h-6V15H4v5h16v-5z"
}));
/* harmony default export */ var library_upload = (upload);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/post-featured-image.js


/**
 * WordPress dependencies
 */

const postFeaturedImage = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M19 3H5c-.6 0-1 .4-1 1v7c0 .5.4 1 1 1h14c.5 0 1-.4 1-1V4c0-.6-.4-1-1-1zM5.5 10.5v-.4l1.8-1.3 1.3.8c.3.2.7.2.9-.1L11 8.1l2.4 2.4H5.5zm13 0h-2.9l-4-4c-.3-.3-.8-.3-1.1 0L8.9 8l-1.2-.8c-.3-.2-.6-.2-.9 0l-1.3 1V4.5h13v6zM4 20h9v-1.5H4V20zm0-4h16v-1.5H4V16z"
}));
/* harmony default export */ var post_featured_image = (postFeaturedImage);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/media-replace-flow/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */











/**
 * Internal dependencies
 */






const media_replace_flow_noop = () => {};

let uniqueId = 0;

const MediaReplaceFlow = ({
  mediaURL,
  mediaId,
  mediaIds,
  allowedTypes,
  accept,
  onError,
  onSelect,
  onSelectURL,
  onToggleFeaturedImage,
  useFeaturedImage,
  onFilesUpload = media_replace_flow_noop,
  name = (0,external_wp_i18n_namespaceObject.__)('Replace'),
  createNotice,
  removeNotice,
  children,
  multiple = false,
  addToGallery,
  handleUpload = true,
  popoverProps
}) => {
  const mediaUpload = (0,external_wp_data_namespaceObject.useSelect)(select => {
    return select(store).getSettings().mediaUpload;
  }, []);
  const canUpload = !!mediaUpload;
  const editMediaButtonRef = (0,external_wp_element_namespaceObject.useRef)();
  const errorNoticeID = `block-editor/media-replace-flow/error-notice/${++uniqueId}`;

  const onUploadError = message => {
    const safeMessage = (0,external_wp_dom_namespaceObject.__unstableStripHTML)(message);

    if (onError) {
      onError(safeMessage);
      return;
    } // We need to set a timeout for showing the notice
    // so that VoiceOver and possibly other screen readers
    // can announce the error afer the toolbar button
    // regains focus once the upload dialog closes.
    // Otherwise VO simply skips over the notice and announces
    // the focused element and the open menu.


    setTimeout(() => {
      createNotice('error', safeMessage, {
        speak: true,
        id: errorNoticeID,
        isDismissible: true
      });
    }, 1000);
  };

  const selectMedia = (media, closeMenu) => {
    if (useFeaturedImage && onToggleFeaturedImage) {
      onToggleFeaturedImage();
    }

    closeMenu(); // Calling `onSelect` after the state update since it might unmount the component.

    onSelect(media);
    (0,external_wp_a11y_namespaceObject.speak)((0,external_wp_i18n_namespaceObject.__)('The media file has been replaced'));
    removeNotice(errorNoticeID);
  };

  const uploadFiles = (event, closeMenu) => {
    const files = event.target.files;

    if (!handleUpload) {
      closeMenu();
      return onSelect(files);
    }

    onFilesUpload(files);
    mediaUpload({
      allowedTypes,
      filesList: files,
      onFileChange: ([media]) => {
        selectMedia(media, closeMenu);
      },
      onError: onUploadError
    });
  };

  const openOnArrowDown = event => {
    if (event.keyCode === external_wp_keycodes_namespaceObject.DOWN) {
      event.preventDefault();
      event.target.click();
    }
  };

  const onlyAllowsImages = () => {
    if (!allowedTypes || allowedTypes.length === 0) {
      return false;
    }

    return allowedTypes.every(allowedType => allowedType === 'image' || allowedType.startsWith('image/'));
  };

  const gallery = multiple && onlyAllowsImages();
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Dropdown, {
    popoverProps: popoverProps,
    contentClassName: "block-editor-media-replace-flow__options",
    renderToggle: ({
      isOpen,
      onToggle
    }) => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarButton, {
      ref: editMediaButtonRef,
      "aria-expanded": isOpen,
      "aria-haspopup": "true",
      onClick: onToggle,
      onKeyDown: openOnArrowDown
    }, name),
    renderContent: ({
      onClose
    }) => (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.NavigableMenu, {
      className: "block-editor-media-replace-flow__media-upload-menu"
    }, (0,external_wp_element_namespaceObject.createElement)(check, null, (0,external_wp_element_namespaceObject.createElement)(media_upload, {
      gallery: gallery,
      addToGallery: addToGallery,
      multiple: multiple,
      value: multiple ? mediaIds : mediaId,
      onSelect: media => selectMedia(media, onClose),
      allowedTypes: allowedTypes,
      render: ({
        open
      }) => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
        icon: library_media,
        onClick: open
      }, (0,external_wp_i18n_namespaceObject.__)('Open Media Library'))
    }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FormFileUpload, {
      onChange: event => {
        uploadFiles(event, onClose);
      },
      accept: accept,
      multiple: multiple,
      render: ({
        openFileDialog
      }) => {
        return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
          icon: library_upload,
          onClick: () => {
            openFileDialog();
          }
        }, (0,external_wp_i18n_namespaceObject.__)('Upload'));
      }
    })), onToggleFeaturedImage && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
      icon: post_featured_image,
      onClick: onToggleFeaturedImage,
      isPressed: useFeaturedImage
    }, (0,external_wp_i18n_namespaceObject.__)('Use featured image')), children), onSelectURL && // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
    (0,external_wp_element_namespaceObject.createElement)("form", {
      className: classnames_default()('block-editor-media-flow__url-input', {
        'has-siblings': canUpload || onToggleFeaturedImage
      })
    }, (0,external_wp_element_namespaceObject.createElement)("span", {
      className: "block-editor-media-replace-flow__image-url-label"
    }, (0,external_wp_i18n_namespaceObject.__)('Current media URL:')), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Tooltip, {
      text: mediaURL,
      position: "bottom"
    }, (0,external_wp_element_namespaceObject.createElement)("div", null, (0,external_wp_element_namespaceObject.createElement)(link_control, {
      value: {
        url: mediaURL
      },
      settings: [],
      showSuggestions: false,
      onChange: ({
        url
      }) => {
        onSelectURL(url);
        editMediaButtonRef.current.focus();
      }
    })))))
  });
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/media-replace-flow/README.md
 */


/* harmony default export */ var media_replace_flow = ((0,external_wp_compose_namespaceObject.compose)([(0,external_wp_data_namespaceObject.withDispatch)(dispatch => {
  const {
    createNotice,
    removeNotice
  } = dispatch(external_wp_notices_namespaceObject.store);
  return {
    createNotice,
    removeNotice
  };
}), (0,external_wp_components_namespaceObject.withFilters)('editor.MediaReplaceFlow')])(MediaReplaceFlow));

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/keyboard-return.js


/**
 * WordPress dependencies
 */

const keyboardReturn = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "-2 -2 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M6.734 16.106l2.176-2.38-1.093-1.028-3.846 4.158 3.846 4.157 1.093-1.027-2.176-2.38h2.811c1.125 0 2.25.03 3.374 0 1.428-.001 3.362-.25 4.963-1.277 1.66-1.065 2.868-2.906 2.868-5.859 0-2.479-1.327-4.896-3.65-5.93-1.82-.813-3.044-.8-4.806-.788l-.567.002v1.5c.184 0 .368 0 .553-.002 1.82-.007 2.704-.014 4.21.657 1.854.827 2.76 2.657 2.76 4.561 0 2.472-.973 3.824-2.178 4.596-1.258.807-2.864 1.04-4.163 1.04h-.02c-1.115.03-2.229 0-3.344 0H6.734z"
}));
/* harmony default export */ var keyboard_return = (keyboardReturn);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/url-popover/link-viewer-url.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



function LinkViewerURL({
  url,
  urlLabel,
  className
}) {
  const linkClassName = classnames_default()(className, 'block-editor-url-popover__link-viewer-url');

  if (!url) {
    return (0,external_wp_element_namespaceObject.createElement)("span", {
      className: linkClassName
    });
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ExternalLink, {
    className: linkClassName,
    href: url
  }, urlLabel || (0,external_wp_url_namespaceObject.filterURLForDisplay)((0,external_wp_url_namespaceObject.safeDecodeURI)(url)));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/url-popover/link-viewer.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


function LinkViewer({
  className,
  linkClassName,
  onEditLinkClick,
  url,
  urlLabel,
  ...props
}) {
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: classnames_default()('block-editor-url-popover__link-viewer', className),
    ...props
  }, (0,external_wp_element_namespaceObject.createElement)(LinkViewerURL, {
    url: url,
    urlLabel: urlLabel,
    className: linkClassName
  }), onEditLinkClick && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    icon: library_edit,
    label: (0,external_wp_i18n_namespaceObject.__)('Edit'),
    onClick: onEditLinkClick
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/url-popover/link-editor.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


function LinkEditor({
  autocompleteRef,
  className,
  onChangeInputValue,
  value,
  ...props
}) {
  return (0,external_wp_element_namespaceObject.createElement)("form", {
    className: classnames_default()('block-editor-url-popover__link-editor', className),
    ...props
  }, (0,external_wp_element_namespaceObject.createElement)(url_input, {
    __nextHasNoMarginBottom: true,
    value: value,
    onChange: onChangeInputValue,
    autocompleteRef: autocompleteRef
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    icon: keyboard_return,
    label: (0,external_wp_i18n_namespaceObject.__)('Apply'),
    type: "submit"
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/url-popover/index.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




const {
  __experimentalPopoverLegacyPositionToPlacement
} = unlock(external_wp_components_namespaceObject.privateApis);
const DEFAULT_PLACEMENT = 'bottom';

function URLPopover({
  additionalControls,
  children,
  renderSettings,
  // The DEFAULT_PLACEMENT value is assigned inside the function's body
  placement,
  focusOnMount = 'firstElement',
  // Deprecated
  position,
  // Rest
  ...popoverProps
}) {
  if (position !== undefined) {
    external_wp_deprecated_default()('`position` prop in wp.blockEditor.URLPopover', {
      since: '6.2',
      alternative: '`placement` prop'
    });
  } // Compute popover's placement:
  // - give priority to `placement` prop, if defined
  // - otherwise, compute it from the legacy `position` prop (if defined)
  // - finally, fallback to the DEFAULT_PLACEMENT.


  let computedPlacement;

  if (placement !== undefined) {
    computedPlacement = placement;
  } else if (position !== undefined) {
    computedPlacement = __experimentalPopoverLegacyPositionToPlacement(position);
  }

  computedPlacement = computedPlacement || DEFAULT_PLACEMENT;
  const [isSettingsExpanded, setIsSettingsExpanded] = (0,external_wp_element_namespaceObject.useState)(false);
  const showSettings = !!renderSettings && isSettingsExpanded;

  const toggleSettingsVisibility = () => {
    setIsSettingsExpanded(!isSettingsExpanded);
  };

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Popover, {
    className: "block-editor-url-popover",
    focusOnMount: focusOnMount,
    placement: computedPlacement,
    shift: true,
    ...popoverProps
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-url-popover__input-container"
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-url-popover__row"
  }, children, !!renderSettings && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    className: "block-editor-url-popover__settings-toggle",
    icon: chevron_down,
    label: (0,external_wp_i18n_namespaceObject.__)('Link settings'),
    onClick: toggleSettingsVisibility,
    "aria-expanded": isSettingsExpanded
  })), showSettings && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-url-popover__row block-editor-url-popover__settings"
  }, renderSettings())), additionalControls && !showSettings && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-url-popover__additional-controls"
  }, additionalControls));
}

URLPopover.LinkEditor = LinkEditor;
URLPopover.LinkViewer = LinkViewer;
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/url-popover/README.md
 */

/* harmony default export */ var url_popover = (URLPopover);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/media-placeholder/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */








/**
 * Internal dependencies
 */






const media_placeholder_noop = () => {};

const InsertFromURLPopover = ({
  src,
  onChange,
  onSubmit,
  onClose,
  popoverAnchor
}) => (0,external_wp_element_namespaceObject.createElement)(url_popover, {
  anchor: popoverAnchor,
  onClose: onClose
}, (0,external_wp_element_namespaceObject.createElement)("form", {
  className: "block-editor-media-placeholder__url-input-form",
  onSubmit: onSubmit
}, (0,external_wp_element_namespaceObject.createElement)("input", {
  className: "block-editor-media-placeholder__url-input-field",
  type: "text",
  "aria-label": (0,external_wp_i18n_namespaceObject.__)('URL'),
  placeholder: (0,external_wp_i18n_namespaceObject.__)('Paste or type URL'),
  onChange: onChange,
  value: src
}), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
  className: "block-editor-media-placeholder__url-input-submit-button",
  icon: keyboard_return,
  label: (0,external_wp_i18n_namespaceObject.__)('Apply'),
  type: "submit"
})));

const URLSelectionUI = ({
  isURLInputVisible,
  src,
  onChangeSrc,
  onSubmitSrc,
  openURLInput,
  closeURLInput
}) => {
  // Use internal state instead of a ref to make sure that the component
  // re-renders when the popover's anchor updates.
  const [popoverAnchor, setPopoverAnchor] = (0,external_wp_element_namespaceObject.useState)(null);
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-media-placeholder__url-input-container",
    ref: setPopoverAnchor
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    className: "block-editor-media-placeholder__button",
    onClick: openURLInput,
    isPressed: isURLInputVisible,
    variant: "tertiary"
  }, (0,external_wp_i18n_namespaceObject.__)('Insert from URL')), isURLInputVisible && (0,external_wp_element_namespaceObject.createElement)(InsertFromURLPopover, {
    src: src,
    onChange: onChangeSrc,
    onSubmit: onSubmitSrc,
    onClose: closeURLInput,
    popoverAnchor: popoverAnchor
  }));
};

function MediaPlaceholder({
  value = {},
  allowedTypes,
  className,
  icon,
  labels = {},
  mediaPreview,
  notices,
  isAppender,
  accept,
  addToGallery,
  multiple = false,
  handleUpload = true,
  disableDropZone,
  disableMediaButtons,
  onError,
  onSelect,
  onCancel,
  onSelectURL,
  onToggleFeaturedImage,
  onDoubleClick,
  onFilesPreUpload = media_placeholder_noop,
  onHTMLDrop: deprecatedOnHTMLDrop,
  children,
  mediaLibraryButton,
  placeholder,
  style
}) {
  if (deprecatedOnHTMLDrop) {
    external_wp_deprecated_default()('wp.blockEditor.MediaPlaceholder onHTMLDrop prop', {
      since: '6.2',
      version: '6.4'
    });
  }

  const mediaUpload = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getSettings
    } = select(store);
    return getSettings().mediaUpload;
  }, []);
  const [src, setSrc] = (0,external_wp_element_namespaceObject.useState)('');
  const [isURLInputVisible, setIsURLInputVisible] = (0,external_wp_element_namespaceObject.useState)(false);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    var _value$src;

    setSrc((_value$src = value?.src) !== null && _value$src !== void 0 ? _value$src : '');
  }, [value?.src]);

  const onlyAllowsImages = () => {
    if (!allowedTypes || allowedTypes.length === 0) {
      return false;
    }

    return allowedTypes.every(allowedType => allowedType === 'image' || allowedType.startsWith('image/'));
  };

  const onChangeSrc = event => {
    setSrc(event.target.value);
  };

  const openURLInput = () => {
    setIsURLInputVisible(true);
  };

  const closeURLInput = () => {
    setIsURLInputVisible(false);
  };

  const onSubmitSrc = event => {
    event.preventDefault();

    if (src && onSelectURL) {
      onSelectURL(src);
      closeURLInput();
    }
  };

  const onFilesUpload = files => {
    if (!handleUpload) {
      return onSelect(files);
    }

    onFilesPreUpload(files);
    let setMedia;

    if (multiple) {
      if (addToGallery) {
        // Since the setMedia function runs multiple times per upload group
        // and is passed newMedia containing every item in its group each time, we must
        // filter out whatever this upload group had previously returned to the
        // gallery before adding and returning the image array with replacement newMedia
        // values.
        // Define an array to store urls from newMedia between subsequent function calls.
        let lastMediaPassed = [];

        setMedia = newMedia => {
          // Remove any images this upload group is responsible for (lastMediaPassed).
          // Their replacements are contained in newMedia.
          const filteredMedia = (value !== null && value !== void 0 ? value : []).filter(item => {
            // If Item has id, only remove it if lastMediaPassed has an item with that id.
            if (item.id) {
              return !lastMediaPassed.some( // Be sure to convert to number for comparison.
              ({
                id
              }) => Number(id) === Number(item.id));
            } // Compare transient images via .includes since gallery may append extra info onto the url.


            return !lastMediaPassed.some(({
              urlSlug
            }) => item.url.includes(urlSlug));
          }); // Return the filtered media array along with newMedia.

          onSelect(filteredMedia.concat(newMedia)); // Reset lastMediaPassed and set it with ids and urls from newMedia.

          lastMediaPassed = newMedia.map(media => {
            // Add everything up to '.fileType' to compare via .includes.
            const cutOffIndex = media.url.lastIndexOf('.');
            const urlSlug = media.url.slice(0, cutOffIndex);
            return {
              id: media.id,
              urlSlug
            };
          });
        };
      } else {
        setMedia = onSelect;
      }
    } else {
      setMedia = ([media]) => onSelect(media);
    }

    mediaUpload({
      allowedTypes,
      filesList: files,
      onFileChange: setMedia,
      onError
    });
  };

  async function handleBlocksDrop(blocks) {
    if (!blocks || !Array.isArray(blocks)) {
      return;
    }

    function recursivelyFindMediaFromBlocks(_blocks) {
      return _blocks.flatMap(block => (block.name === 'core/image' || block.name === 'core/audio' || block.name === 'core/video') && block.attributes.url ? [block] : recursivelyFindMediaFromBlocks(block.innerBlocks));
    }

    const mediaBlocks = recursivelyFindMediaFromBlocks(blocks);

    if (!mediaBlocks.length) {
      return;
    }

    const uploadedMediaList = await Promise.all(mediaBlocks.map(block => block.attributes.id ? block.attributes : new Promise((resolve, reject) => {
      window.fetch(block.attributes.url).then(response => response.blob()).then(blob => mediaUpload({
        filesList: [blob],
        additionalData: {
          title: block.attributes.title,
          alt_text: block.attributes.alt,
          caption: block.attributes.caption
        },
        onFileChange: ([media]) => {
          if (media.id) {
            resolve(media);
          }
        },
        allowedTypes,
        onError: reject
      })).catch(() => resolve(block.attributes.url));
    }))).catch(err => onError(err));

    if (multiple) {
      onSelect(uploadedMediaList);
    } else {
      onSelect(uploadedMediaList[0]);
    }
  }

  async function onHTMLDrop(HTML) {
    const blocks = (0,external_wp_blocks_namespaceObject.pasteHandler)({
      HTML
    });
    return await handleBlocksDrop(blocks);
  }

  const onUpload = event => {
    onFilesUpload(event.target.files);
  };

  const defaultRenderPlaceholder = content => {
    let {
      instructions,
      title
    } = labels;

    if (!mediaUpload && !onSelectURL) {
      instructions = (0,external_wp_i18n_namespaceObject.__)('To edit this block, you need permission to upload media.');
    }

    if (instructions === undefined || title === undefined) {
      const typesAllowed = allowedTypes !== null && allowedTypes !== void 0 ? allowedTypes : [];
      const [firstAllowedType] = typesAllowed;
      const isOneType = 1 === typesAllowed.length;
      const isAudio = isOneType && 'audio' === firstAllowedType;
      const isImage = isOneType && 'image' === firstAllowedType;
      const isVideo = isOneType && 'video' === firstAllowedType;

      if (instructions === undefined && mediaUpload) {
        instructions = (0,external_wp_i18n_namespaceObject.__)('Upload a media file or pick one from your media library.');

        if (isAudio) {
          instructions = (0,external_wp_i18n_namespaceObject.__)('Upload an audio file, pick one from your media library, or add one with a URL.');
        } else if (isImage) {
          instructions = (0,external_wp_i18n_namespaceObject.__)('Upload an image file, pick one from your media library, or add one with a URL.');
        } else if (isVideo) {
          instructions = (0,external_wp_i18n_namespaceObject.__)('Upload a video file, pick one from your media library, or add one with a URL.');
        }
      }

      if (title === undefined) {
        title = (0,external_wp_i18n_namespaceObject.__)('Media');

        if (isAudio) {
          title = (0,external_wp_i18n_namespaceObject.__)('Audio');
        } else if (isImage) {
          title = (0,external_wp_i18n_namespaceObject.__)('Image');
        } else if (isVideo) {
          title = (0,external_wp_i18n_namespaceObject.__)('Video');
        }
      }
    }

    const placeholderClassName = classnames_default()('block-editor-media-placeholder', className, {
      'is-appender': isAppender
    });
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Placeholder, {
      icon: icon,
      label: title,
      instructions: instructions,
      className: placeholderClassName,
      notices: notices,
      onDoubleClick: onDoubleClick,
      preview: mediaPreview,
      style: style
    }, content, children);
  };

  const renderPlaceholder = placeholder !== null && placeholder !== void 0 ? placeholder : defaultRenderPlaceholder;

  const renderDropZone = () => {
    if (disableDropZone) {
      return null;
    }

    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.DropZone, {
      onFilesDrop: onFilesUpload,
      onHTMLDrop: onHTMLDrop
    });
  };

  const renderCancelLink = () => {
    return onCancel && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
      className: "block-editor-media-placeholder__cancel-button",
      title: (0,external_wp_i18n_namespaceObject.__)('Cancel'),
      variant: "link",
      onClick: onCancel
    }, (0,external_wp_i18n_namespaceObject.__)('Cancel'));
  };

  const renderUrlSelectionUI = () => {
    return onSelectURL && (0,external_wp_element_namespaceObject.createElement)(URLSelectionUI, {
      isURLInputVisible: isURLInputVisible,
      src: src,
      onChangeSrc: onChangeSrc,
      onSubmitSrc: onSubmitSrc,
      openURLInput: openURLInput,
      closeURLInput: closeURLInput
    });
  };

  const renderFeaturedImageToggle = () => {
    return onToggleFeaturedImage && (0,external_wp_element_namespaceObject.createElement)("div", {
      className: "block-editor-media-placeholder__url-input-container"
    }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
      className: "block-editor-media-placeholder__button",
      onClick: onToggleFeaturedImage,
      variant: "tertiary"
    }, (0,external_wp_i18n_namespaceObject.__)('Use featured image')));
  };

  const renderMediaUploadChecked = () => {
    const defaultButton = ({
      open
    }) => {
      return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
        variant: "tertiary",
        onClick: () => {
          open();
        }
      }, (0,external_wp_i18n_namespaceObject.__)('Media Library'));
    };

    const libraryButton = mediaLibraryButton !== null && mediaLibraryButton !== void 0 ? mediaLibraryButton : defaultButton;
    const uploadMediaLibraryButton = (0,external_wp_element_namespaceObject.createElement)(media_upload, {
      addToGallery: addToGallery,
      gallery: multiple && onlyAllowsImages(),
      multiple: multiple,
      onSelect: onSelect,
      allowedTypes: allowedTypes,
      mode: 'browse',
      value: Array.isArray(value) ? value.map(({
        id
      }) => id) : value.id,
      render: libraryButton
    });

    if (mediaUpload && isAppender) {
      return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, renderDropZone(), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FormFileUpload, {
        onChange: onUpload,
        accept: accept,
        multiple: multiple,
        render: ({
          openFileDialog
        }) => {
          const content = (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
            variant: "primary",
            className: classnames_default()('block-editor-media-placeholder__button', 'block-editor-media-placeholder__upload-button'),
            onClick: openFileDialog
          }, (0,external_wp_i18n_namespaceObject.__)('Upload')), uploadMediaLibraryButton, renderUrlSelectionUI(), renderFeaturedImageToggle(), renderCancelLink());
          return renderPlaceholder(content);
        }
      }));
    }

    if (mediaUpload) {
      const content = (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, renderDropZone(), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FormFileUpload, {
        variant: "primary",
        className: classnames_default()('block-editor-media-placeholder__button', 'block-editor-media-placeholder__upload-button'),
        onChange: onUpload,
        accept: accept,
        multiple: multiple
      }, (0,external_wp_i18n_namespaceObject.__)('Upload')), uploadMediaLibraryButton, renderUrlSelectionUI(), renderFeaturedImageToggle(), renderCancelLink());
      return renderPlaceholder(content);
    }

    return renderPlaceholder(uploadMediaLibraryButton);
  };

  if (disableMediaButtons) {
    return (0,external_wp_element_namespaceObject.createElement)(check, null, renderDropZone());
  }

  return (0,external_wp_element_namespaceObject.createElement)(check, {
    fallback: renderPlaceholder(renderUrlSelectionUI())
  }, renderMediaUploadChecked());
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/media-placeholder/README.md
 */

/* harmony default export */ var media_placeholder = ((0,external_wp_components_namespaceObject.withFilters)('editor.MediaPlaceholder')(MediaPlaceholder));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/panel-color-settings/index.js


/**
 * Internal dependencies
 */


const PanelColorSettings = ({
  colorSettings,
  ...props
}) => {
  const settings = colorSettings.map(setting => {
    if (!setting) {
      return setting;
    }

    const {
      value,
      onChange,
      ...otherSettings
    } = setting;
    return { ...otherSettings,
      colorValue: value,
      onColorChange: onChange
    };
  });
  return (0,external_wp_element_namespaceObject.createElement)(panel_color_gradient_settings, {
    settings: settings,
    gradients: [],
    disableCustomGradients: true,
    ...props
  });
};

/* harmony default export */ var panel_color_settings = (PanelColorSettings);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/format-toolbar/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


const format_toolbar_POPOVER_PROPS = {
  placement: 'bottom-start'
};

const FormatToolbar = () => {
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, ['bold', 'italic', 'link', 'unknown'].map(format => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Slot, {
    name: `RichText.ToolbarControls.${format}`,
    key: format
  })), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Slot, {
    name: "RichText.ToolbarControls"
  }, fills => {
    if (!fills.length) {
      return null;
    }

    const allProps = fills.map(([{
      props
    }]) => props);
    const hasActive = allProps.some(({
      isActive
    }) => isActive);
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarItem, null, toggleProps => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.DropdownMenu, {
      icon: chevron_down
      /* translators: button label text should, if possible, be under 16 characters. */
      ,
      label: (0,external_wp_i18n_namespaceObject.__)('More'),
      toggleProps: { ...toggleProps,
        className: classnames_default()(toggleProps.className, {
          'is-pressed': hasActive
        }),
        describedBy: (0,external_wp_i18n_namespaceObject.__)('Displays more block tools')
      },
      controls: orderBy(fills.map(([{
        props
      }]) => props), 'title'),
      popoverProps: format_toolbar_POPOVER_PROPS
    }));
  }));
};

/* harmony default export */ var format_toolbar = (FormatToolbar);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/navigable-toolbar/index.js


/**
 * WordPress dependencies
 */






function hasOnlyToolbarItem(elements) {
  const dataProp = 'toolbarItem';
  return !elements.some(element => !(dataProp in element.dataset));
}

function getAllToolbarItemsIn(container) {
  return Array.from(container.querySelectorAll('[data-toolbar-item]'));
}

function hasFocusWithin(container) {
  return container.contains(container.ownerDocument.activeElement);
}

function focusFirstTabbableIn(container) {
  const [firstTabbable] = external_wp_dom_namespaceObject.focus.tabbable.find(container);

  if (firstTabbable) {
    firstTabbable.focus({
      // When focusing newly mounted toolbars,
      // the position of the popover is often not right on the first render
      // This prevents the layout shifts when focusing the dialogs.
      preventScroll: true
    });
  }
}

function useIsAccessibleToolbar(ref) {
  /*
   * By default, we'll assume the starting accessible state of the Toolbar
   * is true, as it seems to be the most common case.
   *
   * Transitioning from an (initial) false to true state causes the
   * <Toolbar /> component to mount twice, which is causing undesired
   * side-effects. These side-effects appear to only affect certain
   * E2E tests.
   *
   * This was initial discovered in this pull-request:
   * https://github.com/WordPress/gutenberg/pull/23425
   */
  const initialAccessibleToolbarState = true; // By default, it's gonna render NavigableMenu. If all the tabbable elements
  // inside the toolbar are ToolbarItem components (or derived components like
  // ToolbarButton), then we can wrap them with the accessible Toolbar
  // component.

  const [isAccessibleToolbar, setIsAccessibleToolbar] = (0,external_wp_element_namespaceObject.useState)(initialAccessibleToolbarState);
  const determineIsAccessibleToolbar = (0,external_wp_element_namespaceObject.useCallback)(() => {
    const tabbables = external_wp_dom_namespaceObject.focus.tabbable.find(ref.current);
    const onlyToolbarItem = hasOnlyToolbarItem(tabbables);

    if (!onlyToolbarItem) {
      external_wp_deprecated_default()('Using custom components as toolbar controls', {
        since: '5.6',
        alternative: 'ToolbarItem, ToolbarButton or ToolbarDropdownMenu components',
        link: 'https://developer.wordpress.org/block-editor/components/toolbar-button/#inside-blockcontrols'
      });
    }

    setIsAccessibleToolbar(onlyToolbarItem);
  }, []);
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    // Toolbar buttons may be rendered asynchronously, so we use
    // MutationObserver to check if the toolbar subtree has been modified.
    const observer = new window.MutationObserver(determineIsAccessibleToolbar);
    observer.observe(ref.current, {
      childList: true,
      subtree: true
    });
    return () => observer.disconnect();
  }, [isAccessibleToolbar]);
  return isAccessibleToolbar;
}

function useToolbarFocus(ref, focusOnMount, isAccessibleToolbar, defaultIndex, onIndexChange, shouldUseKeyboardFocusShortcut) {
  // Make sure we don't use modified versions of this prop.
  const [initialFocusOnMount] = (0,external_wp_element_namespaceObject.useState)(focusOnMount);
  const [initialIndex] = (0,external_wp_element_namespaceObject.useState)(defaultIndex);
  const focusToolbar = (0,external_wp_element_namespaceObject.useCallback)(() => {
    focusFirstTabbableIn(ref.current);
  }, []);

  const focusToolbarViaShortcut = () => {
    if (shouldUseKeyboardFocusShortcut) {
      focusToolbar();
    }
  }; // Focus on toolbar when pressing alt+F10 when the toolbar is visible.


  (0,external_wp_keyboardShortcuts_namespaceObject.useShortcut)('core/block-editor/focus-toolbar', focusToolbarViaShortcut);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (initialFocusOnMount) {
      focusToolbar();
    }
  }, [isAccessibleToolbar, initialFocusOnMount, focusToolbar]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    // Store ref so we have access on useEffect cleanup: https://legacy.reactjs.org/blog/2020/08/10/react-v17-rc.html#effect-cleanup-timing
    const navigableToolbarRef = ref.current; // If initialIndex is passed, we focus on that toolbar item when the
    // toolbar gets mounted and initial focus is not forced.
    // We have to wait for the next browser paint because block controls aren't
    // rendered right away when the toolbar gets mounted.

    let raf = 0;

    if (!initialFocusOnMount) {
      raf = window.requestAnimationFrame(() => {
        const items = getAllToolbarItemsIn(navigableToolbarRef);
        const index = initialIndex || 0;

        if (items[index] && hasFocusWithin(navigableToolbarRef)) {
          items[index].focus({
            // When focusing newly mounted toolbars,
            // the position of the popover is often not right on the first render
            // This prevents the layout shifts when focusing the dialogs.
            preventScroll: true
          });
        }
      });
    }

    return () => {
      window.cancelAnimationFrame(raf);
      if (!onIndexChange || !navigableToolbarRef) return; // When the toolbar element is unmounted and onIndexChange is passed, we
      // pass the focused toolbar item index so it can be hydrated later.

      const items = getAllToolbarItemsIn(navigableToolbarRef);
      const index = items.findIndex(item => item.tabIndex === 0);
      onIndexChange(index);
    };
  }, [initialIndex, initialFocusOnMount]);
}

function NavigableToolbar({
  children,
  focusOnMount,
  shouldUseKeyboardFocusShortcut = true,
  __experimentalInitialIndex: initialIndex,
  __experimentalOnIndexChange: onIndexChange,
  ...props
}) {
  const ref = (0,external_wp_element_namespaceObject.useRef)();
  const isAccessibleToolbar = useIsAccessibleToolbar(ref);
  useToolbarFocus(ref, focusOnMount, isAccessibleToolbar, initialIndex, onIndexChange, shouldUseKeyboardFocusShortcut);

  if (isAccessibleToolbar) {
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Toolbar, {
      label: props['aria-label'],
      ref: ref,
      ...props
    }, children);
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.NavigableMenu, {
    orientation: "horizontal",
    role: "toolbar",
    ref: ref,
    ...props
  }, children);
}

/* harmony default export */ var navigable_toolbar = (NavigableToolbar);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/format-toolbar-container.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */






function InlineSelectionToolbar({
  editableContentElement,
  activeFormats
}) {
  const lastFormat = activeFormats[activeFormats.length - 1];
  const lastFormatType = lastFormat?.type;
  const settings = (0,external_wp_data_namespaceObject.useSelect)(select => select(external_wp_richText_namespaceObject.store).getFormatType(lastFormatType), [lastFormatType]);
  const popoverAnchor = (0,external_wp_richText_namespaceObject.useAnchor)({
    editableContentElement,
    settings
  });
  return (0,external_wp_element_namespaceObject.createElement)(InlineToolbar, {
    popoverAnchor: popoverAnchor
  });
}

function InlineToolbar({
  popoverAnchor
}) {
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Popover, {
    placement: "top",
    focusOnMount: false,
    anchor: popoverAnchor,
    className: "block-editor-rich-text__inline-format-toolbar",
    __unstableSlotName: "block-toolbar"
  }, (0,external_wp_element_namespaceObject.createElement)(navigable_toolbar, {
    className: "block-editor-rich-text__inline-format-toolbar-group"
    /* translators: accessibility text for the inline format toolbar */
    ,
    "aria-label": (0,external_wp_i18n_namespaceObject.__)('Format tools')
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarGroup, null, (0,external_wp_element_namespaceObject.createElement)(format_toolbar, null))));
}

const FormatToolbarContainer = ({
  inline,
  editableContentElement,
  value
}) => {
  const hasInlineToolbar = (0,external_wp_data_namespaceObject.useSelect)(select => select(store).getSettings().hasInlineToolbar, []);

  if (inline) {
    return (0,external_wp_element_namespaceObject.createElement)(InlineToolbar, {
      popoverAnchor: editableContentElement
    });
  }

  if (hasInlineToolbar) {
    const activeFormats = (0,external_wp_richText_namespaceObject.getActiveFormats)(value);

    if ((0,external_wp_richText_namespaceObject.isCollapsed)(value) && !activeFormats.length) {
      return null;
    }

    return (0,external_wp_element_namespaceObject.createElement)(InlineSelectionToolbar, {
      editableContentElement: editableContentElement,
      activeFormats: activeFormats
    });
  } // Render regular toolbar.


  return (0,external_wp_element_namespaceObject.createElement)(block_controls, {
    group: "inline"
  }, (0,external_wp_element_namespaceObject.createElement)(format_toolbar, null));
};

/* harmony default export */ var format_toolbar_container = (FormatToolbarContainer);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-undo-automatic-change.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


function useUndoAutomaticChange() {
  const {
    didAutomaticChange,
    getSettings
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(element => {
    function onKeyDown(event) {
      const {
        keyCode
      } = event;

      if (event.defaultPrevented) {
        return;
      }

      if (keyCode !== external_wp_keycodes_namespaceObject.DELETE && keyCode !== external_wp_keycodes_namespaceObject.BACKSPACE && keyCode !== external_wp_keycodes_namespaceObject.ESCAPE) {
        return;
      }

      const {
        __experimentalUndo
      } = getSettings();

      if (!__experimentalUndo) {
        return;
      }

      if (!didAutomaticChange()) {
        return;
      }

      event.preventDefault();

      __experimentalUndo();
    }

    element.addEventListener('keydown', onKeyDown);
    return () => {
      element.removeEventListener('keydown', onKeyDown);
    };
  }, []);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-mark-persistent.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function useMarkPersistent({
  html,
  value
}) {
  const previousText = (0,external_wp_element_namespaceObject.useRef)();
  const hasActiveFormats = value.activeFormats && !!value.activeFormats.length;
  const {
    __unstableMarkLastChangeAsPersistent
  } = (0,external_wp_data_namespaceObject.useDispatch)(store); // Must be set synchronously to make sure it applies to the last change.

  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    // Ignore mount.
    if (!previousText.current) {
      previousText.current = value.text;
      return;
    } // Text input, so don't create an undo level for every character.
    // Create an undo level after 1 second of no input.


    if (previousText.current !== value.text) {
      const timeout = window.setTimeout(() => {
        __unstableMarkLastChangeAsPersistent();
      }, 1000);
      previousText.current = value.text;
      return () => {
        window.clearTimeout(timeout);
      };
    }

    __unstableMarkLastChangeAsPersistent();
  }, [html, hasActiveFormats]);
}

;// CONCATENATED MODULE: external ["wp","shortcode"]
var external_wp_shortcode_namespaceObject = window["wp"]["shortcode"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/utils.js


/**
 * WordPress dependencies
 */



function addActiveFormats(value, activeFormats) {
  if (activeFormats?.length) {
    let index = value.formats.length;

    while (index--) {
      value.formats[index] = [...activeFormats, ...(value.formats[index] || [])];
    }
  }
}
/**
 * Get the multiline tag based on the multiline prop.
 *
 * @param {?(string|boolean)} multiline The multiline prop.
 *
 * @return {string | undefined} The multiline tag.
 */

function getMultilineTag(multiline) {
  if (multiline !== true && multiline !== 'p' && multiline !== 'li') {
    return;
  }

  return multiline === true ? 'p' : multiline;
}
function getAllowedFormats({
  allowedFormats,
  disableFormats
}) {
  if (disableFormats) {
    return getAllowedFormats.EMPTY_ARRAY;
  }

  return allowedFormats;
}
getAllowedFormats.EMPTY_ARRAY = [];
const isShortcode = text => (0,external_wp_shortcode_namespaceObject.regexp)('.*').test(text);
/**
 * Creates a link from pasted URL.
 * Creates a paragraph block containing a link to the URL, and calls `onReplace`.
 *
 * @param {string}   url       The URL that could not be embedded.
 * @param {Function} onReplace Function to call with the created fallback block.
 */

function createLinkInParagraph(url, onReplace) {
  const link = createElement("a", {
    href: url
  }, url);
  onReplace(createBlock('core/paragraph', {
    content: renderToString(link)
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/split-value.js
/**
 * WordPress dependencies
 */

/*
 * Signals to the RichText owner that the block can be replaced with two blocks
 * as a result of splitting the block by pressing enter, or with blocks as a
 * result of splitting the block by pasting block content in the instance.
 */

function splitValue({
  value,
  pastedBlocks = [],
  onReplace,
  onSplit,
  onSplitMiddle,
  multilineTag
}) {
  if (!onReplace || !onSplit) {
    return;
  } // Ensure the value has a selection. This might happen when trying to split
  // an empty value before there was a `selectionchange` event.


  const {
    start = 0,
    end = 0
  } = value;
  const valueWithEnsuredSelection = { ...value,
    start,
    end
  };
  const blocks = [];
  const [before, after] = (0,external_wp_richText_namespaceObject.split)(valueWithEnsuredSelection);
  const hasPastedBlocks = pastedBlocks.length > 0;
  let lastPastedBlockIndex = -1; // Consider the after value to be the original it is not empty and the
  // before value *is* empty.

  const isAfterOriginal = (0,external_wp_richText_namespaceObject.isEmpty)(before) && !(0,external_wp_richText_namespaceObject.isEmpty)(after); // Create a block with the content before the caret if there's no pasted
  // blocks, or if there are pasted blocks and the value is not empty. We do
  // not want a leading empty block on paste, but we do if split with e.g. the
  // enter key.

  if (!hasPastedBlocks || !(0,external_wp_richText_namespaceObject.isEmpty)(before)) {
    blocks.push(onSplit((0,external_wp_richText_namespaceObject.toHTMLString)({
      value: before,
      multilineTag
    }), !isAfterOriginal));
    lastPastedBlockIndex += 1;
  }

  if (hasPastedBlocks) {
    blocks.push(...pastedBlocks);
    lastPastedBlockIndex += pastedBlocks.length;
  } else if (onSplitMiddle) {
    blocks.push(onSplitMiddle());
  } // If there's pasted blocks, append a block with non empty content / after
  // the caret. Otherwise, do append an empty block if there is no
  // `onSplitMiddle` prop, but if there is and the content is empty, the
  // middle block is enough to set focus in.


  if (hasPastedBlocks ? !(0,external_wp_richText_namespaceObject.isEmpty)(after) : !onSplitMiddle || !(0,external_wp_richText_namespaceObject.isEmpty)(after)) {
    blocks.push(onSplit((0,external_wp_richText_namespaceObject.toHTMLString)({
      value: after,
      multilineTag
    }), isAfterOriginal));
  } // If there are pasted blocks, set the selection to the last one. Otherwise,
  // set the selection to the second block.


  const indexToSelect = hasPastedBlocks ? lastPastedBlockIndex : 1; // If there are pasted blocks, move the caret to the end of the selected
  // block Otherwise, retain the default value.

  const initialPosition = hasPastedBlocks ? -1 : 0;
  onReplace(blocks, indexToSelect, initialPosition);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-paste-handler.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




/** @typedef {import('@wordpress/rich-text').RichTextValue} RichTextValue */

/**
 * Replaces line separators with line breaks if not multiline.
 * Replaces line breaks with line separators if multiline.
 *
 * @param {RichTextValue} value       Value to adjust.
 * @param {boolean}       isMultiline Whether to adjust to multiline or not.
 *
 * @return {RichTextValue} Adjusted value.
 */

function adjustLines(value, isMultiline) {
  if (isMultiline) {
    return (0,external_wp_richText_namespaceObject.replace)(value, /\n+/g, external_wp_richText_namespaceObject.__UNSTABLE_LINE_SEPARATOR);
  }

  return (0,external_wp_richText_namespaceObject.replace)(value, new RegExp(external_wp_richText_namespaceObject.__UNSTABLE_LINE_SEPARATOR, 'g'), '\n');
}

function usePasteHandler(props) {
  const propsRef = (0,external_wp_element_namespaceObject.useRef)(props);
  propsRef.current = props;
  return (0,external_wp_compose_namespaceObject.useRefEffect)(element => {
    function _onPaste(event) {
      const {
        isSelected,
        disableFormats,
        onChange,
        value,
        formatTypes,
        tagName,
        onReplace,
        onSplit,
        onSplitMiddle,
        __unstableEmbedURLOnPaste,
        multilineTag,
        preserveWhiteSpace,
        pastePlainText
      } = propsRef.current;

      if (!isSelected) {
        return;
      }

      const {
        clipboardData
      } = event;
      let plainText = '';
      let html = ''; // IE11 only supports `Text` as an argument for `getData` and will
      // otherwise throw an invalid argument error, so we try the standard
      // arguments first, then fallback to `Text` if they fail.

      try {
        plainText = clipboardData.getData('text/plain');
        html = clipboardData.getData('text/html');
      } catch (error1) {
        try {
          html = clipboardData.getData('Text');
        } catch (error2) {
          // Some browsers like UC Browser paste plain text by default and
          // don't support clipboardData at all, so allow default
          // behaviour.
          return;
        }
      } // Remove Windows-specific metadata appended within copied HTML text.


      html = removeWindowsFragments(html); // Strip meta tag.

      html = removeCharsetMetaTag(html);
      event.preventDefault(); // Allows us to ask for this information when we get a report.

      window.console.log('Received HTML:\n\n', html);
      window.console.log('Received plain text:\n\n', plainText);

      if (disableFormats) {
        onChange((0,external_wp_richText_namespaceObject.insert)(value, plainText));
        return;
      }

      const transformed = formatTypes.reduce((accumlator, {
        __unstablePasteRule
      }) => {
        // Only allow one transform.
        if (__unstablePasteRule && accumlator === value) {
          accumlator = __unstablePasteRule(value, {
            html,
            plainText
          });
        }

        return accumlator;
      }, value);

      if (transformed !== value) {
        onChange(transformed);
        return;
      }

      const files = [...(0,external_wp_dom_namespaceObject.getFilesFromDataTransfer)(clipboardData)];
      const isInternal = clipboardData.getData('rich-text') === 'true'; // If the data comes from a rich text instance, we can directly use it
      // without filtering the data. The filters are only meant for externally
      // pasted content and remove inline styles.

      if (isInternal) {
        const pastedMultilineTag = clipboardData.getData('rich-text-multi-line-tag') || undefined;
        let pastedValue = (0,external_wp_richText_namespaceObject.create)({
          html,
          multilineTag: pastedMultilineTag,
          multilineWrapperTags: pastedMultilineTag === 'li' ? ['ul', 'ol'] : undefined,
          preserveWhiteSpace
        });
        pastedValue = adjustLines(pastedValue, !!multilineTag);
        addActiveFormats(pastedValue, value.activeFormats);
        onChange((0,external_wp_richText_namespaceObject.insert)(value, pastedValue));
        return;
      }

      if (pastePlainText) {
        onChange((0,external_wp_richText_namespaceObject.insert)(value, (0,external_wp_richText_namespaceObject.create)({
          text: plainText
        })));
        return;
      }

      if (files?.length) {
        // Allows us to ask for this information when we get a report.
        // eslint-disable-next-line no-console
        window.console.log('Received items:\n\n', files);
      } // Process any attached files, unless we infer that the files in
      // question are redundant "screenshots" of the actual HTML payload,
      // as created by certain office-type programs.
      //
      // @see shouldDismissPastedFiles


      if (files?.length && !shouldDismissPastedFiles(files, html, plainText)) {
        const fromTransforms = (0,external_wp_blocks_namespaceObject.getBlockTransforms)('from');
        const blocks = files.reduce((accumulator, file) => {
          const transformation = (0,external_wp_blocks_namespaceObject.findTransform)(fromTransforms, transform => transform.type === 'files' && transform.isMatch([file]));

          if (transformation) {
            accumulator.push(transformation.transform([file]));
          }

          return accumulator;
        }, []).flat();

        if (!blocks.length) {
          return;
        }

        if (onReplace && (0,external_wp_richText_namespaceObject.isEmpty)(value)) {
          onReplace(blocks);
        } else {
          splitValue({
            value,
            pastedBlocks: blocks,
            onReplace,
            onSplit,
            onSplitMiddle,
            multilineTag
          });
        }

        return;
      }

      let mode = onReplace && onSplit ? 'AUTO' : 'INLINE'; // Force the blocks mode when the user is pasting
      // on a new line & the content resembles a shortcode.
      // Otherwise it's going to be detected as inline
      // and the shortcode won't be replaced.

      if (mode === 'AUTO' && (0,external_wp_richText_namespaceObject.isEmpty)(value) && isShortcode(plainText)) {
        mode = 'BLOCKS';
      }

      if (__unstableEmbedURLOnPaste && (0,external_wp_richText_namespaceObject.isEmpty)(value) && (0,external_wp_url_namespaceObject.isURL)(plainText.trim())) {
        mode = 'BLOCKS';
      }

      const content = (0,external_wp_blocks_namespaceObject.pasteHandler)({
        HTML: html,
        plainText,
        mode,
        tagName,
        preserveWhiteSpace
      });

      if (typeof content === 'string') {
        let valueToInsert = (0,external_wp_richText_namespaceObject.create)({
          html: content
        }); // If the content should be multiline, we should process text
        // separated by a line break as separate lines.

        valueToInsert = adjustLines(valueToInsert, !!multilineTag);
        addActiveFormats(valueToInsert, value.activeFormats);
        onChange((0,external_wp_richText_namespaceObject.insert)(value, valueToInsert));
      } else if (content.length > 0) {
        if (onReplace && (0,external_wp_richText_namespaceObject.isEmpty)(value)) {
          onReplace(content, content.length - 1, -1);
        } else {
          splitValue({
            value,
            pastedBlocks: content,
            onReplace,
            onSplit,
            onSplitMiddle,
            multilineTag
          });
        }
      }
    }

    element.addEventListener('paste', _onPaste);
    return () => {
      element.removeEventListener('paste', _onPaste);
    };
  }, []);
}
/**
 * Normalizes a given string of HTML to remove the Windows-specific "Fragment"
 * comments and any preceding and trailing content.
 *
 * @param {string} html the html to be normalized
 * @return {string} the normalized html
 */

function removeWindowsFragments(html) {
  const startStr = '<!--StartFragment-->';
  const startIdx = html.indexOf(startStr);

  if (startIdx > -1) {
    html = html.substring(startIdx + startStr.length);
  } else {
    // No point looking for EndFragment
    return html;
  }

  const endStr = '<!--EndFragment-->';
  const endIdx = html.indexOf(endStr);

  if (endIdx > -1) {
    html = html.substring(0, endIdx);
  }

  return html;
}
/**
 * Removes the charset meta tag inserted by Chromium.
 * See:
 * - https://github.com/WordPress/gutenberg/issues/33585
 * - https://bugs.chromium.org/p/chromium/issues/detail?id=1264616#c4
 *
 * @param {string} html the html to be stripped of the meta tag.
 * @return {string} the cleaned html
 */


function removeCharsetMetaTag(html) {
  const metaTag = `<meta charset='utf-8'>`;

  if (html.startsWith(metaTag)) {
    return html.slice(metaTag.length);
  }

  return html;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-before-input-rules.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


/**
 * When typing over a selection, the selection will we wrapped by a matching
 * character pair. The second character is optional, it defaults to the first
 * character.
 *
 * @type {string[]} Array of character pairs.
 */

const wrapSelectionSettings = ['`', '"', "'", '“”', '‘’'];
function useBeforeInputRules(props) {
  const {
    __unstableMarkLastChangeAsPersistent,
    __unstableMarkAutomaticChange
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const propsRef = (0,external_wp_element_namespaceObject.useRef)(props);
  propsRef.current = props;
  return (0,external_wp_compose_namespaceObject.useRefEffect)(element => {
    function onInput(event) {
      const {
        inputType,
        data
      } = event;
      const {
        value,
        onChange
      } = propsRef.current; // Only run the rules when inserting text.

      if (inputType !== 'insertText') {
        return;
      }

      if ((0,external_wp_richText_namespaceObject.isCollapsed)(value)) {
        return;
      }

      const pair = (0,external_wp_hooks_namespaceObject.applyFilters)('blockEditor.wrapSelectionSettings', wrapSelectionSettings).find(([startChar, endChar]) => startChar === data || endChar === data);

      if (!pair) {
        return;
      }

      const [startChar, endChar = startChar] = pair;
      const start = value.start;
      const end = value.end + startChar.length;
      let newValue = (0,external_wp_richText_namespaceObject.insert)(value, startChar, start, start);
      newValue = (0,external_wp_richText_namespaceObject.insert)(newValue, endChar, end, end);

      __unstableMarkLastChangeAsPersistent();

      onChange(newValue);

      __unstableMarkAutomaticChange();

      const init = {};

      for (const key in event) {
        init[key] = event[key];
      }

      init.data = endChar;
      const {
        ownerDocument
      } = element;
      const {
        defaultView
      } = ownerDocument;
      const newEvent = new defaultView.InputEvent('input', init); // Dispatch an `input` event with the new data. This will trigger the
      // input rules.
      // Postpone the `input` to the next event loop tick so that the dispatch
      // doesn't happen synchronously in the middle of `beforeinput` dispatch.
      // This is closer to how native `input` event would be timed, and also
      // makes sure that the `input` event is dispatched only after the `onChange`
      // call few lines above has fully updated the data store state and rerendered
      // all affected components.

      window.queueMicrotask(() => {
        event.target.dispatchEvent(newEvent);
      });
      event.preventDefault();
    }

    element.addEventListener('beforeinput', onInput);
    return () => {
      element.removeEventListener('beforeinput', onInput);
    };
  }, []);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/prevent-event-discovery.js
/**
 * WordPress dependencies
 */

function preventEventDiscovery(value) {
  const searchText = 'tales of gutenberg';
  const addText = ' 🐡🐢🦀🐤🦋🐘🐧🐹🦁🦄🦍🐼🐿🎃🐴🐝🐆🦕🦔🌱🍇π🍌🐉💧🥨🌌🍂🍠🥦🥚🥝🎟🥥🥒🛵🥖🍒🍯🎾🎲🐺🐚🐮⌛️';
  const {
    start,
    text
  } = value;

  if (start < searchText.length) {
    return value;
  }

  const charactersBefore = text.slice(start - searchText.length, start);

  if (charactersBefore.toLowerCase() !== searchText) {
    return value;
  }

  return (0,external_wp_richText_namespaceObject.insert)(value, addText);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-input-rules.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */





function findSelection(blocks) {
  let i = blocks.length;

  while (i--) {
    const attributeKey = retrieveSelectedAttribute(blocks[i].attributes);

    if (attributeKey) {
      blocks[i].attributes[attributeKey] = blocks[i].attributes[attributeKey].replace(START_OF_SELECTED_AREA, '');
      return [blocks[i].clientId, attributeKey, 0, 0];
    }

    const nestedSelection = findSelection(blocks[i].innerBlocks);

    if (nestedSelection) {
      return nestedSelection;
    }
  }

  return [];
}

function useInputRules(props) {
  const {
    __unstableMarkLastChangeAsPersistent,
    __unstableMarkAutomaticChange
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const propsRef = (0,external_wp_element_namespaceObject.useRef)(props);
  propsRef.current = props;
  return (0,external_wp_compose_namespaceObject.useRefEffect)(element => {
    function inputRule() {
      const {
        getValue,
        onReplace,
        selectionChange
      } = propsRef.current;

      if (!onReplace) {
        return;
      } // We must use getValue() here because value may be update
      // asynchronously.


      const value = getValue();
      const {
        start,
        text
      } = value;
      const characterBefore = text.slice(start - 1, start); // The character right before the caret must be a plain space.

      if (characterBefore !== ' ') {
        return;
      }

      const trimmedTextBefore = text.slice(0, start).trim();
      const prefixTransforms = (0,external_wp_blocks_namespaceObject.getBlockTransforms)('from').filter(({
        type
      }) => type === 'prefix');
      const transformation = (0,external_wp_blocks_namespaceObject.findTransform)(prefixTransforms, ({
        prefix
      }) => {
        return trimmedTextBefore === prefix;
      });

      if (!transformation) {
        return;
      }

      const content = (0,external_wp_richText_namespaceObject.toHTMLString)({
        value: (0,external_wp_richText_namespaceObject.insert)(value, START_OF_SELECTED_AREA, 0, start)
      });
      const block = transformation.transform(content);
      selectionChange(...findSelection([block]));
      onReplace([block]);

      __unstableMarkAutomaticChange();

      return true;
    }

    function onInput(event) {
      const {
        inputType,
        type
      } = event;
      const {
        getValue,
        onChange,
        __unstableAllowPrefixTransformations,
        formatTypes
      } = propsRef.current; // Only run input rules when inserting text.

      if (inputType !== 'insertText' && type !== 'compositionend') {
        return;
      }

      if (__unstableAllowPrefixTransformations && inputRule) {
        if (inputRule()) return;
      }

      const value = getValue();
      const transformed = formatTypes.reduce((accumlator, {
        __unstableInputRule
      }) => {
        if (__unstableInputRule) {
          accumlator = __unstableInputRule(accumlator);
        }

        return accumlator;
      }, preventEventDiscovery(value));

      if (transformed !== value) {
        __unstableMarkLastChangeAsPersistent();

        onChange({ ...transformed,
          activeFormats: value.activeFormats
        });

        __unstableMarkAutomaticChange();
      }
    }

    element.addEventListener('input', onInput);
    element.addEventListener('compositionend', onInput);
    return () => {
      element.removeEventListener('input', onInput);
      element.removeEventListener('compositionend', onInput);
    };
  }, []);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-delete.js
/**
 * WordPress dependencies
 */




function useDelete(props) {
  const propsRef = (0,external_wp_element_namespaceObject.useRef)(props);
  propsRef.current = props;
  return (0,external_wp_compose_namespaceObject.useRefEffect)(element => {
    function onKeyDown(event) {
      const {
        keyCode
      } = event;

      if (event.defaultPrevented) {
        return;
      }

      const {
        value,
        onMerge,
        onRemove
      } = propsRef.current;

      if (keyCode === external_wp_keycodes_namespaceObject.DELETE || keyCode === external_wp_keycodes_namespaceObject.BACKSPACE) {
        const {
          start,
          end,
          text
        } = value;
        const isReverse = keyCode === external_wp_keycodes_namespaceObject.BACKSPACE;
        const hasActiveFormats = value.activeFormats && !!value.activeFormats.length; // Only process delete if the key press occurs at an uncollapsed edge.

        if (!(0,external_wp_richText_namespaceObject.isCollapsed)(value) || hasActiveFormats || isReverse && start !== 0 || !isReverse && end !== text.length) {
          return;
        }

        if (onMerge) {
          onMerge(!isReverse);
        } // Only handle remove on Backspace. This serves dual-purpose of being
        // an intentional user interaction distinguishing between Backspace and
        // Delete to remove the empty field, but also to avoid merge & remove
        // causing destruction of two fields (merge, then removed merged).


        if (onRemove && (0,external_wp_richText_namespaceObject.isEmpty)(value) && isReverse) {
          onRemove(!isReverse);
        }

        event.preventDefault();
      }
    }

    element.addEventListener('keydown', onKeyDown);
    return () => {
      element.removeEventListener('keydown', onKeyDown);
    };
  }, []);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-enter.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */



function useEnter(props) {
  const {
    __unstableMarkAutomaticChange
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const propsRef = (0,external_wp_element_namespaceObject.useRef)(props);
  propsRef.current = props;
  return (0,external_wp_compose_namespaceObject.useRefEffect)(element => {
    function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }

      if (event.keyCode !== external_wp_keycodes_namespaceObject.ENTER) {
        return;
      }

      const {
        removeEditorOnlyFormats,
        value,
        onReplace,
        onSplit,
        onSplitMiddle,
        multilineTag,
        onChange,
        disableLineBreaks,
        onSplitAtEnd
      } = propsRef.current;
      event.preventDefault();
      const _value = { ...value
      };
      _value.formats = removeEditorOnlyFormats(value);
      const canSplit = onReplace && onSplit;

      if (onReplace) {
        const transforms = (0,external_wp_blocks_namespaceObject.getBlockTransforms)('from').filter(({
          type
        }) => type === 'enter');
        const transformation = (0,external_wp_blocks_namespaceObject.findTransform)(transforms, item => {
          return item.regExp.test(_value.text);
        });

        if (transformation) {
          onReplace([transformation.transform({
            content: _value.text
          })]);

          __unstableMarkAutomaticChange();
        }
      }

      if (multilineTag) {
        if (event.shiftKey) {
          if (!disableLineBreaks) {
            onChange((0,external_wp_richText_namespaceObject.insert)(_value, '\n'));
          }
        } else if (canSplit && (0,external_wp_richText_namespaceObject.__unstableIsEmptyLine)(_value)) {
          splitValue({
            value: _value,
            onReplace,
            onSplit,
            onSplitMiddle,
            multilineTag
          });
        } else {
          onChange((0,external_wp_richText_namespaceObject.__unstableInsertLineSeparator)(_value));
        }
      } else {
        const {
          text,
          start,
          end
        } = _value;
        const canSplitAtEnd = onSplitAtEnd && start === end && end === text.length;

        if (event.shiftKey || !canSplit && !canSplitAtEnd) {
          if (!disableLineBreaks) {
            onChange((0,external_wp_richText_namespaceObject.insert)(_value, '\n'));
          }
        } else if (!canSplit && canSplitAtEnd) {
          onSplitAtEnd();
        } else if (canSplit) {
          splitValue({
            value: _value,
            onReplace,
            onSplit,
            onSplitMiddle,
            multilineTag
          });
        }
      }
    }

    element.addEventListener('keydown', onKeyDown);
    return () => {
      element.removeEventListener('keydown', onKeyDown);
    };
  }, []);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-format-types.js
/**
 * WordPress dependencies
 */




function formatTypesSelector(select) {
  return select(external_wp_richText_namespaceObject.store).getFormatTypes();
}
/**
 * Set of all interactive content tags.
 *
 * @see https://html.spec.whatwg.org/multipage/dom.html#interactive-content
 */


const interactiveContentTags = new Set(['a', 'audio', 'button', 'details', 'embed', 'iframe', 'input', 'label', 'select', 'textarea', 'video']);

function prefixSelectKeys(selected, prefix) {
  if (typeof selected !== 'object') return {
    [prefix]: selected
  };
  return Object.fromEntries(Object.entries(selected).map(([key, value]) => [`${prefix}.${key}`, value]));
}

function getPrefixedSelectKeys(selected, prefix) {
  if (selected[prefix]) return selected[prefix];
  return Object.keys(selected).filter(key => key.startsWith(prefix + '.')).reduce((accumulator, key) => {
    accumulator[key.slice(prefix.length + 1)] = selected[key];
    return accumulator;
  }, {});
}
/**
 * This hook provides RichText with the `formatTypes` and its derived props from
 * experimental format type settings.
 *
 * @param {Object}  $0                              Options
 * @param {string}  $0.clientId                     Block client ID.
 * @param {string}  $0.identifier                   Block attribute.
 * @param {boolean} $0.withoutInteractiveFormatting Whether to clean the interactive formattings or not.
 * @param {Array}   $0.allowedFormats               Allowed formats
 */


function useFormatTypes({
  clientId,
  identifier,
  withoutInteractiveFormatting,
  allowedFormats
}) {
  const allFormatTypes = (0,external_wp_data_namespaceObject.useSelect)(formatTypesSelector, []);
  const formatTypes = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return allFormatTypes.filter(({
      name,
      interactive,
      tagName
    }) => {
      if (allowedFormats && !allowedFormats.includes(name)) {
        return false;
      }

      if (withoutInteractiveFormatting && (interactive || interactiveContentTags.has(tagName))) {
        return false;
      }

      return true;
    });
  }, [allFormatTypes, allowedFormats, withoutInteractiveFormatting]);
  const keyedSelected = (0,external_wp_data_namespaceObject.useSelect)(select => formatTypes.reduce((accumulator, type) => {
    if (!type.__experimentalGetPropsForEditableTreePreparation) {
      return accumulator;
    }

    return { ...accumulator,
      ...prefixSelectKeys(type.__experimentalGetPropsForEditableTreePreparation(select, {
        richTextIdentifier: identifier,
        blockClientId: clientId
      }), type.name)
    };
  }, {}), [formatTypes, clientId, identifier]);
  const dispatch = (0,external_wp_data_namespaceObject.useDispatch)();
  const prepareHandlers = [];
  const valueHandlers = [];
  const changeHandlers = [];
  const dependencies = [];

  for (const key in keyedSelected) {
    dependencies.push(keyedSelected[key]);
  }

  formatTypes.forEach(type => {
    if (type.__experimentalCreatePrepareEditableTree) {
      const handler = type.__experimentalCreatePrepareEditableTree(getPrefixedSelectKeys(keyedSelected, type.name), {
        richTextIdentifier: identifier,
        blockClientId: clientId
      });

      if (type.__experimentalCreateOnChangeEditableValue) {
        valueHandlers.push(handler);
      } else {
        prepareHandlers.push(handler);
      }
    }

    if (type.__experimentalCreateOnChangeEditableValue) {
      let dispatchers = {};

      if (type.__experimentalGetPropsForEditableTreeChangeHandler) {
        dispatchers = type.__experimentalGetPropsForEditableTreeChangeHandler(dispatch, {
          richTextIdentifier: identifier,
          blockClientId: clientId
        });
      }

      const selected = getPrefixedSelectKeys(keyedSelected, type.name);
      changeHandlers.push(type.__experimentalCreateOnChangeEditableValue({ ...(typeof selected === 'object' ? selected : {}),
        ...dispatchers
      }, {
        richTextIdentifier: identifier,
        blockClientId: clientId
      }));
    }
  });
  return {
    formatTypes,
    prepareHandlers,
    valueHandlers,
    changeHandlers,
    dependencies
  };
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-remove-browser-shortcuts.js
/**
 * WordPress dependencies
 */


/**
 * Hook to prevent default behaviors for key combinations otherwise handled
 * internally by RichText.
 *
 * @return {import('react').RefObject} The component to be rendered.
 */

function useRemoveBrowserShortcuts() {
  return (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    function onKeydown(event) {
      if (external_wp_keycodes_namespaceObject.isKeyboardEvent.primary(event, 'z') || external_wp_keycodes_namespaceObject.isKeyboardEvent.primary(event, 'y') || external_wp_keycodes_namespaceObject.isKeyboardEvent.primaryShift(event, 'z')) {
        event.preventDefault();
      }
    }

    node.addEventListener('keydown', onKeydown);
    return () => {
      node.addEventListener('keydown', onKeydown);
    };
  }, []);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-shortcuts.js
/**
 * WordPress dependencies
 */

function useShortcuts(keyboardShortcuts) {
  return (0,external_wp_compose_namespaceObject.useRefEffect)(element => {
    function onKeyDown(event) {
      for (const keyboardShortcut of keyboardShortcuts.current) {
        keyboardShortcut(event);
      }
    }

    element.addEventListener('keydown', onKeyDown);
    return () => {
      element.removeEventListener('keydown', onKeyDown);
    };
  }, []);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-input-events.js
/**
 * WordPress dependencies
 */

function useInputEvents(inputEvents) {
  return (0,external_wp_compose_namespaceObject.useRefEffect)(element => {
    function onInput(event) {
      for (const keyboardShortcut of inputEvents.current) {
        keyboardShortcut(event);
      }
    }

    element.addEventListener('input', onInput);
    return () => {
      element.removeEventListener('input', onInput);
    };
  }, []);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-insert-replacement-text.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * When the browser is about to auto correct, add an undo level so the user can
 * revert the change.
 */

function useInsertReplacementText() {
  const {
    __unstableMarkLastChangeAsPersistent
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(element => {
    function onInput(event) {
      if (event.inputType === 'insertReplacementText') {
        __unstableMarkLastChangeAsPersistent();
      }
    }

    element.addEventListener('beforeinput', onInput);
    return () => {
      element.removeEventListener('beforeinput', onInput);
    };
  }, []);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-firefox-compat.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


function useFirefoxCompat(props) {
  const propsRef = (0,external_wp_element_namespaceObject.useRef)(props);
  propsRef.current = props;
  const {
    isMultiSelecting
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(element => {
    function onFocus() {
      if (!isMultiSelecting()) {
        return;
      } // This is a little hack to work around focus issues with nested
      // editable elements in Firefox. For some reason the editable child
      // element sometimes regains focus, while it should not be focusable
      // and focus should remain on the editable parent element.
      // To do: try to find the cause of the shifting focus.


      const parentEditable = element.parentElement.closest('[contenteditable="true"]');

      if (parentEditable) {
        parentEditable.focus();
      }
    } // If a contenteditable element is inside a button/summary element,
    // it is not possible to type a space in Firefox. Therefore, cancel
    // the default event and insert a space explicitly.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1822860


    function onKeyDown(event) {
      if (event.keyCode !== external_wp_keycodes_namespaceObject.SPACE) {
        return;
      }

      if (element.closest('button, summary') === null) {
        return;
      }

      const {
        value,
        onChange
      } = propsRef.current;
      onChange((0,external_wp_richText_namespaceObject.insert)(value, ' '));
      event.preventDefault();
    }

    element.addEventListener('focus', onFocus);
    element.addEventListener('keydown', onKeyDown);
    return () => {
      element.removeEventListener('focus', onFocus);
      element.removeEventListener('keydown', onKeyDown);
    };
  }, []);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/format-edit.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


const format_edit_DEFAULT_BLOCK_CONTEXT = {};
const usesContextKey = Symbol('usesContext');

function format_edit_Edit({
  onChange,
  onFocus,
  value,
  forwardedRef,
  settings
}) {
  const {
    name,
    edit: EditFunction,
    [usesContextKey]: usesContext
  } = settings;
  const blockContext = (0,external_wp_element_namespaceObject.useContext)(block_context); // Assign context values using the block type's declared context needs.

  const context = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return usesContext ? Object.fromEntries(Object.entries(blockContext).filter(([key]) => usesContext.includes(key))) : format_edit_DEFAULT_BLOCK_CONTEXT;
  }, [usesContext, blockContext]);

  if (!EditFunction) {
    return null;
  }

  const activeFormat = (0,external_wp_richText_namespaceObject.getActiveFormat)(value, name);
  const isActive = activeFormat !== undefined;
  const activeObject = (0,external_wp_richText_namespaceObject.getActiveObject)(value);
  const isObjectActive = activeObject !== undefined && activeObject.type === name;
  return (0,external_wp_element_namespaceObject.createElement)(EditFunction, {
    key: name,
    isActive: isActive,
    activeAttributes: isActive ? activeFormat.attributes || {} : {},
    isObjectActive: isObjectActive,
    activeObjectAttributes: isObjectActive ? activeObject.attributes || {} : {},
    value: value,
    onChange: onChange,
    onFocus: onFocus,
    contentRef: forwardedRef,
    context: context
  });
}

function FormatEdit({
  formatTypes,
  ...props
}) {
  return formatTypes.map(settings => (0,external_wp_element_namespaceObject.createElement)(format_edit_Edit, {
    settings: settings,
    ...props,
    key: settings.name
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/content.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


const Content = ({
  value,
  tagName: Tag,
  multiline,
  ...props
}) => {
  // Handle deprecated `children` and `node` sources.
  if (Array.isArray(value)) {
    external_wp_deprecated_default()('wp.blockEditor.RichText value prop as children type', {
      since: '6.1',
      version: '6.3',
      alternative: 'value prop as string',
      link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
    });
    value = external_wp_blocks_namespaceObject.children.toHTML(value);
  }

  const MultilineTag = getMultilineTag(multiline);

  if (!value && MultilineTag) {
    value = `<${MultilineTag}></${MultilineTag}>`;
  }

  const content = (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.RawHTML, null, value);

  if (Tag) {
    const {
      format,
      ...restProps
    } = props;
    return (0,external_wp_element_namespaceObject.createElement)(Tag, { ...restProps
    }, content);
  }

  return content;
};

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */








/**
 * Internal dependencies
 */





















const keyboardShortcutContext = (0,external_wp_element_namespaceObject.createContext)();
const inputEventContext = (0,external_wp_element_namespaceObject.createContext)();
/**
 * Removes props used for the native version of RichText so that they are not
 * passed to the DOM element and log warnings.
 *
 * @param {Object} props Props to filter.
 *
 * @return {Object} Filtered props.
 */

function removeNativeProps(props) {
  const {
    __unstableMobileNoFocusOnMount,
    deleteEnter,
    placeholderTextColor,
    textAlign,
    selectionColor,
    tagsToEliminate,
    disableEditingMenu,
    fontSize,
    fontFamily,
    fontWeight,
    fontStyle,
    minWidth,
    maxWidth,
    setRef,
    disableSuggestions,
    disableAutocorrection,
    ...restProps
  } = props;
  return restProps;
}

function RichTextWrapper({
  children,
  tagName = 'div',
  value: originalValue = '',
  onChange: originalOnChange,
  isSelected: originalIsSelected,
  multiline,
  inlineToolbar,
  wrapperClassName,
  autocompleters,
  onReplace,
  placeholder,
  allowedFormats,
  withoutInteractiveFormatting,
  onRemove,
  onMerge,
  onSplit,
  __unstableOnSplitAtEnd: onSplitAtEnd,
  __unstableOnSplitMiddle: onSplitMiddle,
  identifier,
  preserveWhiteSpace,
  __unstablePastePlainText: pastePlainText,
  __unstableEmbedURLOnPaste,
  __unstableDisableFormats: disableFormats,
  disableLineBreaks,
  __unstableAllowPrefixTransformations,
  ...props
}, forwardedRef) {
  if (multiline) {
    external_wp_deprecated_default()('wp.blockEditor.RichText multiline prop', {
      since: '6.1',
      version: '6.3',
      alternative: 'nested blocks (InnerBlocks)',
      link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/nested-blocks-inner-blocks/'
    });
  }

  const instanceId = (0,external_wp_compose_namespaceObject.useInstanceId)(RichTextWrapper);
  identifier = identifier || instanceId;
  props = removeNativeProps(props);
  const anchorRef = (0,external_wp_element_namespaceObject.useRef)();
  const {
    clientId
  } = useBlockEditContext();

  const selector = select => {
    const {
      getSelectionStart,
      getSelectionEnd
    } = select(store);
    const selectionStart = getSelectionStart();
    const selectionEnd = getSelectionEnd();
    let isSelected;

    if (originalIsSelected === undefined) {
      isSelected = selectionStart.clientId === clientId && selectionEnd.clientId === clientId && selectionStart.attributeKey === identifier;
    } else if (originalIsSelected) {
      isSelected = selectionStart.clientId === clientId;
    }

    return {
      selectionStart: isSelected ? selectionStart.offset : undefined,
      selectionEnd: isSelected ? selectionEnd.offset : undefined,
      isSelected
    };
  }; // This selector must run on every render so the right selection state is
  // retreived from the store on merge.
  // To do: fix this somehow.


  const {
    selectionStart,
    selectionEnd,
    isSelected
  } = (0,external_wp_data_namespaceObject.useSelect)(selector);
  const {
    getSelectionStart,
    getSelectionEnd,
    getBlockRootClientId
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    selectionChange
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const multilineTag = getMultilineTag(multiline);
  const adjustedAllowedFormats = getAllowedFormats({
    allowedFormats,
    disableFormats
  });
  const hasFormats = !adjustedAllowedFormats || adjustedAllowedFormats.length > 0;
  let adjustedValue = originalValue;
  let adjustedOnChange = originalOnChange; // Handle deprecated format.

  if (Array.isArray(originalValue)) {
    external_wp_deprecated_default()('wp.blockEditor.RichText value prop as children type', {
      since: '6.1',
      version: '6.3',
      alternative: 'value prop as string',
      link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
    });
    adjustedValue = external_wp_blocks_namespaceObject.children.toHTML(originalValue);

    adjustedOnChange = newValue => originalOnChange(external_wp_blocks_namespaceObject.children.fromDOM((0,external_wp_richText_namespaceObject.__unstableCreateElement)(document, newValue).childNodes));
  }

  const onSelectionChange = (0,external_wp_element_namespaceObject.useCallback)((start, end) => {
    const selection = {};
    const unset = start === undefined && end === undefined;

    if (typeof start === 'number' || unset) {
      // If we are only setting the start (or the end below), which
      // means a partial selection, and we're not updating a selection
      // with the same client ID, abort. This means the selected block
      // is a parent block.
      if (end === undefined && getBlockRootClientId(clientId) !== getBlockRootClientId(getSelectionEnd().clientId)) {
        return;
      }

      selection.start = {
        clientId,
        attributeKey: identifier,
        offset: start
      };
    }

    if (typeof end === 'number' || unset) {
      if (start === undefined && getBlockRootClientId(clientId) !== getBlockRootClientId(getSelectionStart().clientId)) {
        return;
      }

      selection.end = {
        clientId,
        attributeKey: identifier,
        offset: end
      };
    }

    selectionChange(selection);
  }, [clientId, identifier]);
  const {
    formatTypes,
    prepareHandlers,
    valueHandlers,
    changeHandlers,
    dependencies
  } = useFormatTypes({
    clientId,
    identifier,
    withoutInteractiveFormatting,
    allowedFormats: adjustedAllowedFormats
  });

  function addEditorOnlyFormats(value) {
    return valueHandlers.reduce((accumulator, fn) => fn(accumulator, value.text), value.formats);
  }

  function removeEditorOnlyFormats(value) {
    formatTypes.forEach(formatType => {
      // Remove formats created by prepareEditableTree, because they are editor only.
      if (formatType.__experimentalCreatePrepareEditableTree) {
        value = (0,external_wp_richText_namespaceObject.removeFormat)(value, formatType.name, 0, value.text.length);
      }
    });
    return value.formats;
  }

  function addInvisibleFormats(value) {
    return prepareHandlers.reduce((accumulator, fn) => fn(accumulator, value.text), value.formats);
  }

  const {
    value,
    getValue,
    onChange,
    ref: richTextRef
  } = (0,external_wp_richText_namespaceObject.__unstableUseRichText)({
    value: adjustedValue,

    onChange(html, {
      __unstableFormats,
      __unstableText
    }) {
      adjustedOnChange(html);
      Object.values(changeHandlers).forEach(changeHandler => {
        changeHandler(__unstableFormats, __unstableText);
      });
    },

    selectionStart,
    selectionEnd,
    onSelectionChange,
    placeholder,
    __unstableIsSelected: isSelected,
    __unstableMultilineTag: multilineTag,
    __unstableDisableFormats: disableFormats,
    preserveWhiteSpace,
    __unstableDependencies: [...dependencies, tagName],
    __unstableAfterParse: addEditorOnlyFormats,
    __unstableBeforeSerialize: removeEditorOnlyFormats,
    __unstableAddInvisibleFormats: addInvisibleFormats
  });
  const autocompleteProps = useBlockEditorAutocompleteProps({
    onReplace,
    completers: autocompleters,
    record: value,
    onChange
  });
  useMarkPersistent({
    html: adjustedValue,
    value
  });
  const keyboardShortcuts = (0,external_wp_element_namespaceObject.useRef)(new Set());
  const inputEvents = (0,external_wp_element_namespaceObject.useRef)(new Set());

  function onFocus() {
    anchorRef.current?.focus();
  }

  const TagName = tagName;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, isSelected && (0,external_wp_element_namespaceObject.createElement)(keyboardShortcutContext.Provider, {
    value: keyboardShortcuts
  }, (0,external_wp_element_namespaceObject.createElement)(inputEventContext.Provider, {
    value: inputEvents
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Popover.__unstableSlotNameProvider, {
    value: "__unstable-block-tools-after"
  }, children && children({
    value,
    onChange,
    onFocus
  }), (0,external_wp_element_namespaceObject.createElement)(FormatEdit, {
    value: value,
    onChange: onChange,
    onFocus: onFocus,
    formatTypes: formatTypes,
    forwardedRef: anchorRef
  })))), isSelected && hasFormats && (0,external_wp_element_namespaceObject.createElement)(format_toolbar_container, {
    inline: inlineToolbar,
    editableContentElement: anchorRef.current,
    value: value
  }), (0,external_wp_element_namespaceObject.createElement)(TagName // Overridable props.
  , {
    role: "textbox",
    "aria-multiline": !disableLineBreaks,
    "aria-label": placeholder,
    ...props,
    ...autocompleteProps,
    ref: (0,external_wp_compose_namespaceObject.useMergeRefs)([forwardedRef, autocompleteProps.ref, props.ref, richTextRef, useBeforeInputRules({
      value,
      onChange
    }), useInputRules({
      getValue,
      onChange,
      __unstableAllowPrefixTransformations,
      formatTypes,
      onReplace,
      selectionChange
    }), useInsertReplacementText(), useRemoveBrowserShortcuts(), useShortcuts(keyboardShortcuts), useInputEvents(inputEvents), useUndoAutomaticChange(), usePasteHandler({
      isSelected,
      disableFormats,
      onChange,
      value,
      formatTypes,
      tagName,
      onReplace,
      onSplit,
      onSplitMiddle,
      __unstableEmbedURLOnPaste,
      multilineTag,
      preserveWhiteSpace,
      pastePlainText
    }), useDelete({
      value,
      onMerge,
      onRemove
    }), useEnter({
      removeEditorOnlyFormats,
      value,
      onReplace,
      onSplit,
      onSplitMiddle,
      multilineTag,
      onChange,
      disableLineBreaks,
      onSplitAtEnd
    }), useFirefoxCompat({
      value,
      onChange
    }), anchorRef]),
    contentEditable: true,
    suppressContentEditableWarning: true,
    className: classnames_default()('block-editor-rich-text__editable', props.className, 'rich-text') // Setting tabIndex to 0 is unnecessary, the element is already
    // focusable because it's contentEditable. This also fixes a
    // Safari bug where it's not possible to Shift+Click multi
    // select blocks when Shift Clicking into an element with
    // tabIndex because Safari will focus the element. However,
    // Safari will correctly ignore nested contentEditable elements.
    ,
    tabIndex: props.tabIndex === 0 ? null : props.tabIndex
  }));
}

const ForwardedRichTextContainer = (0,external_wp_element_namespaceObject.forwardRef)(RichTextWrapper);
ForwardedRichTextContainer.Content = Content;

ForwardedRichTextContainer.isEmpty = value => {
  return !value || value.length === 0;
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/rich-text/README.md
 */


/* harmony default export */ var rich_text = (ForwardedRichTextContainer);




;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/editable-text/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


const EditableText = (0,external_wp_element_namespaceObject.forwardRef)((props, ref) => {
  return (0,external_wp_element_namespaceObject.createElement)(rich_text, {
    ref: ref,
    ...props,
    __unstableDisableFormats: true,
    preserveWhiteSpace: true
  });
});

EditableText.Content = ({
  value = '',
  tagName: Tag = 'div',
  ...props
}) => {
  return (0,external_wp_element_namespaceObject.createElement)(Tag, { ...props
  }, value);
};
/**
 * Renders an editable text input in which text formatting is not allowed.
 */


/* harmony default export */ var editable_text = (EditableText);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/plain-text/index.js


/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/plain-text/README.md
 */

const PlainText = (0,external_wp_element_namespaceObject.forwardRef)(({
  __experimentalVersion,
  ...props
}, ref) => {
  if (__experimentalVersion === 2) {
    return (0,external_wp_element_namespaceObject.createElement)(editable_text, {
      ref: ref,
      ...props
    });
  }

  const {
    className,
    onChange,
    ...remainingProps
  } = props;
  return (0,external_wp_element_namespaceObject.createElement)(lib/* default */.Z, {
    ref: ref,
    className: classnames_default()('block-editor-plain-text', className),
    onChange: event => onChange(event.target.value),
    ...remainingProps
  });
});
/* harmony default export */ var plain_text = (PlainText);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/responsive-block-control/label.js


/**
 * WordPress dependencies
 */



function ResponsiveBlockControlLabel({
  property,
  viewport,
  desc
}) {
  const instanceId = (0,external_wp_compose_namespaceObject.useInstanceId)(ResponsiveBlockControlLabel);
  const accessibleLabel = desc || (0,external_wp_i18n_namespaceObject.sprintf)(
  /* translators: 1: property name. 2: viewport name. */
  (0,external_wp_i18n_namespaceObject._x)('Controls the %1$s property for %2$s viewports.', 'Text labelling a interface as controlling a given layout property (eg: margin) for a given screen size.'), property, viewport.label);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)("span", {
    "aria-describedby": `rbc-desc-${instanceId}`
  }, viewport.label), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.VisuallyHidden, {
    as: "span",
    id: `rbc-desc-${instanceId}`
  }, accessibleLabel));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/responsive-block-control/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



function ResponsiveBlockControl(props) {
  const {
    title,
    property,
    toggleLabel,
    onIsResponsiveChange,
    renderDefaultControl,
    renderResponsiveControls,
    isResponsive = false,
    defaultLabel = {
      id: 'all',

      /* translators: 'Label. Used to signify a layout property (eg: margin, padding) will apply uniformly to all screensizes.' */
      label: (0,external_wp_i18n_namespaceObject.__)('All')
    },
    viewports = [{
      id: 'small',
      label: (0,external_wp_i18n_namespaceObject.__)('Small screens')
    }, {
      id: 'medium',
      label: (0,external_wp_i18n_namespaceObject.__)('Medium screens')
    }, {
      id: 'large',
      label: (0,external_wp_i18n_namespaceObject.__)('Large screens')
    }]
  } = props;

  if (!title || !property || !renderDefaultControl) {
    return null;
  }

  const toggleControlLabel = toggleLabel || (0,external_wp_i18n_namespaceObject.sprintf)(
  /* translators: 'Toggle control label. Should the property be the same across all screen sizes or unique per screen size.'. %s property value for the control (eg: margin, padding...etc) */
  (0,external_wp_i18n_namespaceObject.__)('Use the same %s on all screensizes.'), property);
  /* translators: 'Help text for the responsive mode toggle control.' */

  const toggleHelpText = (0,external_wp_i18n_namespaceObject.__)('Toggle between using the same value for all screen sizes or using a unique value per screen size.');

  const defaultControl = renderDefaultControl((0,external_wp_element_namespaceObject.createElement)(ResponsiveBlockControlLabel, {
    property: property,
    viewport: defaultLabel
  }), defaultLabel);

  const defaultResponsiveControls = () => {
    return viewports.map(viewport => (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, {
      key: viewport.id
    }, renderDefaultControl((0,external_wp_element_namespaceObject.createElement)(ResponsiveBlockControlLabel, {
      property: property,
      viewport: viewport
    }), viewport)));
  };

  return (0,external_wp_element_namespaceObject.createElement)("fieldset", {
    className: "block-editor-responsive-block-control"
  }, (0,external_wp_element_namespaceObject.createElement)("legend", {
    className: "block-editor-responsive-block-control__title"
  }, title), (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-responsive-block-control__inner"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToggleControl, {
    __nextHasNoMarginBottom: true,
    className: "block-editor-responsive-block-control__toggle",
    label: toggleControlLabel,
    checked: !isResponsive,
    onChange: onIsResponsiveChange,
    help: toggleHelpText
  }), (0,external_wp_element_namespaceObject.createElement)("div", {
    className: classnames_default()('block-editor-responsive-block-control__group', {
      'is-responsive': isResponsive
    })
  }, !isResponsive && defaultControl, isResponsive && (renderResponsiveControls ? renderResponsiveControls(viewports) : defaultResponsiveControls()))));
}

/* harmony default export */ var responsive_block_control = (ResponsiveBlockControl);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/shortcut.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function RichTextShortcut({
  character,
  type,
  onUse
}) {
  const keyboardShortcuts = (0,external_wp_element_namespaceObject.useContext)(keyboardShortcutContext);
  const onUseRef = (0,external_wp_element_namespaceObject.useRef)();
  onUseRef.current = onUse;
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    function callback(event) {
      if (external_wp_keycodes_namespaceObject.isKeyboardEvent[type](event, character)) {
        onUseRef.current();
        event.preventDefault();
      }
    }

    keyboardShortcuts.current.add(callback);
    return () => {
      keyboardShortcuts.current.delete(callback);
    };
  }, [character, type]);
  return null;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/toolbar-button.js


/**
 * WordPress dependencies
 */


function RichTextToolbarButton({
  name,
  shortcutType,
  shortcutCharacter,
  ...props
}) {
  let shortcut;
  let fillName = 'RichText.ToolbarControls';

  if (name) {
    fillName += `.${name}`;
  }

  if (shortcutType && shortcutCharacter) {
    shortcut = external_wp_keycodes_namespaceObject.displayShortcut[shortcutType](shortcutCharacter);
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Fill, {
    name: fillName
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarButton, { ...props,
    shortcut: shortcut
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/input-event.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


function __unstableRichTextInputEvent({
  inputType,
  onInput
}) {
  const callbacks = (0,external_wp_element_namespaceObject.useContext)(inputEventContext);
  const onInputRef = (0,external_wp_element_namespaceObject.useRef)();
  onInputRef.current = onInput;
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    function callback(event) {
      if (event.inputType === inputType) {
        onInputRef.current();
        event.preventDefault();
      }
    }

    callbacks.current.add(callback);
    return () => {
      callbacks.current.delete(callback);
    };
  }, [inputType]);
  return null;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/tool-selector/index.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


const selectIcon = (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Path, {
  d: "M9.4 20.5L5.2 3.8l14.6 9-2 .3c-.2 0-.4.1-.7.1-.9.2-1.6.3-2.2.5-.8.3-1.4.5-1.8.8-.4.3-.8.8-1.3 1.5-.4.5-.8 1.2-1.2 2l-.3.6-.9 1.9zM7.6 7.1l2.4 9.3c.2-.4.5-.8.7-1.1.6-.8 1.1-1.4 1.6-1.8.5-.4 1.3-.8 2.2-1.1l1.2-.3-8.1-5z"
}));

function ToolSelector(props, ref) {
  const mode = (0,external_wp_data_namespaceObject.useSelect)(select => select(store).__unstableGetEditorMode(), []);
  const {
    __unstableSetEditorMode
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Dropdown, {
    renderToggle: ({
      isOpen,
      onToggle
    }) => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, { ...props,
      ref: ref,
      icon: mode === 'navigation' ? selectIcon : library_edit,
      "aria-expanded": isOpen,
      "aria-haspopup": "true",
      onClick: onToggle
      /* translators: button label text should, if possible, be under 16 characters. */
      ,
      label: (0,external_wp_i18n_namespaceObject.__)('Tools')
    }),
    popoverProps: {
      placement: 'bottom-start'
    },
    renderContent: () => (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.NavigableMenu, {
      role: "menu",
      "aria-label": (0,external_wp_i18n_namespaceObject.__)('Tools')
    }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItemsChoice, {
      value: mode === 'navigation' ? 'navigation' : 'edit',
      onSelect: __unstableSetEditorMode,
      choices: [{
        value: 'edit',
        label: (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
          icon: library_edit
        }), (0,external_wp_i18n_namespaceObject.__)('Edit'))
      }, {
        value: 'navigation',
        label: (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, selectIcon, (0,external_wp_i18n_namespaceObject.__)('Select'))
      }]
    })), (0,external_wp_element_namespaceObject.createElement)("div", {
      className: "block-editor-tool-selector__help"
    }, (0,external_wp_i18n_namespaceObject.__)('Tools provide different interactions for selecting, navigating, and editing blocks. Toggle between select and edit by pressing Escape and Enter.')))
  });
}

/* harmony default export */ var tool_selector = ((0,external_wp_element_namespaceObject.forwardRef)(ToolSelector));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/unit-control/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


function UnitControl({
  units: unitsProp,
  ...props
}) {
  const units = (0,external_wp_components_namespaceObject.__experimentalUseCustomUnits)({
    availableUnits: use_setting_useSetting('spacing.units') || ['%', 'px', 'em', 'rem', 'vw'],
    units: unitsProp
  });
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalUnitControl, {
    units: units,
    ...props
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/arrow-left.js


/**
 * WordPress dependencies
 */

const arrowLeft = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M20 11.2H6.8l3.7-3.7-1-1L3.9 12l5.6 5.5 1-1-3.7-3.7H20z"
}));
/* harmony default export */ var arrow_left = (arrowLeft);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/url-input/button.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



class URLInputButton extends external_wp_element_namespaceObject.Component {
  constructor() {
    super(...arguments);
    this.toggle = this.toggle.bind(this);
    this.submitLink = this.submitLink.bind(this);
    this.state = {
      expanded: false
    };
  }

  toggle() {
    this.setState({
      expanded: !this.state.expanded
    });
  }

  submitLink(event) {
    event.preventDefault();
    this.toggle();
  }

  render() {
    const {
      url,
      onChange
    } = this.props;
    const {
      expanded
    } = this.state;
    const buttonLabel = url ? (0,external_wp_i18n_namespaceObject.__)('Edit link') : (0,external_wp_i18n_namespaceObject.__)('Insert link');
    return (0,external_wp_element_namespaceObject.createElement)("div", {
      className: "block-editor-url-input__button"
    }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
      icon: library_link,
      label: buttonLabel,
      onClick: this.toggle,
      className: "components-toolbar__control",
      isPressed: !!url
    }), expanded && (0,external_wp_element_namespaceObject.createElement)("form", {
      className: "block-editor-url-input__button-modal",
      onSubmit: this.submitLink
    }, (0,external_wp_element_namespaceObject.createElement)("div", {
      className: "block-editor-url-input__button-modal-line"
    }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
      className: "block-editor-url-input__back",
      icon: arrow_left,
      label: (0,external_wp_i18n_namespaceObject.__)('Close'),
      onClick: this.toggle
    }), (0,external_wp_element_namespaceObject.createElement)(url_input, {
      __nextHasNoMarginBottom: true,
      value: url || '',
      onChange: onChange
    }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
      icon: keyboard_return,
      label: (0,external_wp_i18n_namespaceObject.__)('Submit'),
      type: "submit"
    }))));
  }

}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/url-input/README.md
 */


/* harmony default export */ var url_input_button = (URLInputButton);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/url-popover/image-url-input-ui.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


const LINK_DESTINATION_NONE = 'none';
const LINK_DESTINATION_CUSTOM = 'custom';
const LINK_DESTINATION_MEDIA = 'media';
const LINK_DESTINATION_ATTACHMENT = 'attachment';
const NEW_TAB_REL = ['noreferrer', 'noopener'];
const icon = (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SVG, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Path, {
  d: "M0,0h24v24H0V0z",
  fill: "none"
}), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Path, {
  d: "m19 5v14h-14v-14h14m0-2h-14c-1.1 0-2 0.9-2 2v14c0 1.1 0.9 2 2 2h14c1.1 0 2-0.9 2-2v-14c0-1.1-0.9-2-2-2z"
}), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Path, {
  d: "m14.14 11.86l-3 3.87-2.14-2.59-3 3.86h12l-3.86-5.14z"
}));

const ImageURLInputUI = ({
  linkDestination,
  onChangeUrl,
  url,
  mediaType = 'image',
  mediaUrl,
  mediaLink,
  linkTarget,
  linkClass,
  rel
}) => {
  const [isOpen, setIsOpen] = (0,external_wp_element_namespaceObject.useState)(false); // Use internal state instead of a ref to make sure that the component
  // re-renders when the popover's anchor updates.

  const [popoverAnchor, setPopoverAnchor] = (0,external_wp_element_namespaceObject.useState)(null);

  const openLinkUI = () => {
    setIsOpen(true);
  };

  const [isEditingLink, setIsEditingLink] = (0,external_wp_element_namespaceObject.useState)(false);
  const [urlInput, setUrlInput] = (0,external_wp_element_namespaceObject.useState)(null);
  const autocompleteRef = (0,external_wp_element_namespaceObject.useRef)(null);

  const startEditLink = () => {
    if (linkDestination === LINK_DESTINATION_MEDIA || linkDestination === LINK_DESTINATION_ATTACHMENT) {
      setUrlInput('');
    }

    setIsEditingLink(true);
  };

  const stopEditLink = () => {
    setIsEditingLink(false);
  };

  const closeLinkUI = () => {
    setUrlInput(null);
    stopEditLink();
    setIsOpen(false);
  };

  const getUpdatedLinkTargetSettings = value => {
    const newLinkTarget = value ? '_blank' : undefined;
    let updatedRel;

    if (newLinkTarget) {
      const rels = (rel !== null && rel !== void 0 ? rel : '').split(' ');
      NEW_TAB_REL.forEach(relVal => {
        if (!rels.includes(relVal)) {
          rels.push(relVal);
        }
      });
      updatedRel = rels.join(' ');
    } else {
      const rels = (rel !== null && rel !== void 0 ? rel : '').split(' ').filter(relVal => NEW_TAB_REL.includes(relVal) === false);
      updatedRel = rels.length ? rels.join(' ') : undefined;
    }

    return {
      linkTarget: newLinkTarget,
      rel: updatedRel
    };
  };

  const onFocusOutside = () => {
    return event => {
      // The autocomplete suggestions list renders in a separate popover (in a portal),
      // so onFocusOutside fails to detect that a click on a suggestion occurred in the
      // LinkContainer. Detect clicks on autocomplete suggestions using a ref here, and
      // return to avoid the popover being closed.
      const autocompleteElement = autocompleteRef.current;

      if (autocompleteElement && autocompleteElement.contains(event.target)) {
        return;
      }

      setIsOpen(false);
      setUrlInput(null);
      stopEditLink();
    };
  };

  const onSubmitLinkChange = () => {
    return event => {
      if (urlInput) {
        // It is possible the entered URL actually matches a named link destination.
        // This check will ensure our link destination is correct.
        const selectedDestination = getLinkDestinations().find(destination => destination.url === urlInput)?.linkDestination || LINK_DESTINATION_CUSTOM;
        onChangeUrl({
          href: urlInput,
          linkDestination: selectedDestination
        });
      }

      stopEditLink();
      setUrlInput(null);
      event.preventDefault();
    };
  };

  const onLinkRemove = () => {
    onChangeUrl({
      linkDestination: LINK_DESTINATION_NONE,
      href: ''
    });
  };

  const getLinkDestinations = () => {
    const linkDestinations = [{
      linkDestination: LINK_DESTINATION_MEDIA,
      title: (0,external_wp_i18n_namespaceObject.__)('Media File'),
      url: mediaType === 'image' ? mediaUrl : undefined,
      icon
    }];

    if (mediaType === 'image' && mediaLink) {
      linkDestinations.push({
        linkDestination: LINK_DESTINATION_ATTACHMENT,
        title: (0,external_wp_i18n_namespaceObject.__)('Attachment Page'),
        url: mediaType === 'image' ? mediaLink : undefined,
        icon: (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SVG, {
          viewBox: "0 0 24 24",
          xmlns: "http://www.w3.org/2000/svg"
        }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Path, {
          d: "M0 0h24v24H0V0z",
          fill: "none"
        }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Path, {
          d: "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zM6 20V4h7v5h5v11H6z"
        }))
      });
    }

    return linkDestinations;
  };

  const onSetHref = value => {
    const linkDestinations = getLinkDestinations();
    let linkDestinationInput;

    if (!value) {
      linkDestinationInput = LINK_DESTINATION_NONE;
    } else {
      linkDestinationInput = (linkDestinations.find(destination => {
        return destination.url === value;
      }) || {
        linkDestination: LINK_DESTINATION_CUSTOM
      }).linkDestination;
    }

    onChangeUrl({
      linkDestination: linkDestinationInput,
      href: value
    });
  };

  const onSetNewTab = value => {
    const updatedLinkTarget = getUpdatedLinkTargetSettings(value);
    onChangeUrl(updatedLinkTarget);
  };

  const onSetLinkRel = value => {
    onChangeUrl({
      rel: value
    });
  };

  const onSetLinkClass = value => {
    onChangeUrl({
      linkClass: value
    });
  };

  const advancedOptions = (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalVStack, {
    spacing: "3"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToggleControl, {
    __nextHasNoMarginBottom: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Open in new tab'),
    onChange: onSetNewTab,
    checked: linkTarget === '_blank'
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.TextControl, {
    __nextHasNoMarginBottom: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Link rel'),
    value: rel !== null && rel !== void 0 ? rel : '',
    onChange: onSetLinkRel
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.TextControl, {
    __nextHasNoMarginBottom: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Link CSS Class'),
    value: linkClass || '',
    onChange: onSetLinkClass
  }));
  const linkEditorValue = urlInput !== null ? urlInput : url;
  const urlLabel = (getLinkDestinations().find(destination => destination.linkDestination === linkDestination) || {}).title;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarButton, {
    icon: library_link,
    className: "components-toolbar__control",
    label: url ? (0,external_wp_i18n_namespaceObject.__)('Edit link') : (0,external_wp_i18n_namespaceObject.__)('Insert link'),
    "aria-expanded": isOpen,
    onClick: openLinkUI,
    ref: setPopoverAnchor
  }), isOpen && (0,external_wp_element_namespaceObject.createElement)(url_popover, {
    anchor: popoverAnchor,
    onFocusOutside: onFocusOutside(),
    onClose: closeLinkUI,
    renderSettings: () => advancedOptions,
    additionalControls: !linkEditorValue && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.NavigableMenu, null, getLinkDestinations().map(link => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
      key: link.linkDestination,
      icon: link.icon,
      onClick: () => {
        setUrlInput(null);
        onSetHref(link.url);
        stopEditLink();
      }
    }, link.title)))
  }, (!url || isEditingLink) && (0,external_wp_element_namespaceObject.createElement)(url_popover.LinkEditor, {
    className: "block-editor-format-toolbar__link-container-content",
    value: linkEditorValue,
    onChangeInputValue: setUrlInput,
    onSubmit: onSubmitLinkChange(),
    autocompleteRef: autocompleteRef
  }), url && !isEditingLink && (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(url_popover.LinkViewer, {
    className: "block-editor-format-toolbar__link-container-content",
    url: url,
    onEditLinkClick: startEditLink,
    urlLabel: urlLabel
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    icon: library_close,
    label: (0,external_wp_i18n_namespaceObject.__)('Remove link'),
    onClick: onLinkRemove
  }))));
};



;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-toolbar/block-toolbar-last-item.js
/**
 * WordPress dependencies
 */

const {
  Fill: __unstableBlockToolbarLastItem,
  Slot: block_toolbar_last_item_Slot
} = (0,external_wp_components_namespaceObject.createSlotFill)('__unstableBlockToolbarLastItem');
__unstableBlockToolbarLastItem.Slot = block_toolbar_last_item_Slot;
/* harmony default export */ var block_toolbar_last_item = (__unstableBlockToolbarLastItem);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-toolbar/block-name-context.js
/**
 * WordPress dependencies
 */


const __unstableBlockNameContext = (0,external_wp_element_namespaceObject.createContext)('');

/* harmony default export */ var block_name_context = (__unstableBlockNameContext);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/mobile.js


/**
 * WordPress dependencies
 */

const mobile = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M15 4H9c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h6c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm.5 14c0 .3-.2.5-.5.5H9c-.3 0-.5-.2-.5-.5V6c0-.3.2-.5.5-.5h6c.3 0 .5.2.5.5v12zm-4.5-.5h2V16h-2v1.5z"
}));
/* harmony default export */ var library_mobile = (mobile);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/tablet.js


/**
 * WordPress dependencies
 */

const tablet = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M17 4H7c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm.5 14c0 .3-.2.5-.5.5H7c-.3 0-.5-.2-.5-.5V6c0-.3.2-.5.5-.5h10c.3 0 .5.2.5.5v12zm-7.5-.5h4V16h-4v1.5z"
}));
/* harmony default export */ var library_tablet = (tablet);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/desktop.js


/**
 * WordPress dependencies
 */

const desktop = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M20.5 16h-.7V8c0-1.1-.9-2-2-2H6.2c-1.1 0-2 .9-2 2v8h-.7c-.8 0-1.5.7-1.5 1.5h20c0-.8-.7-1.5-1.5-1.5zM5.7 8c0-.3.2-.5.5-.5h11.6c.3 0 .5.2.5.5v7.6H5.7V8z"
}));
/* harmony default export */ var library_desktop = (desktop);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/preview-options/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





function PreviewOptions({
  children,
  viewLabel,
  className,
  isEnabled = true,
  deviceType,
  setDeviceType,
  label
}) {
  const isMobile = (0,external_wp_compose_namespaceObject.useViewportMatch)('small', '<');
  if (isMobile) return null;
  const popoverProps = {
    className: classnames_default()(className, 'block-editor-post-preview__dropdown-content'),
    placement: 'bottom-end'
  };
  const toggleProps = {
    className: 'block-editor-post-preview__button-toggle',
    disabled: !isEnabled,
    children: viewLabel
  };
  const menuProps = {
    'aria-label': (0,external_wp_i18n_namespaceObject.__)('View options')
  };
  const deviceIcons = {
    mobile: library_mobile,
    tablet: library_tablet,
    desktop: library_desktop
  };
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.DropdownMenu, {
    className: "block-editor-post-preview__dropdown",
    popoverProps: popoverProps,
    toggleProps: toggleProps,
    menuProps: menuProps,
    icon: deviceIcons[deviceType.toLowerCase()],
    label: label || (0,external_wp_i18n_namespaceObject.__)('Preview')
  }, () => (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuGroup, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    className: "block-editor-post-preview__button-resize",
    onClick: () => setDeviceType('Desktop'),
    icon: deviceType === 'Desktop' && library_check
  }, (0,external_wp_i18n_namespaceObject.__)('Desktop')), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    className: "block-editor-post-preview__button-resize",
    onClick: () => setDeviceType('Tablet'),
    icon: deviceType === 'Tablet' && library_check
  }, (0,external_wp_i18n_namespaceObject.__)('Tablet')), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    className: "block-editor-post-preview__button-resize",
    onClick: () => setDeviceType('Mobile'),
    icon: deviceType === 'Mobile' && library_check
  }, (0,external_wp_i18n_namespaceObject.__)('Mobile'))), children));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/use-resize-canvas/index.js
/**
 * WordPress dependencies
 */

/**
 * Function to resize the editor window.
 *
 * @param {string} deviceType Used for determining the size of the container (e.g. Desktop, Tablet, Mobile)
 *
 * @return {Object} Inline styles to be added to resizable container.
 */

function useResizeCanvas(deviceType) {
  const [actualWidth, updateActualWidth] = (0,external_wp_element_namespaceObject.useState)(window.innerWidth);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (deviceType === 'Desktop') {
      return;
    }

    const resizeListener = () => updateActualWidth(window.innerWidth);

    window.addEventListener('resize', resizeListener);
    return () => {
      window.removeEventListener('resize', resizeListener);
    };
  }, [deviceType]);

  const getCanvasWidth = device => {
    let deviceWidth;

    switch (device) {
      case 'Tablet':
        deviceWidth = 780;
        break;

      case 'Mobile':
        deviceWidth = 360;
        break;

      default:
        return null;
    }

    return deviceWidth < actualWidth ? deviceWidth : actualWidth;
  };

  const marginValue = () => window.innerHeight < 800 ? 36 : 72;

  const contentInlineStyles = device => {
    const height = device === 'Mobile' ? '768px' : '1024px';
    const marginVertical = marginValue() + 'px';
    const marginHorizontal = 'auto';

    switch (device) {
      case 'Tablet':
      case 'Mobile':
        return {
          width: getCanvasWidth(device),
          // Keeping margin styles separate to avoid warnings
          // when those props get overridden in the iframe component
          marginTop: marginVertical,
          marginBottom: marginVertical,
          marginLeft: marginHorizontal,
          marginRight: marginHorizontal,
          height,
          borderRadius: '2px 2px 2px 2px',
          border: '1px solid #ddd',
          overflowY: 'auto'
        };

      default:
        return null;
    }
  };

  return contentInlineStyles(deviceType);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/skip-to-selected-block/index.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




const SkipToSelectedBlock = ({
  selectedBlockClientId
}) => {
  const ref = useBlockRef(selectedBlockClientId);

  const onClick = () => {
    ref.current.focus();
  };

  return selectedBlockClientId ? (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    variant: "secondary",
    className: "block-editor-skip-to-selected-block",
    onClick: onClick
  }, (0,external_wp_i18n_namespaceObject.__)('Skip to the selected block')) : null;
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/skip-to-selected-block/README.md
 */


/* harmony default export */ var skip_to_selected_block = ((0,external_wp_data_namespaceObject.withSelect)(select => {
  return {
    selectedBlockClientId: select(store).getBlockSelectionStart()
  };
})(SkipToSelectedBlock));

;// CONCATENATED MODULE: external ["wp","wordcount"]
var external_wp_wordcount_namespaceObject = window["wp"]["wordcount"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/copy.js


/**
 * WordPress dependencies
 */

const copy_copy = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M20.2 8v11c0 .7-.6 1.2-1.2 1.2H6v1.5h13c1.5 0 2.7-1.2 2.7-2.8V8zM18 16.4V4.6c0-.9-.7-1.6-1.6-1.6H4.6C3.7 3 3 3.7 3 4.6v11.8c0 .9.7 1.6 1.6 1.6h11.8c.9 0 1.6-.7 1.6-1.6zm-13.5 0V4.6c0-.1.1-.1.1-.1h11.8c.1 0 .1.1.1.1v11.8c0 .1-.1.1-.1.1H4.6l-.1-.1z"
}));
/* harmony default export */ var library_copy = (copy_copy);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/multi-selection-inspector/index.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




function MultiSelectionInspector({
  blocks
}) {
  const words = (0,external_wp_wordcount_namespaceObject.count)((0,external_wp_blocks_namespaceObject.serialize)(blocks), 'words');
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-multi-selection-inspector__card"
  }, (0,external_wp_element_namespaceObject.createElement)(block_icon, {
    icon: library_copy,
    showColors: true
  }), (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-multi-selection-inspector__card-content"
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-multi-selection-inspector__card-title"
  }, (0,external_wp_i18n_namespaceObject.sprintf)(
  /* translators: %d: number of blocks */
  (0,external_wp_i18n_namespaceObject._n)('%d Block', '%d Blocks', blocks.length), blocks.length)), (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-multi-selection-inspector__card-description"
  }, (0,external_wp_i18n_namespaceObject.sprintf)(
  /* translators: %d: number of words */
  (0,external_wp_i18n_namespaceObject._n)('%d word selected.', '%d words selected.', words), words))));
}

/* harmony default export */ var multi_selection_inspector = ((0,external_wp_data_namespaceObject.withSelect)(select => {
  const {
    getMultiSelectedBlocks
  } = select(store);
  return {
    blocks: getMultiSelectedBlocks()
  };
})(MultiSelectionInspector));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/default-style-picker/index.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



function DefaultStylePicker({
  blockName
}) {
  const {
    preferredStyle,
    onUpdatePreferredStyleVariations,
    styles
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    var _preferredStyleVariat;

    const settings = select(store).getSettings();
    const preferredStyleVariations = settings.__experimentalPreferredStyleVariations;
    return {
      preferredStyle: preferredStyleVariations?.value?.[blockName],
      onUpdatePreferredStyleVariations: (_preferredStyleVariat = preferredStyleVariations?.onChange) !== null && _preferredStyleVariat !== void 0 ? _preferredStyleVariat : null,
      styles: select(external_wp_blocks_namespaceObject.store).getBlockStyles(blockName)
    };
  }, [blockName]);
  const selectOptions = (0,external_wp_element_namespaceObject.useMemo)(() => [{
    label: (0,external_wp_i18n_namespaceObject.__)('Not set'),
    value: ''
  }, ...styles.map(({
    label,
    name
  }) => ({
    label,
    value: name
  }))], [styles]);
  const defaultStyleName = (0,external_wp_element_namespaceObject.useMemo)(() => getDefaultStyle(styles)?.name, [styles]);
  const selectOnChange = (0,external_wp_element_namespaceObject.useCallback)(blockStyle => {
    onUpdatePreferredStyleVariations(blockName, blockStyle);
  }, [blockName, onUpdatePreferredStyleVariations]); // Until the functionality is migrated to global styles,
  // only show the default style picker if a non-default style has already been selected.

  if (!preferredStyle || preferredStyle === defaultStyleName) {
    return null;
  }

  return onUpdatePreferredStyleVariations && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "default-style-picker__default-switcher"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SelectControl, {
    __nextHasNoMarginBottom: true,
    options: selectOptions,
    value: preferredStyle || '',
    label: (0,external_wp_i18n_namespaceObject.__)('Default Style'),
    onChange: selectOnChange
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/cog.js


/**
 * WordPress dependencies
 */

const cog = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  fillRule: "evenodd",
  d: "M10.289 4.836A1 1 0 0111.275 4h1.306a1 1 0 01.987.836l.244 1.466c.787.26 1.503.679 2.108 1.218l1.393-.522a1 1 0 011.216.437l.653 1.13a1 1 0 01-.23 1.273l-1.148.944a6.025 6.025 0 010 2.435l1.149.946a1 1 0 01.23 1.272l-.653 1.13a1 1 0 01-1.216.437l-1.394-.522c-.605.54-1.32.958-2.108 1.218l-.244 1.466a1 1 0 01-.987.836h-1.306a1 1 0 01-.986-.836l-.244-1.466a5.995 5.995 0 01-2.108-1.218l-1.394.522a1 1 0 01-1.217-.436l-.653-1.131a1 1 0 01.23-1.272l1.149-.946a6.026 6.026 0 010-2.435l-1.148-.944a1 1 0 01-.23-1.272l.653-1.131a1 1 0 011.217-.437l1.393.522a5.994 5.994 0 012.108-1.218l.244-1.466zM14.929 12a3 3 0 11-6 0 3 3 0 016 0z",
  clipRule: "evenodd"
}));
/* harmony default export */ var library_cog = (cog);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/styles.js


/**
 * WordPress dependencies
 */

const styles = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M12 4c-4.4 0-8 3.6-8 8v.1c0 4.1 3.2 7.5 7.2 7.9h.8c4.4 0 8-3.6 8-8s-3.6-8-8-8zm0 15V5c3.9 0 7 3.1 7 7s-3.1 7-7 7z"
}));
/* harmony default export */ var library_styles = (styles);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls-tabs/utils.js
/**
 * WordPress dependencies
 */


const TAB_SETTINGS = {
  name: 'settings',
  title: (0,external_wp_i18n_namespaceObject.__)('Settings'),
  value: 'settings',
  icon: library_cog,
  className: 'block-editor-block-inspector__tab-item'
};
const TAB_STYLES = {
  name: 'styles',
  title: (0,external_wp_i18n_namespaceObject.__)('Styles'),
  value: 'styles',
  icon: library_styles,
  className: 'block-editor-block-inspector__tab-item'
};
const TAB_LIST_VIEW = {
  name: 'list',
  title: (0,external_wp_i18n_namespaceObject.__)('List View'),
  value: 'list-view',
  icon: list_view,
  className: 'block-editor-block-inspector__tab-item'
};

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls-tabs/advanced-controls-panel.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const AdvancedControls = () => {
  const fills = (0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(InspectorAdvancedControls.slotName);
  const hasFills = Boolean(fills && fills.length);

  if (!hasFills) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.PanelBody, {
    className: "block-editor-block-inspector__advanced",
    title: (0,external_wp_i18n_namespaceObject.__)('Advanced'),
    initialOpen: false
  }, (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
    group: "advanced"
  }));
};

/* harmony default export */ var advanced_controls_panel = (AdvancedControls);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls-tabs/position-controls-panel.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





const PositionControlsPanel = () => {
  const [initialOpen, setInitialOpen] = (0,external_wp_element_namespaceObject.useState)(); // Determine whether the panel should be expanded.

  const {
    multiSelectedBlocks
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlocksByClientId,
      getSelectedBlockClientIds
    } = select(store);
    const clientIds = getSelectedBlockClientIds();
    return {
      multiSelectedBlocks: getBlocksByClientId(clientIds)
    };
  }, []);
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    // If any selected block has a position set, open the panel by default.
    // The first block's value will still be used within the control though.
    if (initialOpen === undefined) {
      setInitialOpen(multiSelectedBlocks.some(({
        attributes
      }) => !!attributes?.style?.position?.type));
    }
  }, [initialOpen, multiSelectedBlocks, setInitialOpen]);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.PanelBody, {
    className: "block-editor-block-inspector__position",
    title: (0,external_wp_i18n_namespaceObject.__)('Position'),
    initialOpen: initialOpen !== null && initialOpen !== void 0 ? initialOpen : false
  }, (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
    group: "position"
  }));
};

const PositionControls = () => {
  const fills = (0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(inspector_controls_groups.position.Slot.__unstableName);
  const hasFills = Boolean(fills && fills.length);

  if (!hasFills) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(PositionControlsPanel, null);
};

/* harmony default export */ var position_controls_panel = (PositionControls);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls-tabs/settings-tab-hint.js


/**
 * WordPress dependencies
 */







const settings_tab_hint_PREFERENCE_NAME = 'isInspectorControlsTabsHintVisible';
function InspectorControlsTabsHint() {
  const isInspectorControlsTabsHintVisible = (0,external_wp_data_namespaceObject.useSelect)(select => {
    var _select$get;

    return (_select$get = select(external_wp_preferences_namespaceObject.store).get('core', settings_tab_hint_PREFERENCE_NAME)) !== null && _select$get !== void 0 ? _select$get : true;
  }, []);
  const ref = (0,external_wp_element_namespaceObject.useRef)();
  const {
    set: setPreference
  } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_preferences_namespaceObject.store);

  if (!isInspectorControlsTabsHintVisible) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)("div", {
    ref: ref,
    className: "block-editor-inspector-controls-tabs__hint"
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-inspector-controls-tabs__hint-content"
  }, (0,external_wp_i18n_namespaceObject.__)("Looking for other block settings? They've moved to the styles tab.")), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    className: "block-editor-inspector-controls-tabs__hint-dismiss",
    icon: library_close,
    iconSize: "16",
    label: (0,external_wp_i18n_namespaceObject.__)('Dismiss hint'),
    onClick: () => {
      // Retain focus when dismissing the element.
      const previousElement = external_wp_dom_namespaceObject.focus.tabbable.findPrevious(ref.current);
      previousElement?.focus();
      setPreference('core', settings_tab_hint_PREFERENCE_NAME, false);
    },
    showTooltip: false
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls-tabs/settings-tab.js


/**
 * Internal dependencies
 */





const SettingsTab = ({
  showAdvancedControls = false
}) => (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, null), (0,external_wp_element_namespaceObject.createElement)(position_controls_panel, null), showAdvancedControls && (0,external_wp_element_namespaceObject.createElement)("div", null, (0,external_wp_element_namespaceObject.createElement)(advanced_controls_panel, null)), (0,external_wp_element_namespaceObject.createElement)(InspectorControlsTabsHint, null));

/* harmony default export */ var settings_tab = (SettingsTab);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls-tabs/styles-tab.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */





const StylesTab = ({
  blockName,
  clientId,
  hasBlockStyles
}) => {
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, hasBlockStyles && (0,external_wp_element_namespaceObject.createElement)("div", null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.PanelBody, {
    title: (0,external_wp_i18n_namespaceObject.__)('Styles')
  }, (0,external_wp_element_namespaceObject.createElement)(block_styles, {
    clientId: clientId
  }), (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockName, 'defaultStylePicker', true) && (0,external_wp_element_namespaceObject.createElement)(DefaultStylePicker, {
    blockName: blockName
  }))), (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
    group: "color",
    label: (0,external_wp_i18n_namespaceObject.__)('Color'),
    className: "color-block-support-panel__inner-wrapper"
  }), (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
    group: "filter"
  }), (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
    group: "typography",
    label: (0,external_wp_i18n_namespaceObject.__)('Typography')
  }), (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
    group: "dimensions",
    label: (0,external_wp_i18n_namespaceObject.__)('Dimensions')
  }), (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
    group: "border",
    label: (0,external_wp_i18n_namespaceObject.__)('Border')
  }), (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
    group: "styles"
  }));
};

/* harmony default export */ var styles_tab = (StylesTab);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls-tabs/use-is-list-view-tab-disabled.js
// List view tab restricts the blocks that may render to it via the
// allowlist below.
const allowlist = ['core/navigation'];
const useIsListViewTabDisabled = blockName => {
  return !allowlist.includes(blockName);
};
/* harmony default export */ var use_is_list_view_tab_disabled = (useIsListViewTabDisabled);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls-tabs/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */






function InspectorControlsTabs({
  blockName,
  clientId,
  hasBlockStyles,
  tabs
}) {
  // The tabs panel will mount before fills are rendered to the list view
  // slot. This means the list view tab isn't initially included in the
  // available tabs so the panel defaults selection to the settings tab
  // which at the time is the first tab. This check allows blocks known to
  // include the list view tab to set it as the tab selected by default.
  const initialTabName = !use_is_list_view_tab_disabled(blockName) ? TAB_LIST_VIEW.name : undefined;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.TabPanel, {
    className: "block-editor-block-inspector__tabs",
    tabs: tabs,
    initialTabName: initialTabName,
    key: clientId
  }, tab => {
    if (tab.name === TAB_SETTINGS.name) {
      return (0,external_wp_element_namespaceObject.createElement)(settings_tab, {
        showAdvancedControls: !!blockName
      });
    }

    if (tab.name === TAB_STYLES.name) {
      return (0,external_wp_element_namespaceObject.createElement)(styles_tab, {
        blockName: blockName,
        clientId: clientId,
        hasBlockStyles: hasBlockStyles
      });
    }

    if (tab.name === TAB_LIST_VIEW.name) {
      return (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
        group: "list"
      });
    }
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls-tabs/use-inspector-controls-tabs.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */






const use_inspector_controls_tabs_EMPTY_ARRAY = [];

function getShowTabs(blockName, tabSettings = {}) {
  // Block specific setting takes precedence over generic default.
  if (tabSettings[blockName] !== undefined) {
    return tabSettings[blockName];
  } // Use generic default if set over the Gutenberg experiment option.


  if (tabSettings.default !== undefined) {
    return tabSettings.default;
  }

  return true;
}

function useInspectorControlsTabs(blockName) {
  const tabs = [];
  const {
    border: borderGroup,
    color: colorGroup,
    default: defaultGroup,
    dimensions: dimensionsGroup,
    list: listGroup,
    position: positionGroup,
    styles: stylesGroup,
    typography: typographyGroup
  } = inspector_controls_groups; // List View Tab: If there are any fills for the list group add that tab.

  const listViewDisabled = use_is_list_view_tab_disabled(blockName);
  const listFills = (0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(listGroup.Slot.__unstableName);
  const hasListFills = !listViewDisabled && !!listFills && listFills.length; // Styles Tab: Add this tab if there are any fills for block supports
  // e.g. border, color, spacing, typography, etc.

  const styleFills = [...((0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(borderGroup.Slot.__unstableName) || []), ...((0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(colorGroup.Slot.__unstableName) || []), ...((0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(dimensionsGroup.Slot.__unstableName) || []), ...((0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(stylesGroup.Slot.__unstableName) || []), ...((0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(typographyGroup.Slot.__unstableName) || [])];
  const hasStyleFills = styleFills.length; // Settings Tab: If we don't have multiple tabs to display
  // (i.e. both list view and styles), check only the default and position
  // InspectorControls slots. If we have multiple tabs, we'll need to check
  // the advanced controls slot as well to ensure they are rendered.

  const advancedFills = (0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(InspectorAdvancedControls.slotName) || [];
  const settingsFills = [...((0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(defaultGroup.Slot.__unstableName) || []), ...((0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(positionGroup.Slot.__unstableName) || []), ...(hasListFills && hasStyleFills > 1 ? advancedFills : [])]; // Add the tabs in the order that they will default to if available.
  // List View > Settings > Styles.

  if (hasListFills) {
    tabs.push(TAB_LIST_VIEW);
  }

  if (settingsFills.length) {
    tabs.push(TAB_SETTINGS);
  }

  if (hasStyleFills) {
    tabs.push(TAB_STYLES);
  }

  const tabSettings = (0,external_wp_data_namespaceObject.useSelect)(select => {
    return select(store).getSettings().blockInspectorTabs;
  }, []);
  const showTabs = getShowTabs(blockName, tabSettings);
  return showTabs ? tabs : use_inspector_controls_tabs_EMPTY_ARRAY;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-inspector/useBlockInspectorAnimationSettings.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


function useBlockInspectorAnimationSettings(blockType, selectedBlockClientId) {
  return (0,external_wp_data_namespaceObject.useSelect)(select => {
    if (blockType) {
      const globalBlockInspectorAnimationSettings = select(store).getSettings().blockInspectorAnimation; // Get the name of the block that will allow it's children to be animated.

      const animationParent = globalBlockInspectorAnimationSettings?.animationParent; // Determine whether the animationParent block is a parent of the selected block.

      const {
        getSelectedBlockClientId,
        getBlockParentsByBlockName
      } = select(store);

      const _selectedBlockClientId = getSelectedBlockClientId();

      const animationParentBlockClientId = getBlockParentsByBlockName(_selectedBlockClientId, animationParent, true)[0]; // If the selected block is not a child of the animationParent block,
      // and not an animationParent block itself, don't animate.

      if (!animationParentBlockClientId && blockType.name !== animationParent) {
        return null;
      }

      return globalBlockInspectorAnimationSettings?.[blockType.name];
    }

    return null;
  }, [selectedBlockClientId, blockType]);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-info-slot-fill/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



const {
  createPrivateSlotFill
} = unlock(external_wp_components_namespaceObject.privateApis);
const {
  Fill: block_info_slot_fill_Fill,
  Slot: block_info_slot_fill_Slot
} = createPrivateSlotFill('BlockInformation');

const BlockInfo = props => {
  const isDisplayed = useDisplayBlockControls();

  if (!isDisplayed) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(block_info_slot_fill_Fill, { ...props
  });
};

BlockInfo.Slot = props => (0,external_wp_element_namespaceObject.createElement)(block_info_slot_fill_Slot, { ...props
});

/* harmony default export */ var block_info_slot_fill = (BlockInfo);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-quick-navigation/index.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function BlockQuickNavigation({
  clientIds
}) {
  if (!clientIds.length) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalVStack, {
    spacing: 1
  }, clientIds.map(clientId => (0,external_wp_element_namespaceObject.createElement)(BlockQuickNavigationItem, {
    key: clientId,
    clientId: clientId
  })));
}

function BlockQuickNavigationItem({
  clientId
}) {
  const {
    name,
    icon,
    isSelected
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockName,
      getBlockAttributes,
      isBlockSelected,
      hasSelectedInnerBlock
    } = select(store);
    const {
      getBlockType
    } = select(external_wp_blocks_namespaceObject.store);
    const blockType = getBlockType(getBlockName(clientId));
    const attributes = getBlockAttributes(clientId);
    return {
      name: blockType && (0,external_wp_blocks_namespaceObject.__experimentalGetBlockLabel)(blockType, attributes, 'list-view'),
      icon: blockType?.icon,
      isSelected: isBlockSelected(clientId) || hasSelectedInnerBlock(clientId,
      /* deep: */
      true)
    };
  }, [clientId]);
  const {
    selectBlock
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    isPressed: isSelected,
    onClick: () => selectBlock(clientId)
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHStack, {
    justify: "flex-start"
  }, (0,external_wp_element_namespaceObject.createElement)(block_icon, {
    icon: icon
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, null, name)));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-inspector/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



















function BlockInspectorLockedBlocks({
  topLevelLockedBlock
}) {
  const contentClientIds = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getClientIdsOfDescendants,
      getBlockName,
      getBlockEditingMode
    } = unlock(select(store));
    return getClientIdsOfDescendants([topLevelLockedBlock]).filter(clientId => getBlockName(clientId) !== 'core/list-item' && getBlockEditingMode(clientId) === 'contentOnly');
  }, [topLevelLockedBlock]);
  const blockInformation = useBlockDisplayInformation(topLevelLockedBlock);
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-inspector"
  }, (0,external_wp_element_namespaceObject.createElement)(block_card, { ...blockInformation,
    className: blockInformation.isSynced && 'is-synced'
  }), (0,external_wp_element_namespaceObject.createElement)(block_variation_transforms, {
    blockClientId: topLevelLockedBlock
  }), (0,external_wp_element_namespaceObject.createElement)(block_info_slot_fill.Slot, null), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.PanelBody, {
    title: (0,external_wp_i18n_namespaceObject.__)('Content')
  }, (0,external_wp_element_namespaceObject.createElement)(BlockQuickNavigation, {
    clientIds: contentClientIds
  })));
}

const BlockInspector = ({
  showNoBlockSelectedMessage = true
}) => {
  const {
    count,
    selectedBlockName,
    selectedBlockClientId,
    blockType,
    topLevelLockedBlock
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getSelectedBlockClientId,
      getSelectedBlockCount,
      getBlockName,
      __unstableGetContentLockingParent,
      getTemplateLock
    } = select(store);

    const _selectedBlockClientId = getSelectedBlockClientId();

    const _selectedBlockName = _selectedBlockClientId && getBlockName(_selectedBlockClientId);

    const _blockType = _selectedBlockName && (0,external_wp_blocks_namespaceObject.getBlockType)(_selectedBlockName);

    return {
      count: getSelectedBlockCount(),
      selectedBlockClientId: _selectedBlockClientId,
      selectedBlockName: _selectedBlockName,
      blockType: _blockType,
      topLevelLockedBlock: __unstableGetContentLockingParent(_selectedBlockClientId) || (getTemplateLock(_selectedBlockClientId) === 'contentOnly' ? _selectedBlockClientId : undefined)
    };
  }, []);
  const availableTabs = useInspectorControlsTabs(blockType?.name);
  const showTabs = availableTabs?.length > 1; // The block inspector animation settings will be completely
  // removed in the future to create an API which allows the block
  // inspector to transition between what it
  // displays based on the relationship between the selected block
  // and its parent, and only enable it if the parent is controlling
  // its children blocks.

  const blockInspectorAnimationSettings = useBlockInspectorAnimationSettings(blockType, selectedBlockClientId);

  if (count > 1) {
    return (0,external_wp_element_namespaceObject.createElement)("div", {
      className: "block-editor-block-inspector"
    }, (0,external_wp_element_namespaceObject.createElement)(multi_selection_inspector, null), showTabs ? (0,external_wp_element_namespaceObject.createElement)(InspectorControlsTabs, {
      tabs: availableTabs
    }) : (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, null), (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
      group: "color",
      label: (0,external_wp_i18n_namespaceObject.__)('Color'),
      className: "color-block-support-panel__inner-wrapper"
    }), (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
      group: "typography",
      label: (0,external_wp_i18n_namespaceObject.__)('Typography')
    }), (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
      group: "dimensions",
      label: (0,external_wp_i18n_namespaceObject.__)('Dimensions')
    }), (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
      group: "border",
      label: (0,external_wp_i18n_namespaceObject.__)('Border')
    }), (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
      group: "styles"
    })));
  }

  const isSelectedBlockUnregistered = selectedBlockName === (0,external_wp_blocks_namespaceObject.getUnregisteredTypeHandlerName)();
  /*
   * If the selected block is of an unregistered type, avoid showing it as an actual selection
   * because we want the user to focus on the unregistered block warning, not block settings.
   */

  if (!blockType || !selectedBlockClientId || isSelectedBlockUnregistered) {
    if (showNoBlockSelectedMessage) {
      return (0,external_wp_element_namespaceObject.createElement)("span", {
        className: "block-editor-block-inspector__no-blocks"
      }, (0,external_wp_i18n_namespaceObject.__)('No block selected.'));
    }

    return null;
  }

  if (topLevelLockedBlock) {
    return (0,external_wp_element_namespaceObject.createElement)(BlockInspectorLockedBlocks, {
      topLevelLockedBlock: topLevelLockedBlock
    });
  }

  return (0,external_wp_element_namespaceObject.createElement)(BlockInspectorSingleBlockWrapper, {
    animate: blockInspectorAnimationSettings,
    wrapper: children => (0,external_wp_element_namespaceObject.createElement)(AnimatedContainer, {
      blockInspectorAnimationSettings: blockInspectorAnimationSettings,
      selectedBlockClientId: selectedBlockClientId
    }, children)
  }, (0,external_wp_element_namespaceObject.createElement)(BlockInspectorSingleBlock, {
    clientId: selectedBlockClientId,
    blockName: blockType.name
  }));
};

const BlockInspectorSingleBlockWrapper = ({
  animate,
  wrapper,
  children
}) => {
  return animate ? wrapper(children) : children;
};

const AnimatedContainer = ({
  blockInspectorAnimationSettings,
  selectedBlockClientId,
  children
}) => {
  const animationOrigin = blockInspectorAnimationSettings && blockInspectorAnimationSettings.enterDirection === 'leftToRight' ? -50 : 50;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__unstableMotion.div, {
    animate: {
      x: 0,
      opacity: 1,
      transition: {
        ease: 'easeInOut',
        duration: 0.14
      }
    },
    initial: {
      x: animationOrigin,
      opacity: 0
    },
    key: selectedBlockClientId
  }, children);
};

const BlockInspectorSingleBlock = ({
  clientId,
  blockName
}) => {
  const availableTabs = useInspectorControlsTabs(blockName);
  const showTabs = availableTabs?.length > 1;
  const hasBlockStyles = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockStyles
    } = select(external_wp_blocks_namespaceObject.store);
    const blockStyles = getBlockStyles(blockName);
    return blockStyles && blockStyles.length > 0;
  }, [blockName]);
  const blockInformation = useBlockDisplayInformation(clientId);
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-inspector"
  }, (0,external_wp_element_namespaceObject.createElement)(block_card, { ...blockInformation,
    className: blockInformation.isSynced && 'is-synced'
  }), (0,external_wp_element_namespaceObject.createElement)(block_variation_transforms, {
    blockClientId: clientId
  }), (0,external_wp_element_namespaceObject.createElement)(block_info_slot_fill.Slot, null), showTabs && (0,external_wp_element_namespaceObject.createElement)(InspectorControlsTabs, {
    hasBlockStyles: hasBlockStyles,
    clientId: clientId,
    blockName: blockName,
    tabs: availableTabs
  }), !showTabs && (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, hasBlockStyles && (0,external_wp_element_namespaceObject.createElement)("div", null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.PanelBody, {
    title: (0,external_wp_i18n_namespaceObject.__)('Styles')
  }, (0,external_wp_element_namespaceObject.createElement)(block_styles, {
    clientId: clientId
  }), (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockName, 'defaultStylePicker', true) && (0,external_wp_element_namespaceObject.createElement)(DefaultStylePicker, {
    blockName: blockName
  }))), (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, null), (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
    group: "list"
  }), (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
    group: "color",
    label: (0,external_wp_i18n_namespaceObject.__)('Color'),
    className: "color-block-support-panel__inner-wrapper"
  }), (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
    group: "typography",
    label: (0,external_wp_i18n_namespaceObject.__)('Typography')
  }), (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
    group: "dimensions",
    label: (0,external_wp_i18n_namespaceObject.__)('Dimensions')
  }), (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
    group: "border",
    label: (0,external_wp_i18n_namespaceObject.__)('Border')
  }), (0,external_wp_element_namespaceObject.createElement)(inspector_controls.Slot, {
    group: "styles"
  }), (0,external_wp_element_namespaceObject.createElement)(position_controls_panel, null), (0,external_wp_element_namespaceObject.createElement)("div", null, (0,external_wp_element_namespaceObject.createElement)(advanced_controls_panel, null))), (0,external_wp_element_namespaceObject.createElement)(skip_to_selected_block, {
    key: "back"
  }));
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-inspector/README.md
 */


/* harmony default export */ var block_inspector = (BlockInspector);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-mover/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */





function BlockMover({
  clientIds,
  hideDragHandle
}) {
  const {
    canMove,
    rootClientId,
    isFirst,
    isLast,
    orientation
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockIndex,
      getBlockListSettings,
      canMoveBlocks,
      getBlockOrder,
      getBlockRootClientId
    } = select(store);
    const normalizedClientIds = Array.isArray(clientIds) ? clientIds : [clientIds];
    const firstClientId = normalizedClientIds[0];

    const _rootClientId = getBlockRootClientId(firstClientId);

    const firstIndex = getBlockIndex(firstClientId);
    const lastIndex = getBlockIndex(normalizedClientIds[normalizedClientIds.length - 1]);
    const blockOrder = getBlockOrder(_rootClientId);
    return {
      canMove: canMoveBlocks(clientIds, _rootClientId),
      rootClientId: _rootClientId,
      isFirst: firstIndex === 0,
      isLast: lastIndex === blockOrder.length - 1,
      orientation: getBlockListSettings(_rootClientId)?.orientation
    };
  }, [clientIds]);

  if (!canMove || isFirst && isLast && !rootClientId) {
    return null;
  }

  const dragHandleLabel = (0,external_wp_i18n_namespaceObject.__)('Drag');

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarGroup, {
    className: classnames_default()('block-editor-block-mover', {
      'is-horizontal': orientation === 'horizontal'
    })
  }, !hideDragHandle && (0,external_wp_element_namespaceObject.createElement)(block_draggable, {
    clientIds: clientIds
  }, draggableProps => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    icon: drag_handle,
    className: "block-editor-block-mover__drag-handle",
    "aria-hidden": "true",
    label: dragHandleLabel // Should not be able to tab to drag handle as this
    // button can only be used with a pointer device.
    ,
    tabIndex: "-1",
    ...draggableProps
  })), (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-mover__move-button-container"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarItem, null, itemProps => (0,external_wp_element_namespaceObject.createElement)(BlockMoverUpButton, {
    clientIds: clientIds,
    ...itemProps
  })), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarItem, null, itemProps => (0,external_wp_element_namespaceObject.createElement)(BlockMoverDownButton, {
    clientIds: clientIds,
    ...itemProps
  }))));
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-mover/README.md
 */


/* harmony default export */ var block_mover = (BlockMover);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


function BlockSettingsMenu({
  clientIds,
  ...props
}) {
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarGroup, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarItem, null, toggleProps => (0,external_wp_element_namespaceObject.createElement)(block_settings_dropdown, {
    clientIds: clientIds,
    toggleProps: toggleProps,
    ...props
  })));
}
/* harmony default export */ var block_settings_menu = (BlockSettingsMenu);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-parent-selector/index.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */






/**
 * Block parent selector component, displaying the hierarchy of the
 * current block selection as a single icon to "go up" a level.
 *
 * @return {WPComponent} Parent block selector.
 */

function BlockParentSelector() {
  const {
    selectBlock,
    toggleBlockHighlight
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const {
    firstParentClientId,
    isVisible,
    isDistractionFree
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockName,
      getBlockParents,
      getSelectedBlockClientId,
      getSettings,
      getBlockEditingMode
    } = unlock(select(store));
    const {
      hasBlockSupport
    } = select(external_wp_blocks_namespaceObject.store);
    const selectedBlockClientId = getSelectedBlockClientId();
    const parents = getBlockParents(selectedBlockClientId);
    const _firstParentClientId = parents[parents.length - 1];
    const parentBlockName = getBlockName(_firstParentClientId);

    const _parentBlockType = (0,external_wp_blocks_namespaceObject.getBlockType)(parentBlockName);

    const settings = getSettings();
    return {
      firstParentClientId: _firstParentClientId,
      isVisible: _firstParentClientId && getBlockEditingMode(_firstParentClientId) === 'default' && hasBlockSupport(_parentBlockType, '__experimentalParentSelector', true),
      isDistractionFree: settings.isDistractionFree
    };
  }, []);
  const blockInformation = useBlockDisplayInformation(firstParentClientId); // Allows highlighting the parent block outline when focusing or hovering
  // the parent block selector within the child.

  const nodeRef = (0,external_wp_element_namespaceObject.useRef)();
  const {
    gestures: showMoversGestures
  } = useShowMoversGestures({
    ref: nodeRef,

    onChange(isFocused) {
      if (isFocused && isDistractionFree) {
        return;
      }

      toggleBlockHighlight(firstParentClientId, isFocused);
    }

  });

  if (!isVisible) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-parent-selector",
    key: firstParentClientId,
    ref: nodeRef,
    ...showMoversGestures
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarButton, {
    className: "block-editor-block-parent-selector__button",
    onClick: () => selectBlock(firstParentClientId),
    label: (0,external_wp_i18n_namespaceObject.sprintf)(
    /* translators: %s: Name of the block's parent. */
    (0,external_wp_i18n_namespaceObject.__)('Select %s'), blockInformation?.title),
    showTooltip: true,
    icon: (0,external_wp_element_namespaceObject.createElement)(block_icon, {
      icon: blockInformation?.icon
    })
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/preview-block-popover.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function PreviewBlockPopover({
  blocks
}) {
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-switcher__popover__preview__parent"
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-switcher__popover__preview__container"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Popover, {
    className: "block-editor-block-switcher__preview__popover",
    placement: "bottom-start",
    focusOnMount: false
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-switcher__preview"
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-switcher__preview-title"
  }, (0,external_wp_i18n_namespaceObject.__)('Preview')), (0,external_wp_element_namespaceObject.createElement)(block_preview, {
    viewportWidth: 500,
    blocks: blocks
  })))));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/block-variation-transformations.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




const block_variation_transformations_EMPTY_OBJECT = {};
function useBlockVariationTransforms({
  clientIds,
  blocks
}) {
  const {
    activeBlockVariation,
    blockVariationTransformations
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockRootClientId,
      getBlockAttributes,
      canRemoveBlocks
    } = select(store);
    const {
      getActiveBlockVariation,
      getBlockVariations
    } = select(external_wp_blocks_namespaceObject.store);
    const rootClientId = getBlockRootClientId(Array.isArray(clientIds) ? clientIds[0] : clientIds);
    const canRemove = canRemoveBlocks(clientIds, rootClientId); // Only handle single selected blocks for now.

    if (blocks.length !== 1 || !canRemove) {
      return block_variation_transformations_EMPTY_OBJECT;
    }

    const [firstBlock] = blocks;
    return {
      blockVariationTransformations: getBlockVariations(firstBlock.name, 'transform'),
      activeBlockVariation: getActiveBlockVariation(firstBlock.name, getBlockAttributes(firstBlock.clientId))
    };
  }, [clientIds, blocks]);
  const transformations = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return blockVariationTransformations?.filter(({
      name
    }) => name !== activeBlockVariation?.name);
  }, [blockVariationTransformations, activeBlockVariation]);
  return transformations;
}

const BlockVariationTransformations = ({
  transformations,
  onSelect,
  blocks
}) => {
  const [hoveredTransformItemName, setHoveredTransformItemName] = (0,external_wp_element_namespaceObject.useState)();
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, hoveredTransformItemName && (0,external_wp_element_namespaceObject.createElement)(PreviewBlockPopover, {
    blocks: (0,external_wp_blocks_namespaceObject.cloneBlock)(blocks[0], transformations.find(({
      name
    }) => name === hoveredTransformItemName).attributes)
  }), transformations?.map(item => (0,external_wp_element_namespaceObject.createElement)(BlockVariationTranformationItem, {
    key: item.name,
    item: item,
    onSelect: onSelect,
    setHoveredTransformItemName: setHoveredTransformItemName
  })));
};

function BlockVariationTranformationItem({
  item,
  onSelect,
  setHoveredTransformItemName
}) {
  const {
    name,
    icon,
    title
  } = item;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    className: (0,external_wp_blocks_namespaceObject.getBlockMenuDefaultClassName)(name),
    onClick: event => {
      event.preventDefault();
      onSelect(name);
    },
    onMouseLeave: () => setHoveredTransformItemName(null),
    onMouseEnter: () => setHoveredTransformItemName(name)
  }, (0,external_wp_element_namespaceObject.createElement)(block_icon, {
    icon: icon,
    showColors: true
  }), title);
}

/* harmony default export */ var block_variation_transformations = (BlockVariationTransformations);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/block-transformations-menu.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




/**
 * Helper hook to group transformations to display them in a specific order in the UI.
 * For now we group only priority content driven transformations(ex. paragraph -> heading).
 *
 * Later on we could also group 'layout' transformations(ex. paragraph -> group) and
 * display them in different sections.
 *
 * @param {Object[]} possibleBlockTransformations The available block transformations.
 * @return {Record<string, Object[]>} The grouped block transformations.
 */

function useGroupedTransforms(possibleBlockTransformations) {
  const priorityContentTranformationBlocks = {
    'core/paragraph': 1,
    'core/heading': 2,
    'core/list': 3,
    'core/quote': 4
  };
  const transformations = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const priorityTextTranformsNames = Object.keys(priorityContentTranformationBlocks);
    return possibleBlockTransformations.reduce((accumulator, item) => {
      const {
        name
      } = item;

      if (priorityTextTranformsNames.includes(name)) {
        accumulator.priorityTextTransformations.push(item);
      } else {
        accumulator.restTransformations.push(item);
      }

      return accumulator;
    }, {
      priorityTextTransformations: [],
      restTransformations: []
    });
  }, [possibleBlockTransformations]); // Order the priority text transformations.

  transformations.priorityTextTransformations.sort(({
    name: currentName
  }, {
    name: nextName
  }) => {
    return priorityContentTranformationBlocks[currentName] < priorityContentTranformationBlocks[nextName] ? -1 : 1;
  });
  return transformations;
}

const BlockTransformationsMenu = ({
  className,
  possibleBlockTransformations,
  possibleBlockVariationTransformations,
  onSelect,
  onSelectVariation,
  blocks
}) => {
  const [hoveredTransformItemName, setHoveredTransformItemName] = (0,external_wp_element_namespaceObject.useState)();
  const {
    priorityTextTransformations,
    restTransformations
  } = useGroupedTransforms(possibleBlockTransformations); // We have to check if both content transformations(priority and rest) are set
  // in order to create a separate MenuGroup for them.

  const hasBothContentTransformations = priorityTextTransformations.length && restTransformations.length;
  const restTransformItems = !!restTransformations.length && (0,external_wp_element_namespaceObject.createElement)(RestTransformationItems, {
    restTransformations: restTransformations,
    onSelect: onSelect,
    setHoveredTransformItemName: setHoveredTransformItemName
  });
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuGroup, {
    label: (0,external_wp_i18n_namespaceObject.__)('Transform to'),
    className: className
  }, hoveredTransformItemName && (0,external_wp_element_namespaceObject.createElement)(PreviewBlockPopover, {
    blocks: (0,external_wp_blocks_namespaceObject.switchToBlockType)(blocks, hoveredTransformItemName)
  }), !!possibleBlockVariationTransformations?.length && (0,external_wp_element_namespaceObject.createElement)(block_variation_transformations, {
    transformations: possibleBlockVariationTransformations,
    blocks: blocks,
    onSelect: onSelectVariation
  }), priorityTextTransformations.map(item => (0,external_wp_element_namespaceObject.createElement)(BlockTranformationItem, {
    key: item.name,
    item: item,
    onSelect: onSelect,
    setHoveredTransformItemName: setHoveredTransformItemName
  })), !hasBothContentTransformations && restTransformItems), !!hasBothContentTransformations && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuGroup, {
    className: className
  }, restTransformItems));
};

function RestTransformationItems({
  restTransformations,
  onSelect,
  setHoveredTransformItemName
}) {
  return restTransformations.map(item => (0,external_wp_element_namespaceObject.createElement)(BlockTranformationItem, {
    key: item.name,
    item: item,
    onSelect: onSelect,
    setHoveredTransformItemName: setHoveredTransformItemName
  }));
}

function BlockTranformationItem({
  item,
  onSelect,
  setHoveredTransformItemName
}) {
  const {
    name,
    icon,
    title,
    isDisabled
  } = item;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    className: (0,external_wp_blocks_namespaceObject.getBlockMenuDefaultClassName)(name),
    onClick: event => {
      event.preventDefault();
      onSelect(name);
    },
    disabled: isDisabled,
    onMouseLeave: () => setHoveredTransformItemName(null),
    onMouseEnter: () => setHoveredTransformItemName(name)
  }, (0,external_wp_element_namespaceObject.createElement)(block_icon, {
    icon: icon,
    showColors: true
  }), title);
}

/* harmony default export */ var block_transformations_menu = (BlockTransformationsMenu);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-styles/menu-items.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const menu_items_noop = () => {};

function BlockStylesMenuItems({
  clientId,
  onSwitch = menu_items_noop
}) {
  const {
    onSelect,
    stylesToRender,
    activeStyle
  } = useStylesForBlocks({
    clientId,
    onSwitch
  });

  if (!stylesToRender || stylesToRender.length === 0) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, stylesToRender.map(style => {
    const menuItemText = style.label || style.name;
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
      key: style.name,
      icon: activeStyle.name === style.name ? library_check : null,
      onClick: () => onSelect(style)
    }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalText, {
      as: "span",
      limit: 18,
      ellipsizeMode: "tail",
      truncate: true
    }, menuItemText));
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/block-styles-menu.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function BlockStylesMenu({
  hoveredBlock,
  onSwitch
}) {
  const {
    clientId
  } = hoveredBlock;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuGroup, {
    label: (0,external_wp_i18n_namespaceObject.__)('Styles'),
    className: "block-editor-block-switcher__styles__menugroup"
  }, (0,external_wp_element_namespaceObject.createElement)(BlockStylesMenuItems, {
    clientId: clientId,
    onSwitch: onSwitch
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/utils.js
/**
 * WordPress dependencies
 */

/**
 * Try to find a matching block by a block's name in a provided
 * block. We recurse through InnerBlocks and return the reference
 * of the matched block (it could be an InnerBlock).
 * If no match is found return nothing.
 *
 * @param {WPBlock} block             The block to try to find a match.
 * @param {string}  selectedBlockName The block's name to use for matching condition.
 * @param {Set}     consumedBlocks    A set holding the previously matched/consumed blocks.
 *
 * @return {WPBlock | undefined} The matched block if found or nothing(`undefined`).
 */

const getMatchingBlockByName = (block, selectedBlockName, consumedBlocks = new Set()) => {
  const {
    clientId,
    name,
    innerBlocks = []
  } = block; // Check if block has been consumed already.

  if (consumedBlocks.has(clientId)) return;
  if (name === selectedBlockName) return block; // Try to find a matching block from InnerBlocks recursively.

  for (const innerBlock of innerBlocks) {
    const match = getMatchingBlockByName(innerBlock, selectedBlockName, consumedBlocks);
    if (match) return match;
  }
};
/**
 * Find and return the block attributes to retain through
 * the transformation, based on Block Type's `role:content`
 * attributes. If no `role:content` attributes exist,
 * return selected block's attributes.
 *
 * @param {string} name       Block type's namespaced name.
 * @param {Object} attributes Selected block's attributes.
 * @return {Object} The block's attributes to retain.
 */

const getRetainedBlockAttributes = (name, attributes) => {
  const contentAttributes = (0,external_wp_blocks_namespaceObject.__experimentalGetBlockAttributesNamesByRole)(name, 'content');
  if (!contentAttributes?.length) return attributes;
  return contentAttributes.reduce((_accumulator, attribute) => {
    if (attributes[attribute]) _accumulator[attribute] = attributes[attribute];
    return _accumulator;
  }, {});
};

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/use-transformed-patterns.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Mutate the matched block's attributes by getting
 * which block type's attributes to retain and prioritize
 * them in the merging of the attributes.
 *
 * @param {WPBlock} match         The matched block.
 * @param {WPBlock} selectedBlock The selected block.
 * @return {void}
 */

const transformMatchingBlock = (match, selectedBlock) => {
  // Get the block attributes to retain through the transformation.
  const retainedBlockAttributes = getRetainedBlockAttributes(selectedBlock.name, selectedBlock.attributes);
  match.attributes = { ...match.attributes,
    ...retainedBlockAttributes
  };
};
/**
 * By providing the selected blocks and pattern's blocks
 * find the matching blocks, transform them and return them.
 * If not all selected blocks are matched, return nothing.
 *
 * @param {WPBlock[]} selectedBlocks The selected blocks.
 * @param {WPBlock[]} patternBlocks  The pattern's blocks.
 * @return {WPBlock[]|void} The transformed pattern's blocks or undefined if not all selected blocks have been matched.
 */

const getPatternTransformedBlocks = (selectedBlocks, patternBlocks) => {
  // Clone Pattern's blocks to produce new clientIds and be able to mutate the matches.
  const _patternBlocks = patternBlocks.map(block => (0,external_wp_blocks_namespaceObject.cloneBlock)(block));
  /**
   * Keep track of the consumed pattern blocks.
   * This is needed because we loop the selected blocks
   * and for example we may have selected two paragraphs and
   * the pattern's blocks could have more `paragraphs`.
   */


  const consumedBlocks = new Set();

  for (const selectedBlock of selectedBlocks) {
    let isMatch = false;

    for (const patternBlock of _patternBlocks) {
      const match = getMatchingBlockByName(patternBlock, selectedBlock.name, consumedBlocks);
      if (!match) continue;
      isMatch = true;
      consumedBlocks.add(match.clientId); // We update (mutate) the matching pattern block.

      transformMatchingBlock(match, selectedBlock); // No need to loop through other pattern's blocks.

      break;
    } // Bail eary if a selected block has not been matched.


    if (!isMatch) return;
  }

  return _patternBlocks;
};
/**
 * @typedef {WPBlockPattern & {transformedBlocks: WPBlock[]}} TransformedBlockPattern
 */

/**
 * Custom hook that accepts patterns from state and the selected
 * blocks and tries to match these with the pattern's blocks.
 * If all selected blocks are matched with a Pattern's block,
 * we transform them by retaining block's attributes with `role:content`.
 * The transformed pattern's blocks are set to a new pattern
 * property `transformedBlocks`.
 *
 * @param {WPBlockPattern[]} patterns       Patterns from state.
 * @param {WPBlock[]}        selectedBlocks The currently selected blocks.
 * @return {TransformedBlockPattern[]} Returns the eligible matched patterns with all the selected blocks.
 */

const useTransformedPatterns = (patterns, selectedBlocks) => {
  return (0,external_wp_element_namespaceObject.useMemo)(() => patterns.reduce((accumulator, _pattern) => {
    const transformedBlocks = getPatternTransformedBlocks(selectedBlocks, _pattern.blocks);

    if (transformedBlocks) {
      accumulator.push({ ..._pattern,
        transformedBlocks
      });
    }

    return accumulator;
  }, []), [patterns, selectedBlocks]);
};

/* harmony default export */ var use_transformed_patterns = (useTransformedPatterns);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/pattern-transformations-menu.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




function PatternTransformationsMenu({
  blocks,
  patterns: statePatterns,
  onSelect
}) {
  const [showTransforms, setShowTransforms] = (0,external_wp_element_namespaceObject.useState)(false);
  const patterns = use_transformed_patterns(statePatterns, blocks);
  if (!patterns.length) return null;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuGroup, {
    className: "block-editor-block-switcher__pattern__transforms__menugroup"
  }, showTransforms && (0,external_wp_element_namespaceObject.createElement)(PreviewPatternsPopover, {
    patterns: patterns,
    onSelect: onSelect
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.MenuItem, {
    onClick: event => {
      event.preventDefault();
      setShowTransforms(!showTransforms);
    },
    icon: chevron_right
  }, (0,external_wp_i18n_namespaceObject.__)('Patterns')));
}

function PreviewPatternsPopover({
  patterns,
  onSelect
}) {
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-switcher__popover__preview__parent"
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-switcher__popover__preview__container"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Popover, {
    className: "block-editor-block-switcher__preview__popover",
    position: "bottom right"
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-switcher__preview"
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-switcher__preview-title"
  }, (0,external_wp_i18n_namespaceObject.__)('Preview')), (0,external_wp_element_namespaceObject.createElement)(BlockPatternsList, {
    patterns: patterns,
    onSelect: onSelect
  })))));
}

function BlockPatternsList({
  patterns,
  onSelect
}) {
  const composite = (0,external_wp_components_namespaceObject.__unstableUseCompositeState)();
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__unstableComposite, { ...composite,
    role: "listbox",
    className: "block-editor-block-switcher__preview-patterns-container",
    "aria-label": (0,external_wp_i18n_namespaceObject.__)('Patterns list')
  }, patterns.map(pattern => (0,external_wp_element_namespaceObject.createElement)(pattern_transformations_menu_BlockPattern, {
    key: pattern.name,
    pattern: pattern,
    onSelect: onSelect,
    composite: composite
  })));
}

function pattern_transformations_menu_BlockPattern({
  pattern,
  onSelect,
  composite
}) {
  // TODO check pattern/preview width...
  const baseClassName = 'block-editor-block-switcher__preview-patterns-container';
  const descriptionId = (0,external_wp_compose_namespaceObject.useInstanceId)(pattern_transformations_menu_BlockPattern, `${baseClassName}-list__item-description`);
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: `${baseClassName}-list__list-item`
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__unstableCompositeItem, {
    role: "option",
    as: "div",
    ...composite,
    "aria-label": pattern.title,
    "aria-describedby": pattern.description ? descriptionId : undefined,
    className: `${baseClassName}-list__item`,
    onClick: () => onSelect(pattern.transformedBlocks)
  }, (0,external_wp_element_namespaceObject.createElement)(block_preview, {
    blocks: pattern.transformedBlocks,
    viewportWidth: pattern.viewportWidth || 500
  }), (0,external_wp_element_namespaceObject.createElement)("div", {
    className: `${baseClassName}-list__item-title`
  }, pattern.title)), !!pattern.description && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.VisuallyHidden, {
    id: descriptionId
  }, pattern.description));
}

/* harmony default export */ var pattern_transformations_menu = (PatternTransformationsMenu);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/index.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */









const BlockSwitcherDropdownMenu = ({
  clientIds,
  blocks
}) => {
  const {
    replaceBlocks,
    multiSelect,
    updateBlockAttributes
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const blockInformation = useBlockDisplayInformation(blocks[0].clientId);
  const {
    possibleBlockTransformations,
    canRemove,
    hasBlockStyles,
    icon,
    patterns
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockRootClientId,
      getBlockTransformItems,
      __experimentalGetPatternTransformItems,
      canRemoveBlocks
    } = select(store);
    const {
      getBlockStyles,
      getBlockType
    } = select(external_wp_blocks_namespaceObject.store);
    const rootClientId = getBlockRootClientId(Array.isArray(clientIds) ? clientIds[0] : clientIds);
    const [{
      name: firstBlockName
    }] = blocks;

    const _isSingleBlockSelected = blocks.length === 1;

    const styles = _isSingleBlockSelected && getBlockStyles(firstBlockName);

    let _icon;

    if (_isSingleBlockSelected) {
      _icon = blockInformation?.icon; // Take into account active block variations.
    } else {
      const isSelectionOfSameType = new Set(blocks.map(({
        name
      }) => name)).size === 1; // When selection consists of blocks of multiple types, display an
      // appropriate icon to communicate the non-uniformity.

      _icon = isSelectionOfSameType ? getBlockType(firstBlockName)?.icon : library_copy;
    }

    return {
      possibleBlockTransformations: getBlockTransformItems(blocks, rootClientId),
      canRemove: canRemoveBlocks(clientIds, rootClientId),
      hasBlockStyles: !!styles?.length,
      icon: _icon,
      patterns: __experimentalGetPatternTransformItems(blocks, rootClientId)
    };
  }, [clientIds, blocks, blockInformation?.icon]);
  const blockVariationTransformations = useBlockVariationTransforms({
    clientIds,
    blocks
  });
  const blockTitle = useBlockDisplayTitle({
    clientId: Array.isArray(clientIds) ? clientIds[0] : clientIds,
    maximumLength: 35
  });
  const isReusable = blocks.length === 1 && (0,external_wp_blocks_namespaceObject.isReusableBlock)(blocks[0]);
  const isTemplate = blocks.length === 1 && (0,external_wp_blocks_namespaceObject.isTemplatePart)(blocks[0]);

  function selectForMultipleBlocks(insertedBlocks) {
    if (insertedBlocks.length > 1) {
      multiSelect(insertedBlocks[0].clientId, insertedBlocks[insertedBlocks.length - 1].clientId);
    }
  } // Simple block tranformation based on the `Block Transforms` API.


  function onBlockTransform(name) {
    const newBlocks = (0,external_wp_blocks_namespaceObject.switchToBlockType)(blocks, name);
    replaceBlocks(clientIds, newBlocks);
    selectForMultipleBlocks(newBlocks);
  }

  function onBlockVariationTransform(name) {
    updateBlockAttributes(blocks[0].clientId, { ...blockVariationTransformations.find(({
        name: variationName
      }) => variationName === name).attributes
    });
  } // Pattern transformation through the `Patterns` API.


  function onPatternTransform(transformedBlocks) {
    replaceBlocks(clientIds, transformedBlocks);
    selectForMultipleBlocks(transformedBlocks);
  }
  /**
   * The `isTemplate` check is a stopgap solution here.
   * Ideally, the Transforms API should handle this
   * by allowing to exclude blocks from wildcard transformations.
   */


  const hasPossibleBlockTransformations = !!possibleBlockTransformations.length && canRemove && !isTemplate;
  const hasPossibleBlockVariationTransformations = !!blockVariationTransformations?.length;
  const hasPatternTransformation = !!patterns?.length && canRemove;

  if (!hasBlockStyles && !hasPossibleBlockTransformations && !hasPossibleBlockVariationTransformations) {
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarGroup, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarButton, {
      disabled: true,
      className: "block-editor-block-switcher__no-switcher-icon",
      title: blockTitle,
      icon: (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(block_icon, {
        icon: icon,
        showColors: true
      }), (isReusable || isTemplate) && (0,external_wp_element_namespaceObject.createElement)("span", {
        className: "block-editor-block-switcher__toggle-text"
      }, blockTitle))
    }));
  }

  const blockSwitcherLabel = blockTitle;
  const blockSwitcherDescription = 1 === blocks.length ? (0,external_wp_i18n_namespaceObject.sprintf)(
  /* translators: %s: block title. */
  (0,external_wp_i18n_namespaceObject.__)('%s: Change block type or style'), blockTitle) : (0,external_wp_i18n_namespaceObject.sprintf)(
  /* translators: %d: number of blocks. */
  (0,external_wp_i18n_namespaceObject._n)('Change type of %d block', 'Change type of %d blocks', blocks.length), blocks.length);
  const hasBlockOrBlockVariationTransforms = hasPossibleBlockTransformations || hasPossibleBlockVariationTransformations;
  const showDropDown = hasBlockStyles || hasBlockOrBlockVariationTransforms || hasPatternTransformation;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarGroup, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarItem, null, toggleProps => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.DropdownMenu, {
    className: "block-editor-block-switcher",
    label: blockSwitcherLabel,
    popoverProps: {
      placement: 'bottom-start',
      className: 'block-editor-block-switcher__popover'
    },
    icon: (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(block_icon, {
      icon: icon,
      className: "block-editor-block-switcher__toggle",
      showColors: true
    }), (isReusable || isTemplate) && (0,external_wp_element_namespaceObject.createElement)("span", {
      className: "block-editor-block-switcher__toggle-text"
    }, blockTitle)),
    toggleProps: {
      describedBy: blockSwitcherDescription,
      ...toggleProps
    },
    menuProps: {
      orientation: 'both'
    }
  }, ({
    onClose
  }) => showDropDown && (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-block-switcher__container"
  }, hasPatternTransformation && (0,external_wp_element_namespaceObject.createElement)(pattern_transformations_menu, {
    blocks: blocks,
    patterns: patterns,
    onSelect: transformedBlocks => {
      onPatternTransform(transformedBlocks);
      onClose();
    }
  }), hasBlockOrBlockVariationTransforms && (0,external_wp_element_namespaceObject.createElement)(block_transformations_menu, {
    className: "block-editor-block-switcher__transforms__menugroup",
    possibleBlockTransformations: possibleBlockTransformations,
    possibleBlockVariationTransformations: blockVariationTransformations,
    blocks: blocks,
    onSelect: name => {
      onBlockTransform(name);
      onClose();
    },
    onSelectVariation: name => {
      onBlockVariationTransform(name);
      onClose();
    }
  }), hasBlockStyles && (0,external_wp_element_namespaceObject.createElement)(BlockStylesMenu, {
    hoveredBlock: blocks[0],
    onSwitch: onClose
  })))));
};
const BlockSwitcher = ({
  clientIds
}) => {
  const blocks = (0,external_wp_data_namespaceObject.useSelect)(select => select(store).getBlocksByClientId(clientIds), [clientIds]);

  if (!blocks.length || blocks.some(block => !block)) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(BlockSwitcherDropdownMenu, {
    clientIds: clientIds,
    blocks: blocks
  });
};
/* harmony default export */ var block_switcher = (BlockSwitcher);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-lock/toolbar.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



function BlockLockToolbar({
  clientId,
  wrapperRef
}) {
  const {
    canEdit,
    canMove,
    canRemove,
    canLock
  } = useBlockLock(clientId);
  const [isModalOpen, toggleModal] = (0,external_wp_element_namespaceObject.useReducer)(isActive => !isActive, false);
  const lockButtonRef = (0,external_wp_element_namespaceObject.useRef)(null);
  const isFirstRender = (0,external_wp_element_namespaceObject.useRef)(true);
  const shouldHideBlockLockUI = !canLock || canEdit && canMove && canRemove; // Restore focus manually on the first focusable element in the toolbar
  // when the block lock modal is closed and the block is not locked anymore.
  // See https://github.com/WordPress/gutenberg/issues/51447

  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }

    if (!isModalOpen && shouldHideBlockLockUI) {
      external_wp_dom_namespaceObject.focus.focusable.find(wrapperRef.current, {
        sequential: false
      }).find(element => element.tagName === 'BUTTON' && element !== lockButtonRef.current)?.focus();
    } // wrapperRef is a reference object and should be stable

  }, [isModalOpen, shouldHideBlockLockUI, wrapperRef]);

  if (shouldHideBlockLockUI) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarGroup, {
    className: "block-editor-block-lock-toolbar"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarButton, {
    icon: library_lock,
    label: (0,external_wp_i18n_namespaceObject.__)('Unlock'),
    onClick: toggleModal,
    ref: lockButtonRef
  })), isModalOpen && (0,external_wp_element_namespaceObject.createElement)(BlockLockModal, {
    clientId: clientId,
    onClose: toggleModal
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/group.js


/**
 * WordPress dependencies
 */

const group_group = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M18 4h-7c-1.1 0-2 .9-2 2v3H6c-1.1 0-2 .9-2 2v7c0 1.1.9 2 2 2h7c1.1 0 2-.9 2-2v-3h3c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-4.5 14c0 .3-.2.5-.5.5H6c-.3 0-.5-.2-.5-.5v-7c0-.3.2-.5.5-.5h3V13c0 1.1.9 2 2 2h2.5v3zm0-4.5H11c-.3 0-.5-.2-.5-.5v-2.5H13c.3 0 .5.2.5.5v2.5zm5-.5c0 .3-.2.5-.5.5h-3V11c0-1.1-.9-2-2-2h-2.5V6c0-.3.2-.5.5-.5h7c.3 0 .5.2.5.5v7z"
}));
/* harmony default export */ var library_group = (group_group);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/row.js


/**
 * WordPress dependencies
 */

const row = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M4 6.5h5a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H4V16h5a.5.5 0 0 0 .5-.5v-7A.5.5 0 0 0 9 8H4V6.5Zm16 0h-5a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h5V16h-5a.5.5 0 0 1-.5-.5v-7A.5.5 0 0 1 15 8h5V6.5Z"
}));
/* harmony default export */ var library_row = (row);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/stack.js


/**
 * WordPress dependencies
 */

const stack = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M17.5 4v5a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V4H8v5a.5.5 0 0 0 .5.5h7A.5.5 0 0 0 16 9V4h1.5Zm0 16v-5a2 2 0 0 0-2-2h-7a2 2 0 0 0-2 2v5H8v-5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 .5.5v5h1.5Z"
}));
/* harmony default export */ var library_stack = (stack);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/convert-to-group-buttons/toolbar.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



const layouts = {
  group: {
    type: 'constrained'
  },
  row: {
    type: 'flex',
    flexWrap: 'nowrap'
  },
  stack: {
    type: 'flex',
    orientation: 'vertical'
  }
};

function BlockGroupToolbar() {
  const {
    blocksSelection,
    clientIds,
    groupingBlockName,
    isGroupable
  } = useConvertToGroupButtonProps();
  const {
    replaceBlocks
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const {
    canRemove,
    variations
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      canRemoveBlocks
    } = select(store);
    const {
      getBlockVariations
    } = select(external_wp_blocks_namespaceObject.store);
    return {
      canRemove: canRemoveBlocks(clientIds),
      variations: getBlockVariations(groupingBlockName, 'transform')
    };
  }, [clientIds, groupingBlockName]);

  const onConvertToGroup = layout => {
    const newBlocks = (0,external_wp_blocks_namespaceObject.switchToBlockType)(blocksSelection, groupingBlockName);

    if (typeof layout !== 'string') {
      layout = 'group';
    }

    if (newBlocks && newBlocks.length > 0) {
      // Because the block is not in the store yet we can't use
      // updateBlockAttributes so need to manually update attributes.
      newBlocks[0].attributes.layout = layouts[layout];
      replaceBlocks(clientIds, newBlocks);
    }
  };

  const onConvertToRow = () => onConvertToGroup('row');

  const onConvertToStack = () => onConvertToGroup('stack'); // Don't render the button if the current selection cannot be grouped.
  // A good example is selecting multiple button blocks within a Buttons block:
  // The group block is not a valid child of Buttons, so we should not show the button.
  // Any blocks that are locked against removal also cannot be grouped.


  if (!isGroupable || !canRemove) {
    return null;
  }

  const canInsertRow = !!variations.find(({
    name
  }) => name === 'group-row');
  const canInsertStack = !!variations.find(({
    name
  }) => name === 'group-stack');
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarGroup, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarButton, {
    icon: library_group,
    label: (0,external_wp_i18n_namespaceObject._x)('Group', 'verb'),
    onClick: onConvertToGroup
  }), canInsertRow && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarButton, {
    icon: library_row,
    label: (0,external_wp_i18n_namespaceObject._x)('Row', 'single horizontal line'),
    onClick: onConvertToRow
  }), canInsertStack && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarButton, {
    icon: library_stack,
    label: (0,external_wp_i18n_namespaceObject._x)('Stack', 'verb'),
    onClick: onConvertToStack
  }));
}

/* harmony default export */ var toolbar = (BlockGroupToolbar);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-edit-visually-button/index.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


function BlockEditVisuallyButton({
  clientIds
}) {
  // Edit visually only works for single block selection.
  const clientId = clientIds.length === 1 ? clientIds[0] : undefined;
  const canEditVisually = (0,external_wp_data_namespaceObject.useSelect)(select => !!clientId && select(store).getBlockMode(clientId) === 'html', [clientId]);
  const {
    toggleBlockMode
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);

  if (!canEditVisually) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarGroup, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarButton, {
    onClick: () => {
      toggleBlockMode(clientId);
    }
  }, (0,external_wp_i18n_namespaceObject.__)('Edit visually')));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-toolbar/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */















const BlockToolbar = ({
  hideDragHandle
}) => {
  const {
    blockClientIds,
    blockClientId,
    blockType,
    hasFixedToolbar,
    isDistractionFree,
    isValid,
    isVisual,
    blockEditingMode
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockName,
      getBlockMode,
      getSelectedBlockClientIds,
      isBlockValid,
      getBlockRootClientId,
      getSettings,
      getBlockEditingMode
    } = unlock(select(store));
    const selectedBlockClientIds = getSelectedBlockClientIds();
    const selectedBlockClientId = selectedBlockClientIds[0];
    const blockRootClientId = getBlockRootClientId(selectedBlockClientId);
    const settings = getSettings();
    return {
      blockClientIds: selectedBlockClientIds,
      blockClientId: selectedBlockClientId,
      blockType: selectedBlockClientId && (0,external_wp_blocks_namespaceObject.getBlockType)(getBlockName(selectedBlockClientId)),
      hasFixedToolbar: settings.hasFixedToolbar,
      isDistractionFree: settings.isDistractionFree,
      rootClientId: blockRootClientId,
      isValid: selectedBlockClientIds.every(id => isBlockValid(id)),
      isVisual: selectedBlockClientIds.every(id => getBlockMode(id) === 'visual'),
      blockEditingMode: getBlockEditingMode(selectedBlockClientId)
    };
  }, []);
  const toolbarWrapperRef = (0,external_wp_element_namespaceObject.useRef)(null); // Handles highlighting the current block outline on hover or focus of the
  // block type toolbar area.

  const {
    toggleBlockHighlight
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const nodeRef = (0,external_wp_element_namespaceObject.useRef)();
  const {
    showMovers,
    gestures: showMoversGestures
  } = useShowMoversGestures({
    ref: nodeRef,

    onChange(isFocused) {
      if (isFocused && isDistractionFree) {
        return;
      }

      toggleBlockHighlight(blockClientId, isFocused);
    }

  }); // Account for the cases where the block toolbar is rendered within the
  // header area and not contextually to the block.

  const displayHeaderToolbar = (0,external_wp_compose_namespaceObject.useViewportMatch)('medium', '<') || hasFixedToolbar;
  const isLargeViewport = !(0,external_wp_compose_namespaceObject.useViewportMatch)('medium', '<');

  if (blockType) {
    if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, '__experimentalToolbar', true)) {
      return null;
    }
  }

  const shouldShowMovers = displayHeaderToolbar || showMovers;

  if (blockClientIds.length === 0) {
    return null;
  }

  const shouldShowVisualToolbar = isValid && isVisual;
  const isMultiToolbar = blockClientIds.length > 1;
  const isSynced = (0,external_wp_blocks_namespaceObject.isReusableBlock)(blockType) || (0,external_wp_blocks_namespaceObject.isTemplatePart)(blockType);
  const classes = classnames_default()('block-editor-block-toolbar', {
    'is-showing-movers': shouldShowMovers,
    'is-synced': isSynced
  });
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: classes,
    ref: toolbarWrapperRef
  }, !isMultiToolbar && isLargeViewport && blockEditingMode === 'default' && (0,external_wp_element_namespaceObject.createElement)(BlockParentSelector, null), (shouldShowVisualToolbar || isMultiToolbar) && blockEditingMode === 'default' && (0,external_wp_element_namespaceObject.createElement)("div", {
    ref: nodeRef,
    ...showMoversGestures
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarGroup, {
    className: "block-editor-block-toolbar__block-controls"
  }, (0,external_wp_element_namespaceObject.createElement)(block_switcher, {
    clientIds: blockClientIds
  }), !isMultiToolbar && (0,external_wp_element_namespaceObject.createElement)(BlockLockToolbar, {
    clientId: blockClientIds[0],
    wrapperRef: toolbarWrapperRef
  }), (0,external_wp_element_namespaceObject.createElement)(block_mover, {
    clientIds: blockClientIds,
    hideDragHandle: hideDragHandle
  }))), shouldShowVisualToolbar && isMultiToolbar && (0,external_wp_element_namespaceObject.createElement)(toolbar, null), shouldShowVisualToolbar && (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(block_controls.Slot, {
    group: "parent",
    className: "block-editor-block-toolbar__slot"
  }), (0,external_wp_element_namespaceObject.createElement)(block_controls.Slot, {
    group: "block",
    className: "block-editor-block-toolbar__slot"
  }), (0,external_wp_element_namespaceObject.createElement)(block_controls.Slot, {
    className: "block-editor-block-toolbar__slot"
  }), (0,external_wp_element_namespaceObject.createElement)(block_controls.Slot, {
    group: "inline",
    className: "block-editor-block-toolbar__slot"
  }), (0,external_wp_element_namespaceObject.createElement)(block_controls.Slot, {
    group: "other",
    className: "block-editor-block-toolbar__slot"
  }), (0,external_wp_element_namespaceObject.createElement)(block_name_context.Provider, {
    value: blockType?.name
  }, (0,external_wp_element_namespaceObject.createElement)(block_toolbar_last_item.Slot, null))), (0,external_wp_element_namespaceObject.createElement)(BlockEditVisuallyButton, {
    clientIds: blockClientIds
  }), blockEditingMode === 'default' && (0,external_wp_element_namespaceObject.createElement)(block_settings_menu, {
    clientIds: blockClientIds
  }));
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-toolbar/README.md
 */


/* harmony default export */ var block_toolbar = (BlockToolbar);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-tools/block-selection-button.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */










/**
 * Internal dependencies
 */








/**
 * Block selection button component, displaying the label of the block. If the block
 * descends from a root block, a button is displayed enabling the user to select
 * the root block.
 *
 * @param {string} props          Component props.
 * @param {string} props.clientId Client ID of block.
 *
 * @return {WPComponent} The component to be rendered.
 */

function BlockSelectionButton({
  clientId,
  rootClientId
}) {
  const blockInformation = useBlockDisplayInformation(clientId);
  const selected = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlock,
      getBlockIndex,
      hasBlockMovingClientId,
      getBlockListSettings,
      __unstableGetEditorMode
    } = select(store);
    const index = getBlockIndex(clientId);
    const {
      name,
      attributes
    } = getBlock(clientId);
    const blockMovingMode = hasBlockMovingClientId();
    return {
      index,
      name,
      attributes,
      blockMovingMode,
      orientation: getBlockListSettings(rootClientId)?.orientation,
      editorMode: __unstableGetEditorMode()
    };
  }, [clientId, rootClientId]);
  const {
    index,
    name,
    attributes,
    blockMovingMode,
    orientation,
    editorMode
  } = selected;
  const {
    setNavigationMode,
    removeBlock
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const ref = (0,external_wp_element_namespaceObject.useRef)();
  const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(name);
  const label = (0,external_wp_blocks_namespaceObject.__experimentalGetAccessibleBlockLabel)(blockType, attributes, index + 1, orientation); // Focus the breadcrumb in navigation mode.

  (0,external_wp_element_namespaceObject.useEffect)(() => {
    ref.current.focus();
    (0,external_wp_a11y_namespaceObject.speak)(label);
  }, [label]);
  const blockElement = useBlockElement(clientId);
  const {
    hasBlockMovingClientId,
    getBlockIndex,
    getBlockRootClientId,
    getClientIdsOfDescendants,
    getSelectedBlockClientId,
    getMultiSelectedBlocksEndClientId,
    getPreviousBlockClientId,
    getNextBlockClientId
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    selectBlock,
    clearSelectedBlock,
    setBlockMovingClientId,
    moveBlockToPosition
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);

  function onKeyDown(event) {
    const {
      keyCode
    } = event;
    const isUp = keyCode === external_wp_keycodes_namespaceObject.UP;
    const isDown = keyCode === external_wp_keycodes_namespaceObject.DOWN;
    const isLeft = keyCode === external_wp_keycodes_namespaceObject.LEFT;
    const isRight = keyCode === external_wp_keycodes_namespaceObject.RIGHT;
    const isTab = keyCode === external_wp_keycodes_namespaceObject.TAB;
    const isEscape = keyCode === external_wp_keycodes_namespaceObject.ESCAPE;
    const isEnter = keyCode === external_wp_keycodes_namespaceObject.ENTER;
    const isSpace = keyCode === external_wp_keycodes_namespaceObject.SPACE;
    const isShift = event.shiftKey;

    if (keyCode === external_wp_keycodes_namespaceObject.BACKSPACE || keyCode === external_wp_keycodes_namespaceObject.DELETE) {
      removeBlock(clientId);
      event.preventDefault();
      return;
    }

    const selectedBlockClientId = getSelectedBlockClientId();
    const selectionEndClientId = getMultiSelectedBlocksEndClientId();
    const selectionBeforeEndClientId = getPreviousBlockClientId(selectionEndClientId || selectedBlockClientId);
    const selectionAfterEndClientId = getNextBlockClientId(selectionEndClientId || selectedBlockClientId);
    const navigateUp = isTab && isShift || isUp;
    const navigateDown = isTab && !isShift || isDown; // Move out of current nesting level (no effect if at root level).

    const navigateOut = isLeft; // Move into next nesting level (no effect if the current block has no innerBlocks).

    const navigateIn = isRight;
    let focusedBlockUid;

    if (navigateUp) {
      focusedBlockUid = selectionBeforeEndClientId;
    } else if (navigateDown) {
      focusedBlockUid = selectionAfterEndClientId;
    } else if (navigateOut) {
      var _getBlockRootClientId;

      focusedBlockUid = (_getBlockRootClientId = getBlockRootClientId(selectedBlockClientId)) !== null && _getBlockRootClientId !== void 0 ? _getBlockRootClientId : selectedBlockClientId;
    } else if (navigateIn) {
      var _getClientIdsOfDescen;

      focusedBlockUid = (_getClientIdsOfDescen = getClientIdsOfDescendants([selectedBlockClientId])[0]) !== null && _getClientIdsOfDescen !== void 0 ? _getClientIdsOfDescen : selectedBlockClientId;
    }

    const startingBlockClientId = hasBlockMovingClientId();

    if (isEscape && startingBlockClientId && !event.defaultPrevented) {
      setBlockMovingClientId(null);
      event.preventDefault();
    }

    if ((isEnter || isSpace) && startingBlockClientId) {
      const sourceRoot = getBlockRootClientId(startingBlockClientId);
      const destRoot = getBlockRootClientId(selectedBlockClientId);
      const sourceBlockIndex = getBlockIndex(startingBlockClientId);
      let destinationBlockIndex = getBlockIndex(selectedBlockClientId);

      if (sourceBlockIndex < destinationBlockIndex && sourceRoot === destRoot) {
        destinationBlockIndex -= 1;
      }

      moveBlockToPosition(startingBlockClientId, sourceRoot, destRoot, destinationBlockIndex);
      selectBlock(startingBlockClientId);
      setBlockMovingClientId(null);
    }

    if (navigateDown || navigateUp || navigateOut || navigateIn) {
      if (focusedBlockUid) {
        event.preventDefault();
        selectBlock(focusedBlockUid);
      } else if (isTab && selectedBlockClientId) {
        let nextTabbable;

        if (navigateDown) {
          nextTabbable = blockElement;

          do {
            nextTabbable = external_wp_dom_namespaceObject.focus.tabbable.findNext(nextTabbable);
          } while (nextTabbable && blockElement.contains(nextTabbable));

          if (!nextTabbable) {
            nextTabbable = blockElement.ownerDocument.defaultView.frameElement;
            nextTabbable = external_wp_dom_namespaceObject.focus.tabbable.findNext(nextTabbable);
          }
        } else {
          nextTabbable = external_wp_dom_namespaceObject.focus.tabbable.findPrevious(blockElement);
        }

        if (nextTabbable) {
          event.preventDefault();
          nextTabbable.focus();
          clearSelectedBlock();
        }
      }
    }
  }

  const classNames = classnames_default()('block-editor-block-list__block-selection-button', {
    'is-block-moving-mode': !!blockMovingMode
  });

  const dragHandleLabel = (0,external_wp_i18n_namespaceObject.__)('Drag');

  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: classNames
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Flex, {
    justify: "center",
    className: "block-editor-block-list__block-selection-button__content"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, null, (0,external_wp_element_namespaceObject.createElement)(block_icon, {
    icon: blockInformation?.icon,
    showColors: true
  })), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, null, editorMode === 'zoom-out' && (0,external_wp_element_namespaceObject.createElement)(block_mover, {
    clientIds: [clientId],
    hideDragHandle: true
  }), editorMode === 'navigation' && (0,external_wp_element_namespaceObject.createElement)(block_draggable, {
    clientIds: [clientId]
  }, draggableProps => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    icon: drag_handle,
    className: "block-selection-button_drag-handle",
    "aria-hidden": "true",
    label: dragHandleLabel // Should not be able to tab to drag handle as this
    // button can only be used with a pointer device.
    ,
    tabIndex: "-1",
    ...draggableProps
  }))), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, null, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    ref: ref,
    onClick: editorMode === 'navigation' ? () => setNavigationMode(false) : undefined,
    onKeyDown: onKeyDown,
    label: label,
    showTooltip: false,
    className: "block-selection-button_select-button"
  }, (0,external_wp_element_namespaceObject.createElement)(BlockTitle, {
    clientId: clientId,
    maximumLength: 35
  })))));
}

/* harmony default export */ var block_selection_button = (BlockSelectionButton);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/next.js


/**
 * WordPress dependencies
 */

const next = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M6.6 6L5.4 7l4.5 5-4.5 5 1.1 1 5.5-6-5.4-6zm6 0l-1.1 1 4.5 5-4.5 5 1.1 1 5.5-6-5.5-6z"
}));
/* harmony default export */ var library_next = (next);

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/previous.js


/**
 * WordPress dependencies
 */

const previous = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M11.6 7l-1.1-1L5 12l5.5 6 1.1-1L7 12l4.6-5zm6 0l-1.1-1-5.5 6 5.5 6 1.1-1-4.6-5 4.6-5z"
}));
/* harmony default export */ var library_previous = (previous);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-controls/use-has-block-controls.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function useHasAnyBlockControls() {
  let hasAnyBlockControls = false;

  for (const group in block_controls_groups) {
    // It is safe to violate the rules of hooks here as the `groups` object
    // is static and will not change length between renders. Do not return
    // early as that will cause the hook to be called a different number of
    // times between renders.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    if (useHasBlockControls(group)) {
      hasAnyBlockControls = true;
    }
  }

  return hasAnyBlockControls;
}
function useHasBlockControls(group = 'default') {
  const Slot = block_controls_groups[group]?.Slot;
  const fills = (0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(Slot?.__unstableName);

  if (!Slot) {
    typeof process !== "undefined" && process.env && "production" !== "production" ? 0 : void 0;
    return null;
  }

  return !!fills?.length;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-tools/block-contextual-toolbar.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */








/**
 * Internal dependencies
 */







function BlockContextualToolbar({
  focusOnMount,
  isFixed,
  ...props
}) {
  // When the toolbar is fixed it can be collapsed
  const [isCollapsed, setIsCollapsed] = (0,external_wp_element_namespaceObject.useState)(false);
  const toolbarButtonRef = (0,external_wp_element_namespaceObject.useRef)();
  const isLargeViewport = (0,external_wp_compose_namespaceObject.useViewportMatch)('medium');
  const {
    blockType,
    blockEditingMode,
    hasParents,
    showParentSelector,
    selectedBlockClientId
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockName,
      getBlockParents,
      getSelectedBlockClientIds,
      getBlockEditingMode
    } = unlock(select(store));
    const {
      getBlockType
    } = select(external_wp_blocks_namespaceObject.store);
    const selectedBlockClientIds = getSelectedBlockClientIds();
    const _selectedBlockClientId = selectedBlockClientIds[0];
    const parents = getBlockParents(_selectedBlockClientId);
    const firstParentClientId = parents[parents.length - 1];
    const parentBlockName = getBlockName(firstParentClientId);
    const parentBlockType = getBlockType(parentBlockName);
    return {
      selectedBlockClientId: _selectedBlockClientId,
      blockType: _selectedBlockClientId && getBlockType(getBlockName(_selectedBlockClientId)),
      blockEditingMode: getBlockEditingMode(_selectedBlockClientId),
      hasParents: parents.length,
      showParentSelector: parentBlockType && getBlockEditingMode(firstParentClientId) === 'default' && (0,external_wp_blocks_namespaceObject.hasBlockSupport)(parentBlockType, '__experimentalParentSelector', true) && selectedBlockClientIds.length <= 1 && getBlockEditingMode(_selectedBlockClientId) === 'default'
    };
  }, []);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    setIsCollapsed(false);
  }, [selectedBlockClientId]);
  const isLargerThanTabletViewport = (0,external_wp_compose_namespaceObject.useViewportMatch)('large', '>=');
  const isFullscreen = document.body.classList.contains('is-fullscreen-mode');
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    // don't do anything if not fixed toolbar
    if (!isFixed || !blockType) {
      return;
    }

    const blockToolbar = document.querySelector('.block-editor-block-contextual-toolbar');

    if (!blockToolbar) {
      return;
    }

    if (!isLargerThanTabletViewport) {
      // set the width of the toolbar to auto
      blockToolbar.style = {};
      return;
    }

    if (isCollapsed) {
      // set the width of the toolbar to auto
      blockToolbar.style.width = 'auto';
      return;
    } // get the width of the pinned items in the post editor


    const pinnedItems = document.querySelector('.edit-post-header__settings'); // get the width of the left header in the site editor

    const leftHeader = document.querySelector('.edit-site-header-edit-mode__end');
    const computedToolbarStyle = window.getComputedStyle(blockToolbar);
    const computedPinnedItemsStyle = pinnedItems ? window.getComputedStyle(pinnedItems) : false;
    const computedLeftHeaderStyle = leftHeader ? window.getComputedStyle(leftHeader) : false;
    const marginLeft = parseFloat(computedToolbarStyle.marginLeft);
    const pinnedItemsWidth = computedPinnedItemsStyle ? parseFloat(computedPinnedItemsStyle.width) + 10 // 10 is the pinned items padding
    : 0;
    const leftHeaderWidth = computedLeftHeaderStyle ? parseFloat(computedLeftHeaderStyle.width) : 0; // set the new witdth of the toolbar

    blockToolbar.style.width = `calc(100% - ${leftHeaderWidth + pinnedItemsWidth + marginLeft + (isFullscreen ? 0 : 160) // the width of the admin sidebar expanded
    }px)`;
  }, [isFixed, isLargerThanTabletViewport, isCollapsed, isFullscreen, blockType]);
  const isToolbarEnabled = !blockType || (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, '__experimentalToolbar', true);
  const hasAnyBlockControls = useHasAnyBlockControls();

  if (!isToolbarEnabled || blockEditingMode !== 'default' && !hasAnyBlockControls) {
    return null;
  } // Shifts the toolbar to make room for the parent block selector.


  const classes = classnames_default()('block-editor-block-contextual-toolbar', {
    'has-parent': hasParents && showParentSelector,
    'is-fixed': isFixed,
    'is-collapsed': isCollapsed
  });
  return (0,external_wp_element_namespaceObject.createElement)(navigable_toolbar, {
    focusOnMount: focusOnMount,
    className: classes
    /* translators: accessibility text for the block toolbar */
    ,
    "aria-label": (0,external_wp_i18n_namespaceObject.__)('Block tools'),
    ...props
  }, !isCollapsed && (0,external_wp_element_namespaceObject.createElement)(block_toolbar, {
    hideDragHandle: isFixed
  }), isFixed && isLargeViewport && blockType && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarGroup, {
    className: isCollapsed ? 'block-editor-block-toolbar__group-expand-fixed-toolbar' : 'block-editor-block-toolbar__group-collapse-fixed-toolbar'
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ToolbarItem, {
    as: external_wp_components_namespaceObject.ToolbarButton,
    ref: toolbarButtonRef,
    icon: isCollapsed ? library_next : library_previous,
    onClick: () => {
      setIsCollapsed(collapsed => !collapsed);
      toolbarButtonRef.current.focus();
    },
    label: isCollapsed ? (0,external_wp_i18n_namespaceObject.__)('Show block tools') : (0,external_wp_i18n_namespaceObject.__)('Hide block tools')
  })));
}

/* harmony default export */ var block_contextual_toolbar = (BlockContextualToolbar);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-tools/use-block-toolbar-popover-props.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




const COMMON_PROPS = {
  placement: 'top-start'
}; // By default the toolbar sets the `shift` prop. If the user scrolls the page
// down the toolbar will stay on screen by adopting a sticky position at the
// top of the viewport.

const use_block_toolbar_popover_props_DEFAULT_PROPS = { ...COMMON_PROPS,
  flip: false,
  shift: true
}; // When there isn't enough height between the top of the block and the editor
// canvas, the `shift` prop is set to `false`, as it will cause the block to be
// obscured. The `flip` behavior is enabled, which positions the toolbar below
// the block. This only happens if the block is smaller than the viewport, as
// otherwise the toolbar will be off-screen.

const RESTRICTED_HEIGHT_PROPS = { ...COMMON_PROPS,
  flip: true,
  shift: false
};
/**
 * Get the popover props for the block toolbar, determined by the space at the top of the canvas and the toolbar height.
 *
 * @param {Element} contentElement       The DOM element that represents the editor content or canvas.
 * @param {Element} selectedBlockElement The outer DOM element of the first selected block.
 * @param {Element} scrollContainer      The scrollable container for the contentElement.
 * @param {number}  toolbarHeight        The height of the toolbar in pixels.
 * @param {boolean} isSticky             Whether or not the selected block is sticky or fixed.
 *
 * @return {Object} The popover props used to determine the position of the toolbar.
 */

function getProps(contentElement, selectedBlockElement, scrollContainer, toolbarHeight, isSticky) {
  if (!contentElement || !selectedBlockElement) {
    return use_block_toolbar_popover_props_DEFAULT_PROPS;
  } // Get how far the content area has been scrolled.


  const scrollTop = scrollContainer?.scrollTop || 0;
  const blockRect = selectedBlockElement.getBoundingClientRect();
  const contentRect = contentElement.getBoundingClientRect(); // Get the vertical position of top of the visible content area.

  const topOfContentElementInViewport = scrollTop + contentRect.top; // The document element's clientHeight represents the viewport height.

  const viewportHeight = contentElement.ownerDocument.documentElement.clientHeight; // The restricted height area is calculated as the sum of the
  // vertical position of the visible content area, plus the height
  // of the block toolbar.

  const restrictedTopArea = topOfContentElementInViewport + toolbarHeight;
  const hasSpaceForToolbarAbove = blockRect.top > restrictedTopArea;
  const isBlockTallerThanViewport = blockRect.height > viewportHeight - toolbarHeight; // Sticky blocks are treated as if they will never have enough space for the toolbar above.

  if (!isSticky && (hasSpaceForToolbarAbove || isBlockTallerThanViewport)) {
    return use_block_toolbar_popover_props_DEFAULT_PROPS;
  }

  return RESTRICTED_HEIGHT_PROPS;
}
/**
 * Determines the desired popover positioning behavior, returning a set of appropriate props.
 *
 * @param {Object}  elements
 * @param {Element} elements.contentElement The DOM element that represents the editor content or canvas.
 * @param {string}  elements.clientId       The clientId of the first selected block.
 *
 * @return {Object} The popover props used to determine the position of the toolbar.
 */


function useBlockToolbarPopoverProps({
  contentElement,
  clientId
}) {
  const selectedBlockElement = useBlockElement(clientId);
  const [toolbarHeight, setToolbarHeight] = (0,external_wp_element_namespaceObject.useState)(0);
  const {
    blockIndex,
    isSticky
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockIndex,
      getBlockAttributes
    } = select(store);
    return {
      blockIndex: getBlockIndex(clientId),
      isSticky: hasStickyOrFixedPositionValue(getBlockAttributes(clientId))
    };
  }, [clientId]);
  const scrollContainer = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (!contentElement) {
      return;
    }

    return (0,external_wp_dom_namespaceObject.getScrollContainer)(contentElement);
  }, [contentElement]);
  const [props, setProps] = (0,external_wp_element_namespaceObject.useState)(() => getProps(contentElement, selectedBlockElement, scrollContainer, toolbarHeight, isSticky));
  const popoverRef = (0,external_wp_compose_namespaceObject.useRefEffect)(popoverNode => {
    setToolbarHeight(popoverNode.offsetHeight);
  }, []);
  const updateProps = (0,external_wp_element_namespaceObject.useCallback)(() => setProps(getProps(contentElement, selectedBlockElement, scrollContainer, toolbarHeight, isSticky)), [contentElement, selectedBlockElement, scrollContainer, toolbarHeight]); // Update props when the block is moved. This also ensures the props are
  // correct on initial mount, and when the selected block or content element
  // changes (since the callback ref will update).

  (0,external_wp_element_namespaceObject.useLayoutEffect)(updateProps, [blockIndex, updateProps]); // Update props when the viewport is resized or the block is resized.

  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    if (!contentElement || !selectedBlockElement) {
      return;
    } // Update the toolbar props on viewport resize.


    const contentView = contentElement?.ownerDocument?.defaultView;
    contentView?.addEventHandler?.('resize', updateProps); // Update the toolbar props on block resize.

    let resizeObserver;
    const blockView = selectedBlockElement?.ownerDocument?.defaultView;

    if (blockView.ResizeObserver) {
      resizeObserver = new blockView.ResizeObserver(updateProps);
      resizeObserver.observe(selectedBlockElement);
    }

    return () => {
      contentView?.removeEventHandler?.('resize', updateProps);

      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  }, [updateProps, contentElement, selectedBlockElement]);
  return { ...props,
    ref: popoverRef
  };
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/use-should-contextual-toolbar-show.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/**
 * Returns true if the contextual block toolbar should show, or false if it should be hidden.
 *
 * @return {boolean} Whether the block toolbar is hidden.
 */

function useShouldContextualToolbarShow() {
  const isLargeViewport = (0,external_wp_compose_namespaceObject.useViewportMatch)('medium');
  const {
    shouldShowContextualToolbar,
    canFocusHiddenToolbar,
    fixedToolbarCanBeFocused
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      __unstableGetEditorMode,
      isMultiSelecting,
      isTyping,
      isBlockInterfaceHidden,
      getBlock,
      getSettings,
      isNavigationMode,
      getSelectedBlockClientId,
      getFirstMultiSelectedBlockClientId
    } = unlock(select(store));
    const isEditMode = __unstableGetEditorMode() === 'edit';
    const hasFixedToolbar = getSettings().hasFixedToolbar;
    const isDistractionFree = getSettings().isDistractionFree;
    const selectedBlockId = getFirstMultiSelectedBlockClientId() || getSelectedBlockClientId();
    const hasSelectedBlockId = !!selectedBlockId;
    const isEmptyDefaultBlock = (0,external_wp_blocks_namespaceObject.isUnmodifiedDefaultBlock)(getBlock(selectedBlockId) || {});

    const _shouldShowContextualToolbar = isEditMode && !hasFixedToolbar && (!isDistractionFree || isNavigationMode()) && isLargeViewport && !isMultiSelecting() && !isTyping() && hasSelectedBlockId && !isEmptyDefaultBlock && !isBlockInterfaceHidden();

    const _canFocusHiddenToolbar = isEditMode && hasSelectedBlockId && !_shouldShowContextualToolbar && !hasFixedToolbar && !isDistractionFree && !isEmptyDefaultBlock;

    return {
      shouldShowContextualToolbar: _shouldShowContextualToolbar,
      canFocusHiddenToolbar: _canFocusHiddenToolbar,
      fixedToolbarCanBeFocused: (hasFixedToolbar || !isLargeViewport) && selectedBlockId
    };
  }, [isLargeViewport]);
  return {
    shouldShowContextualToolbar,
    canFocusHiddenToolbar,
    fixedToolbarCanBeFocused
  };
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-tools/selected-block-popover.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */









function selected_block_popover_selector(select) {
  const {
    __unstableGetEditorMode,
    hasMultiSelection,
    isTyping,
    getLastMultiSelectedBlockClientId
  } = select(store);
  return {
    editorMode: __unstableGetEditorMode(),
    hasMultiSelection: hasMultiSelection(),
    isTyping: isTyping(),
    lastClientId: hasMultiSelection() ? getLastMultiSelectedBlockClientId() : null
  };
}

function SelectedBlockPopover({
  clientId,
  rootClientId,
  isEmptyDefaultBlock,
  capturingClientId,
  __unstablePopoverSlot,
  __unstableContentRef
}) {
  const {
    editorMode,
    hasMultiSelection,
    isTyping,
    lastClientId
  } = (0,external_wp_data_namespaceObject.useSelect)(selected_block_popover_selector, []);
  const isInsertionPointVisible = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      isBlockInsertionPointVisible,
      getBlockInsertionPoint,
      getBlockOrder
    } = select(store);

    if (!isBlockInsertionPointVisible()) {
      return false;
    }

    const insertionPoint = getBlockInsertionPoint();
    const order = getBlockOrder(insertionPoint.rootClientId);
    return order[insertionPoint.index] === clientId;
  }, [clientId]);
  const isToolbarForced = (0,external_wp_element_namespaceObject.useRef)(false);
  const {
    shouldShowContextualToolbar,
    canFocusHiddenToolbar
  } = useShouldContextualToolbarShow();
  const {
    stopTyping
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const showEmptyBlockSideInserter = !isTyping && editorMode === 'edit' && isEmptyDefaultBlock;
  const shouldShowBreadcrumb = !hasMultiSelection && (editorMode === 'navigation' || editorMode === 'zoom-out');
  (0,external_wp_keyboardShortcuts_namespaceObject.useShortcut)('core/block-editor/focus-toolbar', () => {
    isToolbarForced.current = true;
    stopTyping(true);
  }, {
    isDisabled: !canFocusHiddenToolbar
  });
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    isToolbarForced.current = false;
  }); // Stores the active toolbar item index so the block toolbar can return focus
  // to it when re-mounting.

  const initialToolbarItemIndexRef = (0,external_wp_element_namespaceObject.useRef)();
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    // Resets the index whenever the active block changes so this is not
    // persisted. See https://github.com/WordPress/gutenberg/pull/25760#issuecomment-717906169
    initialToolbarItemIndexRef.current = undefined;
  }, [clientId]);
  const popoverProps = useBlockToolbarPopoverProps({
    contentElement: __unstableContentRef?.current,
    clientId
  });

  if (showEmptyBlockSideInserter) {
    return (0,external_wp_element_namespaceObject.createElement)(block_popover, {
      clientId: capturingClientId || clientId,
      __unstableCoverTarget: true,
      bottomClientId: lastClientId,
      className: classnames_default()('block-editor-block-list__block-side-inserter-popover', {
        'is-insertion-point-visible': isInsertionPointVisible
      }),
      __unstablePopoverSlot: __unstablePopoverSlot,
      __unstableContentRef: __unstableContentRef,
      resize: false,
      shift: false,
      ...popoverProps
    }, (0,external_wp_element_namespaceObject.createElement)("div", {
      className: "block-editor-block-list__empty-block-inserter"
    }, (0,external_wp_element_namespaceObject.createElement)(inserter, {
      position: "bottom right",
      rootClientId: rootClientId,
      clientId: clientId,
      __experimentalIsQuick: true
    })));
  }

  if (shouldShowBreadcrumb || shouldShowContextualToolbar) {
    return (0,external_wp_element_namespaceObject.createElement)(block_popover, {
      clientId: capturingClientId || clientId,
      bottomClientId: lastClientId,
      className: classnames_default()('block-editor-block-list__block-popover', {
        'is-insertion-point-visible': isInsertionPointVisible
      }),
      __unstablePopoverSlot: __unstablePopoverSlot,
      __unstableContentRef: __unstableContentRef,
      resize: false,
      ...popoverProps
    }, shouldShowContextualToolbar && (0,external_wp_element_namespaceObject.createElement)(block_contextual_toolbar // If the toolbar is being shown because of being forced
    // it should focus the toolbar right after the mount.
    , {
      focusOnMount: isToolbarForced.current,
      __experimentalInitialIndex: initialToolbarItemIndexRef.current,
      __experimentalOnIndexChange: index => {
        initialToolbarItemIndexRef.current = index;
      } // Resets the index whenever the active block changes so
      // this is not persisted. See https://github.com/WordPress/gutenberg/pull/25760#issuecomment-717906169
      ,
      key: clientId
    }), shouldShowBreadcrumb && (0,external_wp_element_namespaceObject.createElement)(block_selection_button, {
      clientId: clientId,
      rootClientId: rootClientId
    }));
  }

  return null;
}

function wrapperSelector(select) {
  const {
    getSelectedBlockClientId,
    getFirstMultiSelectedBlockClientId,
    getBlockRootClientId,
    getBlock,
    getBlockParents,
    __experimentalGetBlockListSettingsForBlocks
  } = select(store);
  const clientId = getSelectedBlockClientId() || getFirstMultiSelectedBlockClientId();

  if (!clientId) {
    return;
  }

  const {
    name,
    attributes = {}
  } = getBlock(clientId) || {};
  const blockParentsClientIds = getBlockParents(clientId); // Get Block List Settings for all ancestors of the current Block clientId.

  const parentBlockListSettings = __experimentalGetBlockListSettingsForBlocks(blockParentsClientIds); // Get the clientId of the topmost parent with the capture toolbars setting.


  const capturingClientId = blockParentsClientIds.find(parentClientId => parentBlockListSettings[parentClientId]?.__experimentalCaptureToolbars);
  return {
    clientId,
    rootClientId: getBlockRootClientId(clientId),
    name,
    isEmptyDefaultBlock: name && (0,external_wp_blocks_namespaceObject.isUnmodifiedDefaultBlock)({
      name,
      attributes
    }),
    capturingClientId
  };
}

function WrappedBlockPopover({
  __unstablePopoverSlot,
  __unstableContentRef
}) {
  const selected = (0,external_wp_data_namespaceObject.useSelect)(wrapperSelector, []);

  if (!selected) {
    return null;
  }

  const {
    clientId,
    rootClientId,
    name,
    isEmptyDefaultBlock,
    capturingClientId
  } = selected;

  if (!name) {
    return null;
  }

  return (0,external_wp_element_namespaceObject.createElement)(SelectedBlockPopover, {
    clientId: clientId,
    rootClientId: rootClientId,
    isEmptyDefaultBlock: isEmptyDefaultBlock,
    capturingClientId: capturingClientId,
    __unstablePopoverSlot: __unstablePopoverSlot,
    __unstableContentRef: __unstableContentRef
  });
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-tools/zoom-out-mode-inserters.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





function ZoomOutModeInserters({
  __unstableContentRef
}) {
  const [isReady, setIsReady] = (0,external_wp_element_namespaceObject.useState)(false);
  const blockOrder = (0,external_wp_data_namespaceObject.useSelect)(select => {
    return select(store).getBlockOrder();
  }, []); // Defer the initial rendering to avoid the jumps due to the animation.

  (0,external_wp_element_namespaceObject.useEffect)(() => {
    const timeout = setTimeout(() => {
      setIsReady(true);
    }, 500);
    return () => {
      clearTimeout(timeout);
    };
  }, []);

  if (!isReady) {
    return null;
  }

  return blockOrder.map((clientId, index) => {
    if (index === blockOrder.length - 1) {
      return null;
    }

    return (0,external_wp_element_namespaceObject.createElement)(inbetween, {
      key: clientId,
      previousClientId: clientId,
      nextClientId: blockOrder[index + 1],
      __unstableContentRef: __unstableContentRef
    }, (0,external_wp_element_namespaceObject.createElement)("div", {
      className: "block-editor-block-list__insertion-point-inserter is-with-inserter"
    }, (0,external_wp_element_namespaceObject.createElement)(inserter, {
      position: "bottom center",
      clientId: blockOrder[index + 1],
      __experimentalIsQuick: true
    })));
  });
}

/* harmony default export */ var zoom_out_mode_inserters = (ZoomOutModeInserters);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-tools/index.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */








function block_tools_selector(select) {
  const {
    __unstableGetEditorMode,
    getSettings,
    isTyping
  } = select(store);
  return {
    isZoomOutMode: __unstableGetEditorMode() === 'zoom-out',
    hasFixedToolbar: getSettings().hasFixedToolbar,
    isTyping: isTyping()
  };
}
/**
 * Renders block tools (the block toolbar, select/navigation mode toolbar, the
 * insertion point and a slot for the inline rich text toolbar). Must be wrapped
 * around the block content and editor styles wrapper or iframe.
 *
 * @param {Object} $0                      Props.
 * @param {Object} $0.children             The block content and style container.
 * @param {Object} $0.__unstableContentRef Ref holding the content scroll container.
 */


function BlockTools({
  children,
  __unstableContentRef,
  ...props
}) {
  const isLargeViewport = (0,external_wp_compose_namespaceObject.useViewportMatch)('medium');
  const {
    hasFixedToolbar,
    isZoomOutMode,
    isTyping
  } = (0,external_wp_data_namespaceObject.useSelect)(block_tools_selector, []);
  const isMatch = (0,external_wp_keyboardShortcuts_namespaceObject.__unstableUseShortcutEventMatch)();
  const {
    getSelectedBlockClientIds,
    getBlockRootClientId
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    duplicateBlocks,
    removeBlocks,
    insertAfterBlock,
    insertBeforeBlock,
    clearSelectedBlock,
    selectBlock,
    moveBlocksUp,
    moveBlocksDown
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);

  function onKeyDown(event) {
    if (event.defaultPrevented) return;

    if (isMatch('core/block-editor/move-up', event)) {
      const clientIds = getSelectedBlockClientIds();

      if (clientIds.length) {
        event.preventDefault();
        const rootClientId = getBlockRootClientId(clientIds[0]);
        moveBlocksUp(clientIds, rootClientId);
      }
    } else if (isMatch('core/block-editor/move-down', event)) {
      const clientIds = getSelectedBlockClientIds();

      if (clientIds.length) {
        event.preventDefault();
        const rootClientId = getBlockRootClientId(clientIds[0]);
        moveBlocksDown(clientIds, rootClientId);
      }
    } else if (isMatch('core/block-editor/duplicate', event)) {
      const clientIds = getSelectedBlockClientIds();

      if (clientIds.length) {
        event.preventDefault();
        duplicateBlocks(clientIds);
      }
    } else if (isMatch('core/block-editor/remove', event)) {
      const clientIds = getSelectedBlockClientIds();

      if (clientIds.length) {
        event.preventDefault();
        removeBlocks(clientIds);
      }
    } else if (isMatch('core/block-editor/insert-after', event)) {
      const clientIds = getSelectedBlockClientIds();

      if (clientIds.length) {
        event.preventDefault();
        insertAfterBlock(clientIds[clientIds.length - 1]);
      }
    } else if (isMatch('core/block-editor/insert-before', event)) {
      const clientIds = getSelectedBlockClientIds();

      if (clientIds.length) {
        event.preventDefault();
        insertBeforeBlock(clientIds[0]);
      }
    } else if (isMatch('core/block-editor/unselect', event)) {
      const clientIds = getSelectedBlockClientIds();

      if (clientIds.length) {
        event.preventDefault(); // If there is more than one block selected, select the first
        // block so that focus is directed back to the beginning of the selection.
        // In effect, to the user this feels like deselecting the multi-selection.

        if (clientIds.length > 1) {
          selectBlock(clientIds[0]);
        } else {
          clearSelectedBlock();
        }

        event.target.ownerDocument.defaultView.getSelection().removeAllRanges();
        __unstableContentRef?.current.focus();
      }
    }
  }

  const blockToolbarRef = use_popover_scroll(__unstableContentRef);
  const blockToolbarAfterRef = use_popover_scroll(__unstableContentRef);
  return (// eslint-disable-next-line jsx-a11y/no-static-element-interactions
    (0,external_wp_element_namespaceObject.createElement)("div", { ...props,
      onKeyDown: onKeyDown
    }, (0,external_wp_element_namespaceObject.createElement)(insertion_point_InsertionPointOpenRef.Provider, {
      value: (0,external_wp_element_namespaceObject.useRef)(false)
    }, !isTyping && (0,external_wp_element_namespaceObject.createElement)(InsertionPoint, {
      __unstableContentRef: __unstableContentRef
    }), !isZoomOutMode && (hasFixedToolbar || !isLargeViewport) && (0,external_wp_element_namespaceObject.createElement)(block_contextual_toolbar, {
      isFixed: true
    }), (0,external_wp_element_namespaceObject.createElement)(WrappedBlockPopover, {
      __unstableContentRef: __unstableContentRef
    }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Popover.Slot, {
      name: "block-toolbar",
      ref: blockToolbarRef
    }), children, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Popover.Slot, {
      name: "__unstable-block-tools-after",
      ref: blockToolbarAfterRef
    }), isZoomOutMode && (0,external_wp_element_namespaceObject.createElement)(zoom_out_mode_inserters, {
      __unstableContentRef: __unstableContentRef
    })))
  );
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/library.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




const library_noop = () => {};

function InserterLibrary({
  rootClientId,
  clientId,
  isAppender,
  showInserterHelpPanel,
  showMostUsedBlocks = false,
  __experimentalInsertionIndex,
  __experimentalFilterValue,
  onSelect = library_noop,
  shouldFocusBlock = false
}, ref) {
  const {
    destinationRootClientId,
    prioritizePatterns
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getBlockRootClientId,
      getSettings
    } = select(store);

    const _rootClientId = rootClientId || getBlockRootClientId(clientId) || undefined;

    return {
      destinationRootClientId: _rootClientId,
      prioritizePatterns: getSettings().__experimentalPreferPatternsOnRoot && !_rootClientId
    };
  }, [clientId, rootClientId]);
  return (0,external_wp_element_namespaceObject.createElement)(menu, {
    onSelect: onSelect,
    rootClientId: destinationRootClientId,
    clientId: clientId,
    isAppender: isAppender,
    showInserterHelpPanel: showInserterHelpPanel,
    showMostUsedBlocks: showMostUsedBlocks,
    __experimentalInsertionIndex: __experimentalInsertionIndex,
    __experimentalFilterValue: __experimentalFilterValue,
    shouldFocusBlock: shouldFocusBlock,
    prioritizePatterns: prioritizePatterns,
    ref: ref
  });
}

/* harmony default export */ var library = ((0,external_wp_element_namespaceObject.forwardRef)(InserterLibrary));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/keyboard-shortcuts/index.js
/**
 * WordPress dependencies
 */





function KeyboardShortcuts() {
  return null;
}

function KeyboardShortcutsRegister() {
  // Registering the shortcuts.
  const {
    registerShortcut
  } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_keyboardShortcuts_namespaceObject.store);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    registerShortcut({
      name: 'core/block-editor/duplicate',
      category: 'block',
      description: (0,external_wp_i18n_namespaceObject.__)('Duplicate the selected block(s).'),
      keyCombination: {
        modifier: 'primaryShift',
        character: 'd'
      }
    });
    registerShortcut({
      name: 'core/block-editor/remove',
      category: 'block',
      description: (0,external_wp_i18n_namespaceObject.__)('Remove the selected block(s).'),
      keyCombination: {
        modifier: 'access',
        character: 'z'
      }
    });
    registerShortcut({
      name: 'core/block-editor/insert-before',
      category: 'block',
      description: (0,external_wp_i18n_namespaceObject.__)('Insert a new block before the selected block(s).'),
      keyCombination: {
        modifier: 'primaryAlt',
        character: 't'
      }
    });
    registerShortcut({
      name: 'core/block-editor/insert-after',
      category: 'block',
      description: (0,external_wp_i18n_namespaceObject.__)('Insert a new block after the selected block(s).'),
      keyCombination: {
        modifier: 'primaryAlt',
        character: 'y'
      }
    });
    registerShortcut({
      name: 'core/block-editor/delete-multi-selection',
      category: 'block',
      description: (0,external_wp_i18n_namespaceObject.__)('Delete selection.'),
      keyCombination: {
        character: 'del'
      },
      aliases: [{
        character: 'backspace'
      }]
    });
    registerShortcut({
      name: 'core/block-editor/select-all',
      category: 'selection',
      description: (0,external_wp_i18n_namespaceObject.__)('Select all text when typing. Press again to select all blocks.'),
      keyCombination: {
        modifier: 'primary',
        character: 'a'
      }
    });
    registerShortcut({
      name: 'core/block-editor/unselect',
      category: 'selection',
      description: (0,external_wp_i18n_namespaceObject.__)('Clear selection.'),
      keyCombination: {
        character: 'escape'
      }
    });
    registerShortcut({
      name: 'core/block-editor/focus-toolbar',
      category: 'global',
      description: (0,external_wp_i18n_namespaceObject.__)('Navigate to the nearest toolbar.'),
      keyCombination: {
        modifier: 'alt',
        character: 'F10'
      }
    });
    registerShortcut({
      name: 'core/block-editor/move-up',
      category: 'block',
      description: (0,external_wp_i18n_namespaceObject.__)('Move the selected block(s) up.'),
      keyCombination: {
        modifier: 'secondary',
        character: 't'
      }
    });
    registerShortcut({
      name: 'core/block-editor/move-down',
      category: 'block',
      description: (0,external_wp_i18n_namespaceObject.__)('Move the selected block(s) down.'),
      keyCombination: {
        modifier: 'secondary',
        character: 'y'
      }
    });
  }, [registerShortcut]);
  return null;
}

KeyboardShortcuts.Register = KeyboardShortcutsRegister;
/* harmony default export */ var keyboard_shortcuts = (KeyboardShortcuts);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/selection-scroll-into-view/index.js
/**
 * WordPress dependencies
 */

/**
 * Scrolls the multi block selection end into view if not in view already. This
 * is important to do after selection by keyboard.
 *
 * @deprecated
 */

function MultiSelectScrollIntoView() {
  external_wp_deprecated_default()('wp.blockEditor.MultiSelectScrollIntoView', {
    hint: 'This behaviour is now built-in.',
    since: '5.8'
  });
  return null;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/observe-typing/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/**
 * Set of key codes upon which typing is to be initiated on a keydown event.
 *
 * @type {Set<number>}
 */

const KEY_DOWN_ELIGIBLE_KEY_CODES = new Set([external_wp_keycodes_namespaceObject.UP, external_wp_keycodes_namespaceObject.RIGHT, external_wp_keycodes_namespaceObject.DOWN, external_wp_keycodes_namespaceObject.LEFT, external_wp_keycodes_namespaceObject.ENTER, external_wp_keycodes_namespaceObject.BACKSPACE]);
/**
 * Returns true if a given keydown event can be inferred as intent to start
 * typing, or false otherwise. A keydown is considered eligible if it is a
 * text navigation without shift active.
 *
 * @param {KeyboardEvent} event Keydown event to test.
 *
 * @return {boolean} Whether event is eligible to start typing.
 */

function isKeyDownEligibleForStartTyping(event) {
  const {
    keyCode,
    shiftKey
  } = event;
  return !shiftKey && KEY_DOWN_ELIGIBLE_KEY_CODES.has(keyCode);
}
/**
 * Removes the `isTyping` flag when the mouse moves in the document of the given
 * element.
 */


function useMouseMoveTypingReset() {
  const isTyping = (0,external_wp_data_namespaceObject.useSelect)(select => select(store).isTyping(), []);
  const {
    stopTyping
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    if (!isTyping) {
      return;
    }

    const {
      ownerDocument
    } = node;
    let lastClientX;
    let lastClientY;
    /**
     * On mouse move, unset typing flag if user has moved cursor.
     *
     * @param {MouseEvent} event Mousemove event.
     */

    function stopTypingOnMouseMove(event) {
      const {
        clientX,
        clientY
      } = event; // We need to check that the mouse really moved because Safari
      // triggers mousemove events when shift or ctrl are pressed.

      if (lastClientX && lastClientY && (lastClientX !== clientX || lastClientY !== clientY)) {
        stopTyping();
      }

      lastClientX = clientX;
      lastClientY = clientY;
    }

    ownerDocument.addEventListener('mousemove', stopTypingOnMouseMove);
    return () => {
      ownerDocument.removeEventListener('mousemove', stopTypingOnMouseMove);
    };
  }, [isTyping, stopTyping]);
}
/**
 * Sets and removes the `isTyping` flag based on user actions:
 *
 * - Sets the flag if the user types within the given element.
 * - Removes the flag when the user selects some text, focusses a non-text
 *   field, presses ESC or TAB, or moves the mouse in the document.
 */

function useTypingObserver() {
  const {
    isTyping,
    hasInlineToolbar
  } = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      isTyping: _isTyping,
      getSettings
    } = select(store);
    return {
      isTyping: _isTyping(),
      hasInlineToolbar: getSettings().hasInlineToolbar
    };
  }, []);
  const {
    startTyping,
    stopTyping
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const ref1 = useMouseMoveTypingReset();
  const ref2 = (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    const {
      ownerDocument
    } = node;
    const {
      defaultView
    } = ownerDocument;
    const selection = defaultView.getSelection(); // Listeners to stop typing should only be added when typing.
    // Listeners to start typing should only be added when not typing.

    if (isTyping) {
      let timerId;
      /**
       * Stops typing when focus transitions to a non-text field element.
       *
       * @param {FocusEvent} event Focus event.
       */

      function stopTypingOnNonTextField(event) {
        const {
          target
        } = event; // Since focus to a non-text field via arrow key will trigger
        // before the keydown event, wait until after current stack
        // before evaluating whether typing is to be stopped. Otherwise,
        // typing will re-start.

        timerId = defaultView.setTimeout(() => {
          if (!(0,external_wp_dom_namespaceObject.isTextField)(target)) {
            stopTyping();
          }
        });
      }
      /**
       * Unsets typing flag if user presses Escape while typing flag is
       * active.
       *
       * @param {KeyboardEvent} event Keypress or keydown event to
       *                              interpret.
       */


      function stopTypingOnEscapeKey(event) {
        const {
          keyCode
        } = event;

        if (keyCode === external_wp_keycodes_namespaceObject.ESCAPE || keyCode === external_wp_keycodes_namespaceObject.TAB) {
          stopTyping();
        }
      }
      /**
       * On selection change, unset typing flag if user has made an
       * uncollapsed (shift) selection.
       */


      function stopTypingOnSelectionUncollapse() {
        if (!selection.isCollapsed) {
          stopTyping();
        }
      }

      node.addEventListener('focus', stopTypingOnNonTextField);
      node.addEventListener('keydown', stopTypingOnEscapeKey);

      if (!hasInlineToolbar) {
        ownerDocument.addEventListener('selectionchange', stopTypingOnSelectionUncollapse);
      }

      return () => {
        defaultView.clearTimeout(timerId);
        node.removeEventListener('focus', stopTypingOnNonTextField);
        node.removeEventListener('keydown', stopTypingOnEscapeKey);
        ownerDocument.removeEventListener('selectionchange', stopTypingOnSelectionUncollapse);
      };
    }
    /**
     * Handles a keypress or keydown event to infer intention to start
     * typing.
     *
     * @param {KeyboardEvent} event Keypress or keydown event to interpret.
     */


    function startTypingInTextField(event) {
      const {
        type,
        target
      } = event; // Abort early if already typing, or key press is incurred outside a
      // text field (e.g. arrow-ing through toolbar buttons).
      // Ignore typing if outside the current DOM container

      if (!(0,external_wp_dom_namespaceObject.isTextField)(target) || !node.contains(target)) {
        return;
      } // Special-case keydown because certain keys do not emit a keypress
      // event. Conversely avoid keydown as the canonical event since
      // there are many keydown which are explicitly not targeted for
      // typing.


      if (type === 'keydown' && !isKeyDownEligibleForStartTyping(event)) {
        return;
      }

      startTyping();
    }

    node.addEventListener('keypress', startTypingInTextField);
    node.addEventListener('keydown', startTypingInTextField);
    return () => {
      node.removeEventListener('keypress', startTypingInTextField);
      node.removeEventListener('keydown', startTypingInTextField);
    };
  }, [isTyping, hasInlineToolbar, startTyping, stopTyping]);
  return (0,external_wp_compose_namespaceObject.useMergeRefs)([ref1, ref2]);
}

function ObserveTyping({
  children
}) {
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    ref: useTypingObserver()
  }, children);
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/observe-typing/README.md
 */


/* harmony default export */ var observe_typing = (ObserveTyping);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/typewriter/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


const isIE = window.navigator.userAgent.indexOf('Trident') !== -1;
const arrowKeyCodes = new Set([external_wp_keycodes_namespaceObject.UP, external_wp_keycodes_namespaceObject.DOWN, external_wp_keycodes_namespaceObject.LEFT, external_wp_keycodes_namespaceObject.RIGHT]);
const initialTriggerPercentage = 0.75;
function useTypewriter() {
  const hasSelectedBlock = (0,external_wp_data_namespaceObject.useSelect)(select => select(store).hasSelectedBlock(), []);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(node => {
    if (!hasSelectedBlock) {
      return;
    }

    const {
      ownerDocument
    } = node;
    const {
      defaultView
    } = ownerDocument;
    let scrollResizeRafId;
    let onKeyDownRafId;
    let caretRect;

    function onScrollResize() {
      if (scrollResizeRafId) {
        return;
      }

      scrollResizeRafId = defaultView.requestAnimationFrame(() => {
        computeCaretRectangle();
        scrollResizeRafId = null;
      });
    }

    function onKeyDown(event) {
      // Ensure the any remaining request is cancelled.
      if (onKeyDownRafId) {
        defaultView.cancelAnimationFrame(onKeyDownRafId);
      } // Use an animation frame for a smooth result.


      onKeyDownRafId = defaultView.requestAnimationFrame(() => {
        maintainCaretPosition(event);
        onKeyDownRafId = null;
      });
    }
    /**
     * Maintains the scroll position after a selection change caused by a
     * keyboard event.
     *
     * @param {KeyboardEvent} event Keyboard event.
     */


    function maintainCaretPosition({
      keyCode
    }) {
      if (!isSelectionEligibleForScroll()) {
        return;
      }

      const currentCaretRect = (0,external_wp_dom_namespaceObject.computeCaretRect)(defaultView);

      if (!currentCaretRect) {
        return;
      } // If for some reason there is no position set to be scrolled to, let
      // this be the position to be scrolled to in the future.


      if (!caretRect) {
        caretRect = currentCaretRect;
        return;
      } // Even though enabling the typewriter effect for arrow keys results in
      // a pleasant experience, it may not be the case for everyone, so, for
      // now, let's disable it.


      if (arrowKeyCodes.has(keyCode)) {
        // Reset the caret position to maintain.
        caretRect = currentCaretRect;
        return;
      }

      const diff = currentCaretRect.top - caretRect.top;

      if (diff === 0) {
        return;
      }

      const scrollContainer = (0,external_wp_dom_namespaceObject.getScrollContainer)(node); // The page must be scrollable.

      if (!scrollContainer) {
        return;
      }

      const windowScroll = scrollContainer === ownerDocument.body || scrollContainer === ownerDocument.documentElement;
      const scrollY = windowScroll ? defaultView.scrollY : scrollContainer.scrollTop;
      const scrollContainerY = windowScroll ? 0 : scrollContainer.getBoundingClientRect().top;
      const relativeScrollPosition = windowScroll ? caretRect.top / defaultView.innerHeight : (caretRect.top - scrollContainerY) / (defaultView.innerHeight - scrollContainerY); // If the scroll position is at the start, the active editable element
      // is the last one, and the caret is positioned within the initial
      // trigger percentage of the page, do not scroll the page.
      // The typewriter effect should not kick in until an empty page has been
      // filled with the initial trigger percentage or the user scrolls
      // intentionally down.

      if (scrollY === 0 && relativeScrollPosition < initialTriggerPercentage && isLastEditableNode()) {
        // Reset the caret position to maintain.
        caretRect = currentCaretRect;
        return;
      }

      const scrollContainerHeight = windowScroll ? defaultView.innerHeight : scrollContainer.clientHeight; // Abort if the target scroll position would scroll the caret out of
      // view.

      if ( // The caret is under the lower fold.
      caretRect.top + caretRect.height > scrollContainerY + scrollContainerHeight || // The caret is above the upper fold.
      caretRect.top < scrollContainerY) {
        // Reset the caret position to maintain.
        caretRect = currentCaretRect;
        return;
      }

      if (windowScroll) {
        defaultView.scrollBy(0, diff);
      } else {
        scrollContainer.scrollTop += diff;
      }
    }
    /**
     * Adds a `selectionchange` listener to reset the scroll position to be
     * maintained.
     */


    function addSelectionChangeListener() {
      ownerDocument.addEventListener('selectionchange', computeCaretRectOnSelectionChange);
    }
    /**
     * Resets the scroll position to be maintained during a `selectionchange`
     * event. Also removes the listener, so it acts as a one-time listener.
     */


    function computeCaretRectOnSelectionChange() {
      ownerDocument.removeEventListener('selectionchange', computeCaretRectOnSelectionChange);
      computeCaretRectangle();
    }
    /**
     * Resets the scroll position to be maintained.
     */


    function computeCaretRectangle() {
      if (isSelectionEligibleForScroll()) {
        caretRect = (0,external_wp_dom_namespaceObject.computeCaretRect)(defaultView);
      }
    }
    /**
     * Checks if the current situation is elegible for scroll:
     * - There should be one and only one block selected.
     * - The component must contain the selection.
     * - The active element must be contenteditable.
     */


    function isSelectionEligibleForScroll() {
      return node.contains(ownerDocument.activeElement) && ownerDocument.activeElement.isContentEditable;
    }

    function isLastEditableNode() {
      const editableNodes = node.querySelectorAll('[contenteditable="true"]');
      const lastEditableNode = editableNodes[editableNodes.length - 1];
      return lastEditableNode === ownerDocument.activeElement;
    } // When the user scrolls or resizes, the scroll position should be
    // reset.


    defaultView.addEventListener('scroll', onScrollResize, true);
    defaultView.addEventListener('resize', onScrollResize, true);
    node.addEventListener('keydown', onKeyDown);
    node.addEventListener('keyup', maintainCaretPosition);
    node.addEventListener('mousedown', addSelectionChangeListener);
    node.addEventListener('touchstart', addSelectionChangeListener);
    return () => {
      defaultView.removeEventListener('scroll', onScrollResize, true);
      defaultView.removeEventListener('resize', onScrollResize, true);
      node.removeEventListener('keydown', onKeyDown);
      node.removeEventListener('keyup', maintainCaretPosition);
      node.removeEventListener('mousedown', addSelectionChangeListener);
      node.removeEventListener('touchstart', addSelectionChangeListener);
      ownerDocument.removeEventListener('selectionchange', computeCaretRectOnSelectionChange);
      defaultView.cancelAnimationFrame(scrollResizeRafId);
      defaultView.cancelAnimationFrame(onKeyDownRafId);
    };
  }, [hasSelectedBlock]);
}

function Typewriter({
  children
}) {
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    ref: useTypewriter(),
    className: "block-editor__typewriter"
  }, children);
}
/**
 * The exported component. The implementation of Typewriter faced technical
 * challenges in Internet Explorer, and is simply skipped, rendering the given
 * props children instead.
 *
 * @type {WPComponent}
 */


const TypewriterOrIEBypass = isIE ? props => props.children : Typewriter;
/**
 * Ensures that the text selection keeps the same vertical distance from the
 * viewport during keyboard events within this component. The vertical distance
 * can vary. It is the last clicked or scrolled to position.
 */

/* harmony default export */ var typewriter = (TypewriterOrIEBypass);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/recursion-provider/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


const RenderedRefsContext = (0,external_wp_element_namespaceObject.createContext)({});
/**
 * Immutably adds an unique identifier to a set scoped for a given block type.
 *
 * @param {Object} renderedBlocks Rendered blocks grouped by block name
 * @param {string} blockName      Name of the block.
 * @param {*}      uniqueId       Any value that acts as a unique identifier for a block instance.
 *
 * @return {Object} The list of rendered blocks grouped by block name.
 */

function addToBlockType(renderedBlocks, blockName, uniqueId) {
  const result = { ...renderedBlocks,
    [blockName]: renderedBlocks[blockName] ? new Set(renderedBlocks[blockName]) : new Set()
  };
  result[blockName].add(uniqueId);
  return result;
}
/**
 * A React context provider for use with the `useHasRecursion` hook to prevent recursive
 * renders.
 *
 * Wrap block content with this provider and provide the same `uniqueId` prop as used
 * with `useHasRecursion`.
 *
 * @param {Object}      props
 * @param {*}           props.uniqueId  Any value that acts as a unique identifier for a block instance.
 * @param {string}      props.blockName Optional block name.
 * @param {JSX.Element} props.children  React children.
 *
 * @return {JSX.Element} A React element.
 */


function RecursionProvider({
  children,
  uniqueId,
  blockName = ''
}) {
  const previouslyRenderedBlocks = (0,external_wp_element_namespaceObject.useContext)(RenderedRefsContext);
  const {
    name
  } = useBlockEditContext();
  blockName = blockName || name;
  const newRenderedBlocks = (0,external_wp_element_namespaceObject.useMemo)(() => addToBlockType(previouslyRenderedBlocks, blockName, uniqueId), [previouslyRenderedBlocks, blockName, uniqueId]);
  return (0,external_wp_element_namespaceObject.createElement)(RenderedRefsContext.Provider, {
    value: newRenderedBlocks
  }, children);
}
/**
 * A React hook for keeping track of blocks previously rendered up in the block
 * tree. Blocks susceptible to recursion can use this hook in their `Edit`
 * function to prevent said recursion.
 *
 * Use this with the `RecursionProvider` component, using the same `uniqueId` value
 * for both the hook and the provider.
 *
 * @param {*}      uniqueId  Any value that acts as a unique identifier for a block instance.
 * @param {string} blockName Optional block name.
 *
 * @return {boolean} A boolean describing whether the provided id has already been rendered.
 */

function useHasRecursion(uniqueId, blockName = '') {
  const previouslyRenderedBlocks = (0,external_wp_element_namespaceObject.useContext)(RenderedRefsContext);
  const {
    name
  } = useBlockEditContext();
  blockName = blockName || name;
  return Boolean(previouslyRenderedBlocks[blockName]?.has(uniqueId));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/close-small.js


/**
 * WordPress dependencies
 */

const closeSmall = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M12 13.06l3.712 3.713 1.061-1.06L13.061 12l3.712-3.712-1.06-1.06L12 10.938 8.288 7.227l-1.061 1.06L10.939 12l-3.712 3.712 1.06 1.061L12 13.061z"
}));
/* harmony default export */ var close_small = (closeSmall);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inspector-popover-header/index.js


/**
 * WordPress dependencies
 */



function InspectorPopoverHeader({
  title,
  help,
  actions = [],
  onClose
}) {
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalVStack, {
    className: "block-editor-inspector-popover-header",
    spacing: 4
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHStack, {
    alignment: "center"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHeading, {
    className: "block-editor-inspector-popover-header__heading",
    level: 2,
    size: 13
  }, title), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalSpacer, null), actions.map(({
    label,
    icon,
    onClick
  }) => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    key: label,
    className: "block-editor-inspector-popover-header__action",
    label: label,
    icon: icon,
    variant: !icon && 'tertiary',
    onClick: onClick
  }, !icon && label)), onClose && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    className: "block-editor-inspector-popover-header__action",
    label: (0,external_wp_i18n_namespaceObject.__)('Close'),
    icon: close_small,
    onClick: onClose
  })), help && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalText, null, help));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/publish-date-time-picker/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



function PublishDateTimePicker({
  onClose,
  onChange,
  ...additionalProps
}, ref) {
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    ref: ref,
    className: "block-editor-publish-date-time-picker"
  }, (0,external_wp_element_namespaceObject.createElement)(InspectorPopoverHeader, {
    title: (0,external_wp_i18n_namespaceObject.__)('Publish'),
    actions: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Now'),
      onClick: () => onChange?.(null)
    }],
    onClose: onClose
  }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.DateTimePicker, {
    startOfWeek: (0,external_wp_date_namespaceObject.getSettings)().l10n.startOfWeek,
    onChange: onChange,
    ...additionalProps
  }));
}

/* harmony default export */ var publish_date_time_picker = ((0,external_wp_element_namespaceObject.forwardRef)(PublishDateTimePicker));

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/index.js
/*
 * Block Creation Components
 */




































































/*
 * Content Related Components
 */





































/*
 * State Related Components
 */




;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/elements/index.js
const ELEMENT_CLASS_NAMES = {
  button: 'wp-element-button',
  caption: 'wp-element-caption'
};
const __experimentalGetElementClassName = element => {
  return ELEMENT_CLASS_NAMES[element] ? ELEMENT_CLASS_NAMES[element] : '';
};

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/block-variation-transforms.js
/** @typedef {import('@wordpress/blocks').WPBlockVariation} WPBlockVariation */
function matchesAttributes(blockAttributes, variation) {
  return Object.entries(variation).every(([key, value]) => {
    if (typeof value === 'object' && typeof blockAttributes[key] === 'object') {
      return matchesAttributes(blockAttributes[key], value);
    }

    return blockAttributes[key] === value;
  });
}
/**
 * Matches the provided block variations with a block's attributes. If no match
 * or more than one matches are found it returns `undefined`. If a single match is
 * found it returns it.
 *
 * This is a simple implementation for now as it takes into account only the attributes
 * of a block variation and not `InnerBlocks`.
 *
 * @param {Object}             blockAttributes - The block attributes to try to find a match.
 * @param {WPBlockVariation[]} variations      - A list of block variations to test for a match.
 * @return {WPBlockVariation | undefined} - If a match is found returns it. If not or more than one matches are found returns `undefined`.
 */


const __experimentalGetMatchingVariation = (blockAttributes, variations) => {
  if (!variations || !blockAttributes) return;
  const matches = variations.filter(({
    attributes
  }) => {
    if (!attributes || !Object.keys(attributes).length) return false;
    return matchesAttributes(blockAttributes, attributes);
  });
  if (matches.length !== 1) return;
  return matches[0];
};

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/parse-css-unit-to-px.js
/**
 * Converts string to object { value, unit }.
 *
 * @param {string} cssUnit
 * @return {Object} parsedUnit
 */
function parseUnit(cssUnit) {
  const match = cssUnit?.trim().match(/^(0?[-.]?\d*\.?\d+)(r?e[m|x]|v[h|w|min|max]+|p[x|t|c]|[c|m]m|%|in|ch|Q|lh)$/);

  if (!isNaN(cssUnit) && !isNaN(parseFloat(cssUnit))) {
    return {
      value: parseFloat(cssUnit),
      unit: 'px'
    };
  }

  return match ? {
    value: parseFloat(match[1]) || match[1],
    unit: match[2]
  } : {
    value: cssUnit,
    unit: undefined
  };
}
/**
 * Evaluate a math expression.
 *
 * @param {string} expression
 * @return {number} evaluated expression.
 */


function calculate(expression) {
  try {
    return Function(`'use strict'; return (${expression})`)();
  } catch (err) {
    return null;
  }
}
/**
 * Calculates the css function value for the supported css functions such as max, min, clamp and calc.
 *
 * @param {string} functionUnitValue string should be in a particular format (for example min(12px,12px) ) no nested loops.
 * @param {Object} options
 * @return {string} unit containing the unit in PX.
 */


function getFunctionUnitValue(functionUnitValue, options) {
  const functionUnit = functionUnitValue.split(/[(),]/g).filter(Boolean);
  const units = functionUnit.slice(1).map(unit => parseUnit(getPxFromCssUnit(unit, options)).value).filter(Boolean);

  switch (functionUnit[0]) {
    case 'min':
      return Math.min(...units) + 'px';

    case 'max':
      return Math.max(...units) + 'px';

    case 'clamp':
      if (units.length !== 3) {
        return null;
      }

      if (units[1] < units[0]) {
        return units[0] + 'px';
      }

      if (units[1] > units[2]) {
        return units[2] + 'px';
      }

      return units[1] + 'px';

    case 'calc':
      return units[0] + 'px';
  }
}
/**
 * Take a css function such as min, max, calc, clamp and returns parsedUnit
 *
 * How this works for the nested function is that it first replaces the inner function call.
 * Then it tackles the outer onces.
 * So for example: min( max(25px, 35px), 40px )
 * in the first pass we would replace max(25px, 35px) with 35px.
 * then we would try to evaluate min( 35px, 40px )
 * and then finally return 35px.
 *
 * @param {string} cssUnit
 * @return {Object} parsedUnit object.
 */


function parseUnitFunction(cssUnit) {
  while (true) {
    const currentCssUnit = cssUnit;
    const regExp = /(max|min|calc|clamp)\(([^()]*)\)/g;
    const matches = regExp.exec(cssUnit) || [];

    if (matches[0]) {
      const functionUnitValue = getFunctionUnitValue(matches[0]);
      cssUnit = cssUnit.replace(matches[0], functionUnitValue);
    } // If the unit hasn't been modified or we have a single value break free.


    if (cssUnit === currentCssUnit || parseFloat(cssUnit)) {
      break;
    }
  }

  return parseUnit(cssUnit);
}
/**
 * Return true if we think this is a math expression.
 *
 * @param {string} cssUnit the cssUnit value being evaluted.
 * @return {boolean} Whether the cssUnit is a math expression.
 */


function isMathExpression(cssUnit) {
  for (let i = 0; i < cssUnit.length; i++) {
    if (['+', '-', '/', '*'].includes(cssUnit[i])) {
      return true;
    }
  }

  return false;
}
/**
 * Evaluates the math expression and return a px value.
 *
 * @param {string} cssUnit the cssUnit value being evaluted.
 * @return {string} return a converfted value to px.
 */


function evalMathExpression(cssUnit) {
  let errorFound = false; // Convert every part of the expression to px values.
  // The following regex matches numbers that have a following unit
  // E.g. 5.25rem, 1vw

  const cssUnitsBits = cssUnit.match(/\d+\.?\d*[a-zA-Z]+|\.\d+[a-zA-Z]+/g);

  if (cssUnitsBits) {
    for (const unit of cssUnitsBits) {
      // Standardize the unit to px and extract the value.
      const parsedUnit = parseUnit(getPxFromCssUnit(unit));

      if (!parseFloat(parsedUnit.value)) {
        errorFound = true; // End early since we are dealing with a null value.

        break;
      }

      cssUnit = cssUnit.replace(unit, parsedUnit.value);
    }
  } else {
    errorFound = true;
  } // For mixed math expressions wrapped within CSS expressions


  const expressionsMatches = cssUnit.match(/(max|min|clamp)/g);

  if (!errorFound && expressionsMatches) {
    const values = cssUnit.split(',');

    for (const currentValue of values) {
      // Check for nested calc() and remove them to calculate the value.
      const rawCurrentValue = currentValue.replace(/\s|calc/g, '');

      if (isMathExpression(rawCurrentValue)) {
        const calculatedExpression = calculate(rawCurrentValue);

        if (calculatedExpression) {
          const calculatedValue = calculatedExpression.toFixed(0) + 'px';
          cssUnit = cssUnit.replace(currentValue, calculatedValue);
        }
      }
    }

    const parsedValue = parseUnitFunction(cssUnit);
    return !parsedValue ? null : parsedValue.value + parsedValue.unit;
  }

  if (errorFound) {
    return null;
  }

  const calculatedResult = calculate(cssUnit);
  return calculatedResult ? calculatedResult.toFixed(0) + 'px' : null;
}
/**
 * Convert a parsedUnit object to px value.
 *
 * @param {Object} parsedUnit
 * @param {Object} options
 * @return {string} or {null} returns the converted with in a px value format.
 */


function convertParsedUnitToPx(parsedUnit, options) {
  const PIXELS_PER_INCH = 96;
  const ONE_PERCENT = 0.01;
  const defaultProperties = {
    fontSize: 16,
    lineHeight: 16,
    width: 375,
    height: 812,
    type: 'font'
  };
  const setOptions = Object.assign({}, defaultProperties, options);
  const relativeUnits = {
    em: setOptions.fontSize,
    rem: setOptions.fontSize,
    vh: setOptions.height * ONE_PERCENT,
    vw: setOptions.width * ONE_PERCENT,
    vmin: (setOptions.width < setOptions.height ? setOptions.width : setOptions.height) * ONE_PERCENT,
    vmax: (setOptions.width > setOptions.height ? setOptions.width : setOptions.height) * ONE_PERCENT,
    '%': (setOptions.type === 'font' ? setOptions.fontSize : setOptions.width) * ONE_PERCENT,
    ch: 8,
    // The advance measure (width) of the glyph "0" of the element's font. Approximate
    ex: 7.15625,
    // X-height of the element's font. Approximate.
    lh: setOptions.lineHeight
  };
  const absoluteUnits = {
    in: PIXELS_PER_INCH,
    cm: PIXELS_PER_INCH / 2.54,
    mm: PIXELS_PER_INCH / 25.4,
    pt: PIXELS_PER_INCH / 72,
    pc: PIXELS_PER_INCH / 6,
    px: 1,
    Q: PIXELS_PER_INCH / 2.54 / 40
  };

  if (relativeUnits[parsedUnit.unit]) {
    return (relativeUnits[parsedUnit.unit] * parsedUnit.value).toFixed(0) + 'px';
  }

  if (absoluteUnits[parsedUnit.unit]) {
    return (absoluteUnits[parsedUnit.unit] * parsedUnit.value).toFixed(0) + 'px';
  }

  return null;
}
/**
 * Returns the px value of a cssUnit.
 *
 * @param {string} cssUnit
 * @param {Object} options
 * @return {string} returns the cssUnit value in a simple px format.
 */


function getPxFromCssUnit(cssUnit, options = {}) {
  if (Number.isFinite(cssUnit)) {
    return cssUnit.toFixed(0) + 'px';
  }

  if (cssUnit === undefined) {
    return null;
  }

  let parsedUnit = parseUnit(cssUnit);

  if (!parsedUnit.unit) {
    parsedUnit = parseUnitFunction(cssUnit);
  }

  if (isMathExpression(cssUnit) && !parsedUnit.unit) {
    return evalMathExpression(cssUnit);
  }

  return convertParsedUnitToPx(parsedUnit, options);
} // Use simple cache.

const cache = {};
/**
 * Returns the px value of a cssUnit. The memoized version of getPxFromCssUnit;
 *
 * @param {string} cssUnit
 * @param {Object} options
 * @return {string} returns the cssUnit value in a simple px format.
 */

function memoizedGetPxFromCssUnit(cssUnit, options = {}) {
  const hash = cssUnit + hashOptions(options);

  if (!cache[hash]) {
    cache[hash] = getPxFromCssUnit(cssUnit, options);
  }

  return cache[hash];
}

function hashOptions(options) {
  let hash = '';

  if (options.hasOwnProperty('fontSize')) {
    hash = ':' + options.width;
  }

  if (options.hasOwnProperty('lineHeight')) {
    hash = ':' + options.lineHeight;
  }

  if (options.hasOwnProperty('width')) {
    hash = ':' + options.width;
  }

  if (options.hasOwnProperty('height')) {
    hash = ':' + options.height;
  }

  if (options.hasOwnProperty('type')) {
    hash = ':' + options.type;
  }

  return hash;
}

/* harmony default export */ var parse_css_unit_to_px = (memoizedGetPxFromCssUnit);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/index.js




;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/global-styles/use-global-styles-output.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */










 // List of block support features that can have their related styles
// generated under their own feature level selector rather than the block's.

const BLOCK_SUPPORT_FEATURE_LEVEL_SELECTORS = {
  __experimentalBorder: 'border',
  color: 'color',
  spacing: 'spacing',
  typography: 'typography'
};

function compileStyleValue(uncompiledValue) {
  const VARIABLE_REFERENCE_PREFIX = 'var:';
  const VARIABLE_PATH_SEPARATOR_TOKEN_ATTRIBUTE = '|';
  const VARIABLE_PATH_SEPARATOR_TOKEN_STYLE = '--';

  if (uncompiledValue?.startsWith?.(VARIABLE_REFERENCE_PREFIX)) {
    const variable = uncompiledValue.slice(VARIABLE_REFERENCE_PREFIX.length).split(VARIABLE_PATH_SEPARATOR_TOKEN_ATTRIBUTE).join(VARIABLE_PATH_SEPARATOR_TOKEN_STYLE);
    return `var(--wp--${variable})`;
  }

  return uncompiledValue;
}
/**
 * Transform given preset tree into a set of style declarations.
 *
 * @param {Object} blockPresets
 * @param {Object} mergedSettings Merged theme.json settings.
 *
 * @return {Array<Object>} An array of style declarations.
 */


function getPresetsDeclarations(blockPresets = {}, mergedSettings) {
  return PRESET_METADATA.reduce((declarations, {
    path,
    valueKey,
    valueFunc,
    cssVarInfix
  }) => {
    const presetByOrigin = (0,external_lodash_namespaceObject.get)(blockPresets, path, []);
    ['default', 'theme', 'custom'].forEach(origin => {
      if (presetByOrigin[origin]) {
        presetByOrigin[origin].forEach(value => {
          if (valueKey && !valueFunc) {
            declarations.push(`--wp--preset--${cssVarInfix}--${kebabCase(value.slug)}: ${value[valueKey]}`);
          } else if (valueFunc && typeof valueFunc === 'function') {
            declarations.push(`--wp--preset--${cssVarInfix}--${kebabCase(value.slug)}: ${valueFunc(value, mergedSettings)}`);
          }
        });
      }
    });
    return declarations;
  }, []);
}
/**
 * Transform given preset tree into a set of preset class declarations.
 *
 * @param {?string} blockSelector
 * @param {Object}  blockPresets
 * @return {string} CSS declarations for the preset classes.
 */


function getPresetsClasses(blockSelector = '*', blockPresets = {}) {
  return PRESET_METADATA.reduce((declarations, {
    path,
    cssVarInfix,
    classes
  }) => {
    if (!classes) {
      return declarations;
    }

    const presetByOrigin = (0,external_lodash_namespaceObject.get)(blockPresets, path, []);
    ['default', 'theme', 'custom'].forEach(origin => {
      if (presetByOrigin[origin]) {
        presetByOrigin[origin].forEach(({
          slug
        }) => {
          classes.forEach(({
            classSuffix,
            propertyName
          }) => {
            const classSelectorToUse = `.has-${kebabCase(slug)}-${classSuffix}`;
            const selectorToUse = blockSelector.split(',') // Selector can be "h1, h2, h3"
            .map(selector => `${selector}${classSelectorToUse}`).join(',');
            const value = `var(--wp--preset--${cssVarInfix}--${kebabCase(slug)})`;
            declarations += `${selectorToUse}{${propertyName}: ${value} !important;}`;
          });
        });
      }
    });
    return declarations;
  }, '');
}

function getPresetsSvgFilters(blockPresets = {}) {
  return PRESET_METADATA.filter( // Duotone are the only type of filters for now.
  metadata => metadata.path.at(-1) === 'duotone').flatMap(metadata => {
    const presetByOrigin = (0,external_lodash_namespaceObject.get)(blockPresets, metadata.path, {});
    return ['default', 'theme'].filter(origin => presetByOrigin[origin]).flatMap(origin => presetByOrigin[origin].map(preset => (0,external_wp_element_namespaceObject.renderToString)((0,external_wp_element_namespaceObject.createElement)(PresetDuotoneFilter, {
      preset: preset,
      key: preset.slug
    })))).join('');
  });
}

function flattenTree(input = {}, prefix, token) {
  let result = [];
  Object.keys(input).forEach(key => {
    const newKey = prefix + kebabCase(key.replace('/', '-'));
    const newLeaf = input[key];

    if (newLeaf instanceof Object) {
      const newPrefix = newKey + token;
      result = [...result, ...flattenTree(newLeaf, newPrefix, token)];
    } else {
      result.push(`${newKey}: ${newLeaf}`);
    }
  });
  return result;
}
/**
 * Gets variation selector string from feature selector.
 *
 * @param {string} featureSelector        The feature selector.
 *
 * @param {string} styleVariationSelector The style variation selector.
 * @return {string} Combined selector string.
 *
 */


function concatFeatureVariationSelectorString(featureSelector, styleVariationSelector) {
  const featureSelectors = featureSelector.split(',');
  const combinedSelectors = [];
  featureSelectors.forEach(selector => {
    combinedSelectors.push(`${styleVariationSelector.trim()}${selector.trim()}`);
  });
  return combinedSelectors.join(', ');
}
/**
 * Generate style declarations for a block's custom feature and subfeature
 * selectors.
 *
 * NOTE: The passed `styles` object will be mutated by this function.
 *
 * @param {Object} selectors Custom selectors object for a block.
 * @param {Object} styles    A block's styles object.
 *
 * @return {Object} Style declarations.
 */


const getFeatureDeclarations = (selectors, styles) => {
  const declarations = {};
  Object.entries(selectors).forEach(([feature, selector]) => {
    // We're only processing features/subfeatures that have styles.
    if (feature === 'root' || !styles?.[feature]) {
      return;
    }

    const isShorthand = typeof selector === 'string'; // If we have a selector object instead of shorthand process it.

    if (!isShorthand) {
      Object.entries(selector).forEach(([subfeature, subfeatureSelector]) => {
        // Don't process root feature selector yet or any
        // subfeature that doesn't have a style.
        if (subfeature === 'root' || !styles?.[feature][subfeature]) {
          return;
        } // Create a temporary styles object and build
        // declarations for subfeature.


        const subfeatureStyles = {
          [feature]: {
            [subfeature]: styles[feature][subfeature]
          }
        };
        const newDeclarations = getStylesDeclarations(subfeatureStyles); // Merge new declarations in with any others that
        // share the same selector.

        declarations[subfeatureSelector] = [...(declarations[subfeatureSelector] || []), ...newDeclarations]; // Remove the subfeature's style now it will be
        // included under its own selector not the block's.

        delete styles[feature][subfeature];
      });
    } // Now subfeatures have been processed and removed, we can
    // process root, or shorthand, feature selectors.


    if (isShorthand || selector.root) {
      const featureSelector = isShorthand ? selector : selector.root; // Create temporary style object and build declarations for feature.

      const featureStyles = {
        [feature]: styles[feature]
      };
      const newDeclarations = getStylesDeclarations(featureStyles); // Merge new declarations with any others that share the selector.

      declarations[featureSelector] = [...(declarations[featureSelector] || []), ...newDeclarations]; // Remove the feature from the block's styles now as it will be
      // included under its own selector not the block's.

      delete styles[feature];
    }
  });
  return declarations;
};
/**
 * Transform given style tree into a set of style declarations.
 *
 * @param {Object}  blockStyles         Block styles.
 *
 * @param {string}  selector            The selector these declarations should attach to.
 *
 * @param {boolean} useRootPaddingAlign Whether to use CSS custom properties in root selector.
 *
 * @param {Object}  tree                A theme.json tree containing layout definitions.
 *
 * @return {Array} An array of style declarations.
 */


function getStylesDeclarations(blockStyles = {}, selector = '', useRootPaddingAlign, tree = {}) {
  const isRoot = ROOT_BLOCK_SELECTOR === selector;
  const output = Object.entries(external_wp_blocks_namespaceObject.__EXPERIMENTAL_STYLE_PROPERTY).reduce((declarations, [key, {
    value,
    properties,
    useEngine,
    rootOnly
  }]) => {
    if (rootOnly && !isRoot) {
      return declarations;
    }

    const pathToValue = value;

    if (pathToValue[0] === 'elements' || useEngine) {
      return declarations;
    }

    const styleValue = (0,external_lodash_namespaceObject.get)(blockStyles, pathToValue); // Root-level padding styles don't currently support strings with CSS shorthand values.
    // This may change: https://github.com/WordPress/gutenberg/issues/40132.

    if (key === '--wp--style--root--padding' && (typeof styleValue === 'string' || !useRootPaddingAlign)) {
      return declarations;
    }

    if (properties && typeof styleValue !== 'string') {
      Object.entries(properties).forEach(entry => {
        const [name, prop] = entry;

        if (!(0,external_lodash_namespaceObject.get)(styleValue, [prop], false)) {
          // Do not create a declaration
          // for sub-properties that don't have any value.
          return;
        }

        const cssProperty = name.startsWith('--') ? name : kebabCase(name);
        declarations.push(`${cssProperty}: ${compileStyleValue((0,external_lodash_namespaceObject.get)(styleValue, [prop]))}`);
      });
    } else if ((0,external_lodash_namespaceObject.get)(blockStyles, pathToValue, false)) {
      const cssProperty = key.startsWith('--') ? key : kebabCase(key);
      declarations.push(`${cssProperty}: ${compileStyleValue((0,external_lodash_namespaceObject.get)(blockStyles, pathToValue))}`);
    }

    return declarations;
  }, []); // The goal is to move everything to server side generated engine styles
  // This is temporary as we absorb more and more styles into the engine.

  const extraRules = (0,external_wp_styleEngine_namespaceObject.getCSSRules)(blockStyles);
  extraRules.forEach(rule => {
    // Don't output padding properties if padding variables are set.
    if (isRoot && useRootPaddingAlign && rule.key.startsWith('padding')) {
      return;
    }

    const cssProperty = rule.key.startsWith('--') ? rule.key : kebabCase(rule.key);
    let ruleValue = rule.value;

    if (typeof ruleValue !== 'string' && ruleValue?.ref) {
      const refPath = ruleValue.ref.split('.');
      ruleValue = (0,external_lodash_namespaceObject.get)(tree, refPath); // Presence of another ref indicates a reference to another dynamic value.
      // Pointing to another dynamic value is not supported.

      if (!ruleValue || ruleValue?.ref) {
        return;
      }
    } // Calculate fluid typography rules where available.


    if (cssProperty === 'font-size') {
      /*
       * getTypographyFontSizeValue() will check
       * if fluid typography has been activated and also
       * whether the incoming value can be converted to a fluid value.
       * Values that already have a "clamp()" function will not pass the test,
       * and therefore the original $value will be returned.
       */
      ruleValue = getTypographyFontSizeValue({
        size: ruleValue
      }, getFluidTypographyOptionsFromSettings(tree?.settings));
    }

    output.push(`${cssProperty}: ${ruleValue}`);
  });
  return output;
}
/**
 * Get generated CSS for layout styles by looking up layout definitions provided
 * in theme.json, and outputting common layout styles, and specific blockGap values.
 *
 * @param {Object}  props
 * @param {Object}  props.layoutDefinitions     Layout definitions, keyed by layout type.
 * @param {Object}  props.style                 A style object containing spacing values.
 * @param {string}  props.selector              Selector used to group together layout styling rules.
 * @param {boolean} props.hasBlockGapSupport    Whether or not the theme opts-in to blockGap support.
 * @param {boolean} props.hasFallbackGapSupport Whether or not the theme allows fallback gap styles.
 * @param {?string} props.fallbackGapValue      An optional fallback gap value if no real gap value is available.
 * @return {string} Generated CSS rules for the layout styles.
 */

function getLayoutStyles({
  layoutDefinitions = LAYOUT_DEFINITIONS,
  style,
  selector,
  hasBlockGapSupport,
  hasFallbackGapSupport,
  fallbackGapValue
}) {
  let ruleset = '';
  let gapValue = hasBlockGapSupport ? getGapCSSValue(style?.spacing?.blockGap) : ''; // Ensure a fallback gap value for the root layout definitions,
  // and use a fallback value if one is provided for the current block.

  if (hasFallbackGapSupport) {
    if (selector === ROOT_BLOCK_SELECTOR) {
      gapValue = !gapValue ? '0.5em' : gapValue;
    } else if (!hasBlockGapSupport && fallbackGapValue) {
      gapValue = fallbackGapValue;
    }
  }

  if (gapValue && layoutDefinitions) {
    Object.values(layoutDefinitions).forEach(({
      className,
      name,
      spacingStyles
    }) => {
      // Allow outputting fallback gap styles for flex layout type when block gap support isn't available.
      if (!hasBlockGapSupport && 'flex' !== name && 'grid' !== name) {
        return;
      }

      if (spacingStyles?.length) {
        spacingStyles.forEach(spacingStyle => {
          const declarations = [];

          if (spacingStyle.rules) {
            Object.entries(spacingStyle.rules).forEach(([cssProperty, cssValue]) => {
              declarations.push(`${cssProperty}: ${cssValue ? cssValue : gapValue}`);
            });
          }

          if (declarations.length) {
            let combinedSelector = '';

            if (!hasBlockGapSupport) {
              // For fallback gap styles, use lower specificity, to ensure styles do not unintentionally override theme styles.
              combinedSelector = selector === ROOT_BLOCK_SELECTOR ? `:where(.${className}${spacingStyle?.selector || ''})` : `:where(${selector}.${className}${spacingStyle?.selector || ''})`;
            } else {
              combinedSelector = selector === ROOT_BLOCK_SELECTOR ? `:where(${selector} .${className})${spacingStyle?.selector || ''}` : `${selector}-${className}${spacingStyle?.selector || ''}`;
            }

            ruleset += `${combinedSelector} { ${declarations.join('; ')}; }`;
          }
        });
      }
    }); // For backwards compatibility, ensure the legacy block gap CSS variable is still available.

    if (selector === ROOT_BLOCK_SELECTOR && hasBlockGapSupport) {
      ruleset += `${selector} { --wp--style--block-gap: ${gapValue}; }`;
    }
  } // Output base styles


  if (selector === ROOT_BLOCK_SELECTOR && layoutDefinitions) {
    const validDisplayModes = ['block', 'flex', 'grid'];
    Object.values(layoutDefinitions).forEach(({
      className,
      displayMode,
      baseStyles
    }) => {
      if (displayMode && validDisplayModes.includes(displayMode)) {
        ruleset += `${selector} .${className} { display:${displayMode}; }`;
      }

      if (baseStyles?.length) {
        baseStyles.forEach(baseStyle => {
          const declarations = [];

          if (baseStyle.rules) {
            Object.entries(baseStyle.rules).forEach(([cssProperty, cssValue]) => {
              declarations.push(`${cssProperty}: ${cssValue}`);
            });
          }

          if (declarations.length) {
            const combinedSelector = `${selector} .${className}${baseStyle?.selector || ''}`;
            ruleset += `${combinedSelector} { ${declarations.join('; ')}; }`;
          }
        });
      }
    });
  }

  return ruleset;
}
const STYLE_KEYS = ['border', 'color', 'dimensions', 'spacing', 'typography', 'filter', 'outline', 'shadow'];

function pickStyleKeys(treeToPickFrom) {
  if (!treeToPickFrom) {
    return {};
  }

  const entries = Object.entries(treeToPickFrom);
  const pickedEntries = entries.filter(([key]) => STYLE_KEYS.includes(key)); // clone the style objects so that `getFeatureDeclarations` can remove consumed keys from it

  const clonedEntries = pickedEntries.map(([key, style]) => [key, JSON.parse(JSON.stringify(style))]);
  return Object.fromEntries(clonedEntries);
}

const getNodesWithStyles = (tree, blockSelectors) => {
  var _tree$styles$blocks;

  const nodes = [];

  if (!tree?.styles) {
    return nodes;
  } // Top-level.


  const styles = pickStyleKeys(tree.styles);

  if (styles) {
    nodes.push({
      styles,
      selector: ROOT_BLOCK_SELECTOR
    });
  }

  Object.entries(external_wp_blocks_namespaceObject.__EXPERIMENTAL_ELEMENTS).forEach(([name, selector]) => {
    if (tree.styles?.elements?.[name]) {
      nodes.push({
        styles: tree.styles?.elements?.[name],
        selector
      });
    }
  }); // Iterate over blocks: they can have styles & elements.

  Object.entries((_tree$styles$blocks = tree.styles?.blocks) !== null && _tree$styles$blocks !== void 0 ? _tree$styles$blocks : {}).forEach(([blockName, node]) => {
    var _node$elements;

    const blockStyles = pickStyleKeys(node);

    if (node?.variations) {
      const variations = {};
      Object.keys(node.variations).forEach(variation => {
        variations[variation] = pickStyleKeys(node.variations[variation]);
      });
      blockStyles.variations = variations;
    }

    if (blockStyles && blockSelectors?.[blockName]?.selector) {
      nodes.push({
        duotoneSelector: blockSelectors[blockName].duotoneSelector,
        fallbackGapValue: blockSelectors[blockName].fallbackGapValue,
        hasLayoutSupport: blockSelectors[blockName].hasLayoutSupport,
        selector: blockSelectors[blockName].selector,
        styles: blockStyles,
        featureSelectors: blockSelectors[blockName].featureSelectors,
        styleVariationSelectors: blockSelectors[blockName].styleVariationSelectors
      });
    }

    Object.entries((_node$elements = node?.elements) !== null && _node$elements !== void 0 ? _node$elements : {}).forEach(([elementName, value]) => {
      if (value && blockSelectors?.[blockName] && external_wp_blocks_namespaceObject.__EXPERIMENTAL_ELEMENTS[elementName]) {
        nodes.push({
          styles: value,
          selector: blockSelectors[blockName]?.selector.split(',').map(sel => {
            const elementSelectors = external_wp_blocks_namespaceObject.__EXPERIMENTAL_ELEMENTS[elementName].split(',');
            return elementSelectors.map(elementSelector => sel + ' ' + elementSelector);
          }).join(',')
        });
      }
    });
  });
  return nodes;
};
const getNodesWithSettings = (tree, blockSelectors) => {
  var _tree$settings$blocks;

  const nodes = [];

  if (!tree?.settings) {
    return nodes;
  }

  const pickPresets = treeToPickFrom => {
    const presets = {};
    PRESET_METADATA.forEach(({
      path
    }) => {
      const value = (0,external_lodash_namespaceObject.get)(treeToPickFrom, path, false);

      if (value !== false) {
        (0,external_lodash_namespaceObject.set)(presets, path, value);
      }
    });
    return presets;
  }; // Top-level.


  const presets = pickPresets(tree.settings);
  const custom = tree.settings?.custom;

  if (Object.keys(presets).length > 0 || custom) {
    nodes.push({
      presets,
      custom,
      selector: ROOT_BLOCK_SELECTOR
    });
  } // Blocks.


  Object.entries((_tree$settings$blocks = tree.settings?.blocks) !== null && _tree$settings$blocks !== void 0 ? _tree$settings$blocks : {}).forEach(([blockName, node]) => {
    const blockPresets = pickPresets(node);
    const blockCustom = node.custom;

    if (Object.keys(blockPresets).length > 0 || blockCustom) {
      nodes.push({
        presets: blockPresets,
        custom: blockCustom,
        selector: blockSelectors[blockName]?.selector
      });
    }
  });
  return nodes;
};
const toCustomProperties = (tree, blockSelectors) => {
  const settings = getNodesWithSettings(tree, blockSelectors);
  let ruleset = '';
  settings.forEach(({
    presets,
    custom,
    selector
  }) => {
    const declarations = getPresetsDeclarations(presets, tree?.settings);
    const customProps = flattenTree(custom, '--wp--custom--', '--');

    if (customProps.length > 0) {
      declarations.push(...customProps);
    }

    if (declarations.length > 0) {
      ruleset += `${selector}{${declarations.join(';')};}`;
    }
  });
  return ruleset;
};
const toStyles = (tree, blockSelectors, hasBlockGapSupport, hasFallbackGapSupport, disableLayoutStyles = false) => {
  const nodesWithStyles = getNodesWithStyles(tree, blockSelectors);
  const nodesWithSettings = getNodesWithSettings(tree, blockSelectors);
  const useRootPaddingAlign = tree?.settings?.useRootPaddingAwareAlignments;
  const {
    contentSize,
    wideSize
  } = tree?.settings?.layout || {};
  /*
   * Reset default browser margin on the root body element.
   * This is set on the root selector **before** generating the ruleset
   * from the `theme.json`. This is to ensure that if the `theme.json` declares
   * `margin` in its `spacing` declaration for the `body` element then these
   * user-generated values take precedence in the CSS cascade.
   * @link https://github.com/WordPress/gutenberg/issues/36147.
   */

  let ruleset = 'body {margin: 0;';

  if (contentSize) {
    ruleset += ` --wp--style--global--content-size: ${contentSize};`;
  }

  if (wideSize) {
    ruleset += ` --wp--style--global--wide-size: ${wideSize};`;
  }

  if (useRootPaddingAlign) {
    /*
     * These rules reproduce the ones from https://github.com/WordPress/gutenberg/blob/79103f124925d1f457f627e154f52a56228ed5ad/lib/class-wp-theme-json-gutenberg.php#L2508
     * almost exactly, but for the selectors that target block wrappers in the front end. This code only runs in the editor, so it doesn't need those selectors.
     */
    ruleset += `padding-right: 0; padding-left: 0; padding-top: var(--wp--style--root--padding-top); padding-bottom: var(--wp--style--root--padding-bottom) }
			.has-global-padding { padding-right: var(--wp--style--root--padding-right); padding-left: var(--wp--style--root--padding-left); }
			.has-global-padding :where(.has-global-padding) { padding-right: 0; padding-left: 0; }
			.has-global-padding > .alignfull { margin-right: calc(var(--wp--style--root--padding-right) * -1); margin-left: calc(var(--wp--style--root--padding-left) * -1); }
			.has-global-padding :where(.has-global-padding) > .alignfull { margin-right: 0; margin-left: 0; }
			.has-global-padding > .alignfull:where(:not(.has-global-padding)) > :where(.wp-block:not(.alignfull),p,h1,h2,h3,h4,h5,h6,ul,ol) { padding-right: var(--wp--style--root--padding-right); padding-left: var(--wp--style--root--padding-left); }
			.has-global-padding :where(.has-global-padding) > .alignfull:where(:not(.has-global-padding)) > :where(.wp-block:not(.alignfull),p,h1,h2,h3,h4,h5,h6,ul,ol) { padding-right: 0; padding-left: 0;`;
  }

  ruleset += '}';
  nodesWithStyles.forEach(({
    selector,
    duotoneSelector,
    styles,
    fallbackGapValue,
    hasLayoutSupport,
    featureSelectors,
    styleVariationSelectors
  }) => {
    // Process styles for block support features with custom feature level
    // CSS selectors set.
    if (featureSelectors) {
      const featureDeclarations = getFeatureDeclarations(featureSelectors, styles);
      Object.entries(featureDeclarations).forEach(([cssSelector, declarations]) => {
        if (declarations.length) {
          const rules = declarations.join(';');
          ruleset += `${cssSelector}{${rules};}`;
        }
      });
    }

    if (styleVariationSelectors) {
      Object.entries(styleVariationSelectors).forEach(([styleVariationName, styleVariationSelector]) => {
        const styleVariations = styles?.variations?.[styleVariationName];

        if (styleVariations) {
          // If the block uses any custom selectors for block support, add those first.
          if (featureSelectors) {
            const featureDeclarations = getFeatureDeclarations(featureSelectors, styleVariations);
            Object.entries(featureDeclarations).forEach(([baseSelector, declarations]) => {
              if (declarations.length) {
                const cssSelector = concatFeatureVariationSelectorString(baseSelector, styleVariationSelector);
                const rules = declarations.join(';');
                ruleset += `${cssSelector}{${rules};}`;
              }
            });
          } // Otherwise add regular selectors.


          const styleVariationDeclarations = getStylesDeclarations(styleVariations, styleVariationSelector, useRootPaddingAlign, tree);

          if (styleVariationDeclarations.length) {
            ruleset += `${styleVariationSelector}{${styleVariationDeclarations.join(';')};}`;
          }
        }
      });
    } // Process duotone styles.


    if (duotoneSelector) {
      const duotoneStyles = {};

      if (styles?.filter) {
        duotoneStyles.filter = styles.filter;
        delete styles.filter;
      }

      const duotoneDeclarations = getStylesDeclarations(duotoneStyles);

      if (duotoneDeclarations.length) {
        ruleset += `${duotoneSelector}{${duotoneDeclarations.join(';')};}`;
      }
    } // Process blockGap and layout styles.


    if (!disableLayoutStyles && (ROOT_BLOCK_SELECTOR === selector || hasLayoutSupport)) {
      ruleset += getLayoutStyles({
        style: styles,
        selector,
        hasBlockGapSupport,
        hasFallbackGapSupport,
        fallbackGapValue
      });
    } // Process the remaining block styles (they use either normal block class or __experimentalSelector).


    const declarations = getStylesDeclarations(styles, selector, useRootPaddingAlign, tree);

    if (declarations?.length) {
      ruleset += `${selector}{${declarations.join(';')};}`;
    } // Check for pseudo selector in `styles` and handle separately.


    const pseudoSelectorStyles = Object.entries(styles).filter(([key]) => key.startsWith(':'));

    if (pseudoSelectorStyles?.length) {
      pseudoSelectorStyles.forEach(([pseudoKey, pseudoStyle]) => {
        const pseudoDeclarations = getStylesDeclarations(pseudoStyle);

        if (!pseudoDeclarations?.length) {
          return;
        } // `selector` maybe provided in a form
        // where block level selectors have sub element
        // selectors appended to them as a comma separated
        // string.
        // e.g. `h1 a,h2 a,h3 a,h4 a,h5 a,h6 a`;
        // Split and append pseudo selector to create
        // the proper rules to target the elements.


        const _selector = selector.split(',').map(sel => sel + pseudoKey).join(',');

        const pseudoRule = `${_selector}{${pseudoDeclarations.join(';')};}`;
        ruleset += pseudoRule;
      });
    }
  });
  /* Add alignment / layout styles */

  ruleset = ruleset + '.wp-site-blocks > .alignleft { float: left; margin-right: 2em; }';
  ruleset = ruleset + '.wp-site-blocks > .alignright { float: right; margin-left: 2em; }';
  ruleset = ruleset + '.wp-site-blocks > .aligncenter { justify-content: center; margin-left: auto; margin-right: auto; }';

  if (hasBlockGapSupport) {
    // Use fallback of `0.5em` just in case, however if there is blockGap support, there should nearly always be a real value.
    const gapValue = getGapCSSValue(tree?.styles?.spacing?.blockGap) || '0.5em';
    ruleset = ruleset + `:where(.wp-site-blocks) > * { margin-block-start: ${gapValue}; margin-block-end: 0; }`;
    ruleset = ruleset + ':where(.wp-site-blocks) > :first-child:first-child { margin-block-start: 0; }';
    ruleset = ruleset + ':where(.wp-site-blocks) > :last-child:last-child { margin-block-end: 0; }';
  }

  nodesWithSettings.forEach(({
    selector,
    presets
  }) => {
    if (ROOT_BLOCK_SELECTOR === selector) {
      // Do not add extra specificity for top-level classes.
      selector = '';
    }

    const classes = getPresetsClasses(selector, presets);

    if (classes.length > 0) {
      ruleset += classes;
    }
  });
  return ruleset;
};
function toSvgFilters(tree, blockSelectors) {
  const nodesWithSettings = getNodesWithSettings(tree, blockSelectors);
  return nodesWithSettings.flatMap(({
    presets
  }) => {
    return getPresetsSvgFilters(presets);
  });
}

const getSelectorsConfig = (blockType, rootSelector) => {
  if (blockType?.selectors && Object.keys(blockType.selectors).length > 0) {
    return blockType.selectors;
  }

  const config = {
    root: rootSelector
  };
  Object.entries(BLOCK_SUPPORT_FEATURE_LEVEL_SELECTORS).forEach(([featureKey, featureName]) => {
    const featureSelector = getBlockCSSSelector(blockType, featureKey);

    if (featureSelector) {
      config[featureName] = featureSelector;
    }
  });
  return config;
};

const getBlockSelectors = (blockTypes, getBlockStyles) => {
  const result = {};
  blockTypes.forEach(blockType => {
    const name = blockType.name;
    const selector = getBlockCSSSelector(blockType);
    let duotoneSelector = getBlockCSSSelector(blockType, 'filter.duotone'); // Keep backwards compatibility for support.color.__experimentalDuotone.

    if (!duotoneSelector) {
      const rootSelector = getBlockCSSSelector(blockType);
      const duotoneSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, 'color.__experimentalDuotone', false);
      duotoneSelector = duotoneSupport && scopeSelector(rootSelector, duotoneSupport);
    }

    const hasLayoutSupport = !!blockType?.supports?.layout || !!blockType?.supports?.__experimentalLayout;
    const fallbackGapValue = blockType?.supports?.spacing?.blockGap?.__experimentalDefault;
    const blockStyleVariations = getBlockStyles(name);
    const styleVariationSelectors = {};

    if (blockStyleVariations?.length) {
      blockStyleVariations.forEach(variation => {
        const styleVariationSelector = `.is-style-${variation.name}${selector}`;
        styleVariationSelectors[variation.name] = styleVariationSelector;
      });
    } // For each block support feature add any custom selectors.


    const featureSelectors = getSelectorsConfig(blockType, selector);
    result[name] = {
      duotoneSelector,
      fallbackGapValue,
      featureSelectors: Object.keys(featureSelectors).length ? featureSelectors : undefined,
      hasLayoutSupport,
      name,
      selector,
      styleVariationSelectors: Object.keys(styleVariationSelectors).length ? styleVariationSelectors : undefined
    };
  });
  return result;
};
/**
 * If there is a separator block whose color is defined in theme.json via background,
 * update the separator color to the same value by using border color.
 *
 * @param {Object} config Theme.json configuration file object.
 * @return {Object} configTheme.json configuration file object updated.
 */

function updateConfigWithSeparator(config) {
  const needsSeparatorStyleUpdate = config.styles?.blocks?.['core/separator'] && config.styles?.blocks?.['core/separator'].color?.background && !config.styles?.blocks?.['core/separator'].color?.text && !config.styles?.blocks?.['core/separator'].border?.color;

  if (needsSeparatorStyleUpdate) {
    return { ...config,
      styles: { ...config.styles,
        blocks: { ...config.styles.blocks,
          'core/separator': { ...config.styles.blocks['core/separator'],
            color: { ...config.styles.blocks['core/separator'].color,
              text: config.styles?.blocks['core/separator'].color.background
            }
          }
        }
      }
    };
  }

  return config;
}

const processCSSNesting = (css, blockSelector) => {
  let processedCSS = ''; // Split CSS nested rules.

  const parts = css.split('&');
  parts.forEach(part => {
    processedCSS += !part.includes('{') ? blockSelector + '{' + part + '}' // If the part doesn't contain braces, it applies to the root level.
    : blockSelector + part; // Prepend the selector, which effectively replaces the "&" character.
  });
  return processedCSS;
};
/**
 * Returns the global styles output using a global styles configuration.
 * If wishing to generate global styles and settings based on the
 * global styles config loaded in the editor context, use `useGlobalStylesOutput()`.
 * The use case for a custom config is to generate bespoke styles
 * and settings for previews, or other out-of-editor experiences.
 *
 * @param {Object} mergedConfig Global styles configuration.
 * @return {Array} Array of stylesheets and settings.
 */


function useGlobalStylesOutputWithConfig(mergedConfig = {}) {
  const [blockGap] = useGlobalSetting('spacing.blockGap');
  const hasBlockGapSupport = blockGap !== null;
  const hasFallbackGapSupport = !hasBlockGapSupport; // This setting isn't useful yet: it exists as a placeholder for a future explicit fallback styles support.

  const disableLayoutStyles = (0,external_wp_data_namespaceObject.useSelect)(select => {
    const {
      getSettings
    } = select(store);
    return !!getSettings().disableLayoutStyles;
  });
  const getBlockStyles = (0,external_wp_data_namespaceObject.useSelect)(select => {
    return select(external_wp_blocks_namespaceObject.store).getBlockStyles;
  }, []);
  return (0,external_wp_element_namespaceObject.useMemo)(() => {
    var _mergedConfig$styles$;

    if (!mergedConfig?.styles || !mergedConfig?.settings) {
      return [];
    }

    mergedConfig = updateConfigWithSeparator(mergedConfig);
    const blockSelectors = getBlockSelectors((0,external_wp_blocks_namespaceObject.getBlockTypes)(), getBlockStyles);
    const customProperties = toCustomProperties(mergedConfig, blockSelectors);
    const globalStyles = toStyles(mergedConfig, blockSelectors, hasBlockGapSupport, hasFallbackGapSupport, disableLayoutStyles);
    const svgs = toSvgFilters(mergedConfig, blockSelectors);
    const styles = [{
      css: customProperties,
      isGlobalStyles: true
    }, {
      css: globalStyles,
      isGlobalStyles: true
    }, // Load custom CSS in own stylesheet so that any invalid CSS entered in the input won't break all the global styles in the editor.
    {
      css: (_mergedConfig$styles$ = mergedConfig.styles.css) !== null && _mergedConfig$styles$ !== void 0 ? _mergedConfig$styles$ : '',
      isGlobalStyles: true
    }, {
      assets: svgs,
      __unstableType: 'svg',
      isGlobalStyles: true
    }]; // Loop through the blocks to check if there are custom CSS values.
    // If there are, get the block selector and push the selector together with
    // the CSS value to the 'stylesheets' array.

    (0,external_wp_blocks_namespaceObject.getBlockTypes)().forEach(blockType => {
      if (mergedConfig.styles.blocks[blockType.name]?.css) {
        const selector = blockSelectors[blockType.name].selector;
        styles.push({
          css: processCSSNesting(mergedConfig.styles.blocks[blockType.name]?.css, selector),
          isGlobalStyles: true
        });
      }
    });
    return [styles, mergedConfig.settings];
  }, [hasBlockGapSupport, hasFallbackGapSupport, mergedConfig, disableLayoutStyles]);
}
/**
 * Returns the global styles output based on the current state of global styles config loaded in the editor context.
 *
 * @return {Array} Array of stylesheets and settings.
 */

function useGlobalStylesOutput() {
  const {
    merged: mergedConfig
  } = (0,external_wp_element_namespaceObject.useContext)(GlobalStylesContext);
  return useGlobalStylesOutputWithConfig(mergedConfig);
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/shadow.js


/**
 * WordPress dependencies
 */

const shadow = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M12 8c-2.2 0-4 1.8-4 4s1.8 4 4 4 4-1.8 4-4-1.8-4-4-4zm0 6.5c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5-1.1 2.5-2.5 2.5zM12.8 3h-1.5v3h1.5V3zm-1.6 18h1.5v-3h-1.5v3zm6.8-9.8v1.5h3v-1.5h-3zm-12 0H3v1.5h3v-1.5zm9.7 5.6 2.1 2.1 1.1-1.1-2.1-2.1-1.1 1.1zM8.3 7.2 6.2 5.1 5.1 6.2l2.1 2.1 1.1-1.1zM5.1 17.8l1.1 1.1 2.1-2.1-1.1-1.1-2.1 2.1zM18.9 6.2l-1.1-1.1-2.1 2.1 1.1 1.1 2.1-2.1z"
}));
/* harmony default export */ var library_shadow = (shadow);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/global-styles/effects-panel.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



function useHasEffectsPanel(settings) {
  const hasShadowControl = useHasShadowControl(settings);
  return hasShadowControl;
}

function useHasShadowControl(settings) {
  return !!settings?.shadow;
}

function EffectsToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children
}) {
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanel, {
    label: (0,external_wp_i18n_namespaceObject.__)('Effects'),
    resetAll: resetAll,
    panelId: panelId
  }, children);
}

const effects_panel_DEFAULT_CONTROLS = {
  shadow: true
};
function EffectsPanel({
  as: Wrapper = EffectsToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  defaultControls = effects_panel_DEFAULT_CONTROLS
}) {
  const decodeValue = rawValue => getValueFromVariable({
    settings
  }, '', rawValue); // Shadow


  const hasShadowEnabled = useHasShadowControl(settings);
  const shadow = decodeValue(inheritedValue?.shadow);

  const setShadow = newValue => {
    onChange(setImmutably(value, ['shadow'], newValue));
  };

  const hasShadow = () => !!value?.shadow;

  const resetShadow = () => setShadow(undefined);

  const resetAllFilter = (0,external_wp_element_namespaceObject.useCallback)(previousValue => {
    return { ...previousValue,
      shadow: undefined
    };
  }, []);
  return (0,external_wp_element_namespaceObject.createElement)(Wrapper, {
    resetAllFilter: resetAllFilter,
    value: value,
    onChange: onChange,
    panelId: panelId
  }, hasShadowEnabled && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    label: (0,external_wp_i18n_namespaceObject.__)('Shadow'),
    hasValue: hasShadow,
    onDeselect: resetShadow,
    isShownByDefault: defaultControls.shadow,
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalItemGroup, {
    isBordered: true,
    isSeparated: true
  }, (0,external_wp_element_namespaceObject.createElement)(ShadowPopover, {
    shadow: shadow,
    onShadowChange: setShadow,
    settings: settings
  }))));
}

const ShadowPopover = ({
  shadow,
  onShadowChange,
  settings
}) => {
  const popoverProps = {
    placement: 'left-start',
    offset: 36,
    shift: true
  };
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Dropdown, {
    popoverProps: popoverProps,
    className: "block-editor-global-styles-effects-panel__shadow-dropdown",
    renderToggle: renderShadowToggle(),
    renderContent: () => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalDropdownContentWrapper, {
      paddingSize: "medium"
    }, (0,external_wp_element_namespaceObject.createElement)(ShadowPopoverContainer, {
      shadow: shadow,
      onShadowChange: onShadowChange,
      settings: settings
    }))
  });
};

function renderShadowToggle() {
  return ({
    onToggle,
    isOpen
  }) => {
    const toggleProps = {
      onClick: onToggle,
      className: classnames_default()({
        'is-open': isOpen
      }),
      'aria-expanded': isOpen
    };
    return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, { ...toggleProps
    }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHStack, {
      justify: "flex-start"
    }, (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
      className: "block-editor-global-styles-effects-panel__toggle-icon",
      icon: library_shadow,
      size: 24
    }), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.FlexItem, null, (0,external_wp_i18n_namespaceObject.__)('Shadow'))));
  };
}

function ShadowPopoverContainer({
  shadow,
  onShadowChange,
  settings
}) {
  const defaultShadows = settings?.shadow?.presets?.default;
  const themeShadows = settings?.shadow?.presets?.theme;
  const defaultPresetsEnabled = settings?.shadow?.defaultPresets;
  const shadows = [...(defaultPresetsEnabled ? defaultShadows : []), ...(themeShadows || [])];
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-global-styles-effects-panel__shadow-popover-container"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalVStack, {
    spacing: 4
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHeading, {
    level: 5
  }, (0,external_wp_i18n_namespaceObject.__)('Shadow')), (0,external_wp_element_namespaceObject.createElement)(ShadowPresets, {
    presets: shadows,
    activeShadow: shadow,
    onSelect: onShadowChange
  })));
}

function ShadowPresets({
  presets,
  activeShadow,
  onSelect
}) {
  return !presets ? null : (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalGrid, {
    columns: 6,
    gap: 0,
    align: "center",
    justify: "center"
  }, presets.map(({
    name,
    slug,
    shadow
  }) => (0,external_wp_element_namespaceObject.createElement)(ShadowIndicator, {
    key: slug,
    label: name,
    isActive: shadow === activeShadow,
    onSelect: () => onSelect(shadow === activeShadow ? undefined : shadow),
    shadow: shadow
  })));
}

function ShadowIndicator({
  label,
  isActive,
  onSelect,
  shadow
}) {
  return (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-global-styles-effects-panel__shadow-indicator-wrapper"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    className: "block-editor-global-styles-effects-panel__shadow-indicator",
    onClick: onSelect,
    label: label,
    style: {
      boxShadow: shadow
    },
    showTooltip: true
  }, isActive && (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
    icon: library_check
  })));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/global-styles/advanced-panel.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


function AdvancedPanel({
  value,
  onChange,
  inheritedValue = value
}) {
  // Custom CSS
  const [cssError, setCSSError] = (0,external_wp_element_namespaceObject.useState)(null);
  const customCSS = inheritedValue?.css;

  function handleOnChange(newValue) {
    onChange({ ...value,
      css: newValue
    });

    if (cssError) {
      const [transformed] = transform_styles([{
        css: value
      }], '.editor-styles-wrapper');

      if (transformed) {
        setCSSError(null);
      }
    }
  }

  function handleOnBlur(event) {
    if (!event?.target?.value) {
      setCSSError(null);
      return;
    }

    const [transformed] = transform_styles([{
      css: event.target.value
    }], '.editor-styles-wrapper');
    setCSSError(transformed === null ? (0,external_wp_i18n_namespaceObject.__)('There is an error with your CSS structure.') : null);
  }

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalVStack, {
    spacing: 3
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.TextareaControl, {
    label: (0,external_wp_i18n_namespaceObject.__)('Additional CSS'),
    __nextHasNoMarginBottom: true,
    value: customCSS,
    onChange: newValue => handleOnChange(newValue),
    onBlur: handleOnBlur,
    className: "block-editor-global-styles-advanced-panel__custom-css-input",
    spellCheck: false
  }), cssError && (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Tooltip, {
    text: cssError
  }, (0,external_wp_element_namespaceObject.createElement)("div", {
    className: "block-editor-global-styles-advanced-panel__custom-css-validation-wrapper"
  }, (0,external_wp_element_namespaceObject.createElement)(build_module_icon, {
    icon: library_info,
    className: "block-editor-global-styles-advanced-panel__custom-css-validation-icon"
  }))));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/global-styles/index.js













;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/get-rich-text-values.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/*
 * This function is similar to `@wordpress/element`'s `renderToString` function,
 * except that it does not render the elements to a string, but instead collects
 * the values of all rich text `Content` elements.
 */

function addValuesForElement(element, values, innerBlocks) {
  if (null === element || undefined === element || false === element) {
    return;
  }

  if (Array.isArray(element)) {
    return addValuesForElements(element, values, innerBlocks);
  }

  switch (typeof element) {
    case 'string':
    case 'number':
      return;
  }

  const {
    type,
    props
  } = element;

  switch (type) {
    case external_wp_element_namespaceObject.StrictMode:
    case external_wp_element_namespaceObject.Fragment:
      return addValuesForElements(props.children, values, innerBlocks);

    case external_wp_element_namespaceObject.RawHTML:
      return;

    case inner_blocks.Content:
      return addValuesForBlocks(values, innerBlocks);

    case Content:
      values.push(props.value);
      return;
  }

  switch (typeof type) {
    case 'string':
      if (typeof props.children !== 'undefined') {
        return addValuesForElements(props.children, values, innerBlocks);
      }

      return;

    case 'function':
      const el = type.prototype && typeof type.prototype.render === 'function' ? new type(props).render() : type(props);
      return addValuesForElement(el, values, innerBlocks);
  }
}

function addValuesForElements(children, ...args) {
  children = Array.isArray(children) ? children : [children];

  for (let i = 0; i < children.length; i++) {
    addValuesForElement(children[i], ...args);
  }
}

function addValuesForBlocks(values, blocks) {
  for (let i = 0; i < blocks.length; i++) {
    const {
      name,
      attributes,
      innerBlocks
    } = blocks[i];
    const saveElement = (0,external_wp_blocks_namespaceObject.getSaveElement)(name, attributes, // Instead of letting save elements use `useInnerBlocksProps.save`,
    // force them to use InnerBlocks.Content instead so we can intercept
    // a single component.
    (0,external_wp_element_namespaceObject.createElement)(inner_blocks.Content, null));
    addValuesForElement(saveElement, values, innerBlocks);
  }
}

function getRichTextValues(blocks = []) {
  external_wp_blocks_namespaceObject.__unstableGetBlockProps.skipFilters = true;
  const values = [];
  addValuesForBlocks(values, blocks);
  external_wp_blocks_namespaceObject.__unstableGetBlockProps.skipFilters = false;
  return values;
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/resizable-box-popover/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


function ResizableBoxPopover({
  clientId,
  resizableBoxProps,
  ...props
}) {
  return (0,external_wp_element_namespaceObject.createElement)(block_popover, {
    clientId: clientId,
    __unstableCoverTarget: true,
    __unstablePopoverSlot: "block-toolbar",
    shift: false,
    ...props
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.ResizableBox, { ...resizableBoxProps
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-removal-warning-modal/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



function BlockRemovalWarningModal({
  rules
}) {
  const {
    clientIds,
    selectPrevious,
    blockNamesForPrompt
  } = (0,external_wp_data_namespaceObject.useSelect)(select => unlock(select(store)).getRemovalPromptData());
  const {
    clearBlockRemovalPrompt,
    setBlockRemovalRules,
    privateRemoveBlocks
  } = unlock((0,external_wp_data_namespaceObject.useDispatch)(store)); // Load block removal rules, simultaneously signalling that the block
  // removal prompt is in place.

  (0,external_wp_element_namespaceObject.useEffect)(() => {
    setBlockRemovalRules(rules);
    return () => {
      setBlockRemovalRules();
    };
  }, [rules, setBlockRemovalRules]);

  if (!blockNamesForPrompt) {
    return;
  }

  const onConfirmRemoval = () => {
    privateRemoveBlocks(clientIds, selectPrevious,
    /* force */
    true);
    clearBlockRemovalPrompt();
  };

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Modal, {
    title: (0,external_wp_i18n_namespaceObject.__)('Are you sure?'),
    onRequestClose: clearBlockRemovalPrompt,
    style: {
      maxWidth: '40rem'
    }
  }, blockNamesForPrompt.length === 1 ? (0,external_wp_element_namespaceObject.createElement)("p", null, rules[blockNamesForPrompt[0]]) : (0,external_wp_element_namespaceObject.createElement)("ul", {
    style: {
      listStyleType: 'disc',
      paddingLeft: '1rem'
    }
  }, blockNamesForPrompt.map(name => (0,external_wp_element_namespaceObject.createElement)("li", {
    key: name
  }, rules[name]))), (0,external_wp_element_namespaceObject.createElement)("p", null, blockNamesForPrompt.length > 1 ? (0,external_wp_i18n_namespaceObject.__)('Removing these blocks is not advised.') : (0,external_wp_i18n_namespaceObject.__)('Removing this block is not advised.')), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalHStack, {
    justify: "right"
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    variant: "tertiary",
    onClick: clearBlockRemovalPrompt
  }, (0,external_wp_i18n_namespaceObject.__)('Cancel')), (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.Button, {
    variant: "primary",
    onClick: onConfirmRemoval
  }, (0,external_wp_i18n_namespaceObject.__)('Delete'))));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/dimensions-tool/aspect-ratio-tool.js


/**
 * WordPress dependencies
 */


/**
 * @typedef {import('@wordpress/components/build-types/select-control/types').SelectControlProps} SelectControlProps
 */

/**
 * @type {SelectControlProps[]}
 */

const DEFAULT_ASPECT_RATIO_OPTIONS = [{
  label: (0,external_wp_i18n_namespaceObject._x)('Original', 'Aspect ratio option for dimensions control'),
  value: 'auto'
}, {
  label: (0,external_wp_i18n_namespaceObject._x)('Square - 1:1', 'Aspect ratio option for dimensions control'),
  value: '1'
}, {
  label: (0,external_wp_i18n_namespaceObject._x)('Standard - 4:3', 'Aspect ratio option for dimensions control'),
  value: '4/3'
}, {
  label: (0,external_wp_i18n_namespaceObject._x)('Portrait - 3:4', 'Aspect ratio option for dimensions control'),
  value: '3/4'
}, {
  label: (0,external_wp_i18n_namespaceObject._x)('Classic - 3:2', 'Aspect ratio option for dimensions control'),
  value: '3/2'
}, {
  label: (0,external_wp_i18n_namespaceObject._x)('Classic Portrait - 2:3', 'Aspect ratio option for dimensions control'),
  value: '2/3'
}, {
  label: (0,external_wp_i18n_namespaceObject._x)('Wide - 16:9', 'Aspect ratio option for dimensions control'),
  value: '16/9'
}, {
  label: (0,external_wp_i18n_namespaceObject._x)('Tall - 9:16', 'Aspect ratio option for dimensions control'),
  value: '9/16'
}, {
  label: (0,external_wp_i18n_namespaceObject._x)('Custom', 'Aspect ratio option for dimensions control'),
  value: 'custom',
  disabled: true,
  hidden: true
}];
/**
 * @callback AspectRatioToolPropsOnChange
 * @param {string} [value] New aspect ratio value.
 * @return {void} No return.
 */

/**
 * @typedef {Object} AspectRatioToolProps
 * @property {string}                       [panelId]          ID of the panel this tool is associated with.
 * @property {string}                       [value]            Current aspect ratio value.
 * @property {AspectRatioToolPropsOnChange} [onChange]         Callback to update the aspect ratio value.
 * @property {SelectControlProps[]}         [options]          Aspect ratio options.
 * @property {string}                       [defaultValue]     Default aspect ratio value.
 * @property {boolean}                      [isShownByDefault] Whether the tool is shown by default.
 */

function AspectRatioTool({
  panelId,
  value,
  onChange = () => {},
  options = DEFAULT_ASPECT_RATIO_OPTIONS,
  defaultValue = DEFAULT_ASPECT_RATIO_OPTIONS[0].value,
  isShownByDefault = true
}) {
  // Match the CSS default so if the value is used directly in CSS it will look correct in the control.
  const displayValue = value !== null && value !== void 0 ? value : 'auto';
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    hasValue: () => displayValue !== defaultValue,
    label: (0,external_wp_i18n_namespaceObject.__)('Aspect ratio'),
    onDeselect: () => onChange(undefined),
    isShownByDefault: isShownByDefault,
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SelectControl, {
    label: (0,external_wp_i18n_namespaceObject.__)('Aspect ratio'),
    value: displayValue,
    options: options,
    onChange: onChange,
    size: '__unstable-large',
    __nextHasNoMarginBottom: true
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/dimensions-tool/scale-tool.js


/**
 * WordPress dependencies
 */



/**
 * @typedef {import('@wordpress/components/build-types/select-control/types').SelectControlProps} SelectControlProps
 */

/**
 * The descriptions are purposely made generic as object-fit could be used for
 * any replaced element. Provide your own set of options if you need different
 * help text or labels.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/Replaced_element
 *
 * @type {SelectControlProps[]}
 */

const DEFAULT_SCALE_OPTIONS = [{
  value: 'fill',
  label: (0,external_wp_i18n_namespaceObject._x)('Fill', 'Scale option for dimensions control'),
  help: (0,external_wp_i18n_namespaceObject.__)('Fill the space by stretching the content.')
}, {
  value: 'contain',
  label: (0,external_wp_i18n_namespaceObject._x)('Contain', 'Scale option for dimensions control'),
  help: (0,external_wp_i18n_namespaceObject.__)('Fit the content to the space without clipping.')
}, {
  value: 'cover',
  label: (0,external_wp_i18n_namespaceObject._x)('Cover', 'Scale option for dimensions control'),
  help: (0,external_wp_i18n_namespaceObject.__)("Fill the space by clipping what doesn't fit.")
}, {
  value: 'none',
  label: (0,external_wp_i18n_namespaceObject._x)('None', 'Scale option for dimensions control'),
  help: (0,external_wp_i18n_namespaceObject.__)('Do not adjust the sizing of the content. Content that is too large will be clipped, and content that is too small will have additional padding.')
}, {
  value: 'scale-down',
  label: (0,external_wp_i18n_namespaceObject._x)('Scale down', 'Scale option for dimensions control'),
  help: (0,external_wp_i18n_namespaceObject.__)('Scale down the content to fit the space if it is too big. Content that is too small will have additional padding.')
}];
/**
 * @callback ScaleToolPropsOnChange
 * @param {string} nextValue New scale value.
 * @return {void}
 */

/**
 * @typedef {Object} ScaleToolProps
 * @property {string}                 [panelId]               ID of the panel that contains the controls.
 * @property {string}                 [value]                 Current scale value.
 * @property {ScaleToolPropsOnChange} [onChange]              Callback to update the scale value.
 * @property {SelectControlProps[]}   [options]               Scale options.
 * @property {string}                 [defaultValue]          Default scale value.
 * @property {boolean}                [showControl=true]      Whether to show the control.
 * @property {boolean}                [isShownByDefault=true] Whether the tool panel is shown by default.
 */

/**
 * A tool to select the CSS object-fit property for the image.
 *
 * @param {ScaleToolProps} props
 *
 * @return {import('@wordpress/element').WPElement} The scale tool.
 */

function ScaleTool({
  panelId,
  value,
  onChange,
  options = DEFAULT_SCALE_OPTIONS,
  defaultValue = DEFAULT_SCALE_OPTIONS[0].value,
  isShownByDefault = true
}) {
  // Match the CSS default so if the value is used directly in CSS it will look correct in the control.
  const displayValue = value !== null && value !== void 0 ? value : 'fill';
  const scaleHelp = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return options.reduce((acc, option) => {
      acc[option.value] = option.help;
      return acc;
    }, {});
  }, [options]);
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    label: (0,external_wp_i18n_namespaceObject.__)('Scale'),
    isShownByDefault: isShownByDefault,
    hasValue: () => displayValue !== defaultValue,
    onDeselect: () => onChange(defaultValue),
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToggleGroupControl, {
    label: (0,external_wp_i18n_namespaceObject.__)('Scale'),
    isBlock: true,
    help: scaleHelp[displayValue],
    value: displayValue,
    onChange: onChange,
    __nextHasNoMarginBottom: true
  }, options.map(option => (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToggleGroupControlOption, {
    key: option.value,
    ...option
  }))));
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
function extends_extends() {
  extends_extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return extends_extends.apply(this, arguments);
}
;// CONCATENATED MODULE: ./node_modules/@emotion/styled/node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn) {
  var cache = Object.create(null);
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}



;// CONCATENATED MODULE: ./node_modules/@emotion/styled/node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js


var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

var isPropValid = /* #__PURE__ */memoize(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
  /* o */
  && prop.charCodeAt(1) === 110
  /* n */
  && prop.charCodeAt(2) < 91;
}
/* Z+1 */
);



;// CONCATENATED MODULE: ./node_modules/@emotion/sheet/dist/emotion-sheet.browser.esm.js
/*

Based off glamor's StyleSheet, thanks Sunil ❤️

high performance StyleSheet for css-in-js systems

- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance

// usage

import { StyleSheet } from '@emotion/sheet'

let styleSheet = new StyleSheet({ key: '', container: document.head })

styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet

styleSheet.flush()
- empties the stylesheet of all its contents

*/
// $FlowFixMe
function sheetForTag(tag) {
  if (tag.sheet) {
    // $FlowFixMe
    return tag.sheet;
  } // this weirdness brought to you by firefox

  /* istanbul ignore next */


  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      // $FlowFixMe
      return document.styleSheets[i];
    }
  }
}

function createStyleElement(options) {
  var tag = document.createElement('style');
  tag.setAttribute('data-emotion', options.key);

  if (options.nonce !== undefined) {
    tag.setAttribute('nonce', options.nonce);
  }

  tag.appendChild(document.createTextNode(''));
  tag.setAttribute('data-s', '');
  return tag;
}

var StyleSheet = /*#__PURE__*/function () {
  // Using Node instead of HTMLElement since container may be a ShadowRoot
  function StyleSheet(options) {
    var _this = this;

    this._insertTag = function (tag) {
      var before;

      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }

      _this.container.insertBefore(tag, before);

      _this.tags.push(tag);
    };

    this.isSpeedy = options.speedy === undefined ? "production" === 'production' : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }

  var _proto = StyleSheet.prototype;

  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };

  _proto.insert = function insert(rule) {
    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
    // it's 1 in dev because we insert source maps that map a single rule to a location
    // and you can only have one source map per style tag
    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }

    var tag = this.tags[this.tags.length - 1];

    if (false) { var isImportRule; }

    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);

      try {
        // this is the ultrafast version, works across browsers
        // the big drawback is that the css won't be editable in devtools
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
        if (false) {}
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }

    this.ctr++;
  };

  _proto.flush = function flush() {
    // $FlowFixMe
    this.tags.forEach(function (tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;

    if (false) {}
  };

  return StyleSheet;
}();



;// CONCATENATED MODULE: ./node_modules/stylis/src/Utility.js
/**
 * @param {number}
 * @return {number}
 */
var abs = Math.abs

/**
 * @param {number}
 * @return {string}
 */
var Utility_from = String.fromCharCode

/**
 * @param {object}
 * @return {object}
 */
var Utility_assign = Object.assign

/**
 * @param {string} value
 * @param {number} length
 * @return {number}
 */
function hash (value, length) {
	return Utility_charat(value, 0) ^ 45 ? (((((((length << 2) ^ Utility_charat(value, 0)) << 2) ^ Utility_charat(value, 1)) << 2) ^ Utility_charat(value, 2)) << 2) ^ Utility_charat(value, 3) : 0
}

/**
 * @param {string} value
 * @return {string}
 */
function Utility_trim (value) {
	return value.trim()
}

/**
 * @param {string} value
 * @param {RegExp} pattern
 * @return {string?}
 */
function Utility_match (value, pattern) {
	return (value = pattern.exec(value)) ? value[0] : value
}

/**
 * @param {string} value
 * @param {(string|RegExp)} pattern
 * @param {string} replacement
 * @return {string}
 */
function Utility_replace (value, pattern, replacement) {
	return value.replace(pattern, replacement)
}

/**
 * @param {string} value
 * @param {string} search
 * @return {number}
 */
function indexof (value, search) {
	return value.indexOf(search)
}

/**
 * @param {string} value
 * @param {number} index
 * @return {number}
 */
function Utility_charat (value, index) {
	return value.charCodeAt(index) | 0
}

/**
 * @param {string} value
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function Utility_substr (value, begin, end) {
	return value.slice(begin, end)
}

/**
 * @param {string} value
 * @return {number}
 */
function Utility_strlen (value) {
	return value.length
}

/**
 * @param {any[]} value
 * @return {number}
 */
function Utility_sizeof (value) {
	return value.length
}

/**
 * @param {any} value
 * @param {any[]} array
 * @return {any}
 */
function Utility_append (value, array) {
	return array.push(value), value
}

/**
 * @param {string[]} array
 * @param {function} callback
 * @return {string}
 */
function Utility_combine (array, callback) {
	return array.map(callback).join('')
}

;// CONCATENATED MODULE: ./node_modules/stylis/src/Tokenizer.js


var line = 1
var column = 1
var Tokenizer_length = 0
var position = 0
var Tokenizer_character = 0
var characters = ''

/**
 * @param {string} value
 * @param {object | null} root
 * @param {object | null} parent
 * @param {string} type
 * @param {string[] | string} props
 * @param {object[] | string} children
 * @param {number} length
 */
function node (value, root, parent, type, props, children, length) {
	return {value: value, root: root, parent: parent, type: type, props: props, children: children, line: line, column: column, length: length, return: ''}
}

/**
 * @param {object} root
 * @param {object} props
 * @return {object}
 */
function Tokenizer_copy (root, props) {
	return Utility_assign(node('', null, null, '', null, null, 0), root, {length: -root.length}, props)
}

/**
 * @return {number}
 */
function Tokenizer_char () {
	return Tokenizer_character
}

/**
 * @return {number}
 */
function prev () {
	Tokenizer_character = position > 0 ? Utility_charat(characters, --position) : 0

	if (column--, Tokenizer_character === 10)
		column = 1, line--

	return Tokenizer_character
}

/**
 * @return {number}
 */
function Tokenizer_next () {
	Tokenizer_character = position < Tokenizer_length ? Utility_charat(characters, position++) : 0

	if (column++, Tokenizer_character === 10)
		column = 1, line++

	return Tokenizer_character
}

/**
 * @return {number}
 */
function peek () {
	return Utility_charat(characters, position)
}

/**
 * @return {number}
 */
function caret () {
	return position
}

/**
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function slice (begin, end) {
	return Utility_substr(characters, begin, end)
}

/**
 * @param {number} type
 * @return {number}
 */
function token (type) {
	switch (type) {
		// \0 \t \n \r \s whitespace token
		case 0: case 9: case 10: case 13: case 32:
			return 5
		// ! + , / > @ ~ isolate token
		case 33: case 43: case 44: case 47: case 62: case 64: case 126:
		// ; { } breakpoint token
		case 59: case 123: case 125:
			return 4
		// : accompanied token
		case 58:
			return 3
		// " ' ( [ opening delimit token
		case 34: case 39: case 40: case 91:
			return 2
		// ) ] closing delimit token
		case 41: case 93:
			return 1
	}

	return 0
}

/**
 * @param {string} value
 * @return {any[]}
 */
function alloc (value) {
	return line = column = 1, Tokenizer_length = Utility_strlen(characters = value), position = 0, []
}

/**
 * @param {any} value
 * @return {any}
 */
function dealloc (value) {
	return characters = '', value
}

/**
 * @param {number} type
 * @return {string}
 */
function delimit (type) {
	return Utility_trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)))
}

/**
 * @param {string} value
 * @return {string[]}
 */
function Tokenizer_tokenize (value) {
	return dealloc(tokenizer(alloc(value)))
}

/**
 * @param {number} type
 * @return {string}
 */
function whitespace (type) {
	while (Tokenizer_character = peek())
		if (Tokenizer_character < 33)
			Tokenizer_next()
		else
			break

	return token(type) > 2 || token(Tokenizer_character) > 3 ? '' : ' '
}

/**
 * @param {string[]} children
 * @return {string[]}
 */
function tokenizer (children) {
	while (Tokenizer_next())
		switch (token(Tokenizer_character)) {
			case 0: append(identifier(position - 1), children)
				break
			case 2: append(delimit(Tokenizer_character), children)
				break
			default: append(from(Tokenizer_character), children)
		}

	return children
}

/**
 * @param {number} index
 * @param {number} count
 * @return {string}
 */
function escaping (index, count) {
	while (--count && Tokenizer_next())
		// not 0-9 A-F a-f
		if (Tokenizer_character < 48 || Tokenizer_character > 102 || (Tokenizer_character > 57 && Tokenizer_character < 65) || (Tokenizer_character > 70 && Tokenizer_character < 97))
			break

	return slice(index, caret() + (count < 6 && peek() == 32 && Tokenizer_next() == 32))
}

/**
 * @param {number} type
 * @return {number}
 */
function delimiter (type) {
	while (Tokenizer_next())
		switch (Tokenizer_character) {
			// ] ) " '
			case type:
				return position
			// " '
			case 34: case 39:
				if (type !== 34 && type !== 39)
					delimiter(Tokenizer_character)
				break
			// (
			case 40:
				if (type === 41)
					delimiter(type)
				break
			// \
			case 92:
				Tokenizer_next()
				break
		}

	return position
}

/**
 * @param {number} type
 * @param {number} index
 * @return {number}
 */
function commenter (type, index) {
	while (Tokenizer_next())
		// //
		if (type + Tokenizer_character === 47 + 10)
			break
		// /*
		else if (type + Tokenizer_character === 42 + 42 && peek() === 47)
			break

	return '/*' + slice(index, position - 1) + '*' + Utility_from(type === 47 ? type : Tokenizer_next())
}

/**
 * @param {number} index
 * @return {string}
 */
function identifier (index) {
	while (!token(peek()))
		Tokenizer_next()

	return slice(index, position)
}

;// CONCATENATED MODULE: ./node_modules/stylis/src/Enum.js
var Enum_MS = '-ms-'
var Enum_MOZ = '-moz-'
var Enum_WEBKIT = '-webkit-'

var COMMENT = 'comm'
var Enum_RULESET = 'rule'
var Enum_DECLARATION = 'decl'

var PAGE = '@page'
var MEDIA = '@media'
var IMPORT = '@import'
var CHARSET = '@charset'
var VIEWPORT = '@viewport'
var SUPPORTS = '@supports'
var DOCUMENT = '@document'
var NAMESPACE = '@namespace'
var Enum_KEYFRAMES = '@keyframes'
var FONT_FACE = '@font-face'
var COUNTER_STYLE = '@counter-style'
var FONT_FEATURE_VALUES = '@font-feature-values'
var LAYER = '@layer'

;// CONCATENATED MODULE: ./node_modules/stylis/src/Serializer.js



/**
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function Serializer_serialize (children, callback) {
	var output = ''
	var length = Utility_sizeof(children)

	for (var i = 0; i < length; i++)
		output += callback(children[i], i, children, callback) || ''

	return output
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function Serializer_stringify (element, index, children, callback) {
	switch (element.type) {
		case LAYER: if (element.children.length) break
		case IMPORT: case Enum_DECLARATION: return element.return = element.return || element.value
		case COMMENT: return ''
		case Enum_KEYFRAMES: return element.return = element.value + '{' + Serializer_serialize(element.children, callback) + '}'
		case Enum_RULESET: element.value = element.props.join(',')
	}

	return Utility_strlen(children = Serializer_serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : ''
}

;// CONCATENATED MODULE: ./node_modules/stylis/src/Middleware.js






/**
 * @param {function[]} collection
 * @return {function}
 */
function middleware (collection) {
	var length = Utility_sizeof(collection)

	return function (element, index, children, callback) {
		var output = ''

		for (var i = 0; i < length; i++)
			output += collection[i](element, index, children, callback) || ''

		return output
	}
}

/**
 * @param {function} callback
 * @return {function}
 */
function rulesheet (callback) {
	return function (element) {
		if (!element.root)
			if (element = element.return)
				callback(element)
	}
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 */
function prefixer (element, index, children, callback) {
	if (element.length > -1)
		if (!element.return)
			switch (element.type) {
				case DECLARATION: element.return = prefix(element.value, element.length, children)
					return
				case KEYFRAMES:
					return serialize([copy(element, {value: replace(element.value, '@', '@' + WEBKIT)})], callback)
				case RULESET:
					if (element.length)
						return combine(element.props, function (value) {
							switch (match(value, /(::plac\w+|:read-\w+)/)) {
								// :read-(only|write)
								case ':read-only': case ':read-write':
									return serialize([copy(element, {props: [replace(value, /:(read-\w+)/, ':' + MOZ + '$1')]})], callback)
								// :placeholder
								case '::placeholder':
									return serialize([
										copy(element, {props: [replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1')]}),
										copy(element, {props: [replace(value, /:(plac\w+)/, ':' + MOZ + '$1')]}),
										copy(element, {props: [replace(value, /:(plac\w+)/, MS + 'input-$1')]})
									], callback)
							}

							return ''
						})
			}
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 */
function namespace (element) {
	switch (element.type) {
		case RULESET:
			element.props = element.props.map(function (value) {
				return combine(tokenize(value), function (value, index, children) {
					switch (charat(value, 0)) {
						// \f
						case 12:
							return substr(value, 1, strlen(value))
						// \0 ( + > ~
						case 0: case 40: case 43: case 62: case 126:
							return value
						// :
						case 58:
							if (children[++index] === 'global')
								children[index] = '', children[++index] = '\f' + substr(children[index], index = 1, -1)
						// \s
						case 32:
							return index === 1 ? '' : value
						default:
							switch (index) {
								case 0: element = value
									return sizeof(children) > 1 ? '' : value
								case index = sizeof(children) - 1: case 2:
									return index === 2 ? value + element + element : value + element
								default:
									return value
							}
					}
				})
			})
	}
}

;// CONCATENATED MODULE: ./node_modules/stylis/src/Parser.js




/**
 * @param {string} value
 * @return {object[]}
 */
function compile (value) {
	return dealloc(Parser_parse('', null, null, null, [''], value = alloc(value), 0, [0], value))
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {string[]} rule
 * @param {string[]} rules
 * @param {string[]} rulesets
 * @param {number[]} pseudo
 * @param {number[]} points
 * @param {string[]} declarations
 * @return {object}
 */
function Parser_parse (value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
	var index = 0
	var offset = 0
	var length = pseudo
	var atrule = 0
	var property = 0
	var previous = 0
	var variable = 1
	var scanning = 1
	var ampersand = 1
	var character = 0
	var type = ''
	var props = rules
	var children = rulesets
	var reference = rule
	var characters = type

	while (scanning)
		switch (previous = character, character = Tokenizer_next()) {
			// (
			case 40:
				if (previous != 108 && Utility_charat(characters, length - 1) == 58) {
					if (indexof(characters += Utility_replace(delimit(character), '&', '&\f'), '&\f') != -1)
						ampersand = -1
					break
				}
			// " ' [
			case 34: case 39: case 91:
				characters += delimit(character)
				break
			// \t \n \r \s
			case 9: case 10: case 13: case 32:
				characters += whitespace(previous)
				break
			// \
			case 92:
				characters += escaping(caret() - 1, 7)
				continue
			// /
			case 47:
				switch (peek()) {
					case 42: case 47:
						Utility_append(comment(commenter(Tokenizer_next(), caret()), root, parent), declarations)
						break
					default:
						characters += '/'
				}
				break
			// {
			case 123 * variable:
				points[index++] = Utility_strlen(characters) * ampersand
			// } ; \0
			case 125 * variable: case 59: case 0:
				switch (character) {
					// \0 }
					case 0: case 125: scanning = 0
					// ;
					case 59 + offset: if (ampersand == -1) characters = Utility_replace(characters, /\f/g, '')
						if (property > 0 && (Utility_strlen(characters) - length))
							Utility_append(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(Utility_replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations)
						break
					// @ ;
					case 59: characters += ';'
					// { rule/at-rule
					default:
						Utility_append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets)

						if (character === 123)
							if (offset === 0)
								Parser_parse(characters, root, reference, reference, props, rulesets, length, points, children)
							else
								switch (atrule === 99 && Utility_charat(characters, 3) === 110 ? 100 : atrule) {
									// d l m s
									case 100: case 108: case 109: case 115:
										Parser_parse(value, reference, reference, rule && Utility_append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children)
										break
									default:
										Parser_parse(characters, reference, reference, reference, [''], children, 0, points, children)
								}
				}

				index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo
				break
			// :
			case 58:
				length = 1 + Utility_strlen(characters), property = previous
			default:
				if (variable < 1)
					if (character == 123)
						--variable
					else if (character == 125 && variable++ == 0 && prev() == 125)
						continue

				switch (characters += Utility_from(character), character * variable) {
					// &
					case 38:
						ampersand = offset > 0 ? 1 : (characters += '\f', -1)
						break
					// ,
					case 44:
						points[index++] = (Utility_strlen(characters) - 1) * ampersand, ampersand = 1
						break
					// @
					case 64:
						// -
						if (peek() === 45)
							characters += delimit(Tokenizer_next())

						atrule = peek(), offset = length = Utility_strlen(type = characters += identifier(caret())), character++
						break
					// -
					case 45:
						if (previous === 45 && Utility_strlen(characters) == 2)
							variable = 0
				}
		}

	return rulesets
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} index
 * @param {number} offset
 * @param {string[]} rules
 * @param {number[]} points
 * @param {string} type
 * @param {string[]} props
 * @param {string[]} children
 * @param {number} length
 * @return {object}
 */
function ruleset (value, root, parent, index, offset, rules, points, type, props, children, length) {
	var post = offset - 1
	var rule = offset === 0 ? rules : ['']
	var size = Utility_sizeof(rule)

	for (var i = 0, j = 0, k = 0; i < index; ++i)
		for (var x = 0, y = Utility_substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
			if (z = Utility_trim(j > 0 ? rule[x] + ' ' + y : Utility_replace(y, /&\f/g, rule[x])))
				props[k++] = z

	return node(value, root, parent, offset === 0 ? Enum_RULESET : type, props, children, length)
}

/**
 * @param {number} value
 * @param {object} root
 * @param {object?} parent
 * @return {object}
 */
function comment (value, root, parent) {
	return node(value, root, parent, COMMENT, Utility_from(Tokenizer_char()), Utility_substr(value, 2, -2), 0)
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} length
 * @return {object}
 */
function declaration (value, root, parent, length) {
	return node(value, root, parent, Enum_DECLARATION, Utility_substr(value, 0, length), Utility_substr(value, length + 1, -1), length)
}

;// CONCATENATED MODULE: ./node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js





var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
  var previous = 0;
  var character = 0;

  while (true) {
    previous = character;
    character = peek(); // &\f

    if (previous === 38 && character === 12) {
      points[index] = 1;
    }

    if (token(character)) {
      break;
    }

    Tokenizer_next();
  }

  return slice(begin, position);
};

var toRules = function toRules(parsed, points) {
  // pretend we've started with a comma
  var index = -1;
  var character = 44;

  do {
    switch (token(character)) {
      case 0:
        // &\f
        if (character === 38 && peek() === 12) {
          // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
          // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
          // and when it should just concatenate the outer and inner selectors
          // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
          points[index] = 1;
        }

        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;

      case 2:
        parsed[index] += delimit(character);
        break;

      case 4:
        // comma
        if (character === 44) {
          // colon
          parsed[++index] = peek() === 58 ? '&\f' : '';
          points[index] = parsed[index].length;
          break;
        }

      // fallthrough

      default:
        parsed[index] += Utility_from(character);
    }
  } while (character = Tokenizer_next());

  return parsed;
};

var getRules = function getRules(value, points) {
  return dealloc(toRules(alloc(value), points));
}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11


var fixedElements = /* #__PURE__ */new WeakMap();
var compat = function compat(element) {
  if (element.type !== 'rule' || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }

  var value = element.value,
      parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;

  while (parent.type !== 'rule') {
    parent = parent.parent;
    if (!parent) return;
  } // short-circuit for the simplest case


  if (element.props.length === 1 && value.charCodeAt(0) !== 58
  /* colon */
  && !fixedElements.get(parent)) {
    return;
  } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
  // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"


  if (isImplicitRule) {
    return;
  }

  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;

  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel(element) {
  if (element.type === 'decl') {
    var value = element.value;

    if ( // charcode for l
    value.charCodeAt(0) === 108 && // charcode for b
    value.charCodeAt(2) === 98) {
      // this ignores label
      element["return"] = '';
      element.value = '';
    }
  }
};
var ignoreFlag = 'emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason';

var isIgnoringComment = function isIgnoringComment(element) {
  return element.type === 'comm' && element.children.indexOf(ignoreFlag) > -1;
};

var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {
  return function (element, index, children) {
    if (element.type !== 'rule' || cache.compat) return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);

    if (unsafePseudoClasses) {
      var isNested = !!element.parent; // in nested rules comments become children of the "auto-inserted" rule and that's always the `element.parent`
      //
      // considering this input:
      // .a {
      //   .b /* comm */ {}
      //   color: hotpink;
      // }
      // we get output corresponding to this:
      // .a {
      //   & {
      //     /* comm */
      //     color: hotpink;
      //   }
      //   .b {}
      // }

      var commentContainer = isNested ? element.parent.children : // global rule at the root level
      children;

      for (var i = commentContainer.length - 1; i >= 0; i--) {
        var node = commentContainer[i];

        if (node.line < element.line) {
          break;
        } // it is quite weird but comments are *usually* put at `column: element.column - 1`
        // so we seek *from the end* for the node that is earlier than the rule's `element` and check that
        // this will also match inputs like this:
        // .a {
        //   /* comm */
        //   .b {}
        // }
        //
        // but that is fine
        //
        // it would be the easiest to change the placement of the comment to be the first child of the rule:
        // .a {
        //   .b { /* comm */ }
        // }
        // with such inputs we wouldn't have to search for the comment at all
        // TODO: consider changing this comment placement in the next major version


        if (node.column < element.column) {
          if (isIgnoringComment(node)) {
            return;
          }

          break;
        }
      }

      unsafePseudoClasses.forEach(function (unsafePseudoClass) {
        console.error("The pseudo class \"" + unsafePseudoClass + "\" is potentially unsafe when doing server-side rendering. Try changing it to \"" + unsafePseudoClass.split('-child')[0] + "-of-type\".");
      });
    }
  };
};

var isImportRule = function isImportRule(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};

var isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {
  for (var i = index - 1; i >= 0; i--) {
    if (!isImportRule(children[i])) {
      return true;
    }
  }

  return false;
}; // use this to remove incorrect elements from further processing
// so they don't get handed to the `sheet` (or anything else)
// as that could potentially lead to additional logs which in turn could be overhelming to the user


var nullifyElement = function nullifyElement(element) {
  element.type = '';
  element.value = '';
  element["return"] = '';
  element.children = '';
  element.props = '';
};

var incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {
  if (!isImportRule(element)) {
    return;
  }

  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};

/* eslint-disable no-fallthrough */

function emotion_cache_browser_esm_prefix(value, length) {
  switch (hash(value, length)) {
    // color-adjust
    case 5103:
      return Enum_WEBKIT + 'print-' + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)

    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921: // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break

    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005: // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,

    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855: // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)

    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Enum_WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust

    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Enum_WEBKIT + value + Enum_MOZ + value + Enum_MS + value + value;
    // flex, flex-direction

    case 6828:
    case 4268:
      return Enum_WEBKIT + value + Enum_MS + value + value;
    // order

    case 6165:
      return Enum_WEBKIT + value + Enum_MS + 'flex-' + value + value;
    // align-items

    case 5187:
      return Enum_WEBKIT + value + Utility_replace(value, /(\w+).+(:[^]+)/, Enum_WEBKIT + 'box-$1$2' + Enum_MS + 'flex-$1$2') + value;
    // align-self

    case 5443:
      return Enum_WEBKIT + value + Enum_MS + 'flex-item-' + Utility_replace(value, /flex-|-self/, '') + value;
    // align-content

    case 4675:
      return Enum_WEBKIT + value + Enum_MS + 'flex-line-pack' + Utility_replace(value, /align-content|flex-|-self/, '') + value;
    // flex-shrink

    case 5548:
      return Enum_WEBKIT + value + Enum_MS + Utility_replace(value, 'shrink', 'negative') + value;
    // flex-basis

    case 5292:
      return Enum_WEBKIT + value + Enum_MS + Utility_replace(value, 'basis', 'preferred-size') + value;
    // flex-grow

    case 6060:
      return Enum_WEBKIT + 'box-' + Utility_replace(value, '-grow', '') + Enum_WEBKIT + value + Enum_MS + Utility_replace(value, 'grow', 'positive') + value;
    // transition

    case 4554:
      return Enum_WEBKIT + Utility_replace(value, /([^-])(transform)/g, '$1' + Enum_WEBKIT + '$2') + value;
    // cursor

    case 6187:
      return Utility_replace(Utility_replace(Utility_replace(value, /(zoom-|grab)/, Enum_WEBKIT + '$1'), /(image-set)/, Enum_WEBKIT + '$1'), value, '') + value;
    // background, background-image

    case 5495:
    case 3959:
      return Utility_replace(value, /(image-set\([^]*)/, Enum_WEBKIT + '$1' + '$`$1');
    // justify-content

    case 4968:
      return Utility_replace(Utility_replace(value, /(.+:)(flex-)?(.*)/, Enum_WEBKIT + 'box-pack:$3' + Enum_MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + Enum_WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)

    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Utility_replace(value, /(.+)-inline(.+)/, Enum_WEBKIT + '$1$2') + value;
    // (min|max)?(width|height|inline-size|block-size)

    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      // stretch, max-content, min-content, fill-available
      if (Utility_strlen(value) - 1 - length > 6) switch (Utility_charat(value, length + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          // -
          if (Utility_charat(value, length + 4) !== 45) break;
        // (f)ill-available, (f)it-content

        case 102:
          return Utility_replace(value, /(.+:)(.+)-([^]+)/, '$1' + Enum_WEBKIT + '$2-$3' + '$1' + Enum_MOZ + (Utility_charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
        // (s)tretch

        case 115:
          return ~indexof(value, 'stretch') ? emotion_cache_browser_esm_prefix(Utility_replace(value, 'stretch', 'fill-available'), length) + value : value;
      }
      break;
    // position: sticky

    case 4949:
      // (s)ticky?
      if (Utility_charat(value, length + 1) !== 115) break;
    // display: (flex|inline-flex)

    case 6444:
      switch (Utility_charat(value, Utility_strlen(value) - 3 - (~indexof(value, '!important') && 10))) {
        // stic(k)y
        case 107:
          return Utility_replace(value, ':', ':' + Enum_WEBKIT) + value;
        // (inline-)?fl(e)x

        case 101:
          return Utility_replace(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + Enum_WEBKIT + (Utility_charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + Enum_WEBKIT + '$2$3' + '$1' + Enum_MS + '$2box$3') + value;
      }

      break;
    // writing-mode

    case 5936:
      switch (Utility_charat(value, length + 11)) {
        // vertical-l(r)
        case 114:
          return Enum_WEBKIT + value + Enum_MS + Utility_replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
        // vertical-r(l)

        case 108:
          return Enum_WEBKIT + value + Enum_MS + Utility_replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
        // horizontal(-)tb

        case 45:
          return Enum_WEBKIT + value + Enum_MS + Utility_replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
      }

      return Enum_WEBKIT + value + Enum_MS + value + value;
  }

  return value;
}

var emotion_cache_browser_esm_prefixer = function prefixer(element, index, children, callback) {
  if (element.length > -1) if (!element["return"]) switch (element.type) {
    case Enum_DECLARATION:
      element["return"] = emotion_cache_browser_esm_prefix(element.value, element.length);
      break;

    case Enum_KEYFRAMES:
      return Serializer_serialize([Tokenizer_copy(element, {
        value: Utility_replace(element.value, '@', '@' + Enum_WEBKIT)
      })], callback);

    case Enum_RULESET:
      if (element.length) return Utility_combine(element.props, function (value) {
        switch (Utility_match(value, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ':read-only':
          case ':read-write':
            return Serializer_serialize([Tokenizer_copy(element, {
              props: [Utility_replace(value, /:(read-\w+)/, ':' + Enum_MOZ + '$1')]
            })], callback);
          // :placeholder

          case '::placeholder':
            return Serializer_serialize([Tokenizer_copy(element, {
              props: [Utility_replace(value, /:(plac\w+)/, ':' + Enum_WEBKIT + 'input-$1')]
            }), Tokenizer_copy(element, {
              props: [Utility_replace(value, /:(plac\w+)/, ':' + Enum_MOZ + '$1')]
            }), Tokenizer_copy(element, {
              props: [Utility_replace(value, /:(plac\w+)/, Enum_MS + 'input-$1')]
            })], callback);
        }

        return '';
      });
  }
};

var defaultStylisPlugins = [emotion_cache_browser_esm_prefixer];

var emotion_cache_browser_esm_createCache = function createCache(options) {
  var key = options.key;

  if (false) {}

  if (key === 'css') {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
    // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
    // note this very very intentionally targets all style elements regardless of the key to ensure
    // that creating a cache works inside of render of a React component

    Array.prototype.forEach.call(ssrStyles, function (node) {
      // we want to only move elements which have a space in the data-emotion attribute value
      // because that indicates that it is an Emotion 11 server-side rendered style elements
      // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
      // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
      // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
      // will not result in the Emotion 10 styles being destroyed
      var dataEmotionAttribute = node.getAttribute('data-emotion');

      if (dataEmotionAttribute.indexOf(' ') === -1) {
        return;
      }
      document.head.appendChild(node);
      node.setAttribute('data-s', '');
    });
  }

  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;

  if (false) {}

  var inserted = {};
  var container;
  var nodesToHydrate = [];

  {
    container = options.container || document.head;
    Array.prototype.forEach.call( // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
      var attrib = node.getAttribute("data-emotion").split(' '); // $FlowFixMe

      for (var i = 1; i < attrib.length; i++) {
        inserted[attrib[i]] = true;
      }

      nodesToHydrate.push(node);
    });
  }

  var _insert;

  var omnipresentPlugins = [compat, removeLabel];

  if (false) {}

  {
    var currentSheet;
    var finalizingPlugins = [Serializer_stringify,  false ? 0 : rulesheet(function (rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));

    var stylis = function stylis(styles) {
      return Serializer_serialize(compile(styles), serializer);
    };

    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;

      if (false) {}

      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);

      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }

  var cache = {
    key: key,
    sheet: new StyleSheet({
      key: key,
      container: container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted: inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};



;// CONCATENATED MODULE: ./node_modules/@emotion/hash/dist/emotion-hash.esm.js
/* eslint-disable */
// Inspired by https://github.com/garycourt/murmurhash-js
// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
function murmur2(str) {
  // 'm' and 'r' are mixing constants generated offline.
  // They're not really 'magic', they just happen to work well.
  // const m = 0x5bd1e995;
  // const r = 24;
  // Initialize the hash
  var h = 0; // Mix 4 bytes at a time into the hash

  var k,
      i = 0,
      len = str.length;

  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
    k =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
    k ^=
    /* k >>> r: */
    k >>> 24;
    h =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
    /* Math.imul(h, m): */
    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Handle the last few bytes of the input array


  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

    case 2:
      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

    case 1:
      h ^= str.charCodeAt(i) & 0xff;
      h =
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Do a few final mixes of the hash to ensure the last few
  // bytes are well-incorporated.


  h ^= h >>> 13;
  h =
  /* Math.imul(h, m): */
  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}



;// CONCATENATED MODULE: ./node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};



;// CONCATENATED MODULE: ./node_modules/@emotion/serialize/node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function emotion_memoize_esm_memoize(fn) {
  var cache = Object.create(null);
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}



;// CONCATENATED MODULE: ./node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js




var ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;

var isCustomProperty = function isCustomProperty(property) {
  return property.charCodeAt(1) === 45;
};

var isProcessableValue = function isProcessableValue(value) {
  return value != null && typeof value !== 'boolean';
};

var processStyleName = /* #__PURE__ */emotion_memoize_esm_memoize(function (styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
});

var processStyleValue = function processStyleValue(key, value) {
  switch (key) {
    case 'animation':
    case 'animationName':
      {
        if (typeof value === 'string') {
          return value.replace(animationRegex, function (match, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
  }

  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
    return value + 'px';
  }

  return value;
};

if (false) { var hyphenatedCache, hyphenPattern, msPattern, oldProcessStyleValue, contentValues, contentValuePattern; }

var noComponentSelectorMessage = (/* unused pure expression or super */ null && ('Component selectors can only be used in conjunction with ' + '@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware ' + 'compiler transform.'));

function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return '';
  }

  if (interpolation.__emotion_styles !== undefined) {
    if (false) {}

    return interpolation;
  }

  switch (typeof interpolation) {
    case 'boolean':
      {
        return '';
      }

    case 'object':
      {
        if (interpolation.anim === 1) {
          cursor = {
            name: interpolation.name,
            styles: interpolation.styles,
            next: cursor
          };
          return interpolation.name;
        }

        if (interpolation.styles !== undefined) {
          var next = interpolation.next;

          if (next !== undefined) {
            // not the most efficient thing ever but this is a pretty rare case
            // and there will be very few iterations of this generally
            while (next !== undefined) {
              cursor = {
                name: next.name,
                styles: next.styles,
                next: cursor
              };
              next = next.next;
            }
          }

          var styles = interpolation.styles + ";";

          if (false) {}

          return styles;
        }

        return createStringFromObject(mergedProps, registered, interpolation);
      }

    case 'function':
      {
        if (mergedProps !== undefined) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        } else if (false) {}

        break;
      }

    case 'string':
      if (false) { var replaced, matched; }

      break;
  } // finalize string values (regular strings and functions interpolated into css calls)


  if (registered == null) {
    return interpolation;
  }

  var cached = registered[interpolation];
  return cached !== undefined ? cached : interpolation;
}

function createStringFromObject(mergedProps, registered, obj) {
  var string = '';

  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];

      if (typeof value !== 'object') {
        if (registered != null && registered[value] !== undefined) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === 'NO_COMPONENT_SELECTOR' && "production" !== 'production') {}

        if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);

          switch (_key) {
            case 'animation':
            case 'animationName':
              {
                string += processStyleName(_key) + ":" + interpolated + ";";
                break;
              }

            default:
              {
                if (false) {}

                string += _key + "{" + interpolated + "}";
              }
          }
        }
      }
    }
  }

  return string;
}

var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var sourceMapPattern;

if (false) {} // this is the cursor for keyframes
// keyframes are stored on the SerializedStyles object as a linked list


var cursor;
var emotion_serialize_browser_esm_serializeStyles = function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
    return args[0];
  }

  var stringMode = true;
  var styles = '';
  cursor = undefined;
  var strings = args[0];

  if (strings == null || strings.raw === undefined) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    if (false) {}

    styles += strings[0];
  } // we start at 1 since we've already handled the first arg


  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);

    if (stringMode) {
      if (false) {}

      styles += strings[i];
    }
  }

  var sourceMap;

  if (false) {} // using a global regex with .exec is stateful so lastIndex has to be reset each time


  labelPattern.lastIndex = 0;
  var identifierName = '';
  var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

  while ((match = labelPattern.exec(styles)) !== null) {
    identifierName += '-' + // $FlowFixMe we know it's not null
    match[1];
  }

  var name = murmur2(styles) + identifierName;

  if (false) {}

  return {
    name: name,
    styles: styles,
    next: cursor
  };
};



;// CONCATENATED MODULE: ./node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js


var syncFallback = function syncFallback(create) {
  return create();
};

var useInsertionEffect = external_React_['useInsertion' + 'Effect'] ? external_React_['useInsertion' + 'Effect'] : false;
var emotion_use_insertion_effect_with_fallbacks_browser_esm_useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || external_React_.useLayoutEffect;



;// CONCATENATED MODULE: ./node_modules/@emotion/react/dist/emotion-element-c39617d8.browser.esm.js










var isBrowser = "object" !== 'undefined';
var emotion_element_c39617d8_browser_esm_hasOwnProperty = {}.hasOwnProperty;

var EmotionCacheContext = /* #__PURE__ */external_React_.createContext( // we're doing this to avoid preconstruct's dead code elimination in this one case
// because this module is primarily intended for the browser and node
// but it's also required in react native and similar environments sometimes
// and we could have a special build just for that
// but this is much easier and the native packages
// might use a different theme context in the future anyway
typeof HTMLElement !== 'undefined' ? /* #__PURE__ */emotion_cache_browser_esm_createCache({
  key: 'css'
}) : null);

if (false) {}

var CacheProvider = EmotionCacheContext.Provider;
var __unsafe_useEmotionCache = function useEmotionCache() {
  return useContext(EmotionCacheContext);
};

var withEmotionCache = function withEmotionCache(func) {
  // $FlowFixMe
  return /*#__PURE__*/(0,external_React_.forwardRef)(function (props, ref) {
    // the cache will never be null in the browser
    var cache = (0,external_React_.useContext)(EmotionCacheContext);
    return func(props, cache, ref);
  });
};

if (!isBrowser) {
  withEmotionCache = function withEmotionCache(func) {
    return function (props) {
      var cache = (0,external_React_.useContext)(EmotionCacheContext);

      if (cache === null) {
        // yes, we're potentially creating this on every render
        // it doesn't actually matter though since it's only on the server
        // so there will only every be a single render
        // that could change in the future because of suspense and etc. but for now,
        // this works and i don't want to optimise for a future thing that we aren't sure about
        cache = emotion_cache_browser_esm_createCache({
          key: 'css'
        });
        return /*#__PURE__*/external_React_.createElement(EmotionCacheContext.Provider, {
          value: cache
        }, func(props, cache));
      } else {
        return func(props, cache);
      }
    };
  };
}

var ThemeContext = /* #__PURE__ */external_React_.createContext({});

if (false) {}

var useTheme = function useTheme() {
  return React.useContext(ThemeContext);
};

var getTheme = function getTheme(outerTheme, theme) {
  if (typeof theme === 'function') {
    var mergedTheme = theme(outerTheme);

    if (false) {}

    return mergedTheme;
  }

  if (false) {}

  return _extends({}, outerTheme, theme);
};

var createCacheWithTheme = /* #__PURE__ */(/* unused pure expression or super */ null && (weakMemoize(function (outerTheme) {
  return weakMemoize(function (theme) {
    return getTheme(outerTheme, theme);
  });
})));
var ThemeProvider = function ThemeProvider(props) {
  var theme = React.useContext(ThemeContext);

  if (props.theme !== theme) {
    theme = createCacheWithTheme(theme)(props.theme);
  }

  return /*#__PURE__*/React.createElement(ThemeContext.Provider, {
    value: theme
  }, props.children);
};
function withTheme(Component) {
  var componentName = Component.displayName || Component.name || 'Component';

  var render = function render(props, ref) {
    var theme = React.useContext(ThemeContext);
    return /*#__PURE__*/React.createElement(Component, _extends({
      theme: theme,
      ref: ref
    }, props));
  }; // $FlowFixMe


  var WithTheme = /*#__PURE__*/React.forwardRef(render);
  WithTheme.displayName = "WithTheme(" + componentName + ")";
  return hoistNonReactStatics(WithTheme, Component);
}

var getLastPart = function getLastPart(functionName) {
  // The match may be something like 'Object.createEmotionProps' or
  // 'Loader.prototype.render'
  var parts = functionName.split('.');
  return parts[parts.length - 1];
};

var getFunctionNameFromStackTraceLine = function getFunctionNameFromStackTraceLine(line) {
  // V8
  var match = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(line);
  if (match) return getLastPart(match[1]); // Safari / Firefox

  match = /^([A-Za-z0-9$.]+)@/.exec(line);
  if (match) return getLastPart(match[1]);
  return undefined;
};

var internalReactFunctionNames = /* #__PURE__ */new Set(['renderWithHooks', 'processChild', 'finishClassComponent', 'renderToString']); // These identifiers come from error stacks, so they have to be valid JS
// identifiers, thus we only need to replace what is a valid character for JS,
// but not for CSS.

var sanitizeIdentifier = function sanitizeIdentifier(identifier) {
  return identifier.replace(/\$/g, '-');
};

var getLabelFromStackTrace = function getLabelFromStackTrace(stackTrace) {
  if (!stackTrace) return undefined;
  var lines = stackTrace.split('\n');

  for (var i = 0; i < lines.length; i++) {
    var functionName = getFunctionNameFromStackTraceLine(lines[i]); // The first line of V8 stack traces is just "Error"

    if (!functionName) continue; // If we reach one of these, we have gone too far and should quit

    if (internalReactFunctionNames.has(functionName)) break; // The component name is the first function in the stack that starts with an
    // uppercase letter

    if (/^[A-Z]/.test(functionName)) return sanitizeIdentifier(functionName);
  }

  return undefined;
};

var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
var labelPropName = '__EMOTION_LABEL_PLEASE_DO_NOT_USE__';
var createEmotionProps = function createEmotionProps(type, props) {
  if (false) {}

  var newProps = {};

  for (var key in props) {
    if (emotion_element_c39617d8_browser_esm_hasOwnProperty.call(props, key)) {
      newProps[key] = props[key];
    }
  }

  newProps[typePropName] = type; // For performance, only call getLabelFromStackTrace in development and when
  // the label hasn't already been computed

  if (false) { var label; }

  return newProps;
};

var Insertion = function Insertion(_ref) {
  var cache = _ref.cache,
      serialized = _ref.serialized,
      isStringTag = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function () {
    return insertStyles(cache, serialized, isStringTag);
  });

  return null;
};

var Emotion = /* #__PURE__ */(/* unused pure expression or super */ null && (withEmotionCache(function (props, cache, ref) {
  var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works
  // not passing the registered cache to serializeStyles because it would
  // make certain babel optimisations not possible

  if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
    cssProp = cache.registered[cssProp];
  }

  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = '';

  if (typeof props.className === 'string') {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }

  var serialized = serializeStyles(registeredStyles, undefined, React.useContext(ThemeContext));

  if (false) { var labelFromStack; }

  className += cache.key + "-" + serialized.name;
  var newProps = {};

  for (var key in props) {
    if (emotion_element_c39617d8_browser_esm_hasOwnProperty.call(props, key) && key !== 'css' && key !== typePropName && ( true || 0)) {
      newProps[key] = props[key];
    }
  }

  newProps.ref = ref;
  newProps.className = className;
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Insertion, {
    cache: cache,
    serialized: serialized,
    isStringTag: typeof WrappedComponent === 'string'
  }), /*#__PURE__*/React.createElement(WrappedComponent, newProps));
})));

if (false) {}

var Emotion$1 = (/* unused pure expression or super */ null && (Emotion));



;// CONCATENATED MODULE: ./node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var emotion_utils_browser_esm_isBrowser = "object" !== 'undefined';
function emotion_utils_browser_esm_getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = '';
  classNames.split(' ').forEach(function (className) {
    if (registered[className] !== undefined) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var emotion_utils_browser_esm_registerStyles = function registerStyles(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;

  if ( // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (isStringTag === false || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  emotion_utils_browser_esm_isBrowser === false ) && cache.registered[className] === undefined) {
    cache.registered[className] = serialized.styles;
  }
};
var emotion_utils_browser_esm_insertStyles = function insertStyles(cache, serialized, isStringTag) {
  emotion_utils_browser_esm_registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;

  if (cache.inserted[serialized.name] === undefined) {
    var current = serialized;

    do {
      cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);

      current = current.next;
    } while (current !== undefined);
  }
};



;// CONCATENATED MODULE: ./node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js








var testOmitPropsOnStringTag = isPropValid;

var testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {
  return key !== 'theme';
};

var getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {
  return typeof tag === 'string' && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {
  var shouldForwardProp;

  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function (propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }

  if (typeof shouldForwardProp !== 'function' && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }

  return shouldForwardProp;
};

var emotion_styled_base_browser_esm_ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";

var emotion_styled_base_browser_esm_Insertion = function Insertion(_ref) {
  var cache = _ref.cache,
      serialized = _ref.serialized,
      isStringTag = _ref.isStringTag;
  emotion_utils_browser_esm_registerStyles(cache, serialized, isStringTag);
  emotion_use_insertion_effect_with_fallbacks_browser_esm_useInsertionEffectAlwaysWithSyncFallback(function () {
    return emotion_utils_browser_esm_insertStyles(cache, serialized, isStringTag);
  });

  return null;
};

var createStyled = function createStyled(tag, options) {
  if (false) {}

  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;

  if (options !== undefined) {
    identifierName = options.label;
    targetClassName = options.target;
  }

  var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp('as');
  return function () {
    var args = arguments;
    var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];

    if (identifierName !== undefined) {
      styles.push("label:" + identifierName + ";");
    }

    if (args[0] == null || args[0].raw === undefined) {
      styles.push.apply(styles, args);
    } else {
      if (false) {}

      styles.push(args[0][0]);
      var len = args.length;
      var i = 1;

      for (; i < len; i++) {
        if (false) {}

        styles.push(args[i], args[0][i]);
      }
    } // $FlowFixMe: we need to cast StatelessFunctionalComponent to our PrivateStyledComponent class


    var Styled = withEmotionCache(function (props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = '';
      var classInterpolations = [];
      var mergedProps = props;

      if (props.theme == null) {
        mergedProps = {};

        for (var key in props) {
          mergedProps[key] = props[key];
        }

        mergedProps.theme = external_React_.useContext(ThemeContext);
      }

      if (typeof props.className === 'string') {
        className = emotion_utils_browser_esm_getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }

      var serialized = emotion_serialize_browser_esm_serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;

      if (targetClassName !== undefined) {
        className += " " + targetClassName;
      }

      var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};

      for (var _key in props) {
        if (shouldUseAs && _key === 'as') continue;

        if ( // $FlowFixMe
        finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }

      newProps.className = className;
      newProps.ref = ref;
      return /*#__PURE__*/external_React_.createElement(external_React_.Fragment, null, /*#__PURE__*/external_React_.createElement(emotion_styled_base_browser_esm_Insertion, {
        cache: cache,
        serialized: serialized,
        isStringTag: typeof FinalTag === 'string'
      }), /*#__PURE__*/external_React_.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== undefined ? identifierName : "Styled(" + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles;
    Styled.__emotion_forwardProp = shouldForwardProp;
    Object.defineProperty(Styled, 'toString', {
      value: function value() {
        if (targetClassName === undefined && "production" !== 'production') {} // $FlowFixMe: coerce undefined to string


        return "." + targetClassName;
      }
    });

    Styled.withComponent = function (nextTag, nextOptions) {
      return createStyled(nextTag, extends_extends({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles);
    };

    return Styled;
  };
};



;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/dimensions-tool/width-height-tool.js



function _EMOTION_STRINGIFIED_CSS_ERROR__() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



const SingleColumnToolsPanelItem = /*#__PURE__*/createStyled(external_wp_components_namespaceObject.__experimentalToolsPanelItem,  true ? {
  target: "ef8pe3d0"
} : 0)( true ? {
  name: "957xgf",
  styles: "grid-column:span 1"
} : 0);
/**
 * @typedef {import('@wordpress/components/build-types/unit-control/types').WPUnitControlUnit} WPUnitControlUnit
 */

/**
 * @typedef {Object} WidthHeightToolValue
 * @property {string} [width]  Width CSS value.
 * @property {string} [height] Height CSS value.
 */

/**
 * @callback WidthHeightToolOnChange
 * @param {WidthHeightToolValue} nextValue Next dimensions value.
 * @return {void}
 */

/**
 * @typedef {Object} WidthHeightToolProps
 * @property {string}                  [panelId]          ID of the panel that contains the controls.
 * @property {WidthHeightToolValue}    [value]            Current dimensions values.
 * @property {WidthHeightToolOnChange} [onChange]         Callback to update the dimensions values.
 * @property {WPUnitControlUnit[]}     [units]            Units options.
 * @property {boolean}                 [isShownByDefault] Whether the panel is shown by default.
 */

/**
 * Component that renders controls to edit the dimensions of an image or container.
 *
 * @param {WidthHeightToolProps} props The component props.
 *
 * @return {import('@wordpress/element').WPElement} The width and height tool.
 */


function WidthHeightTool({
  panelId,
  value = {},
  onChange = () => {},
  units,
  isShownByDefault = true
}) {
  var _value$width, _value$height;

  // null, undefined, and 'auto' all represent the default value.
  const width = value.width === 'auto' ? '' : (_value$width = value.width) !== null && _value$width !== void 0 ? _value$width : '';
  const height = value.height === 'auto' ? '' : (_value$height = value.height) !== null && _value$height !== void 0 ? _value$height : '';

  const onDimensionChange = dimension => nextDimension => {
    const nextValue = { ...value
    }; // Empty strings or undefined may be passed and both represent removing the value.

    if (!nextDimension) {
      delete nextValue[dimension];
    } else {
      nextValue[dimension] = nextDimension;
    }

    onChange(nextValue);
  };

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(SingleColumnToolsPanelItem, {
    label: (0,external_wp_i18n_namespaceObject.__)('Width'),
    isShownByDefault: isShownByDefault,
    hasValue: () => width !== '',
    onDeselect: onDimensionChange('width'),
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalUnitControl, {
    label: (0,external_wp_i18n_namespaceObject.__)('Width'),
    placeholder: (0,external_wp_i18n_namespaceObject.__)('Auto'),
    labelPosition: "top",
    units: units,
    min: 0,
    value: width,
    onChange: onDimensionChange('width'),
    size: '__unstable-large'
  })), (0,external_wp_element_namespaceObject.createElement)(SingleColumnToolsPanelItem, {
    label: (0,external_wp_i18n_namespaceObject.__)('Height'),
    isShownByDefault: isShownByDefault,
    hasValue: () => height !== '',
    onDeselect: onDimensionChange('height'),
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalUnitControl, {
    label: (0,external_wp_i18n_namespaceObject.__)('Height'),
    placeholder: (0,external_wp_i18n_namespaceObject.__)('Auto'),
    labelPosition: "top",
    units: units,
    min: 0,
    value: height,
    onChange: onDimensionChange('height'),
    size: '__unstable-large'
  })));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/dimensions-tool/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




/**
 * @typedef {import('@wordpress/components/build-types/select-control/types').SelectControlProps} SelectControlProps
 */

/**
 * @typedef {import('@wordpress/components/build-types/unit-control/types').WPUnitControlUnit} WPUnitControlUnit
 */

/**
 * @typedef {Object} Dimensions
 * @property {string} [width]       CSS width property.
 * @property {string} [height]      CSS height property.
 * @property {string} [scale]       CSS object-fit property.
 * @property {string} [aspectRatio] CSS aspect-ratio property.
 */

/**
 * @callback DimensionsControlsOnChange
 * @param {Dimensions} nextValue
 * @return {void}
 */

/**
 * @typedef {Object} DimensionsControlsProps
 * @property {string}                     [panelId]            ID of the panel that contains the controls.
 * @property {Dimensions}                 [value]              Current dimensions values.
 * @property {DimensionsControlsOnChange} [onChange]           Callback to update the dimensions values.
 * @property {SelectControlProps[]}       [aspectRatioOptions] Aspect ratio options.
 * @property {SelectControlProps[]}       [scaleOptions]       Scale options.
 * @property {WPUnitControlUnit[]}        [unitsOptions]       Units options.
 */

/**
 * Component that renders controls to edit the dimensions of an image or container.
 *
 * @param {DimensionsControlsProps} props The component props.
 *
 * @return {WPElement} The dimensions controls.
 */

function DimensionsTool({
  panelId,
  value = {},
  onChange = () => {},
  aspectRatioOptions,
  // Default options handled by AspectRatioTool.
  defaultAspectRatio = 'auto',
  // Match CSS default value for aspect-ratio.
  scaleOptions,
  // Default options handled by ScaleTool.
  defaultScale = 'fill',
  // Match CSS default value for object-fit.
  unitsOptions // Default options handled by UnitControl.

}) {
  // Coerce undefined and CSS default values to be null.
  const width = value.width === undefined || value.width === 'auto' ? null : value.width;
  const height = value.height === undefined || value.height === 'auto' ? null : value.height;
  const aspectRatio = value.aspectRatio === undefined || value.aspectRatio === 'auto' ? null : value.aspectRatio;
  const scale = value.scale === undefined || value.scale === 'fill' ? null : value.scale; // Keep track of state internally, so when the value is cleared by means
  // other than directly editing that field, it's easier to restore the
  // previous value.

  const [lastScale, setLastScale] = (0,external_wp_element_namespaceObject.useState)(scale);
  const [lastAspectRatio, setLastAspectRatio] = (0,external_wp_element_namespaceObject.useState)(aspectRatio); // 'custom' is not a valid value for CSS aspect-ratio, but it is used in the
  // dropdown to indicate that setting both the width and height is the same
  // as a custom aspect ratio.

  const aspectRatioValue = width && height ? 'custom' : lastAspectRatio;
  const showScaleControl = aspectRatio || width && height;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_element_namespaceObject.Fragment, null, (0,external_wp_element_namespaceObject.createElement)(AspectRatioTool, {
    panelId: panelId,
    options: aspectRatioOptions,
    defaultValue: defaultAspectRatio,
    value: aspectRatioValue,
    onChange: nextAspectRatio => {
      const nextValue = { ...value
      }; // 'auto' is CSS default, so it gets treated as null.

      nextAspectRatio = nextAspectRatio === 'auto' ? null : nextAspectRatio;
      setLastAspectRatio(nextAspectRatio); // Update aspectRatio.

      if (!nextAspectRatio) {
        delete nextValue.aspectRatio;
      } else {
        nextValue.aspectRatio = nextAspectRatio;
      } // Auto-update scale.


      if (!nextAspectRatio) {
        delete nextValue.scale;
      } else if (lastScale) {
        nextValue.scale = lastScale;
      } else {
        nextValue.scale = defaultScale;
        setLastScale(defaultScale);
      } // Auto-update width and height.


      if (nextAspectRatio && width && height) {
        delete nextValue.height;
      }

      onChange(nextValue);
    }
  }), showScaleControl && (0,external_wp_element_namespaceObject.createElement)(ScaleTool, {
    panelId: panelId,
    options: scaleOptions,
    defaultValue: defaultScale,
    value: lastScale,
    onChange: nextScale => {
      const nextValue = { ...value
      }; // 'fill' is CSS default, so it gets treated as null.

      nextScale = nextScale === 'fill' ? null : nextScale;
      setLastScale(nextScale); // Update scale.

      if (!nextScale) {
        delete nextValue.scale;
      } else {
        nextValue.scale = nextScale;
      }

      onChange(nextValue);
    }
  }), (0,external_wp_element_namespaceObject.createElement)(WidthHeightTool, {
    panelId: panelId,
    units: unitsOptions,
    value: {
      width,
      height
    },
    onChange: ({
      width: nextWidth,
      height: nextHeight
    }) => {
      const nextValue = { ...value
      }; // 'auto' is CSS default, so it gets treated as null.

      nextWidth = nextWidth === 'auto' ? null : nextWidth;
      nextHeight = nextHeight === 'auto' ? null : nextHeight; // Update width.

      if (!nextWidth) {
        delete nextValue.width;
      } else {
        nextValue.width = nextWidth;
      } // Update height.


      if (!nextHeight) {
        delete nextValue.height;
      } else {
        nextValue.height = nextHeight;
      } // Auto-update aspectRatio.


      if (nextWidth && nextHeight) {
        delete nextValue.aspectRatio;
      } else if (lastAspectRatio) {
        nextValue.aspectRatio = lastAspectRatio;
      } else {// No setting defaultAspectRatio here, because
        // aspectRatio is optional in this scenario,
        // unlike scale.
      } // Auto-update scale.


      if (!lastAspectRatio && !!nextWidth !== !!nextHeight) {
        delete nextValue.scale;
      } else if (lastScale) {
        nextValue.scale = lastScale;
      } else {
        nextValue.scale = defaultScale;
        setLastScale(defaultScale);
      }

      onChange(nextValue);
    }
  }));
}

/* harmony default export */ var dimensions_tool = (DimensionsTool);

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/resolution-tool/index.js


/**
 * WordPress dependencies
 */


const DEFAULT_SIZE_OPTIONS = [{
  label: (0,external_wp_i18n_namespaceObject._x)('Thumbnail', 'Image size option for resolution control'),
  value: 'thumbnail'
}, {
  label: (0,external_wp_i18n_namespaceObject._x)('Medium', 'Image size option for resolution control'),
  value: 'medium'
}, {
  label: (0,external_wp_i18n_namespaceObject._x)('Large', 'Image size option for resolution control'),
  value: 'large'
}, {
  label: (0,external_wp_i18n_namespaceObject._x)('Full Size', 'Image size option for resolution control'),
  value: 'full'
}];
function ResolutionTool({
  panelId,
  value,
  onChange,
  options = DEFAULT_SIZE_OPTIONS,
  defaultValue = DEFAULT_SIZE_OPTIONS[0].value,
  isShownByDefault = true
}) {
  const displayValue = value !== null && value !== void 0 ? value : defaultValue;
  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, {
    hasValue: () => displayValue !== defaultValue,
    label: (0,external_wp_i18n_namespaceObject.__)('Resolution'),
    onDeselect: () => onChange(defaultValue),
    isShownByDefault: isShownByDefault,
    panelId: panelId
  }, (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SelectControl, {
    label: (0,external_wp_i18n_namespaceObject.__)('Resolution'),
    value: displayValue,
    options: options,
    onChange: onChange,
    help: (0,external_wp_i18n_namespaceObject.__)('Select the size of the source image.'),
    size: '__unstable-large'
  }));
}

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/private-apis.js
/**
 * Internal dependencies
 */



















/**
 * Private @wordpress/block-editor APIs.
 */

const privateApis = {};
lock(privateApis, { ...global_styles_namespaceObject,
  ExperimentalBlockEditorProvider: ExperimentalBlockEditorProvider,
  getRichTextValues: getRichTextValues,
  PrivateInserter: ComposedPrivateInserter,
  PrivateListView: PrivateListView,
  ResizableBoxPopover: ResizableBoxPopover,
  BlockInfo: block_info_slot_fill,
  useShouldContextualToolbarShow: useShouldContextualToolbarShow,
  cleanEmptyObject: utils_cleanEmptyObject,
  useBlockEditingMode: useBlockEditingMode,
  BlockQuickNavigation: BlockQuickNavigation,
  LayoutStyle: LayoutStyle,
  BlockRemovalWarningModal: BlockRemovalWarningModal,
  useLayoutClasses: useLayoutClasses,
  useLayoutStyles: useLayoutStyles,
  DimensionsTool: dimensions_tool,
  ResolutionTool: ResolutionTool,
  ReusableBlocksRenameHint: ReusableBlocksRenameHint,
  useReusableBlocksRenameHint: useReusableBlocksRenameHint,
  usesContextKey: usesContextKey
});

;// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/index.js
/**
 * Internal dependencies
 */









}();
(window.wp = window.wp || {}).blockEditor = __webpack_exports__;
/******/ })()
;