this["wp"] = this["wp"] || {}; this["wp"]["blockEditor"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "tr0p");
/******/ })
/************************************************************************/
/******/ ({

/***/ "//Lo":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const blockDefault = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M19 8h-1V6h-5v2h-2V6H6v2H5c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-8c0-1.1-.9-2-2-2zm.5 10c0 .3-.2.5-.5.5H5c-.3 0-.5-.2-.5-.5v-8c0-.3.2-.5.5-.5h14c.3 0 .5.2.5.5v8z"
}));
/* harmony default export */ __webpack_exports__["a"] = (blockDefault);


/***/ }),

/***/ "16Al":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__("WbBG");

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "17x9":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) { var throwOnDirectAccess, ReactIs; } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__("16Al")();
}


/***/ }),

/***/ "1CF3":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["dom"]; }());

/***/ }),

/***/ "1ZqX":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["data"]; }());

/***/ }),

/***/ "1iEr":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const chevronRight = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M10.6 6L9.4 7l4.6 5-4.6 5 1.2 1 5.4-6z"
}));
/* harmony default export */ __webpack_exports__["a"] = (chevronRight);


/***/ }),

/***/ "2gm7":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const chevronLeft = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M14.6 7l-1.2-1L8 12l5.4 6 1.2-1-4.6-5z"
}));
/* harmony default export */ __webpack_exports__["a"] = (chevronLeft);


/***/ }),

/***/ "4eJC":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Memize options object.
 *
 * @typedef MemizeOptions
 *
 * @property {number} [maxSize] Maximum size of the cache.
 */

/**
 * Internal cache entry.
 *
 * @typedef MemizeCacheNode
 *
 * @property {?MemizeCacheNode|undefined} [prev] Previous node.
 * @property {?MemizeCacheNode|undefined} [next] Next node.
 * @property {Array<*>}                   args   Function arguments for cache
 *                                               entry.
 * @property {*}                          val    Function result.
 */

/**
 * Properties of the enhanced function for controlling cache.
 *
 * @typedef MemizeMemoizedFunction
 *
 * @property {()=>void} clear Clear the cache.
 */

/**
 * Accepts a function to be memoized, and returns a new memoized function, with
 * optional options.
 *
 * @template {Function} F
 *
 * @param {F}             fn        Function to memoize.
 * @param {MemizeOptions} [options] Options object.
 *
 * @return {F & MemizeMemoizedFunction} Memoized function.
 */
function memize( fn, options ) {
	var size = 0;

	/** @type {?MemizeCacheNode|undefined} */
	var head;

	/** @type {?MemizeCacheNode|undefined} */
	var tail;

	options = options || {};

	function memoized( /* ...args */ ) {
		var node = head,
			len = arguments.length,
			args, i;

		searchCache: while ( node ) {
			// Perform a shallow equality test to confirm that whether the node
			// under test is a candidate for the arguments passed. Two arrays
			// are shallowly equal if their length matches and each entry is
			// strictly equal between the two sets. Avoid abstracting to a
			// function which could incur an arguments leaking deoptimization.

			// Check whether node arguments match arguments length
			if ( node.args.length !== arguments.length ) {
				node = node.next;
				continue;
			}

			// Check whether node arguments match arguments values
			for ( i = 0; i < len; i++ ) {
				if ( node.args[ i ] !== arguments[ i ] ) {
					node = node.next;
					continue searchCache;
				}
			}

			// At this point we can assume we've found a match

			// Surface matched node to head if not already
			if ( node !== head ) {
				// As tail, shift to previous. Must only shift if not also
				// head, since if both head and tail, there is no previous.
				if ( node === tail ) {
					tail = node.prev;
				}

				// Adjust siblings to point to each other. If node was tail,
				// this also handles new tail's empty `next` assignment.
				/** @type {MemizeCacheNode} */ ( node.prev ).next = node.next;
				if ( node.next ) {
					node.next.prev = node.prev;
				}

				node.next = head;
				node.prev = null;
				/** @type {MemizeCacheNode} */ ( head ).prev = node;
				head = node;
			}

			// Return immediately
			return node.val;
		}

		// No cached value found. Continue to insertion phase:

		// Create a copy of arguments (avoid leaking deoptimization)
		args = new Array( len );
		for ( i = 0; i < len; i++ ) {
			args[ i ] = arguments[ i ];
		}

		node = {
			args: args,

			// Generate the result from original function
			val: fn.apply( null, args ),
		};

		// Don't need to check whether node is already head, since it would
		// have been returned above already if it was

		// Shift existing head down list
		if ( head ) {
			head.prev = node;
			node.next = head;
		} else {
			// If no head, follows that there's no tail (at initial or reset)
			tail = node;
		}

		// Trim tail if we're reached max size and are pending cache insertion
		if ( size === /** @type {MemizeOptions} */ ( options ).maxSize ) {
			tail = /** @type {MemizeCacheNode} */ ( tail ).prev;
			/** @type {MemizeCacheNode} */ ( tail ).next = null;
		} else {
			size++;
		}

		head = node;

		return node.val;
	}

	memoized.clear = function() {
		head = null;
		tail = null;
		size = 0;
	};

	if ( false ) {}

	// Ignore reason: There's not a clear solution to create an intersection of
	// the function with additional properties, where the goal is to retain the
	// function signature of the incoming argument and add control properties
	// on the return value.

	// @ts-ignore
	return memoized;
}

module.exports = memize;


/***/ }),

/***/ "6fKw":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
Copyright (c) 2014, Yahoo! Inc. All rights reserved.
Copyrights licensed under the New BSD License.
See the accompanying LICENSE file for terms.
*/



exports.match = matchQuery;
exports.parse = parseQuery;

// -----------------------------------------------------------------------------

var RE_MEDIA_QUERY     = /(?:(only|not)?\s*([^\s\(\)]+)(?:\s*and)?\s*)?(.+)?/i,
    RE_MQ_EXPRESSION   = /\(\s*([^\s\:\)]+)\s*(?:\:\s*([^\s\)]+))?\s*\)/,
    RE_MQ_FEATURE      = /^(?:(min|max)-)?(.+)/,
    RE_LENGTH_UNIT     = /(em|rem|px|cm|mm|in|pt|pc)?$/,
    RE_RESOLUTION_UNIT = /(dpi|dpcm|dppx)?$/;

function matchQuery(mediaQuery, values) {
    return parseQuery(mediaQuery).some(function (query) {
        var inverse = query.inverse;

        // Either the parsed or specified `type` is "all", or the types must be
        // equal for a match.
        var typeMatch = query.type === 'all' || values.type === query.type;

        // Quit early when `type` doesn't match, but take "not" into account.
        if ((typeMatch && inverse) || !(typeMatch || inverse)) {
            return false;
        }

        var expressionsMatch = query.expressions.every(function (expression) {
            var feature  = expression.feature,
                modifier = expression.modifier,
                expValue = expression.value,
                value    = values[feature];

            // Missing or falsy values don't match.
            if (!value) { return false; }

            switch (feature) {
                case 'orientation':
                case 'scan':
                    return value.toLowerCase() === expValue.toLowerCase();

                case 'width':
                case 'height':
                case 'device-width':
                case 'device-height':
                    expValue = toPx(expValue);
                    value    = toPx(value);
                    break;

                case 'resolution':
                    expValue = toDpi(expValue);
                    value    = toDpi(value);
                    break;

                case 'aspect-ratio':
                case 'device-aspect-ratio':
                case /* Deprecated */ 'device-pixel-ratio':
                    expValue = toDecimal(expValue);
                    value    = toDecimal(value);
                    break;

                case 'grid':
                case 'color':
                case 'color-index':
                case 'monochrome':
                    expValue = parseInt(expValue, 10) || 1;
                    value    = parseInt(value, 10) || 0;
                    break;
            }

            switch (modifier) {
                case 'min': return value >= expValue;
                case 'max': return value <= expValue;
                default   : return value === expValue;
            }
        });

        return (expressionsMatch && !inverse) || (!expressionsMatch && inverse);
    });
}

function parseQuery(mediaQuery) {
    return mediaQuery.split(',').map(function (query) {
        query = query.trim();

        var captures    = query.match(RE_MEDIA_QUERY),
            modifier    = captures[1],
            type        = captures[2],
            expressions = captures[3] || '',
            parsed      = {};

        parsed.inverse = !!modifier && modifier.toLowerCase() === 'not';
        parsed.type    = type ? type.toLowerCase() : 'all';

        // Split expressions into a list.
        expressions = expressions.match(/\([^\)]+\)/g) || [];

        parsed.expressions = expressions.map(function (expression) {
            var captures = expression.match(RE_MQ_EXPRESSION),
                feature  = captures[1].toLowerCase().match(RE_MQ_FEATURE);

            return {
                modifier: feature[1],
                feature : feature[2],
                value   : captures[2]
            };
        });

        return parsed;
    });
}

// -- Utilities ----------------------------------------------------------------

function toDecimal(ratio) {
    var decimal = Number(ratio),
        numbers;

    if (!decimal) {
        numbers = ratio.match(/^(\d+)\s*\/\s*(\d+)$/);
        decimal = numbers[1] / numbers[2];
    }

    return decimal;
}

function toDpi(resolution) {
    var value = parseFloat(resolution),
        units = String(resolution).match(RE_RESOLUTION_UNIT)[1];

    switch (units) {
        case 'dpcm': return value / 2.54;
        case 'dppx': return value * 96;
        default    : return value;
    }
}

function toPx(length) {
    var value = parseFloat(length),
        units = String(length).match(RE_LENGTH_UNIT)[1];

    switch (units) {
        case 'em' : return value * 16;
        case 'rem': return value * 16;
        case 'cm' : return value * 96 / 2.54;
        case 'mm' : return value * 96 / 2.54 / 10;
        case 'in' : return value * 96;
        case 'pt' : return value * 72;
        case 'pc' : return value * 72 / 12;
        default   : return value;
    }
}


/***/ }),

/***/ "7fqt":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["wordcount"]; }());

/***/ }),

/***/ "8OQS":
/***/ (function(module, exports) {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "9Do8":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__("zt9T");

/***/ }),

/***/ "B9Az":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: external ["wp","element"]
var external_wp_element_ = __webpack_require__("GRId");

// EXTERNAL MODULE: external ["wp","primitives"]
var external_wp_primitives_ = __webpack_require__("Tqx9");

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/pencil.js


/**
 * WordPress dependencies
 */

const pencil = Object(external_wp_element_["createElement"])(external_wp_primitives_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_primitives_["Path"], {
  d: "M20.1 5.1L16.9 2 6.2 12.7l-1.3 4.4 4.5-1.3L20.1 5.1zM4 20.8h8v-1.5H4v1.5z"
}));
/* harmony default export */ var library_pencil = (pencil);

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/edit.js
/**
 * Internal dependencies
 */

/* harmony default export */ var edit = __webpack_exports__["a"] = (library_pencil);


/***/ }),

/***/ "BLeD":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["tokenList"]; }());

/***/ }),

/***/ "Bpkj":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const link = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M15.6 7.2H14v1.5h1.6c2 0 3.7 1.7 3.7 3.7s-1.7 3.7-3.7 3.7H14v1.5h1.6c2.8 0 5.2-2.3 5.2-5.2 0-2.9-2.3-5.2-5.2-5.2zM4.7 12.4c0-2 1.7-3.7 3.7-3.7H10V7.2H8.4c-2.9 0-5.2 2.3-5.2 5.2 0 2.9 2.3 5.2 5.2 5.2H10v-1.5H8.4c-2 0-3.7-1.7-3.7-3.7zm4.6.9h5.3v-1.5H9.3v1.5z"
}));
/* harmony default export */ __webpack_exports__["a"] = (link);


/***/ }),

/***/ "CNgt":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
exports.__esModule = true;
var React = __webpack_require__("cDcd");
var PropTypes = __webpack_require__("17x9");
var autosize = __webpack_require__("GemG");
var _getLineHeight = __webpack_require__("Rk8H");
var getLineHeight = _getLineHeight;
var RESIZED = "autosize:resized";
/**
 * A light replacement for built-in textarea component
 * which automaticaly adjusts its height to match the content
 */
var TextareaAutosizeClass = /** @class */ (function (_super) {
    __extends(TextareaAutosizeClass, _super);
    function TextareaAutosizeClass() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            lineHeight: null
        };
        _this.textarea = null;
        _this.onResize = function (e) {
            if (_this.props.onResize) {
                _this.props.onResize(e);
            }
        };
        _this.updateLineHeight = function () {
            if (_this.textarea) {
                _this.setState({
                    lineHeight: getLineHeight(_this.textarea)
                });
            }
        };
        _this.onChange = function (e) {
            var onChange = _this.props.onChange;
            _this.currentValue = e.currentTarget.value;
            onChange && onChange(e);
        };
        return _this;
    }
    TextareaAutosizeClass.prototype.componentDidMount = function () {
        var _this = this;
        var _a = this.props, maxRows = _a.maxRows, async = _a.async;
        if (typeof maxRows === "number") {
            this.updateLineHeight();
        }
        if (typeof maxRows === "number" || async) {
            /*
              the defer is needed to:
                - force "autosize" to activate the scrollbar when this.props.maxRows is passed
                - support StyledComponents (see #71)
            */
            setTimeout(function () { return _this.textarea && autosize(_this.textarea); });
        }
        else {
            this.textarea && autosize(this.textarea);
        }
        if (this.textarea) {
            this.textarea.addEventListener(RESIZED, this.onResize);
        }
    };
    TextareaAutosizeClass.prototype.componentWillUnmount = function () {
        if (this.textarea) {
            this.textarea.removeEventListener(RESIZED, this.onResize);
            autosize.destroy(this.textarea);
        }
    };
    TextareaAutosizeClass.prototype.render = function () {
        var _this = this;
        var _a = this, _b = _a.props, onResize = _b.onResize, maxRows = _b.maxRows, onChange = _b.onChange, style = _b.style, innerRef = _b.innerRef, children = _b.children, props = __rest(_b, ["onResize", "maxRows", "onChange", "style", "innerRef", "children"]), lineHeight = _a.state.lineHeight;
        var maxHeight = maxRows && lineHeight ? lineHeight * maxRows : null;
        return (React.createElement("textarea", __assign({}, props, { onChange: this.onChange, style: maxHeight ? __assign({}, style, { maxHeight: maxHeight }) : style, ref: function (element) {
                _this.textarea = element;
                if (typeof _this.props.innerRef === 'function') {
                    _this.props.innerRef(element);
                }
                else if (_this.props.innerRef) {
                    _this.props.innerRef.current = element;
                }
            } }), children));
    };
    TextareaAutosizeClass.prototype.componentDidUpdate = function () {
        this.textarea && autosize.update(this.textarea);
    };
    TextareaAutosizeClass.defaultProps = {
        rows: 1,
        async: false
    };
    TextareaAutosizeClass.propTypes = {
        rows: PropTypes.number,
        maxRows: PropTypes.number,
        onResize: PropTypes.func,
        innerRef: PropTypes.any,
        async: PropTypes.bool
    };
    return TextareaAutosizeClass;
}(React.Component));
exports.TextareaAutosize = React.forwardRef(function (props, ref) {
    return React.createElement(TextareaAutosizeClass, __assign({}, props, { innerRef: ref }));
});


/***/ }),

/***/ "Civd":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const layout = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M18 5.5H6a.5.5 0 00-.5.5v3h13V6a.5.5 0 00-.5-.5zm.5 5H10v8h8a.5.5 0 00.5-.5v-7.5zm-10 0h-3V18a.5.5 0 00.5.5h2.5v-8zM6 4h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V6a2 2 0 012-2z"
}));
/* harmony default export */ __webpack_exports__["a"] = (layout);


/***/ }),

/***/ "Crq9":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const formatStrikethrough = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M9.1 9v-.5c0-.6.2-1.1.7-1.4.5-.3 1.2-.5 2-.5.7 0 1.4.1 2.1.3.7.2 1.4.5 2.1.9l.2-1.9c-.6-.3-1.2-.5-1.9-.7-.8-.1-1.6-.2-2.4-.2-1.5 0-2.7.3-3.6 1-.8.7-1.2 1.5-1.2 2.6V9h2zM20 12H4v1h8.3c.3.1.6.2.8.3.5.2.9.5 1.1.8.3.3.4.7.4 1.2 0 .7-.2 1.1-.8 1.5-.5.3-1.2.5-2.1.5-.8 0-1.6-.1-2.4-.3-.8-.2-1.5-.5-2.2-.8L7 18.1c.5.2 1.2.4 2 .6.8.2 1.6.3 2.4.3 1.7 0 3-.3 3.9-1 .9-.7 1.3-1.6 1.3-2.8 0-.9-.2-1.7-.7-2.2H20v-1z"
}));
/* harmony default export */ __webpack_exports__["a"] = (formatStrikethrough);


/***/ }),

/***/ "GRId":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["element"]; }());

/***/ }),

/***/ "GemG":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	autosize 4.0.4
	license: MIT
	http://www.jacklmoore.com/autosize
*/
(function (global, factory) {
	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else { var mod; }
})(this, function (module, exports) {
	'use strict';

	var map = typeof Map === "function" ? new Map() : function () {
		var keys = [];
		var values = [];

		return {
			has: function has(key) {
				return keys.indexOf(key) > -1;
			},
			get: function get(key) {
				return values[keys.indexOf(key)];
			},
			set: function set(key, value) {
				if (keys.indexOf(key) === -1) {
					keys.push(key);
					values.push(value);
				}
			},
			delete: function _delete(key) {
				var index = keys.indexOf(key);
				if (index > -1) {
					keys.splice(index, 1);
					values.splice(index, 1);
				}
			}
		};
	}();

	var createEvent = function createEvent(name) {
		return new Event(name, { bubbles: true });
	};
	try {
		new Event('test');
	} catch (e) {
		// IE does not support `new Event()`
		createEvent = function createEvent(name) {
			var evt = document.createEvent('Event');
			evt.initEvent(name, true, false);
			return evt;
		};
	}

	function assign(ta) {
		if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || map.has(ta)) return;

		var heightOffset = null;
		var clientWidth = null;
		var cachedHeight = null;

		function init() {
			var style = window.getComputedStyle(ta, null);

			if (style.resize === 'vertical') {
				ta.style.resize = 'none';
			} else if (style.resize === 'both') {
				ta.style.resize = 'horizontal';
			}

			if (style.boxSizing === 'content-box') {
				heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
			} else {
				heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
			}
			// Fix when a textarea is not on document body and heightOffset is Not a Number
			if (isNaN(heightOffset)) {
				heightOffset = 0;
			}

			update();
		}

		function changeOverflow(value) {
			{
				// Chrome/Safari-specific fix:
				// When the textarea y-overflow is hidden, Chrome/Safari do not reflow the text to account for the space
				// made available by removing the scrollbar. The following forces the necessary text reflow.
				var width = ta.style.width;
				ta.style.width = '0px';
				// Force reflow:
				/* jshint ignore:start */
				ta.offsetWidth;
				/* jshint ignore:end */
				ta.style.width = width;
			}

			ta.style.overflowY = value;
		}

		function getParentOverflows(el) {
			var arr = [];

			while (el && el.parentNode && el.parentNode instanceof Element) {
				if (el.parentNode.scrollTop) {
					arr.push({
						node: el.parentNode,
						scrollTop: el.parentNode.scrollTop
					});
				}
				el = el.parentNode;
			}

			return arr;
		}

		function resize() {
			if (ta.scrollHeight === 0) {
				// If the scrollHeight is 0, then the element probably has display:none or is detached from the DOM.
				return;
			}

			var overflows = getParentOverflows(ta);
			var docTop = document.documentElement && document.documentElement.scrollTop; // Needed for Mobile IE (ticket #240)

			ta.style.height = '';
			ta.style.height = ta.scrollHeight + heightOffset + 'px';

			// used to check if an update is actually necessary on window.resize
			clientWidth = ta.clientWidth;

			// prevents scroll-position jumping
			overflows.forEach(function (el) {
				el.node.scrollTop = el.scrollTop;
			});

			if (docTop) {
				document.documentElement.scrollTop = docTop;
			}
		}

		function update() {
			resize();

			var styleHeight = Math.round(parseFloat(ta.style.height));
			var computed = window.getComputedStyle(ta, null);

			// Using offsetHeight as a replacement for computed.height in IE, because IE does not account use of border-box
			var actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(computed.height)) : ta.offsetHeight;

			// The actual height not matching the style height (set via the resize method) indicates that 
			// the max-height has been exceeded, in which case the overflow should be allowed.
			if (actualHeight < styleHeight) {
				if (computed.overflowY === 'hidden') {
					changeOverflow('scroll');
					resize();
					actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
				}
			} else {
				// Normally keep overflow set to hidden, to avoid flash of scrollbar as the textarea expands.
				if (computed.overflowY !== 'hidden') {
					changeOverflow('hidden');
					resize();
					actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
				}
			}

			if (cachedHeight !== actualHeight) {
				cachedHeight = actualHeight;
				var evt = createEvent('autosize:resized');
				try {
					ta.dispatchEvent(evt);
				} catch (err) {
					// Firefox will throw an error on dispatchEvent for a detached element
					// https://bugzilla.mozilla.org/show_bug.cgi?id=889376
				}
			}
		}

		var pageResize = function pageResize() {
			if (ta.clientWidth !== clientWidth) {
				update();
			}
		};

		var destroy = function (style) {
			window.removeEventListener('resize', pageResize, false);
			ta.removeEventListener('input', update, false);
			ta.removeEventListener('keyup', update, false);
			ta.removeEventListener('autosize:destroy', destroy, false);
			ta.removeEventListener('autosize:update', update, false);

			Object.keys(style).forEach(function (key) {
				ta.style[key] = style[key];
			});

			map.delete(ta);
		}.bind(ta, {
			height: ta.style.height,
			resize: ta.style.resize,
			overflowY: ta.style.overflowY,
			overflowX: ta.style.overflowX,
			wordWrap: ta.style.wordWrap
		});

		ta.addEventListener('autosize:destroy', destroy, false);

		// IE9 does not fire onpropertychange or oninput for deletions,
		// so binding to onkeyup to catch most of those events.
		// There is no way that I know of to detect something like 'cut' in IE9.
		if ('onpropertychange' in ta && 'oninput' in ta) {
			ta.addEventListener('keyup', update, false);
		}

		window.addEventListener('resize', pageResize, false);
		ta.addEventListener('input', update, false);
		ta.addEventListener('autosize:update', update, false);
		ta.style.overflowX = 'hidden';
		ta.style.wordWrap = 'break-word';

		map.set(ta, {
			destroy: destroy,
			update: update
		});

		init();
	}

	function destroy(ta) {
		var methods = map.get(ta);
		if (methods) {
			methods.destroy();
		}
	}

	function update(ta) {
		var methods = map.get(ta);
		if (methods) {
			methods.update();
		}
	}

	var autosize = null;

	// Do nothing in Node.js environment and IE8 (or lower)
	if (typeof window === 'undefined' || typeof window.getComputedStyle !== 'function') {
		autosize = function autosize(el) {
			return el;
		};
		autosize.destroy = function (el) {
			return el;
		};
		autosize.update = function (el) {
			return el;
		};
	} else {
		autosize = function autosize(el, options) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], function (x) {
					return assign(x, options);
				});
			}
			return el;
		};
		autosize.destroy = function (el) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], destroy);
			}
			return el;
		};
		autosize.update = function (el) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], update);
			}
			return el;
		};
	}

	exports.default = autosize;
	module.exports = exports['default'];
});

/***/ }),

/***/ "HSyU":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["blocks"]; }());

/***/ }),

/***/ "K9lf":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["compose"]; }());

/***/ }),

/***/ "Mmq9":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["url"]; }());

/***/ }),

/***/ "NMb1":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["deprecated"]; }());

/***/ }),

/***/ "NTP4":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const upload = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M18.5 15v3.5H13V6.7l4.5 4.1 1-1.1-6.2-5.8-5.8 5.8 1 1.1 4-4v11.7h-6V15H4v5h16v-5z"
}));
/* harmony default export */ __webpack_exports__["a"] = (upload);


/***/ }),

/***/ "NWDH":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const chevronDown = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M17.5 11.6L12 16l-5.5-4.4.9-1.2L12 14l4.5-3.6 1 1.2z"
}));
/* harmony default export */ __webpack_exports__["a"] = (chevronDown);


/***/ }),

/***/ "O6Fj":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var TextareaAutosize_1 = __webpack_require__("CNgt");
exports["default"] = TextareaAutosize_1.TextareaAutosize;


/***/ }),

/***/ "OzlF":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const listView = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M13.8 5.2H3v1.5h10.8V5.2zm-3.6 12v1.5H21v-1.5H10.2zm7.2-6H6.6v1.5h10.8v-1.5z"
}));
/* harmony default export */ __webpack_exports__["a"] = (listView);


/***/ }),

/***/ "P7XM":
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "PJYZ":
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "Q4Sy":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const plus = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M18 11.2h-5.2V6h-1.6v5.2H6v1.6h5.2V18h1.6v-5.2H18z"
}));
/* harmony default export */ __webpack_exports__["a"] = (plus);


/***/ }),

/***/ "RMJe":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const check = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M18.3 5.6L9.9 16.9l-4.6-3.4-.9 1.2 5.8 4.3 9.3-12.6z"
}));
/* harmony default export */ __webpack_exports__["a"] = (check);


/***/ }),

/***/ "Rk8H":
/***/ (function(module, exports, __webpack_require__) {

// Load in dependencies
var computedStyle = __webpack_require__("jTPX");

/**
 * Calculate the `line-height` of a given node
 * @param {HTMLElement} node Element to calculate line height of. Must be in the DOM.
 * @returns {Number} `line-height` of the element in pixels
 */
function lineHeight(node) {
  // Grab the line-height via style
  var lnHeightStr = computedStyle(node, 'line-height');
  var lnHeight = parseFloat(lnHeightStr, 10);

  // If the lineHeight did not contain a unit (i.e. it was numeric), convert it to ems (e.g. '2.3' === '2.3em')
  if (lnHeightStr === lnHeight + '') {
    // Save the old lineHeight style and update the em unit to the element
    var _lnHeightStyle = node.style.lineHeight;
    node.style.lineHeight = lnHeightStr + 'em';

    // Calculate the em based height
    lnHeightStr = computedStyle(node, 'line-height');
    lnHeight = parseFloat(lnHeightStr, 10);

    // Revert the lineHeight style
    if (_lnHeightStyle) {
      node.style.lineHeight = _lnHeightStyle;
    } else {
      delete node.style.lineHeight;
    }
  }

  // If the lineHeight is in `pt`, convert it to pixels (4px for 3pt)
  // DEV: `em` units are converted to `pt` in IE6
  // Conversion ratio from https://developer.mozilla.org/en-US/docs/Web/CSS/length
  if (lnHeightStr.indexOf('pt') !== -1) {
    lnHeight *= 4;
    lnHeight /= 3;
  // Otherwise, if the lineHeight is in `mm`, convert it to pixels (96px for 25.4mm)
  } else if (lnHeightStr.indexOf('mm') !== -1) {
    lnHeight *= 96;
    lnHeight /= 25.4;
  // Otherwise, if the lineHeight is in `cm`, convert it to pixels (96px for 2.54cm)
  } else if (lnHeightStr.indexOf('cm') !== -1) {
    lnHeight *= 96;
    lnHeight /= 2.54;
  // Otherwise, if the lineHeight is in `in`, convert it to pixels (96px for 1in)
  } else if (lnHeightStr.indexOf('in') !== -1) {
    lnHeight *= 96;
  // Otherwise, if the lineHeight is in `pc`, convert it to pixels (12pt for 1pc)
  } else if (lnHeightStr.indexOf('pc') !== -1) {
    lnHeight *= 16;
  }

  // Continue our computation
  lnHeight = Math.round(lnHeight);

  // If the line-height is "normal", calculate by font-size
  if (lnHeightStr === 'normal') {
    // Create a temporary node
    var nodeName = node.nodeName;
    var _node = document.createElement(nodeName);
    _node.innerHTML = '&nbsp;';

    // If we have a text area, reset it to only 1 row
    // https://github.com/twolfson/line-height/issues/4
    if (nodeName.toUpperCase() === 'TEXTAREA') {
      _node.setAttribute('rows', '1');
    }

    // Set the font-size of the element
    var fontSizeStr = computedStyle(node, 'font-size');
    _node.style.fontSize = fontSizeStr;

    // Remove default padding/border which can affect offset height
    // https://github.com/twolfson/line-height/issues/4
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight
    _node.style.padding = '0px';
    _node.style.border = '0px';

    // Append it to the body
    var body = document.body;
    body.appendChild(_node);

    // Assume the line height of the element is the height
    var height = _node.offsetHeight;
    lnHeight = height;

    // Remove our child from the DOM
    body.removeChild(_node);
  }

  // Return the calculated height
  return lnHeight;
}

// Export lineHeight
module.exports = lineHeight;


/***/ }),

/***/ "RxS6":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["keycodes"]; }());

/***/ }),

/***/ "SVSp":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["shortcode"]; }());

/***/ }),

/***/ "SksO":
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "TSYQ":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				if (arg.length) {
					var inner = classNames.apply(null, arg);
					if (inner) {
						classes.push(inner);
					}
				}
			} else if (argType === 'object') {
				if (arg.toString === Object.prototype.toString) {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				} else {
					classes.push(arg.toString());
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),

/***/ "Tqx9":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["primitives"]; }());

/***/ }),

/***/ "VKE3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const moreVertical = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M13 19h-2v-2h2v2zm0-6h-2v-2h2v2zm0-6h-2V5h2v2z"
}));
/* harmony default export */ __webpack_exports__["a"] = (moreVertical);


/***/ }),

/***/ "VbXa":
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__("SksO");

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  setPrototypeOf(subClass, superClass);
}

module.exports = _inheritsLoose;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "WbBG":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "XgzB":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const chevronUp = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M6.5 12.4L12 8l5.5 4.4-.9 1.2L12 10l-4.5 3.6-1-1.2z"
}));
/* harmony default export */ __webpack_exports__["a"] = (chevronUp);


/***/ }),

/***/ "YLtl":
/***/ (function(module, exports) {

(function() { module.exports = window["lodash"]; }());

/***/ }),

/***/ "ZO3Q":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(__webpack_require__("pVnL"));
var _objectWithoutPropertiesLoose = _interopDefault(__webpack_require__("8OQS"));
var React = __webpack_require__("cDcd");
var React__default = _interopDefault(React);
var _inheritsLoose = _interopDefault(__webpack_require__("VbXa"));
var _assertThisInitialized = _interopDefault(__webpack_require__("PJYZ"));

var is = {
  arr: Array.isArray,
  obj: function obj(a) {
    return Object.prototype.toString.call(a) === '[object Object]';
  },
  fun: function fun(a) {
    return typeof a === 'function';
  },
  str: function str(a) {
    return typeof a === 'string';
  },
  num: function num(a) {
    return typeof a === 'number';
  },
  und: function und(a) {
    return a === void 0;
  },
  nul: function nul(a) {
    return a === null;
  },
  set: function set(a) {
    return a instanceof Set;
  },
  map: function map(a) {
    return a instanceof Map;
  },
  equ: function equ(a, b) {
    if (typeof a !== typeof b) return false;
    if (is.str(a) || is.num(a)) return a === b;
    if (is.obj(a) && is.obj(b) && Object.keys(a).length + Object.keys(b).length === 0) return true;
    var i;

    for (i in a) {
      if (!(i in b)) return false;
    }

    for (i in b) {
      if (a[i] !== b[i]) return false;
    }

    return is.und(i) ? a === b : true;
  }
};
function merge(target, lowercase) {
  if (lowercase === void 0) {
    lowercase = true;
  }

  return function (object) {
    return (is.arr(object) ? object : Object.keys(object)).reduce(function (acc, element) {
      var key = lowercase ? element[0].toLowerCase() + element.substring(1) : element;
      acc[key] = target(key);
      return acc;
    }, target);
  };
}
function useForceUpdate() {
  var _useState = React.useState(false),
      f = _useState[1];

  var forceUpdate = React.useCallback(function () {
    return f(function (v) {
      return !v;
    });
  }, []);
  return forceUpdate;
}
function withDefault(value, defaultValue) {
  return is.und(value) || is.nul(value) ? defaultValue : value;
}
function toArray(a) {
  return !is.und(a) ? is.arr(a) ? a : [a] : [];
}
function callProp(obj) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return is.fun(obj) ? obj.apply(void 0, args) : obj;
}

function getForwardProps(props) {
  var to = props.to,
      from = props.from,
      config = props.config,
      onStart = props.onStart,
      onRest = props.onRest,
      onFrame = props.onFrame,
      children = props.children,
      reset = props.reset,
      reverse = props.reverse,
      force = props.force,
      immediate = props.immediate,
      delay = props.delay,
      attach = props.attach,
      destroyed = props.destroyed,
      interpolateTo = props.interpolateTo,
      ref = props.ref,
      lazy = props.lazy,
      forward = _objectWithoutPropertiesLoose(props, ["to", "from", "config", "onStart", "onRest", "onFrame", "children", "reset", "reverse", "force", "immediate", "delay", "attach", "destroyed", "interpolateTo", "ref", "lazy"]);

  return forward;
}

function interpolateTo(props) {
  var forward = getForwardProps(props);
  if (is.und(forward)) return _extends({
    to: forward
  }, props);
  var rest = Object.keys(props).reduce(function (a, k) {
    var _extends2;

    return !is.und(forward[k]) ? a : _extends({}, a, (_extends2 = {}, _extends2[k] = props[k], _extends2));
  }, {});
  return _extends({
    to: forward
  }, rest);
}
function handleRef(ref, forward) {
  if (forward) {
    // If it's a function, assume it's a ref callback
    if (is.fun(forward)) forward(ref);else if (is.obj(forward)) {
      forward.current = ref;
    }
  }

  return ref;
}

var Animated =
/*#__PURE__*/
function () {
  function Animated() {
    this.payload = void 0;
    this.children = [];
  }

  var _proto = Animated.prototype;

  _proto.getAnimatedValue = function getAnimatedValue() {
    return this.getValue();
  };

  _proto.getPayload = function getPayload() {
    return this.payload || this;
  };

  _proto.attach = function attach() {};

  _proto.detach = function detach() {};

  _proto.getChildren = function getChildren() {
    return this.children;
  };

  _proto.addChild = function addChild(child) {
    if (this.children.length === 0) this.attach();
    this.children.push(child);
  };

  _proto.removeChild = function removeChild(child) {
    var index = this.children.indexOf(child);
    this.children.splice(index, 1);
    if (this.children.length === 0) this.detach();
  };

  return Animated;
}();
var AnimatedArray =
/*#__PURE__*/
function (_Animated) {
  _inheritsLoose(AnimatedArray, _Animated);

  function AnimatedArray() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Animated.call.apply(_Animated, [this].concat(args)) || this;
    _this.payload = [];

    _this.attach = function () {
      return _this.payload.forEach(function (p) {
        return p instanceof Animated && p.addChild(_assertThisInitialized(_this));
      });
    };

    _this.detach = function () {
      return _this.payload.forEach(function (p) {
        return p instanceof Animated && p.removeChild(_assertThisInitialized(_this));
      });
    };

    return _this;
  }

  return AnimatedArray;
}(Animated);
var AnimatedObject =
/*#__PURE__*/
function (_Animated2) {
  _inheritsLoose(AnimatedObject, _Animated2);

  function AnimatedObject() {
    var _this2;

    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    _this2 = _Animated2.call.apply(_Animated2, [this].concat(args)) || this;
    _this2.payload = {};

    _this2.attach = function () {
      return Object.values(_this2.payload).forEach(function (s) {
        return s instanceof Animated && s.addChild(_assertThisInitialized(_this2));
      });
    };

    _this2.detach = function () {
      return Object.values(_this2.payload).forEach(function (s) {
        return s instanceof Animated && s.removeChild(_assertThisInitialized(_this2));
      });
    };

    return _this2;
  }

  var _proto2 = AnimatedObject.prototype;

  _proto2.getValue = function getValue(animated) {
    if (animated === void 0) {
      animated = false;
    }

    var payload = {};

    for (var _key4 in this.payload) {
      var value = this.payload[_key4];
      if (animated && !(value instanceof Animated)) continue;
      payload[_key4] = value instanceof Animated ? value[animated ? 'getAnimatedValue' : 'getValue']() : value;
    }

    return payload;
  };

  _proto2.getAnimatedValue = function getAnimatedValue() {
    return this.getValue(true);
  };

  return AnimatedObject;
}(Animated);

var applyAnimatedValues;
function injectApplyAnimatedValues(fn, transform) {
  applyAnimatedValues = {
    fn: fn,
    transform: transform
  };
}
var colorNames;
function injectColorNames(names) {
  colorNames = names;
}
var requestFrame = function requestFrame(cb) {
  return typeof window !== 'undefined' ? window.requestAnimationFrame(cb) : -1;
};
var cancelFrame = function cancelFrame(id) {
  typeof window !== 'undefined' && window.cancelAnimationFrame(id);
};
function injectFrame(raf, caf) {
  requestFrame = raf;
  cancelFrame = caf;
}
var interpolation;
function injectStringInterpolator(fn) {
  interpolation = fn;
}
var now = function now() {
  return Date.now();
};
function injectNow(nowFn) {
  now = nowFn;
}
var defaultElement;
function injectDefaultElement(el) {
  defaultElement = el;
}
var animatedApi = function animatedApi(node) {
  return node.current;
};
function injectAnimatedApi(fn) {
  animatedApi = fn;
}
var createAnimatedStyle;
function injectCreateAnimatedStyle(factory) {
  createAnimatedStyle = factory;
}
var manualFrameloop;
function injectManualFrameloop(callback) {
  manualFrameloop = callback;
}

var Globals = /*#__PURE__*/Object.freeze({
  get applyAnimatedValues () { return applyAnimatedValues; },
  injectApplyAnimatedValues: injectApplyAnimatedValues,
  get colorNames () { return colorNames; },
  injectColorNames: injectColorNames,
  get requestFrame () { return requestFrame; },
  get cancelFrame () { return cancelFrame; },
  injectFrame: injectFrame,
  get interpolation () { return interpolation; },
  injectStringInterpolator: injectStringInterpolator,
  get now () { return now; },
  injectNow: injectNow,
  get defaultElement () { return defaultElement; },
  injectDefaultElement: injectDefaultElement,
  get animatedApi () { return animatedApi; },
  injectAnimatedApi: injectAnimatedApi,
  get createAnimatedStyle () { return createAnimatedStyle; },
  injectCreateAnimatedStyle: injectCreateAnimatedStyle,
  get manualFrameloop () { return manualFrameloop; },
  injectManualFrameloop: injectManualFrameloop
});

/**
 * Wraps the `style` property with `AnimatedStyle`.
 */

var AnimatedProps =
/*#__PURE__*/
function (_AnimatedObject) {
  _inheritsLoose(AnimatedProps, _AnimatedObject);

  function AnimatedProps(props, callback) {
    var _this;

    _this = _AnimatedObject.call(this) || this;
    _this.update = void 0;
    _this.payload = !props.style ? props : _extends({}, props, {
      style: createAnimatedStyle(props.style)
    });
    _this.update = callback;

    _this.attach();

    return _this;
  }

  return AnimatedProps;
}(AnimatedObject);

var isFunctionComponent = function isFunctionComponent(val) {
  return is.fun(val) && !(val.prototype instanceof React__default.Component);
};

var createAnimatedComponent = function createAnimatedComponent(Component) {
  var AnimatedComponent = React.forwardRef(function (props, ref) {
    var forceUpdate = useForceUpdate();
    var mounted = React.useRef(true);
    var propsAnimated = React.useRef(null);
    var node = React.useRef(null);
    var attachProps = React.useCallback(function (props) {
      var oldPropsAnimated = propsAnimated.current;

      var callback = function callback() {
        var didUpdate = false;

        if (node.current) {
          didUpdate = applyAnimatedValues.fn(node.current, propsAnimated.current.getAnimatedValue());
        }

        if (!node.current || didUpdate === false) {
          // If no referenced node has been found, or the update target didn't have a
          // native-responder, then forceUpdate the animation ...
          forceUpdate();
        }
      };

      propsAnimated.current = new AnimatedProps(props, callback);
      oldPropsAnimated && oldPropsAnimated.detach();
    }, []);
    React.useEffect(function () {
      return function () {
        mounted.current = false;
        propsAnimated.current && propsAnimated.current.detach();
      };
    }, []);
    React.useImperativeHandle(ref, function () {
      return animatedApi(node, mounted, forceUpdate);
    });
    attachProps(props);

    var _getValue = propsAnimated.current.getValue(),
        scrollTop = _getValue.scrollTop,
        scrollLeft = _getValue.scrollLeft,
        animatedProps = _objectWithoutPropertiesLoose(_getValue, ["scrollTop", "scrollLeft"]); // Functions cannot have refs, see:
    // See: https://github.com/react-spring/react-spring/issues/569


    var refFn = isFunctionComponent(Component) ? undefined : function (childRef) {
      return node.current = handleRef(childRef, ref);
    };
    return React__default.createElement(Component, _extends({}, animatedProps, {
      ref: refFn
    }));
  });
  return AnimatedComponent;
};

var active = false;
var controllers = new Set();

var update = function update() {
  if (!active) return false;
  var time = now();

  for (var _iterator = controllers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var controller = _ref;
    var isActive = false;

    for (var configIdx = 0; configIdx < controller.configs.length; configIdx++) {
      var config = controller.configs[configIdx];
      var endOfAnimation = void 0,
          lastTime = void 0;

      for (var valIdx = 0; valIdx < config.animatedValues.length; valIdx++) {
        var animation = config.animatedValues[valIdx]; // If an animation is done, skip, until all of them conclude

        if (animation.done) continue;
        var from = config.fromValues[valIdx];
        var to = config.toValues[valIdx];
        var position = animation.lastPosition;
        var isAnimated = to instanceof Animated;
        var velocity = Array.isArray(config.initialVelocity) ? config.initialVelocity[valIdx] : config.initialVelocity;
        if (isAnimated) to = to.getValue(); // Conclude animation if it's either immediate, or from-values match end-state

        if (config.immediate) {
          animation.setValue(to);
          animation.done = true;
          continue;
        } // Break animation when string values are involved


        if (typeof from === 'string' || typeof to === 'string') {
          animation.setValue(to);
          animation.done = true;
          continue;
        }

        if (config.duration !== void 0) {
          /** Duration easing */
          position = from + config.easing((time - animation.startTime) / config.duration) * (to - from);
          endOfAnimation = time >= animation.startTime + config.duration;
        } else if (config.decay) {
          /** Decay easing */
          position = from + velocity / (1 - 0.998) * (1 - Math.exp(-(1 - 0.998) * (time - animation.startTime)));
          endOfAnimation = Math.abs(animation.lastPosition - position) < 0.1;
          if (endOfAnimation) to = position;
        } else {
          /** Spring easing */
          lastTime = animation.lastTime !== void 0 ? animation.lastTime : time;
          velocity = animation.lastVelocity !== void 0 ? animation.lastVelocity : config.initialVelocity; // If we lost a lot of frames just jump to the end.

          if (time > lastTime + 64) lastTime = time; // http://gafferongames.com/game-physics/fix-your-timestep/

          var numSteps = Math.floor(time - lastTime);

          for (var i = 0; i < numSteps; ++i) {
            var force = -config.tension * (position - to);
            var damping = -config.friction * velocity;
            var acceleration = (force + damping) / config.mass;
            velocity = velocity + acceleration * 1 / 1000;
            position = position + velocity * 1 / 1000;
          } // Conditions for stopping the spring animation


          var isOvershooting = config.clamp && config.tension !== 0 ? from < to ? position > to : position < to : false;
          var isVelocity = Math.abs(velocity) <= config.precision;
          var isDisplacement = config.tension !== 0 ? Math.abs(to - position) <= config.precision : true;
          endOfAnimation = isOvershooting || isVelocity && isDisplacement;
          animation.lastVelocity = velocity;
          animation.lastTime = time;
        } // Trails aren't done until their parents conclude


        if (isAnimated && !config.toValues[valIdx].done) endOfAnimation = false;

        if (endOfAnimation) {
          // Ensure that we end up with a round value
          if (animation.value !== to) position = to;
          animation.done = true;
        } else isActive = true;

        animation.setValue(position);
        animation.lastPosition = position;
      } // Keep track of updated values only when necessary


      if (controller.props.onFrame) controller.values[config.name] = config.interpolation.getValue();
    } // Update callbacks in the end of the frame


    if (controller.props.onFrame) controller.props.onFrame(controller.values); // Either call onEnd or next frame

    if (!isActive) {
      controllers.delete(controller);
      controller.stop(true);
    }
  } // Loop over as long as there are controllers ...


  if (controllers.size) {
    if (manualFrameloop) manualFrameloop();else requestFrame(update);
  } else {
    active = false;
  }

  return active;
};

var start = function start(controller) {
  if (!controllers.has(controller)) controllers.add(controller);

  if (!active) {
    active = true;
    if (manualFrameloop) requestFrame(manualFrameloop);else requestFrame(update);
  }
};

var stop = function stop(controller) {
  if (controllers.has(controller)) controllers.delete(controller);
};

function createInterpolator(range, output, extrapolate) {
  if (typeof range === 'function') {
    return range;
  }

  if (Array.isArray(range)) {
    return createInterpolator({
      range: range,
      output: output,
      extrapolate: extrapolate
    });
  }

  if (interpolation && typeof range.output[0] === 'string') {
    return interpolation(range);
  }

  var config = range;
  var outputRange = config.output;
  var inputRange = config.range || [0, 1];
  var extrapolateLeft = config.extrapolateLeft || config.extrapolate || 'extend';
  var extrapolateRight = config.extrapolateRight || config.extrapolate || 'extend';

  var easing = config.easing || function (t) {
    return t;
  };

  return function (input) {
    var range = findRange(input, inputRange);
    return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight, config.map);
  };
}

function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
  var result = map ? map(input) : input; // Extrapolate

  if (result < inputMin) {
    if (extrapolateLeft === 'identity') return result;else if (extrapolateLeft === 'clamp') result = inputMin;
  }

  if (result > inputMax) {
    if (extrapolateRight === 'identity') return result;else if (extrapolateRight === 'clamp') result = inputMax;
  }

  if (outputMin === outputMax) return outputMin;
  if (inputMin === inputMax) return input <= inputMin ? outputMin : outputMax; // Input Range

  if (inputMin === -Infinity) result = -result;else if (inputMax === Infinity) result = result - inputMin;else result = (result - inputMin) / (inputMax - inputMin); // Easing

  result = easing(result); // Output Range

  if (outputMin === -Infinity) result = -result;else if (outputMax === Infinity) result = result + outputMin;else result = result * (outputMax - outputMin) + outputMin;
  return result;
}

function findRange(input, inputRange) {
  for (var i = 1; i < inputRange.length - 1; ++i) {
    if (inputRange[i] >= input) break;
  }

  return i - 1;
}

var AnimatedInterpolation =
/*#__PURE__*/
function (_AnimatedArray) {
  _inheritsLoose(AnimatedInterpolation, _AnimatedArray);

  function AnimatedInterpolation(parents, range, output, extrapolate) {
    var _this;

    _this = _AnimatedArray.call(this) || this;
    _this.calc = void 0;
    _this.payload = parents instanceof AnimatedArray && !(parents instanceof AnimatedInterpolation) ? parents.getPayload() : Array.isArray(parents) ? parents : [parents];
    _this.calc = createInterpolator(range, output, extrapolate);
    return _this;
  }

  var _proto = AnimatedInterpolation.prototype;

  _proto.getValue = function getValue() {
    return this.calc.apply(this, this.payload.map(function (value) {
      return value.getValue();
    }));
  };

  _proto.updateConfig = function updateConfig(range, output, extrapolate) {
    this.calc = createInterpolator(range, output, extrapolate);
  };

  _proto.interpolate = function interpolate(range, output, extrapolate) {
    return new AnimatedInterpolation(this, range, output, extrapolate);
  };

  return AnimatedInterpolation;
}(AnimatedArray);

var interpolate$1 = function interpolate(parents, range, output) {
  return parents && new AnimatedInterpolation(parents, range, output);
};

var config = {
  default: {
    tension: 170,
    friction: 26
  },
  gentle: {
    tension: 120,
    friction: 14
  },
  wobbly: {
    tension: 180,
    friction: 12
  },
  stiff: {
    tension: 210,
    friction: 20
  },
  slow: {
    tension: 280,
    friction: 60
  },
  molasses: {
    tension: 280,
    friction: 120
  }
};

/** API
 *  useChain(references, timeSteps, timeFrame)
 */

function useChain(refs, timeSteps, timeFrame) {
  if (timeFrame === void 0) {
    timeFrame = 1000;
  }

  var previous = React.useRef();
  React.useEffect(function () {
    if (is.equ(refs, previous.current)) refs.forEach(function (_ref) {
      var current = _ref.current;
      return current && current.start();
    });else if (timeSteps) {
      refs.forEach(function (_ref2, index) {
        var current = _ref2.current;

        if (current) {
          var ctrls = current.controllers;

          if (ctrls.length) {
            var t = timeFrame * timeSteps[index];
            ctrls.forEach(function (ctrl) {
              ctrl.queue = ctrl.queue.map(function (e) {
                return _extends({}, e, {
                  delay: e.delay + t
                });
              });
              ctrl.start();
            });
          }
        }
      });
    } else refs.reduce(function (q, _ref3, rI) {
      var current = _ref3.current;
      return q = q.then(function () {
        return current.start();
      });
    }, Promise.resolve());
    previous.current = refs;
  });
}

/**
 * Animated works by building a directed acyclic graph of dependencies
 * transparently when you render your Animated components.
 *
 *               new Animated.Value(0)
 *     .interpolate()        .interpolate()    new Animated.Value(1)
 *         opacity               translateY      scale
 *          style                         transform
 *         View#234                         style
 *                                         View#123
 *
 * A) Top Down phase
 * When an AnimatedValue is updated, we recursively go down through this
 * graph in order to find leaf nodes: the views that we flag as needing
 * an update.
 *
 * B) Bottom Up phase
 * When a view is flagged as needing an update, we recursively go back up
 * in order to build the new value that it needs. The reason why we need
 * this two-phases process is to deal with composite props such as
 * transform which can receive values from multiple parents.
 */
function addAnimatedStyles(node, styles) {
  if ('update' in node) {
    styles.add(node);
  } else {
    node.getChildren().forEach(function (child) {
      return addAnimatedStyles(child, styles);
    });
  }
}

var AnimatedValue =
/*#__PURE__*/
function (_Animated) {
  _inheritsLoose(AnimatedValue, _Animated);

  function AnimatedValue(_value) {
    var _this;

    _this = _Animated.call(this) || this;
    _this.animatedStyles = new Set();
    _this.value = void 0;
    _this.startPosition = void 0;
    _this.lastPosition = void 0;
    _this.lastVelocity = void 0;
    _this.startTime = void 0;
    _this.lastTime = void 0;
    _this.done = false;

    _this.setValue = function (value, flush) {
      if (flush === void 0) {
        flush = true;
      }

      _this.value = value;
      if (flush) _this.flush();
    };

    _this.value = _value;
    _this.startPosition = _value;
    _this.lastPosition = _value;
    return _this;
  }

  var _proto = AnimatedValue.prototype;

  _proto.flush = function flush() {
    if (this.animatedStyles.size === 0) {
      addAnimatedStyles(this, this.animatedStyles);
    }

    this.animatedStyles.forEach(function (animatedStyle) {
      return animatedStyle.update();
    });
  };

  _proto.clearStyles = function clearStyles() {
    this.animatedStyles.clear();
  };

  _proto.getValue = function getValue() {
    return this.value;
  };

  _proto.interpolate = function interpolate(range, output, extrapolate) {
    return new AnimatedInterpolation(this, range, output, extrapolate);
  };

  return AnimatedValue;
}(Animated);

var AnimatedValueArray =
/*#__PURE__*/
function (_AnimatedArray) {
  _inheritsLoose(AnimatedValueArray, _AnimatedArray);

  function AnimatedValueArray(values) {
    var _this;

    _this = _AnimatedArray.call(this) || this;
    _this.payload = values.map(function (n) {
      return new AnimatedValue(n);
    });
    return _this;
  }

  var _proto = AnimatedValueArray.prototype;

  _proto.setValue = function setValue(value, flush) {
    var _this2 = this;

    if (flush === void 0) {
      flush = true;
    }

    if (Array.isArray(value)) {
      if (value.length === this.payload.length) {
        value.forEach(function (v, i) {
          return _this2.payload[i].setValue(v, flush);
        });
      }
    } else {
      this.payload.forEach(function (p) {
        return p.setValue(value, flush);
      });
    }
  };

  _proto.getValue = function getValue() {
    return this.payload.map(function (v) {
      return v.getValue();
    });
  };

  _proto.interpolate = function interpolate(range, output) {
    return new AnimatedInterpolation(this, range, output);
  };

  return AnimatedValueArray;
}(AnimatedArray);

var G = 0;

var Controller =
/*#__PURE__*/
function () {
  function Controller() {
    var _this = this;

    this.id = void 0;
    this.idle = true;
    this.hasChanged = false;
    this.guid = 0;
    this.local = 0;
    this.props = {};
    this.merged = {};
    this.animations = {};
    this.interpolations = {};
    this.values = {};
    this.configs = [];
    this.listeners = [];
    this.queue = [];
    this.localQueue = void 0;

    this.getValues = function () {
      return _this.interpolations;
    };

    this.id = G++;
  }
  /** update(props)
   *  This function filters input props and creates an array of tasks which are executed in .start()
   *  Each task is allowed to carry a delay, which means it can execute asnychroneously */


  var _proto = Controller.prototype;

  _proto.update = function update$$1(args) {
    //this._id = n + this.id
    if (!args) return this; // Extract delay and the to-prop from props

    var _ref = interpolateTo(args),
        _ref$delay = _ref.delay,
        delay = _ref$delay === void 0 ? 0 : _ref$delay,
        to = _ref.to,
        props = _objectWithoutPropertiesLoose(_ref, ["delay", "to"]);

    if (is.arr(to) || is.fun(to)) {
      // If config is either a function or an array queue it up as is
      this.queue.push(_extends({}, props, {
        delay: delay,
        to: to
      }));
    } else if (to) {
      // Otherwise go through each key since it could be delayed individually
      var ops = {};
      Object.entries(to).forEach(function (_ref2) {
        var _to;

        var k = _ref2[0],
            v = _ref2[1];

        // Fetch delay and create an entry, consisting of the to-props, the delay, and basic props
        var entry = _extends({
          to: (_to = {}, _to[k] = v, _to),
          delay: callProp(delay, k)
        }, props);

        var previous = ops[entry.delay] && ops[entry.delay].to;
        ops[entry.delay] = _extends({}, ops[entry.delay], entry, {
          to: _extends({}, previous, entry.to)
        });
      });
      this.queue = Object.values(ops);
    } // Sort queue, so that async calls go last


    this.queue = this.queue.sort(function (a, b) {
      return a.delay - b.delay;
    }); // Diff the reduced props immediately (they'll contain the from-prop and some config)

    this.diff(props);
    return this;
  }
  /** start(onEnd)
   *  This function either executes a queue, if present, or starts the frameloop, which animates */
  ;

  _proto.start = function start$$1(onEnd) {
    var _this2 = this;

    // If a queue is present we must excecute it
    if (this.queue.length) {
      this.idle = false; // Updates can interrupt trailing queues, in that case we just merge values

      if (this.localQueue) {
        this.localQueue.forEach(function (_ref3) {
          var _ref3$from = _ref3.from,
              from = _ref3$from === void 0 ? {} : _ref3$from,
              _ref3$to = _ref3.to,
              to = _ref3$to === void 0 ? {} : _ref3$to;
          if (is.obj(from)) _this2.merged = _extends({}, from, _this2.merged);
          if (is.obj(to)) _this2.merged = _extends({}, _this2.merged, to);
        });
      } // The guid helps us tracking frames, a new queue over an old one means an override
      // We discard async calls in that caseÍ


      var local = this.local = ++this.guid;
      var queue = this.localQueue = this.queue;
      this.queue = []; // Go through each entry and execute it

      queue.forEach(function (_ref4, index) {
        var delay = _ref4.delay,
            props = _objectWithoutPropertiesLoose(_ref4, ["delay"]);

        var cb = function cb(finished) {
          if (index === queue.length - 1 && local === _this2.guid && finished) {
            _this2.idle = true;
            if (_this2.props.onRest) _this2.props.onRest(_this2.merged);
          }

          if (onEnd) onEnd();
        }; // Entries can be delayed, ansyc or immediate


        var async = is.arr(props.to) || is.fun(props.to);

        if (delay) {
          setTimeout(function () {
            if (local === _this2.guid) {
              if (async) _this2.runAsync(props, cb);else _this2.diff(props).start(cb);
            }
          }, delay);
        } else if (async) _this2.runAsync(props, cb);else _this2.diff(props).start(cb);
      });
    } // Otherwise we kick of the frameloop
    else {
        if (is.fun(onEnd)) this.listeners.push(onEnd);
        if (this.props.onStart) this.props.onStart();

        start(this);
      }

    return this;
  };

  _proto.stop = function stop$$1(finished) {
    this.listeners.forEach(function (onEnd) {
      return onEnd(finished);
    });
    this.listeners = [];
    return this;
  }
  /** Pause sets onEnd listeners free, but also removes the controller from the frameloop */
  ;

  _proto.pause = function pause(finished) {
    this.stop(true);
    if (finished) stop(this);
    return this;
  };

  _proto.runAsync = function runAsync(_ref5, onEnd) {
    var _this3 = this;

    var delay = _ref5.delay,
        props = _objectWithoutPropertiesLoose(_ref5, ["delay"]);

    var local = this.local; // If "to" is either a function or an array it will be processed async, therefor "to" should be empty right now
    // If the view relies on certain values "from" has to be present

    var queue = Promise.resolve(undefined);

    if (is.arr(props.to)) {
      var _loop = function _loop(i) {
        var index = i;

        var fresh = _extends({}, props, interpolateTo(props.to[index]));

        if (is.arr(fresh.config)) fresh.config = fresh.config[index];
        queue = queue.then(function () {
          //this.stop()
          if (local === _this3.guid) return new Promise(function (r) {
            return _this3.diff(fresh).start(r);
          });
        });
      };

      for (var i = 0; i < props.to.length; i++) {
        _loop(i);
      }
    } else if (is.fun(props.to)) {
      var index = 0;
      var last;
      queue = queue.then(function () {
        return props.to( // next(props)
        function (p) {
          var fresh = _extends({}, props, interpolateTo(p));

          if (is.arr(fresh.config)) fresh.config = fresh.config[index];
          index++; //this.stop()

          if (local === _this3.guid) return last = new Promise(function (r) {
            return _this3.diff(fresh).start(r);
          });
          return;
        }, // cancel()
        function (finished) {
          if (finished === void 0) {
            finished = true;
          }

          return _this3.stop(finished);
        }).then(function () {
          return last;
        });
      });
    }

    queue.then(onEnd);
  };

  _proto.diff = function diff(props) {
    var _this4 = this;

    this.props = _extends({}, this.props, props);
    var _this$props = this.props,
        _this$props$from = _this$props.from,
        from = _this$props$from === void 0 ? {} : _this$props$from,
        _this$props$to = _this$props.to,
        to = _this$props$to === void 0 ? {} : _this$props$to,
        _this$props$config = _this$props.config,
        config = _this$props$config === void 0 ? {} : _this$props$config,
        reverse = _this$props.reverse,
        attach = _this$props.attach,
        reset = _this$props.reset,
        immediate = _this$props.immediate; // Reverse values when requested

    if (reverse) {
      var _ref6 = [to, from];
      from = _ref6[0];
      to = _ref6[1];
    } // This will collect all props that were ever set, reset merged props when necessary


    this.merged = _extends({}, from, this.merged, to);
    this.hasChanged = false; // Attachment handling, trailed springs can "attach" themselves to a previous spring

    var target = attach && attach(this); // Reduces input { name: value } pairs into animated values

    this.animations = Object.entries(this.merged).reduce(function (acc, _ref7) {
      var name = _ref7[0],
          value = _ref7[1];
      // Issue cached entries, except on reset
      var entry = acc[name] || {}; // Figure out what the value is supposed to be

      var isNumber = is.num(value);
      var isString = is.str(value) && !value.startsWith('#') && !/\d/.test(value) && !colorNames[value];
      var isArray = is.arr(value);
      var isInterpolation = !isNumber && !isArray && !isString;
      var fromValue = !is.und(from[name]) ? from[name] : value;
      var toValue = isNumber || isArray ? value : isString ? value : 1;
      var toConfig = callProp(config, name);
      if (target) toValue = target.animations[name].parent;
      var parent = entry.parent,
          interpolation$$1 = entry.interpolation,
          toValues = toArray(target ? toValue.getPayload() : toValue),
          animatedValues;
      var newValue = value;
      if (isInterpolation) newValue = interpolation({
        range: [0, 1],
        output: [value, value]
      })(1);
      var currentValue = interpolation$$1 && interpolation$$1.getValue(); // Change detection flags

      var isFirst = is.und(parent);
      var isActive = !isFirst && entry.animatedValues.some(function (v) {
        return !v.done;
      });
      var currentValueDiffersFromGoal = !is.equ(newValue, currentValue);
      var hasNewGoal = !is.equ(newValue, entry.previous);
      var hasNewConfig = !is.equ(toConfig, entry.config); // Change animation props when props indicate a new goal (new value differs from previous one)
      // and current values differ from it. Config changes trigger a new update as well (though probably shouldn't?)

      if (reset || hasNewGoal && currentValueDiffersFromGoal || hasNewConfig) {
        var _extends2;

        // Convert regular values into animated values, ALWAYS re-use if possible
        if (isNumber || isString) parent = interpolation$$1 = entry.parent || new AnimatedValue(fromValue);else if (isArray) parent = interpolation$$1 = entry.parent || new AnimatedValueArray(fromValue);else if (isInterpolation) {
          var prev = entry.interpolation && entry.interpolation.calc(entry.parent.value);
          prev = prev !== void 0 && !reset ? prev : fromValue;

          if (entry.parent) {
            parent = entry.parent;
            parent.setValue(0, false);
          } else parent = new AnimatedValue(0);

          var range = {
            output: [prev, value]
          };

          if (entry.interpolation) {
            interpolation$$1 = entry.interpolation;
            entry.interpolation.updateConfig(range);
          } else interpolation$$1 = parent.interpolate(range);
        }
        toValues = toArray(target ? toValue.getPayload() : toValue);
        animatedValues = toArray(parent.getPayload());
        if (reset && !isInterpolation) parent.setValue(fromValue, false);
        _this4.hasChanged = true; // Reset animated values

        animatedValues.forEach(function (value) {
          value.startPosition = value.value;
          value.lastPosition = value.value;
          value.lastVelocity = isActive ? value.lastVelocity : undefined;
          value.lastTime = isActive ? value.lastTime : undefined;
          value.startTime = now();
          value.done = false;
          value.animatedStyles.clear();
        }); // Set immediate values

        if (callProp(immediate, name)) {
          parent.setValue(isInterpolation ? toValue : value, false);
        }

        return _extends({}, acc, (_extends2 = {}, _extends2[name] = _extends({}, entry, {
          name: name,
          parent: parent,
          interpolation: interpolation$$1,
          animatedValues: animatedValues,
          toValues: toValues,
          previous: newValue,
          config: toConfig,
          fromValues: toArray(parent.getValue()),
          immediate: callProp(immediate, name),
          initialVelocity: withDefault(toConfig.velocity, 0),
          clamp: withDefault(toConfig.clamp, false),
          precision: withDefault(toConfig.precision, 0.01),
          tension: withDefault(toConfig.tension, 170),
          friction: withDefault(toConfig.friction, 26),
          mass: withDefault(toConfig.mass, 1),
          duration: toConfig.duration,
          easing: withDefault(toConfig.easing, function (t) {
            return t;
          }),
          decay: toConfig.decay
        }), _extends2));
      } else {
        if (!currentValueDiffersFromGoal) {
          var _extends3;

          // So ... the current target value (newValue) appears to be different from the previous value,
          // which normally constitutes an update, but the actual value (currentValue) matches the target!
          // In order to resolve this without causing an animation update we silently flag the animation as done,
          // which it technically is. Interpolations also needs a config update with their target set to 1.
          if (isInterpolation) {
            parent.setValue(1, false);
            interpolation$$1.updateConfig({
              output: [newValue, newValue]
            });
          }

          parent.done = true;
          _this4.hasChanged = true;
          return _extends({}, acc, (_extends3 = {}, _extends3[name] = _extends({}, acc[name], {
            previous: newValue
          }), _extends3));
        }

        return acc;
      }
    }, this.animations);

    if (this.hasChanged) {
      // Make animations available to frameloop
      this.configs = Object.values(this.animations);
      this.values = {};
      this.interpolations = {};

      for (var key in this.animations) {
        this.interpolations[key] = this.animations[key].interpolation;
        this.values[key] = this.animations[key].interpolation.getValue();
      }
    }

    return this;
  };

  _proto.destroy = function destroy() {
    this.stop();
    this.props = {};
    this.merged = {};
    this.animations = {};
    this.interpolations = {};
    this.values = {};
    this.configs = [];
    this.local = 0;
  };

  return Controller;
}();

/** API
 * const props = useSprings(number, [{ ... }, { ... }, ...])
 * const [props, set] = useSprings(number, (i, controller) => ({ ... }))
 */

var useSprings = function useSprings(length, props) {
  var mounted = React.useRef(false);
  var ctrl = React.useRef();
  var isFn = is.fun(props); // The controller maintains the animation values, starts and stops animations

  var _useMemo = React.useMemo(function () {
    // Remove old controllers
    if (ctrl.current) {
      ctrl.current.map(function (c) {
        return c.destroy();
      });
      ctrl.current = undefined;
    }

    var ref;
    return [new Array(length).fill().map(function (_, i) {
      var ctrl = new Controller();
      var newProps = isFn ? callProp(props, i, ctrl) : props[i];
      if (i === 0) ref = newProps.ref;
      ctrl.update(newProps);
      if (!ref) ctrl.start();
      return ctrl;
    }), ref];
  }, [length]),
      controllers = _useMemo[0],
      ref = _useMemo[1];

  ctrl.current = controllers; // The hooks reference api gets defined here ...

  var api = React.useImperativeHandle(ref, function () {
    return {
      start: function start() {
        return Promise.all(ctrl.current.map(function (c) {
          return new Promise(function (r) {
            return c.start(r);
          });
        }));
      },
      stop: function stop(finished) {
        return ctrl.current.forEach(function (c) {
          return c.stop(finished);
        });
      },

      get controllers() {
        return ctrl.current;
      }

    };
  }); // This function updates the controllers

  var updateCtrl = React.useMemo(function () {
    return function (updateProps) {
      return ctrl.current.map(function (c, i) {
        c.update(isFn ? callProp(updateProps, i, c) : updateProps[i]);
        if (!ref) c.start();
      });
    };
  }, [length]); // Update controller if props aren't functional

  React.useEffect(function () {
    if (mounted.current) {
      if (!isFn) updateCtrl(props);
    } else if (!ref) ctrl.current.forEach(function (c) {
      return c.start();
    });
  }); // Update mounted flag and destroy controller on unmount

  React.useEffect(function () {
    return mounted.current = true, function () {
      return ctrl.current.forEach(function (c) {
        return c.destroy();
      });
    };
  }, []); // Return animated props, or, anim-props + the update-setter above

  var propValues = ctrl.current.map(function (c) {
    return c.getValues();
  });
  return isFn ? [propValues, updateCtrl, function (finished) {
    return ctrl.current.forEach(function (c) {
      return c.pause(finished);
    });
  }] : propValues;
};

/** API
 * const props = useSpring({ ... })
 * const [props, set] = useSpring(() => ({ ... }))
 */

var useSpring = function useSpring(props) {
  var isFn = is.fun(props);

  var _useSprings = useSprings(1, isFn ? props : [props]),
      result = _useSprings[0],
      set = _useSprings[1],
      pause = _useSprings[2];

  return isFn ? [result[0], set, pause] : result;
};

/** API
 * const trails = useTrail(number, { ... })
 * const [trails, set] = useTrail(number, () => ({ ... }))
 */

var useTrail = function useTrail(length, props) {
  var mounted = React.useRef(false);
  var isFn = is.fun(props);
  var updateProps = callProp(props);
  var instances = React.useRef();

  var _useSprings = useSprings(length, function (i, ctrl) {
    if (i === 0) instances.current = [];
    instances.current.push(ctrl);
    return _extends({}, updateProps, {
      config: callProp(updateProps.config, i),
      attach: i > 0 && function () {
        return instances.current[i - 1];
      }
    });
  }),
      result = _useSprings[0],
      set = _useSprings[1],
      pause = _useSprings[2]; // Set up function to update controller


  var updateCtrl = React.useMemo(function () {
    return function (props) {
      return set(function (i, ctrl) {
        var last = props.reverse ? i === 0 : length - 1 === i;
        var attachIdx = props.reverse ? i + 1 : i - 1;
        var attachController = instances.current[attachIdx];
        return _extends({}, props, {
          config: callProp(props.config || updateProps.config, i),
          attach: attachController && function () {
            return attachController;
          }
        });
      });
    };
  }, [length, updateProps.reverse]); // Update controller if props aren't functional

  React.useEffect(function () {
    return void (mounted.current && !isFn && updateCtrl(props));
  }); // Update mounted flag and destroy controller on unmount

  React.useEffect(function () {
    return void (mounted.current = true);
  }, []);
  return isFn ? [result, updateCtrl, pause] : result;
};

/** API
 * const transitions = useTransition(items, itemKeys, { ... })
 * const [transitions, update] = useTransition(items, itemKeys, () => ({ ... }))
 */

var guid = 0;
var ENTER = 'enter';
var LEAVE = 'leave';
var UPDATE = 'update';

var mapKeys = function mapKeys(items, keys) {
  return (typeof keys === 'function' ? items.map(keys) : toArray(keys)).map(String);
};

var get = function get(props) {
  var items = props.items,
      _props$keys = props.keys,
      keys = _props$keys === void 0 ? function (item) {
    return item;
  } : _props$keys,
      rest = _objectWithoutPropertiesLoose(props, ["items", "keys"]);

  items = toArray(items !== void 0 ? items : null);
  return _extends({
    items: items,
    keys: mapKeys(items, keys)
  }, rest);
};

function useTransition(input, keyTransform, config) {
  var props = _extends({
    items: input,
    keys: keyTransform || function (i) {
      return i;
    }
  }, config);

  var _get = get(props),
      _get$lazy = _get.lazy,
      lazy = _get$lazy === void 0 ? false : _get$lazy,
      _get$unique = _get.unique,
      _get$reset = _get.reset,
      reset = _get$reset === void 0 ? false : _get$reset,
      enter = _get.enter,
      leave = _get.leave,
      update = _get.update,
      onDestroyed = _get.onDestroyed,
      keys = _get.keys,
      items = _get.items,
      onFrame = _get.onFrame,
      _onRest = _get.onRest,
      onStart = _get.onStart,
      ref = _get.ref,
      extra = _objectWithoutPropertiesLoose(_get, ["lazy", "unique", "reset", "enter", "leave", "update", "onDestroyed", "keys", "items", "onFrame", "onRest", "onStart", "ref"]);

  var forceUpdate = useForceUpdate();
  var mounted = React.useRef(false);
  var state = React.useRef({
    mounted: false,
    first: true,
    deleted: [],
    current: {},
    transitions: [],
    prevProps: {},
    paused: !!props.ref,
    instances: !mounted.current && new Map(),
    forceUpdate: forceUpdate
  });
  React.useImperativeHandle(props.ref, function () {
    return {
      start: function start() {
        return Promise.all(Array.from(state.current.instances).map(function (_ref) {
          var c = _ref[1];
          return new Promise(function (r) {
            return c.start(r);
          });
        }));
      },
      stop: function stop(finished) {
        return Array.from(state.current.instances).forEach(function (_ref2) {
          var c = _ref2[1];
          return c.stop(finished);
        });
      },

      get controllers() {
        return Array.from(state.current.instances).map(function (_ref3) {
          var c = _ref3[1];
          return c;
        });
      }

    };
  }); // Update state

  state.current = diffItems(state.current, props);

  if (state.current.changed) {
    // Update state
    state.current.transitions.forEach(function (transition) {
      var slot = transition.slot,
          from = transition.from,
          to = transition.to,
          config = transition.config,
          trail = transition.trail,
          key = transition.key,
          item = transition.item;
      if (!state.current.instances.has(key)) state.current.instances.set(key, new Controller()); // update the map object

      var ctrl = state.current.instances.get(key);

      var newProps = _extends({}, extra, {
        to: to,
        from: from,
        config: config,
        ref: ref,
        onRest: function onRest(values) {
          if (state.current.mounted) {
            if (transition.destroyed) {
              // If no ref is given delete destroyed items immediately
              if (!ref && !lazy) cleanUp(state, key);
              if (onDestroyed) onDestroyed(item);
            } // A transition comes to rest once all its springs conclude


            var curInstances = Array.from(state.current.instances);
            var active = curInstances.some(function (_ref4) {
              var c = _ref4[1];
              return !c.idle;
            });
            if (!active && (ref || lazy) && state.current.deleted.length > 0) cleanUp(state);
            if (_onRest) _onRest(item, slot, values);
          }
        },
        onStart: onStart && function () {
          return onStart(item, slot);
        },
        onFrame: onFrame && function (values) {
          return onFrame(item, slot, values);
        },
        delay: trail,
        reset: reset && slot === ENTER // Update controller

      });

      ctrl.update(newProps);
      if (!state.current.paused) ctrl.start();
    });
  }

  React.useEffect(function () {
    state.current.mounted = mounted.current = true;
    return function () {
      state.current.mounted = mounted.current = false;
      Array.from(state.current.instances).map(function (_ref5) {
        var c = _ref5[1];
        return c.destroy();
      });
      state.current.instances.clear();
    };
  }, []);
  return state.current.transitions.map(function (_ref6) {
    var item = _ref6.item,
        slot = _ref6.slot,
        key = _ref6.key;
    return {
      item: item,
      key: key,
      state: slot,
      props: state.current.instances.get(key).getValues()
    };
  });
}

function cleanUp(state, filterKey) {
  var deleted = state.current.deleted;

  var _loop = function _loop() {
    if (_isArray) {
      if (_i >= _iterator.length) return "break";
      _ref8 = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) return "break";
      _ref8 = _i.value;
    }

    var _ref7 = _ref8;
    var key = _ref7.key;

    var filter = function filter(t) {
      return t.key !== key;
    };

    if (is.und(filterKey) || filterKey === key) {
      state.current.instances.delete(key);
      state.current.transitions = state.current.transitions.filter(filter);
      state.current.deleted = state.current.deleted.filter(filter);
    }
  };

  for (var _iterator = deleted, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref8;

    var _ret = _loop();

    if (_ret === "break") break;
  }

  state.current.forceUpdate();
}

function diffItems(_ref9, props) {
  var first = _ref9.first,
      prevProps = _ref9.prevProps,
      state = _objectWithoutPropertiesLoose(_ref9, ["first", "prevProps"]);

  var _get2 = get(props),
      items = _get2.items,
      keys = _get2.keys,
      initial = _get2.initial,
      from = _get2.from,
      enter = _get2.enter,
      leave = _get2.leave,
      update = _get2.update,
      _get2$trail = _get2.trail,
      trail = _get2$trail === void 0 ? 0 : _get2$trail,
      unique = _get2.unique,
      config = _get2.config,
      _get2$order = _get2.order,
      order = _get2$order === void 0 ? [ENTER, LEAVE, UPDATE] : _get2$order;

  var _get3 = get(prevProps),
      _keys = _get3.keys,
      _items = _get3.items;

  var current = _extends({}, state.current);

  var deleted = [].concat(state.deleted); // Compare next keys with current keys

  var currentKeys = Object.keys(current);
  var currentSet = new Set(currentKeys);
  var nextSet = new Set(keys);
  var added = keys.filter(function (item) {
    return !currentSet.has(item);
  });
  var removed = state.transitions.filter(function (item) {
    return !item.destroyed && !nextSet.has(item.originalKey);
  }).map(function (i) {
    return i.originalKey;
  });
  var updated = keys.filter(function (item) {
    return currentSet.has(item);
  });
  var delay = -trail;

  while (order.length) {
    var changeType = order.shift();

    switch (changeType) {
      case ENTER:
        {
          added.forEach(function (key, index) {
            // In unique mode, remove fading out transitions if their key comes in again
            if (unique && deleted.find(function (d) {
              return d.originalKey === key;
            })) deleted = deleted.filter(function (t) {
              return t.originalKey !== key;
            });
            var keyIndex = keys.indexOf(key);
            var item = items[keyIndex];
            var slot = first && initial !== void 0 ? 'initial' : ENTER;
            current[key] = {
              slot: slot,
              originalKey: key,
              key: unique ? String(key) : guid++,
              item: item,
              trail: delay = delay + trail,
              config: callProp(config, item, slot),
              from: callProp(first ? initial !== void 0 ? initial || {} : from : from, item),
              to: callProp(enter, item)
            };
          });
          break;
        }

      case LEAVE:
        {
          removed.forEach(function (key) {
            var keyIndex = _keys.indexOf(key);

            var item = _items[keyIndex];
            var slot = LEAVE;
            deleted.unshift(_extends({}, current[key], {
              slot: slot,
              destroyed: true,
              left: _keys[Math.max(0, keyIndex - 1)],
              right: _keys[Math.min(_keys.length, keyIndex + 1)],
              trail: delay = delay + trail,
              config: callProp(config, item, slot),
              to: callProp(leave, item)
            }));
            delete current[key];
          });
          break;
        }

      case UPDATE:
        {
          updated.forEach(function (key) {
            var keyIndex = keys.indexOf(key);
            var item = items[keyIndex];
            var slot = UPDATE;
            current[key] = _extends({}, current[key], {
              item: item,
              slot: slot,
              trail: delay = delay + trail,
              config: callProp(config, item, slot),
              to: callProp(update, item)
            });
          });
          break;
        }
    }
  }

  var out = keys.map(function (key) {
    return current[key];
  }); // This tries to restore order for deleted items by finding their last known siblings
  // only using the left sibling to keep order placement consistent for all deleted items

  deleted.forEach(function (_ref10) {
    var left = _ref10.left,
        right = _ref10.right,
        item = _objectWithoutPropertiesLoose(_ref10, ["left", "right"]);

    var pos; // Was it the element on the left, if yes, move there ...

    if ((pos = out.findIndex(function (t) {
      return t.originalKey === left;
    })) !== -1) pos += 1; // And if nothing else helps, move it to the start ¯\_(ツ)_/¯

    pos = Math.max(0, pos);
    out = [].concat(out.slice(0, pos), [item], out.slice(pos));
  });
  return _extends({}, state, {
    changed: added.length || removed.length || updated.length,
    first: first && added.length === 0,
    transitions: out,
    current: current,
    deleted: deleted,
    prevProps: props
  });
}

var AnimatedStyle =
/*#__PURE__*/
function (_AnimatedObject) {
  _inheritsLoose(AnimatedStyle, _AnimatedObject);

  function AnimatedStyle(style) {
    var _this;

    if (style === void 0) {
      style = {};
    }

    _this = _AnimatedObject.call(this) || this;

    if (style.transform && !(style.transform instanceof Animated)) {
      style = applyAnimatedValues.transform(style);
    }

    _this.payload = style;
    return _this;
  }

  return AnimatedStyle;
}(AnimatedObject);

// http://www.w3.org/TR/css3-color/#svg-color
var colors = {
  transparent: 0x00000000,
  aliceblue: 0xf0f8ffff,
  antiquewhite: 0xfaebd7ff,
  aqua: 0x00ffffff,
  aquamarine: 0x7fffd4ff,
  azure: 0xf0ffffff,
  beige: 0xf5f5dcff,
  bisque: 0xffe4c4ff,
  black: 0x000000ff,
  blanchedalmond: 0xffebcdff,
  blue: 0x0000ffff,
  blueviolet: 0x8a2be2ff,
  brown: 0xa52a2aff,
  burlywood: 0xdeb887ff,
  burntsienna: 0xea7e5dff,
  cadetblue: 0x5f9ea0ff,
  chartreuse: 0x7fff00ff,
  chocolate: 0xd2691eff,
  coral: 0xff7f50ff,
  cornflowerblue: 0x6495edff,
  cornsilk: 0xfff8dcff,
  crimson: 0xdc143cff,
  cyan: 0x00ffffff,
  darkblue: 0x00008bff,
  darkcyan: 0x008b8bff,
  darkgoldenrod: 0xb8860bff,
  darkgray: 0xa9a9a9ff,
  darkgreen: 0x006400ff,
  darkgrey: 0xa9a9a9ff,
  darkkhaki: 0xbdb76bff,
  darkmagenta: 0x8b008bff,
  darkolivegreen: 0x556b2fff,
  darkorange: 0xff8c00ff,
  darkorchid: 0x9932ccff,
  darkred: 0x8b0000ff,
  darksalmon: 0xe9967aff,
  darkseagreen: 0x8fbc8fff,
  darkslateblue: 0x483d8bff,
  darkslategray: 0x2f4f4fff,
  darkslategrey: 0x2f4f4fff,
  darkturquoise: 0x00ced1ff,
  darkviolet: 0x9400d3ff,
  deeppink: 0xff1493ff,
  deepskyblue: 0x00bfffff,
  dimgray: 0x696969ff,
  dimgrey: 0x696969ff,
  dodgerblue: 0x1e90ffff,
  firebrick: 0xb22222ff,
  floralwhite: 0xfffaf0ff,
  forestgreen: 0x228b22ff,
  fuchsia: 0xff00ffff,
  gainsboro: 0xdcdcdcff,
  ghostwhite: 0xf8f8ffff,
  gold: 0xffd700ff,
  goldenrod: 0xdaa520ff,
  gray: 0x808080ff,
  green: 0x008000ff,
  greenyellow: 0xadff2fff,
  grey: 0x808080ff,
  honeydew: 0xf0fff0ff,
  hotpink: 0xff69b4ff,
  indianred: 0xcd5c5cff,
  indigo: 0x4b0082ff,
  ivory: 0xfffff0ff,
  khaki: 0xf0e68cff,
  lavender: 0xe6e6faff,
  lavenderblush: 0xfff0f5ff,
  lawngreen: 0x7cfc00ff,
  lemonchiffon: 0xfffacdff,
  lightblue: 0xadd8e6ff,
  lightcoral: 0xf08080ff,
  lightcyan: 0xe0ffffff,
  lightgoldenrodyellow: 0xfafad2ff,
  lightgray: 0xd3d3d3ff,
  lightgreen: 0x90ee90ff,
  lightgrey: 0xd3d3d3ff,
  lightpink: 0xffb6c1ff,
  lightsalmon: 0xffa07aff,
  lightseagreen: 0x20b2aaff,
  lightskyblue: 0x87cefaff,
  lightslategray: 0x778899ff,
  lightslategrey: 0x778899ff,
  lightsteelblue: 0xb0c4deff,
  lightyellow: 0xffffe0ff,
  lime: 0x00ff00ff,
  limegreen: 0x32cd32ff,
  linen: 0xfaf0e6ff,
  magenta: 0xff00ffff,
  maroon: 0x800000ff,
  mediumaquamarine: 0x66cdaaff,
  mediumblue: 0x0000cdff,
  mediumorchid: 0xba55d3ff,
  mediumpurple: 0x9370dbff,
  mediumseagreen: 0x3cb371ff,
  mediumslateblue: 0x7b68eeff,
  mediumspringgreen: 0x00fa9aff,
  mediumturquoise: 0x48d1ccff,
  mediumvioletred: 0xc71585ff,
  midnightblue: 0x191970ff,
  mintcream: 0xf5fffaff,
  mistyrose: 0xffe4e1ff,
  moccasin: 0xffe4b5ff,
  navajowhite: 0xffdeadff,
  navy: 0x000080ff,
  oldlace: 0xfdf5e6ff,
  olive: 0x808000ff,
  olivedrab: 0x6b8e23ff,
  orange: 0xffa500ff,
  orangered: 0xff4500ff,
  orchid: 0xda70d6ff,
  palegoldenrod: 0xeee8aaff,
  palegreen: 0x98fb98ff,
  paleturquoise: 0xafeeeeff,
  palevioletred: 0xdb7093ff,
  papayawhip: 0xffefd5ff,
  peachpuff: 0xffdab9ff,
  peru: 0xcd853fff,
  pink: 0xffc0cbff,
  plum: 0xdda0ddff,
  powderblue: 0xb0e0e6ff,
  purple: 0x800080ff,
  rebeccapurple: 0x663399ff,
  red: 0xff0000ff,
  rosybrown: 0xbc8f8fff,
  royalblue: 0x4169e1ff,
  saddlebrown: 0x8b4513ff,
  salmon: 0xfa8072ff,
  sandybrown: 0xf4a460ff,
  seagreen: 0x2e8b57ff,
  seashell: 0xfff5eeff,
  sienna: 0xa0522dff,
  silver: 0xc0c0c0ff,
  skyblue: 0x87ceebff,
  slateblue: 0x6a5acdff,
  slategray: 0x708090ff,
  slategrey: 0x708090ff,
  snow: 0xfffafaff,
  springgreen: 0x00ff7fff,
  steelblue: 0x4682b4ff,
  tan: 0xd2b48cff,
  teal: 0x008080ff,
  thistle: 0xd8bfd8ff,
  tomato: 0xff6347ff,
  turquoise: 0x40e0d0ff,
  violet: 0xee82eeff,
  wheat: 0xf5deb3ff,
  white: 0xffffffff,
  whitesmoke: 0xf5f5f5ff,
  yellow: 0xffff00ff,
  yellowgreen: 0x9acd32ff
};

// const INTEGER = '[-+]?\\d+';
var NUMBER = '[-+]?\\d*\\.?\\d+';
var PERCENTAGE = NUMBER + '%';

function call() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }

  return '\\(\\s*(' + parts.join(')\\s*,\\s*(') + ')\\s*\\)';
}

var rgb = new RegExp('rgb' + call(NUMBER, NUMBER, NUMBER));
var rgba = new RegExp('rgba' + call(NUMBER, NUMBER, NUMBER, NUMBER));
var hsl = new RegExp('hsl' + call(NUMBER, PERCENTAGE, PERCENTAGE));
var hsla = new RegExp('hsla' + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex6 = /^#([0-9a-fA-F]{6})$/;
var hex8 = /^#([0-9a-fA-F]{8})$/;

/*
https://github.com/react-community/normalize-css-color

BSD 3-Clause License

Copyright (c) 2016, React Community
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function normalizeColor(color) {
  var match;

  if (typeof color === 'number') {
    return color >>> 0 === color && color >= 0 && color <= 0xffffffff ? color : null;
  } // Ordered based on occurrences on Facebook codebase


  if (match = hex6.exec(color)) return parseInt(match[1] + 'ff', 16) >>> 0;
  if (colors.hasOwnProperty(color)) return colors[color];

  if (match = rgb.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    0x000000ff) >>> // a
    0;
  }

  if (match = rgba.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    parse1(match[4])) >>> // a
    0;
  }

  if (match = hex3.exec(color)) {
    return parseInt(match[1] + match[1] + // r
    match[2] + match[2] + // g
    match[3] + match[3] + // b
    'ff', // a
    16) >>> 0;
  } // https://drafts.csswg.org/css-color-4/#hex-notation


  if (match = hex8.exec(color)) return parseInt(match[1], 16) >>> 0;

  if (match = hex4.exec(color)) {
    return parseInt(match[1] + match[1] + // r
    match[2] + match[2] + // g
    match[3] + match[3] + // b
    match[4] + match[4], // a
    16) >>> 0;
  }

  if (match = hsl.exec(color)) {
    return (hslToRgb(parse360(match[1]), // h
    parsePercentage(match[2]), // s
    parsePercentage(match[3]) // l
    ) | 0x000000ff) >>> // a
    0;
  }

  if (match = hsla.exec(color)) {
    return (hslToRgb(parse360(match[1]), // h
    parsePercentage(match[2]), // s
    parsePercentage(match[3]) // l
    ) | parse1(match[4])) >>> // a
    0;
  }

  return null;
}

function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}

function hslToRgb(h, s, l) {
  var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  var p = 2 * l - q;
  var r = hue2rgb(p, q, h + 1 / 3);
  var g = hue2rgb(p, q, h);
  var b = hue2rgb(p, q, h - 1 / 3);
  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
}

function parse255(str) {
  var int = parseInt(str, 10);
  if (int < 0) return 0;
  if (int > 255) return 255;
  return int;
}

function parse360(str) {
  var int = parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}

function parse1(str) {
  var num = parseFloat(str);
  if (num < 0) return 0;
  if (num > 1) return 255;
  return Math.round(num * 255);
}

function parsePercentage(str) {
  // parseFloat conveniently ignores the final %
  var int = parseFloat(str);
  if (int < 0) return 0;
  if (int > 100) return 1;
  return int / 100;
}

function colorToRgba(input) {
  var int32Color = normalizeColor(input);
  if (int32Color === null) return input;
  int32Color = int32Color || 0;
  var r = (int32Color & 0xff000000) >>> 24;
  var g = (int32Color & 0x00ff0000) >>> 16;
  var b = (int32Color & 0x0000ff00) >>> 8;
  var a = (int32Color & 0x000000ff) / 255;
  return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
} // Problem: https://github.com/animatedjs/animated/pull/102
// Solution: https://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly/658662


var stringShapeRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g; // Covers rgb, rgba, hsl, hsla
// Taken from https://gist.github.com/olmokramer/82ccce673f86db7cda5e

var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi; // Covers color names (transparent, blue, etc.)

var colorNamesRegex = new RegExp("(" + Object.keys(colors).join('|') + ")", 'g');
/**
 * Supports string shapes by extracting numbers so new values can be computed,
 * and recombines those values into new strings of the same shape.  Supports
 * things like:
 *
 *   rgba(123, 42, 99, 0.36)           // colors
 *   -45deg                            // values with units
 *   0 2px 2px 0px rgba(0, 0, 0, 0.12) // box shadows
 */

var createStringInterpolator = function createStringInterpolator(config) {
  // Replace colors with rgba
  var outputRange = config.output.map(function (rangeValue) {
    return rangeValue.replace(colorRegex, colorToRgba);
  }).map(function (rangeValue) {
    return rangeValue.replace(colorNamesRegex, colorToRgba);
  });
  var outputRanges = outputRange[0].match(stringShapeRegex).map(function () {
    return [];
  });
  outputRange.forEach(function (value) {
    value.match(stringShapeRegex).forEach(function (number, i) {
      return outputRanges[i].push(+number);
    });
  });
  var interpolations = outputRange[0].match(stringShapeRegex).map(function (_value, i) {
    return createInterpolator(_extends({}, config, {
      output: outputRanges[i]
    }));
  });
  return function (input) {
    var i = 0;
    return outputRange[0] // 'rgba(0, 100, 200, 0)'
    // ->
    // 'rgba(${interpolations[0](input)}, ${interpolations[1](input)}, ...'
    .replace(stringShapeRegex, function () {
      return interpolations[i++](input);
    }) // rgba requires that the r,g,b are integers.... so we want to round them, but we *dont* want to
    // round the opacity (4th column).
    .replace(/rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, function (_, p1, p2, p3, p4) {
      return "rgba(" + Math.round(p1) + ", " + Math.round(p2) + ", " + Math.round(p3) + ", " + p4 + ")";
    });
  };
};

var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

var prefixKey = function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
};

var prefixes = ['Webkit', 'Ms', 'Moz', 'O'];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce(function (acc, prop) {
  prefixes.forEach(function (prefix) {
    return acc[prefixKey(prefix, prop)] = acc[prop];
  });
  return acc;
}, isUnitlessNumber);

function dangerousStyleValue(name, value, isCustomProperty) {
  if (value == null || typeof value === 'boolean' || value === '') return '';
  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers

  return ('' + value).trim();
}

var attributeCache = {};
injectCreateAnimatedStyle(function (style) {
  return new AnimatedStyle(style);
});
injectDefaultElement('div');
injectStringInterpolator(createStringInterpolator);
injectColorNames(colors);
injectApplyAnimatedValues(function (instance, props) {
  if (instance.nodeType && instance.setAttribute !== undefined) {
    var style = props.style,
        children = props.children,
        scrollTop = props.scrollTop,
        scrollLeft = props.scrollLeft,
        attributes = _objectWithoutPropertiesLoose(props, ["style", "children", "scrollTop", "scrollLeft"]);

    var filter = instance.nodeName === 'filter' || instance.parentNode && instance.parentNode.nodeName === 'filter';
    if (scrollTop !== void 0) instance.scrollTop = scrollTop;
    if (scrollLeft !== void 0) instance.scrollLeft = scrollLeft; // Set textContent, if children is an animatable value

    if (children !== void 0) instance.textContent = children; // Set styles ...

    for (var styleName in style) {
      if (!style.hasOwnProperty(styleName)) continue;
      var isCustomProperty = styleName.indexOf('--') === 0;
      var styleValue = dangerousStyleValue(styleName, style[styleName], isCustomProperty);
      if (styleName === 'float') styleName = 'cssFloat';
      if (isCustomProperty) instance.style.setProperty(styleName, styleValue);else instance.style[styleName] = styleValue;
    } // Set attributes ...


    for (var name in attributes) {
      // Attributes are written in dash case
      var dashCase = filter ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, function (n) {
        return '-' + n.toLowerCase();
      }));
      if (typeof instance.getAttribute(dashCase) !== 'undefined') instance.setAttribute(dashCase, attributes[name]);
    }

    return;
  } else return false;
}, function (style) {
  return style;
});

var domElements = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', // SVG
'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];
// Extend animated with all the available THREE elements
var apply = merge(createAnimatedComponent, false);
var extendedAnimated = apply(domElements);

exports.apply = apply;
exports.config = config;
exports.update = update;
exports.animated = extendedAnimated;
exports.a = extendedAnimated;
exports.interpolate = interpolate$1;
exports.Globals = Globals;
exports.useSpring = useSpring;
exports.useTrail = useTrail;
exports.useTransition = useTransition;
exports.useChain = useChain;
exports.useSprings = useSprings;


/***/ }),

/***/ "Zss7":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;// TinyColor v1.4.2
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

(function(Math) {

var trimLeft = /^\s+/,
    trimRight = /\s+$/,
    tinyCounter = 0,
    mathRound = Math.round,
    mathMin = Math.min,
    mathMax = Math.max,
    mathRandom = Math.random;

function tinycolor (color, opts) {

    color = (color) ? color : '';
    opts = opts || { };

    // If input is already a tinycolor, return itself
    if (color instanceof tinycolor) {
       return color;
    }
    // If we are called as a function, call using new instead
    if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
    }

    var rgb = inputToRGB(color);
    this._originalInput = color,
    this._r = rgb.r,
    this._g = rgb.g,
    this._b = rgb.b,
    this._a = rgb.a,
    this._roundA = mathRound(100*this._a) / 100,
    this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;

    // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
    if (this._r < 1) { this._r = mathRound(this._r); }
    if (this._g < 1) { this._g = mathRound(this._g); }
    if (this._b < 1) { this._b = mathRound(this._b); }

    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
}

tinycolor.prototype = {
    isDark: function() {
        return this.getBrightness() < 128;
    },
    isLight: function() {
        return !this.isDark();
    },
    isValid: function() {
        return this._ok;
    },
    getOriginalInput: function() {
      return this._originalInput;
    },
    getFormat: function() {
        return this._format;
    },
    getAlpha: function() {
        return this._a;
    },
    getBrightness: function() {
        //http://www.w3.org/TR/AERT#color-contrast
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    getLuminance: function() {
        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r/255;
        GsRGB = rgb.g/255;
        BsRGB = rgb.b/255;

        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
    },
    setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100*this._a) / 100;
        return this;
    },
    toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
    },
    toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return (this._a == 1) ?
          "hsv("  + h + ", " + s + "%, " + v + "%)" :
          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
    },
    toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
    },
    toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return (this._a == 1) ?
          "hsl("  + h + ", " + s + "%, " + l + "%)" :
          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
    },
    toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function(allow3Char) {
        return '#' + this.toHex(allow3Char);
    },
    toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function(allow4Char) {
        return '#' + this.toHex8(allow4Char);
    },
    toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
    },
    toRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
    },
    toPercentageRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function() {
        if (this._a === 0) {
            return "transparent";
        }

        if (this._a < 1) {
            return false;
        }

        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function(secondColor) {
        var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";

        if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
        }

        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
    },
    toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;

        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

        if (needsAlphaFormat) {
            // Special case for "transparent", all other non-alpha formats
            // will return rgba when there is transparency.
            if (format === "name" && this._a === 0) {
                return this.toName();
            }
            return this.toRgbString();
        }
        if (format === "rgb") {
            formattedString = this.toRgbString();
        }
        if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
        }
        if (format === "hex3") {
            formattedString = this.toHexString(true);
        }
        if (format === "hex4") {
            formattedString = this.toHex8String(true);
        }
        if (format === "hex8") {
            formattedString = this.toHex8String();
        }
        if (format === "name") {
            formattedString = this.toName();
        }
        if (format === "hsl") {
            formattedString = this.toHslString();
        }
        if (format === "hsv") {
            formattedString = this.toHsvString();
        }

        return formattedString || this.toHexString();
    },
    clone: function() {
        return tinycolor(this.toString());
    },

    _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
    },
    lighten: function() {
        return this._applyModification(lighten, arguments);
    },
    brighten: function() {
        return this._applyModification(brighten, arguments);
    },
    darken: function() {
        return this._applyModification(darken, arguments);
    },
    desaturate: function() {
        return this._applyModification(desaturate, arguments);
    },
    saturate: function() {
        return this._applyModification(saturate, arguments);
    },
    greyscale: function() {
        return this._applyModification(greyscale, arguments);
    },
    spin: function() {
        return this._applyModification(spin, arguments);
    },

    _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function() {
        return this._applyCombination(analogous, arguments);
    },
    complement: function() {
        return this._applyCombination(complement, arguments);
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
    },
    triad: function() {
        return this._applyCombination(triad, arguments);
    },
    tetrad: function() {
        return this._applyCombination(tetrad, arguments);
    }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function(color, opts) {
    if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
            if (color.hasOwnProperty(i)) {
                if (i === "a") {
                    newColor[i] = color[i];
                }
                else {
                    newColor[i] = convertToPercentage(color[i]);
                }
            }
        }
        color = newColor;
    }

    return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {

    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;

    if (typeof color == "string") {
        color = stringInputToObject(color);
    }

    if (typeof color == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
        }

        if (color.hasOwnProperty("a")) {
            a = color.a;
        }
    }

    a = boundAlpha(a);

    return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
    };
}


// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b){
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
    };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return { h: h, s: s, l: l };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
    var r, g, b;

    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }

    if(s === 0) {
        r = g = b = l; // achromatic
    }
    else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if(max == min) {
        h = 0; // achromatic
    }
    else {
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
 function hsvToRgb(h, s, v) {

    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);

    var i = Math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    // Return a 3 character hex if possible
    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join("");
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b are contained in the set [0, 255] and
// a in [0, 1]. Returns a 4 or 8 character rgba hex
function rgbaToHex(r, g, b, a, allow4Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16)),
        pad2(convertDecimalToHex(a))
    ];

    // Return a 4 character hex if possible
    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }

    return hex.join("");
}

// `rgbaToArgbHex`
// Converts an RGBA color to an ARGB Hex8 string
// Rarely used, but required for "toFilter()"
function rgbaToArgbHex(r, g, b, a) {

    var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    return hex.join("");
}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) { return false; }
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};

tinycolor.random = function() {
    return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
    });
};


// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function desaturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function saturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function greyscale(color) {
    return tinycolor(color).desaturate(100);
}

function lighten (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

function brighten(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
    return tinycolor(rgb);
}

function darken (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
}

function triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
    ];
}

function tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
    ];
}

function splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
    ];
}

function analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;

    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];

    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
    }
    return ret;
}

function monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;

    while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v}));
        v = (v + modification) % 1;
    }

    return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function(color1, color2, amount) {
    amount = (amount === 0) ? 0 : (amount || 50);

    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();

    var p = amount / 100;

    var rgba = {
        r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
        g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
        b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
        a: ((rgb2.a - rgb1.a) * p) + rgb1.a
    };

    return tinycolor(rgba);
};


// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function(color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;

    out = false;

    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
            out = readability >= 4.5;
            break;
        case "AAlarge":
            out = readability >= 3;
            break;
        case "AAAsmall":
            out = readability >= 7;
            break;
    }
    return out;

};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function(baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size ;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors ;
    level = args.level;
    size = args.size;

    for (var i= 0; i < colorList.length ; i++) {
        readability = tinycolor.readability(baseColor, colorList[i]);
        if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor(colorList[i]);
        }
    }

    if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
        return bestColor;
    }
    else {
        args.includeFallbackColors=false;
        return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
    }
};


// Big List of Colors
// ------------------
// <http://www.w3.org/TR/css3-color/#svg-color>
var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names);


// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
    var flipped = { };
    for (var i in o) {
        if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
        }
    }
    return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
    }

    return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
    if (isOnePointZero(n)) { n = "100%"; }

    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n)));

    // Automatically convert percentage into number
    if (processPercent) {
        n = parseInt(n * max, 10) / 100;
    }

    // Handle floating point rounding errors
    if ((Math.abs(n - max) < 0.000001)) {
        return 1;
    }

    // Convert into [0, 1] range if it isn't already
    return (n % max) / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
    return mathMin(1, mathMax(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
    return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
    return typeof n === "string" && n.indexOf('%') != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
    return c.length == 1 ? '0' + c : '' + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
    if (n <= 1) {
        n = (n * 100) + "%";
    }

    return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
    return (parseIntFromHex(h) / 255);
}

var matchers = (function() {

    // <http://www.w3.org/TR/css3-values/#integers>
    var CSS_INTEGER = "[-\\+]?\\d+%?";

    // <http://www.w3.org/TR/css3-values/#number-value>
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

    // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

    return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
})();

// `isValidCSSUnit`
// Take in a single string / number and check to see if it looks like a CSS unit
// (see `matchers` above for definition).
function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
}

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {

    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
    var named = false;
    if (names[color]) {
        color = names[color];
        named = true;
    }
    else if (color == 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }

    // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.
    var match;
    if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] };
    }
    if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] };
    }
    if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] };
    }
    if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    if ((match = matchers.hex8.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex6.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
        };
    }
    if ((match = matchers.hex4.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            a: convertHexToDecimal(match[4] + '' + match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex3.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            format: named ? "name" : "hex"
        };
    }

    return false;
}

function validateWCAG2Parms(parms) {
    // return valid WCAG2 parms for isReadable.
    // If input parms are invalid, return {"level":"AA", "size":"small"}
    var level, size;
    parms = parms || {"level":"AA", "size":"small"};
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();
    if (level !== "AA" && level !== "AAA") {
        level = "AA";
    }
    if (size !== "small" && size !== "large") {
        size = "small";
    }
    return {"level":level, "size":size};
}

// Node: Export function
if ( true && module.exports) {
    module.exports = tinycolor;
}
// AMD/requirejs: Define the module
else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {return tinycolor;}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}
// Browser: Expose to window
else {}

})(Math);


/***/ }),

/***/ "b2RC":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const grid = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7.8 16.5H5c-.3 0-.5-.2-.5-.5v-6.2h6.8v6.7zm0-8.3H4.5V5c0-.3.2-.5.5-.5h6.2v6.7zm8.3 7.8c0 .3-.2.5-.5.5h-6.2v-6.8h6.8V19zm0-7.8h-6.8V4.5H19c.3 0 .5.2.5.5v6.2z",
  fillRule: "evenodd",
  clipRule: "evenodd"
}));
/* harmony default export */ __webpack_exports__["a"] = (grid);


/***/ }),

/***/ "bWcr":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const closeSmall = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M12 13.06l3.712 3.713 1.061-1.06L13.061 12l3.712-3.712-1.06-1.06L12 10.938 8.288 7.227l-1.061 1.06L10.939 12l-3.712 3.712 1.06 1.061L12 13.061z"
}));
/* harmony default export */ __webpack_exports__["a"] = (closeSmall);


/***/ }),

/***/ "btIw":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const keyboardReturn = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "-2 -2 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M6.734 16.106l2.176-2.38-1.093-1.028-3.846 4.158 3.846 4.157 1.093-1.027-2.176-2.38h2.811c1.125 0 2.25.03 3.374 0 1.428-.001 3.362-.25 4.963-1.277 1.66-1.065 2.868-2.906 2.868-5.859 0-2.479-1.327-4.896-3.65-5.93-1.82-.813-3.044-.8-4.806-.788l-.567.002v1.5c.184 0 .368 0 .553-.002 1.82-.007 2.704-.014 4.21.657 1.854.827 2.76 2.657 2.76 4.561 0 2.472-.973 3.824-2.178 4.596-1.258.807-2.864 1.04-4.163 1.04h-.02c-1.115.03-2.229 0-3.344 0H6.734z"
}));
/* harmony default export */ __webpack_exports__["a"] = (keyboardReturn);


/***/ }),

/***/ "cDcd":
/***/ (function(module, exports) {

(function() { module.exports = window["React"]; }());

/***/ }),

/***/ "cGtP":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const search = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M13.5 6C10.5 6 8 8.5 8 11.5c0 1.1.3 2.1.9 3l-3.4 3 1 1.1 3.4-2.9c1 .9 2.2 1.4 3.6 1.4 3 0 5.5-2.5 5.5-5.5C19 8.5 16.5 6 13.5 6zm0 9.5c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4-1.8 4-4 4z"
}));
/* harmony default export */ __webpack_exports__["a"] = (search);


/***/ }),

/***/ "cjQ8":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const arrowLeft = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M20 10.8H6.7l4.1-4.5-1.1-1.1-5.8 6.3 5.8 5.8 1.1-1.1-4-3.9H20z"
}));
/* harmony default export */ __webpack_exports__["a"] = (arrowLeft);


/***/ }),

/***/ "eGrx":
/***/ (function(module, exports) {

var traverse = module.exports = function (obj) {
    return new Traverse(obj);
};

function Traverse (obj) {
    this.value = obj;
}

Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};

Traverse.prototype.has = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            return false;
        }
        node = node[key];
    }
    return true;
};

Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i ++) {
        var key = ps[i];
        if (!hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};

Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};

Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path); 
    });
    return acc;
};

Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};

Traverse.prototype.clone = function () {
    var parents = [], nodes = [];
    
    return (function clone (src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        
        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);
            
            parents.push(src);
            nodes.push(dst);
            
            forEach(objectKeys(src), function (key) {
                dst[key] = clone(src[key]);
            });
            
            parents.pop();
            nodes.pop();
            return dst;
        }
        else {
            return src;
        }
    })(this.value);
};

function walk (root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    
    return (function walker (node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        
        var keepGoing = true;
        
        var state = {
            node : node,
            node_ : node_,
            path : [].concat(path),
            parent : parents[parents.length - 1],
            parents : parents,
            key : path.slice(-1)[0],
            isRoot : path.length === 0,
            level : path.length,
            circular : null,
            update : function (x, stopHere) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
                if (stopHere) keepGoing = false;
            },
            'delete' : function (stopHere) {
                delete state.parent.node[state.key];
                if (stopHere) keepGoing = false;
            },
            remove : function (stopHere) {
                if (isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                }
                else {
                    delete state.parent.node[state.key];
                }
                if (stopHere) keepGoing = false;
            },
            keys : null,
            before : function (f) { modifiers.before = f },
            after : function (f) { modifiers.after = f },
            pre : function (f) { modifiers.pre = f },
            post : function (f) { modifiers.post = f },
            stop : function () { alive = false },
            block : function () { keepGoing = false }
        };
        
        if (!alive) return state;
        
        function updateState() {
            if (typeof state.node === 'object' && state.node !== null) {
                if (!state.keys || state.node_ !== state.node) {
                    state.keys = objectKeys(state.node)
                }
                
                state.isLeaf = state.keys.length == 0;
                
                for (var i = 0; i < parents.length; i++) {
                    if (parents[i].node_ === node_) {
                        state.circular = parents[i];
                        break;
                    }
                }
            }
            else {
                state.isLeaf = true;
                state.keys = null;
            }
            
            state.notLeaf = !state.isLeaf;
            state.notRoot = !state.isRoot;
        }
        
        updateState();
        
        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        
        if (modifiers.before) modifiers.before.call(state, state.node);
        
        if (!keepGoing) return state;
        
        if (typeof state.node == 'object'
        && state.node !== null && !state.circular) {
            parents.push(state);
            
            updateState();
            
            forEach(state.keys, function (key, i) {
                path.push(key);
                
                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                
                var child = walker(state.node[key]);
                if (immutable && hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                
                child.isLast = i == state.keys.length - 1;
                child.isFirst = i == 0;
                
                if (modifiers.post) modifiers.post.call(state, child);
                
                path.pop();
            });
            parents.pop();
        }
        
        if (modifiers.after) modifiers.after.call(state, state.node);
        
        return state;
    })(root).node;
}

function copy (src) {
    if (typeof src === 'object' && src !== null) {
        var dst;
        
        if (isArray(src)) {
            dst = [];
        }
        else if (isDate(src)) {
            dst = new Date(src.getTime ? src.getTime() : src);
        }
        else if (isRegExp(src)) {
            dst = new RegExp(src);
        }
        else if (isError(src)) {
            dst = { message: src.message };
        }
        else if (isBoolean(src)) {
            dst = new Boolean(src);
        }
        else if (isNumber(src)) {
            dst = new Number(src);
        }
        else if (isString(src)) {
            dst = new String(src);
        }
        else if (Object.create && Object.getPrototypeOf) {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        else if (src.constructor === Object) {
            dst = {};
        }
        else {
            var proto =
                (src.constructor && src.constructor.prototype)
                || src.__proto__
                || {}
            ;
            var T = function () {};
            T.prototype = proto;
            dst = new T;
        }
        
        forEach(objectKeys(src), function (key) {
            dst[key] = src[key];
        });
        return dst;
    }
    else return src;
}

var objectKeys = Object.keys || function keys (obj) {
    var res = [];
    for (var key in obj) res.push(key)
    return res;
};

function toS (obj) { return Object.prototype.toString.call(obj) }
function isDate (obj) { return toS(obj) === '[object Date]' }
function isRegExp (obj) { return toS(obj) === '[object RegExp]' }
function isError (obj) { return toS(obj) === '[object Error]' }
function isBoolean (obj) { return toS(obj) === '[object Boolean]' }
function isNumber (obj) { return toS(obj) === '[object Number]' }
function isString (obj) { return toS(obj) === '[object String]' }

var isArray = Array.isArray || function isArray (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

forEach(objectKeys(Traverse.prototype), function (key) {
    traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = new Traverse(obj);
        return t[key].apply(t, args);
    };
});

var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
    return key in obj;
};


/***/ }),

/***/ "fPbg":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const alignLeft = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M4 19.8h8.9v-1.5H4v1.5zm8.9-15.6H4v1.5h8.9V4.2zm-8.9 7v1.5h16v-1.5H4z"
}));
/* harmony default export */ __webpack_exports__["a"] = (alignLeft);


/***/ }),

/***/ "g56x":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["hooks"]; }());

/***/ }),

/***/ "gdqT":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["a11y"]; }());

/***/ }),

/***/ "hF7m":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["keyboardShortcuts"]; }());

/***/ }),

/***/ "iA5R":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.diffChars = diffChars;
exports.characterDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__("smQA"))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*istanbul ignore end*/
var characterDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
.
/*istanbul ignore start*/
default
/*istanbul ignore end*/
();

/*istanbul ignore start*/
exports.characterDiff = characterDiff;

/*istanbul ignore end*/
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}


/***/ }),

/***/ "iClF":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/**
 * WordPress dependencies
 */

/** @typedef {{icon: JSX.Element, size?: number} & import('@wordpress/primitives').SVGProps} IconProps */

/**
 * Return an SVG icon.
 *
 * @param {IconProps} props icon is the SVG component to render
 *                          size is a number specifiying the icon size in pixels
 *                          Other props will be passed to wrapped SVG component
 *
 * @return {JSX.Element}  Icon component
 */

function Icon({
  icon,
  size = 24,
  ...props
}) {
  return Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["cloneElement"])(icon, {
    width: size,
    height: size,
    ...props
  });
}

/* harmony default export */ __webpack_exports__["a"] = (Icon);


/***/ }),

/***/ "jB5C":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;

function getClientPosition(elem) {
  var box = undefined;
  var x = undefined;
  var y = undefined;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement;
  // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式
  box = elem.getBoundingClientRect();

  // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop
  // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确
  // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin

  x = box.left;
  y = box.top;

  // In IE, most of the time, 2 extra pixels are added to the top and left
  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
  // IE6 standards mode, this border can be overridden by setting the
  // document element's border to zero -- thus, we cannot rely on the
  // offset always being 2 pixels.

  // In quirks mode, the offset can be determined by querying the body's
  // clientLeft/clientTop, but in standards mode, it is found by querying
  // the document element's clientLeft/clientTop.  Since we already called
  // getClientBoundingRect we have already forced a reflow, so it is not
  // too expensive just to query them all.

  // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的
  // 窗口边框标准是设 documentElement ,quirks 时设置 body
  // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去
  // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置
  // 标准 ie 下 docElem.clientTop 就是 border-top
  // ie7 html 即窗口边框改变不了。永远为 2
  // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0

  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;

  return {
    left: x,
    top: y
  };
}

function getScroll(w, top) {
  var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
  var method = 'scroll' + (top ? 'Top' : 'Left');
  if (typeof ret !== 'number') {
    var d = w.document;
    // ie6,7,8 standard mode
    ret = d.documentElement[method];
    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }
  return ret;
}

function getScrollLeft(w) {
  return getScroll(w);
}

function getScrollTop(w) {
  return getScroll(w, true);
}

function getOffset(el) {
  var pos = getClientPosition(el);
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w);
  pos.top += getScrollTop(w);
  return pos;
}
function _getComputedStyle(elem, name, computedStyle_) {
  var val = '';
  var d = elem.ownerDocument;
  var computedStyle = computedStyle_ || d.defaultView.getComputedStyle(elem, null);

  // https://github.com/kissyteam/kissy/issues/61
  if (computedStyle) {
    val = computedStyle.getPropertyValue(name) || computedStyle[name];
  }

  return val;
}

var _RE_NUM_NO_PX = new RegExp('^(' + RE_NUM + ')(?!px)[a-z%]+$', 'i');
var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = 'currentStyle';
var RUNTIME_STYLE = 'runtimeStyle';
var LEFT = 'left';
var PX = 'px';

function _getComputedStyleIE(elem, name) {
  // currentStyle maybe null
  // http://msdn.microsoft.com/en-us/library/ms535231.aspx
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];

  // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值
  // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19
  // 在 ie 下不对，需要直接用 offset 方式
  // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了

  // From the awesome hack by Dean Edwards
  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
  // If we're not dealing with a regular pixel number
  // but a number that has a weird ending, we need to convert it to pixels
  // exclude left right for relativity
  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
    // Remember the original values
    var style = elem.style;
    var left = style[LEFT];
    var rsLeft = elem[RUNTIME_STYLE][LEFT];

    // prevent flashing of content
    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];

    // Put in the new values to get a computed value out
    style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
    ret = style.pixelLeft + PX;

    // Revert the changed values
    style[LEFT] = left;

    elem[RUNTIME_STYLE][LEFT] = rsLeft;
  }
  return ret === '' ? 'auto' : ret;
}

var getComputedStyleX = undefined;
if (typeof window !== 'undefined') {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}

function each(arr, fn) {
  for (var i = 0; i < arr.length; i++) {
    fn(arr[i]);
  }
}

function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
}

var BOX_MODELS = ['margin', 'border', 'padding'];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;

function swap(elem, options, callback) {
  var old = {};
  var style = elem.style;
  var name = undefined;

  // Remember the old values, and insert the new ones
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      old[name] = style[name];
      style[name] = options[name];
    }
  }

  callback.call(elem);

  // Revert the old values
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      style[name] = old[name];
    }
  }
}

function getPBMWidth(elem, props, which) {
  var value = 0;
  var prop = undefined;
  var j = undefined;
  var i = undefined;
  for (j = 0; j < props.length; j++) {
    prop = props[j];
    if (prop) {
      for (i = 0; i < which.length; i++) {
        var cssProp = undefined;
        if (prop === 'border') {
          cssProp = prop + which[i] + 'Width';
        } else {
          cssProp = prop + which[i];
        }
        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }
  return value;
}

/**
 * A crude way of determining if an object is a window
 * @member util
 */
function isWindow(obj) {
  // must use == for ie8
  /* eslint eqeqeq:0 */
  return obj != null && obj == obj.window;
}

var domUtils = {};

each(['Width', 'Height'], function (name) {
  domUtils['doc' + name] = function (refWin) {
    var d = refWin.document;
    return Math.max(
    // firefox chrome documentElement.scrollHeight< body.scrollHeight
    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
    d.documentElement['scroll' + name],
    // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
    d.body['scroll' + name], domUtils['viewport' + name](d));
  };

  domUtils['viewport' + name] = function (win) {
    // pc browser includes scrollbar in window.innerWidth
    var prop = 'client' + name;
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop];
    // 标准模式取 documentElement
    // backcompat 取 body
    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
  };
});

/*
 得到元素的大小信息
 @param elem
 @param name
 @param {String} [extra]  'padding' : (css width) + padding
 'border' : (css width) + padding + border
 'margin' : (css width) + padding + border + margin
 */
function getWH(elem, name, extra) {
  if (isWindow(elem)) {
    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }
  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
  var borderBoxValue = name === 'width' ? elem.offsetWidth : elem.offsetHeight;
  var computedStyle = getComputedStyleX(elem);
  var isBorderBox = isBorderBoxFn(elem, computedStyle);
  var cssBoxValue = 0;
  if (borderBoxValue == null || borderBoxValue <= 0) {
    borderBoxValue = undefined;
    // Fall back to computed then un computed css if necessary
    cssBoxValue = getComputedStyleX(elem, name);
    if (cssBoxValue == null || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    }
    // Normalize '', auto, and prepare for extra
    cssBoxValue = parseFloat(cssBoxValue) || 0;
  }
  if (extra === undefined) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }
  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
  var val = borderBoxValue || cssBoxValue;
  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ['border', 'padding'], which, computedStyle);
    }
    return cssBoxValue;
  }
  if (borderBoxValueOrIsBorderBox) {
    var padding = extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which, computedStyle) : getPBMWidth(elem, ['margin'], which, computedStyle);
    return val + (extra === BORDER_INDEX ? 0 : padding);
  }
  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which, computedStyle);
}

var cssShow = {
  position: 'absolute',
  visibility: 'hidden',
  display: 'block'
};

// fix #119 : https://github.com/kissyteam/kissy/issues/119
function getWHIgnoreDisplay(elem) {
  var val = undefined;
  var args = arguments;
  // in case elem is window
  // elem.offsetWidth === undefined
  if (elem.offsetWidth !== 0) {
    val = getWH.apply(undefined, args);
  } else {
    swap(elem, cssShow, function () {
      val = getWH.apply(undefined, args);
    });
  }
  return val;
}

function css(el, name, v) {
  var value = v;
  if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
    for (var i in name) {
      if (name.hasOwnProperty(i)) {
        css(el, i, name[i]);
      }
    }
    return undefined;
  }
  if (typeof value !== 'undefined') {
    if (typeof value === 'number') {
      value += 'px';
    }
    el.style[name] = value;
    return undefined;
  }
  return getComputedStyleX(el, name);
}

each(['width', 'height'], function (name) {
  var first = name.charAt(0).toUpperCase() + name.slice(1);
  domUtils['outer' + first] = function (el, includeMargin) {
    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };
  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];

  domUtils[name] = function (elem, val) {
    if (val !== undefined) {
      if (elem) {
        var computedStyle = getComputedStyleX(elem);
        var isBorderBox = isBorderBoxFn(elem);
        if (isBorderBox) {
          val += getPBMWidth(elem, ['padding', 'border'], which, computedStyle);
        }
        return css(elem, name, val);
      }
      return undefined;
    }
    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
  };
});

// 设置 elem 相对 elem.ownerDocument 的坐标
function setOffset(elem, offset) {
  // set position first, in-case top/left are set even on static elem
  if (css(elem, 'position') === 'static') {
    elem.style.position = 'relative';
  }

  var old = getOffset(elem);
  var ret = {};
  var current = undefined;
  var key = undefined;

  for (key in offset) {
    if (offset.hasOwnProperty(key)) {
      current = parseFloat(css(elem, key)) || 0;
      ret[key] = current + offset[key] - old[key];
    }
  }
  css(elem, ret);
}

module.exports = _extends({
  getWindow: function getWindow(node) {
    var doc = node.ownerDocument || node;
    return doc.defaultView || doc.parentWindow;
  },
  offset: function offset(el, value) {
    if (typeof value !== 'undefined') {
      setOffset(el, value);
    } else {
      return getOffset(el);
    }
  },

  isWindow: isWindow,
  each: each,
  css: css,
  clone: function clone(obj) {
    var ret = {};
    for (var i in obj) {
      if (obj.hasOwnProperty(i)) {
        ret[i] = obj[i];
      }
    }
    var overflow = obj.overflow;
    if (overflow) {
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          ret.overflow[i] = obj.overflow[i];
        }
      }
    }
    return ret;
  },
  scrollLeft: function scrollLeft(w, v) {
    if (isWindow(w)) {
      if (v === undefined) {
        return getScrollLeft(w);
      }
      window.scrollTo(v, getScrollTop(w));
    } else {
      if (v === undefined) {
        return w.scrollLeft;
      }
      w.scrollLeft = v;
    }
  },
  scrollTop: function scrollTop(w, v) {
    if (isWindow(w)) {
      if (v === undefined) {
        return getScrollTop(w);
      }
      window.scrollTo(getScrollLeft(w), v);
    } else {
      if (v === undefined) {
        return w.scrollTop;
      }
      w.scrollTop = v;
    }
  },

  viewportWidth: 0,
  viewportHeight: 0
}, domUtils);

/***/ }),

/***/ "jTPX":
/***/ (function(module, exports) {

// This code has been refactored for 140 bytes
// You can see the original here: https://github.com/twolfson/computedStyle/blob/04cd1da2e30fa45844f95f5cb1ac898e9b9ef050/lib/computedStyle.js
var computedStyle = function (el, prop, getComputedStyle) {
  getComputedStyle = window.getComputedStyle;

  // In one fell swoop
  return (
    // If we have getComputedStyle
    getComputedStyle ?
      // Query it
      // TODO: From CSS-Query notes, we might need (node, null) for FF
      getComputedStyle(el) :

    // Otherwise, we are in IE and use currentStyle
      el.currentStyle
  )[
    // Switch to camelCase for CSSOM
    // DEV: Grabbed from jQuery
    // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194
    // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597
    prop.replace(/-(\w)/gi, function (word, letter) {
      return letter.toUpperCase();
    })
  ];
};

module.exports = computedStyle;


/***/ }),

/***/ "l3Sj":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["i18n"]; }());

/***/ }),

/***/ "onLe":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["notices"]; }());

/***/ }),

/***/ "pPDe":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


var LEAF_KEY, hasWeakMap;

/**
 * Arbitrary value used as key for referencing cache object in WeakMap tree.
 *
 * @type {Object}
 */
LEAF_KEY = {};

/**
 * Whether environment supports WeakMap.
 *
 * @type {boolean}
 */
hasWeakMap = typeof WeakMap !== 'undefined';

/**
 * Returns the first argument as the sole entry in an array.
 *
 * @param {*} value Value to return.
 *
 * @return {Array} Value returned as entry in array.
 */
function arrayOf( value ) {
	return [ value ];
}

/**
 * Returns true if the value passed is object-like, or false otherwise. A value
 * is object-like if it can support property assignment, e.g. object or array.
 *
 * @param {*} value Value to test.
 *
 * @return {boolean} Whether value is object-like.
 */
function isObjectLike( value ) {
	return !! value && 'object' === typeof value;
}

/**
 * Creates and returns a new cache object.
 *
 * @return {Object} Cache object.
 */
function createCache() {
	var cache = {
		clear: function() {
			cache.head = null;
		},
	};

	return cache;
}

/**
 * Returns true if entries within the two arrays are strictly equal by
 * reference from a starting index.
 *
 * @param {Array}  a         First array.
 * @param {Array}  b         Second array.
 * @param {number} fromIndex Index from which to start comparison.
 *
 * @return {boolean} Whether arrays are shallowly equal.
 */
function isShallowEqual( a, b, fromIndex ) {
	var i;

	if ( a.length !== b.length ) {
		return false;
	}

	for ( i = fromIndex; i < a.length; i++ ) {
		if ( a[ i ] !== b[ i ] ) {
			return false;
		}
	}

	return true;
}

/**
 * Returns a memoized selector function. The getDependants function argument is
 * called before the memoized selector and is expected to return an immutable
 * reference or array of references on which the selector depends for computing
 * its own return value. The memoize cache is preserved only as long as those
 * dependant references remain the same. If getDependants returns a different
 * reference(s), the cache is cleared and the selector value regenerated.
 *
 * @param {Function} selector      Selector function.
 * @param {Function} getDependants Dependant getter returning an immutable
 *                                 reference or array of reference used in
 *                                 cache bust consideration.
 *
 * @return {Function} Memoized selector.
 */
/* harmony default export */ __webpack_exports__["a"] = (function( selector, getDependants ) {
	var rootCache, getCache;

	// Use object source as dependant if getter not provided
	if ( ! getDependants ) {
		getDependants = arrayOf;
	}

	/**
	 * Returns the root cache. If WeakMap is supported, this is assigned to the
	 * root WeakMap cache set, otherwise it is a shared instance of the default
	 * cache object.
	 *
	 * @return {(WeakMap|Object)} Root cache object.
	 */
	function getRootCache() {
		return rootCache;
	}

	/**
	 * Returns the cache for a given dependants array. When possible, a WeakMap
	 * will be used to create a unique cache for each set of dependants. This
	 * is feasible due to the nature of WeakMap in allowing garbage collection
	 * to occur on entries where the key object is no longer referenced. Since
	 * WeakMap requires the key to be an object, this is only possible when the
	 * dependant is object-like. The root cache is created as a hierarchy where
	 * each top-level key is the first entry in a dependants set, the value a
	 * WeakMap where each key is the next dependant, and so on. This continues
	 * so long as the dependants are object-like. If no dependants are object-
	 * like, then the cache is shared across all invocations.
	 *
	 * @see isObjectLike
	 *
	 * @param {Array} dependants Selector dependants.
	 *
	 * @return {Object} Cache object.
	 */
	function getWeakMapCache( dependants ) {
		var caches = rootCache,
			isUniqueByDependants = true,
			i, dependant, map, cache;

		for ( i = 0; i < dependants.length; i++ ) {
			dependant = dependants[ i ];

			// Can only compose WeakMap from object-like key.
			if ( ! isObjectLike( dependant ) ) {
				isUniqueByDependants = false;
				break;
			}

			// Does current segment of cache already have a WeakMap?
			if ( caches.has( dependant ) ) {
				// Traverse into nested WeakMap.
				caches = caches.get( dependant );
			} else {
				// Create, set, and traverse into a new one.
				map = new WeakMap();
				caches.set( dependant, map );
				caches = map;
			}
		}

		// We use an arbitrary (but consistent) object as key for the last item
		// in the WeakMap to serve as our running cache.
		if ( ! caches.has( LEAF_KEY ) ) {
			cache = createCache();
			cache.isUniqueByDependants = isUniqueByDependants;
			caches.set( LEAF_KEY, cache );
		}

		return caches.get( LEAF_KEY );
	}

	// Assign cache handler by availability of WeakMap
	getCache = hasWeakMap ? getWeakMapCache : getRootCache;

	/**
	 * Resets root memoization cache.
	 */
	function clear() {
		rootCache = hasWeakMap ? new WeakMap() : createCache();
	}

	// eslint-disable-next-line jsdoc/check-param-names
	/**
	 * The augmented selector call, considering first whether dependants have
	 * changed before passing it to underlying memoize function.
	 *
	 * @param {Object} source    Source object for derivation.
	 * @param {...*}   extraArgs Additional arguments to pass to selector.
	 *
	 * @return {*} Selector result.
	 */
	function callSelector( /* source, ...extraArgs */ ) {
		var len = arguments.length,
			cache, node, i, args, dependants;

		// Create copy of arguments (avoid leaking deoptimization).
		args = new Array( len );
		for ( i = 0; i < len; i++ ) {
			args[ i ] = arguments[ i ];
		}

		dependants = getDependants.apply( null, args );
		cache = getCache( dependants );

		// If not guaranteed uniqueness by dependants (primitive type or lack
		// of WeakMap support), shallow compare against last dependants and, if
		// references have changed, destroy cache to recalculate result.
		if ( ! cache.isUniqueByDependants ) {
			if ( cache.lastDependants && ! isShallowEqual( dependants, cache.lastDependants, 0 ) ) {
				cache.clear();
			}

			cache.lastDependants = dependants;
		}

		node = cache.head;
		while ( node ) {
			// Check whether node arguments match arguments
			if ( ! isShallowEqual( node.args, args, 1 ) ) {
				node = node.next;
				continue;
			}

			// At this point we can assume we've found a match

			// Surface matched node to head if not already
			if ( node !== cache.head ) {
				// Adjust siblings to point to each other.
				node.prev.next = node.next;
				if ( node.next ) {
					node.next.prev = node.prev;
				}

				node.next = cache.head;
				node.prev = null;
				cache.head.prev = node;
				cache.head = node;
			}

			// Return immediately
			return node.val;
		}

		// No cached value found. Continue to insertion phase:

		node = {
			// Generate the result from original function
			val: selector.apply( null, args ),
		};

		// Avoid including the source object in the cache.
		args[ 0 ] = null;
		node.args = args;

		// Don't need to check whether node is already head, since it would
		// have been returned above already if it was

		// Shift existing head down list
		if ( cache.head ) {
			cache.head.prev = node;
			node.next = cache.head;
		}

		cache.head = node;

		return node.val;
	}

	callSelector.getDependants = getDependants;
	callSelector.clear = clear;
	clear();

	return callSelector;
});


/***/ }),

/***/ "pVnL":
/***/ (function(module, exports) {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _extends.apply(this, arguments);
}

module.exports = _extends;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "plpT":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const alignCenter = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M16.4 4.2H7.6v1.5h8.9V4.2zM4 11.2v1.5h16v-1.5H4zm3.6 8.6h8.9v-1.5H7.6v1.5z"
}));
/* harmony default export */ __webpack_exports__["a"] = (alignCenter);


/***/ }),

/***/ "qRz9":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["richText"]; }());

/***/ }),

/***/ "rH4q":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const media = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M18.7 3H5.3C4 3 3 4 3 5.3v13.4C3 20 4 21 5.3 21h13.4c1.3 0 2.3-1 2.3-2.3V5.3C21 4 20 3 18.7 3zm.8 15.7c0 .4-.4.8-.8.8H5.3c-.4 0-.8-.4-.8-.8V5.3c0-.4.4-.8.8-.8h13.4c.4 0 .8.4.8.8v13.4zM10 15l5-3-5-3v6z"
}));
/* harmony default export */ __webpack_exports__["a"] = (media);


/***/ }),

/***/ "rl8x":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["isShallowEqual"]; }());

/***/ }),

/***/ "rmEH":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["htmlEntities"]; }());

/***/ }),

/***/ "smQA":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Diff;

/*istanbul ignore end*/
function Diff() {}

Diff.prototype = {
  /*istanbul ignore start*/

  /*istanbul ignore end*/
  diff: function diff(oldString, newString) {
    /*istanbul ignore start*/
    var
    /*istanbul ignore end*/
    options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var callback = options.callback;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    this.options = options;
    var self = this;

    function done(value) {
      if (callback) {
        setTimeout(function () {
          callback(undefined, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    } // Allow subclasses to massage the input prior to running


    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length,
        oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    var bestPath = [{
      newPos: -1,
      components: []
    }]; // Seed editLength = 0, i.e. the content starts with the same values

    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);

    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
      // Identity per the equality and tokenizer
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    } // Main worker method. checks all permutations of a given edit length for acceptance.


    function execEditLength() {
      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
        var basePath =
        /*istanbul ignore start*/
        void 0
        /*istanbul ignore end*/
        ;

        var addPath = bestPath[diagonalPath - 1],
            removePath = bestPath[diagonalPath + 1],
            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;

        if (addPath) {
          // No one else is going to attempt to use this value, clear it
          bestPath[diagonalPath - 1] = undefined;
        }

        var canAdd = addPath && addPath.newPos + 1 < newLen,
            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;

        if (!canAdd && !canRemove) {
          // If this path is a terminal then prune
          bestPath[diagonalPath] = undefined;
          continue;
        } // Select the diagonal that we want to branch from. We select the prior
        // path whose position in the new string is the farthest from the origin
        // and does not pass the bounds of the diff graph


        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
          basePath = clonePath(removePath);
          self.pushComponent(basePath.components, undefined, true);
        } else {
          basePath = addPath; // No need to clone, we've pulled it from the list

          basePath.newPos++;
          self.pushComponent(basePath.components, true, undefined);
        }

        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done

        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
        } else {
          // Otherwise track this path as a potential candidate and continue.
          bestPath[diagonalPath] = basePath;
        }
      }

      editLength++;
    } // Performs the length of edit iteration. Is a bit fugly as this has to support the
    // sync and async mode which is never fun. Loops over execEditLength until a value
    // is produced.


    if (callback) {
      (function exec() {
        setTimeout(function () {
          // This should not happen, but we want to be safe.

          /* istanbul ignore next */
          if (editLength > maxEditLength) {
            return callback();
          }

          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength) {
        var ret = execEditLength();

        if (ret) {
          return ret;
        }
      }
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  pushComponent: function pushComponent(components, added, removed) {
    var last = components[components.length - 1];

    if (last && last.added === added && last.removed === removed) {
      // We need to clone here as the component clone operation is just
      // as shallow array clone
      components[components.length - 1] = {
        count: last.count + 1,
        added: added,
        removed: removed
      };
    } else {
      components.push({
        count: 1,
        added: added,
        removed: removed
      });
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length,
        oldLen = oldString.length,
        newPos = basePath.newPos,
        oldPos = newPos - diagonalPath,
        commonCount = 0;

    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }

    if (commonCount) {
      basePath.components.push({
        count: commonCount
      });
    }

    basePath.newPos = newPos;
    return oldPos;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  removeEmpty: function removeEmpty(array) {
    var ret = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }

    return ret;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  castInput: function castInput(value) {
    return value;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  tokenize: function tokenize(value) {
    return value.split('');
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  join: function join(chars) {
    return chars.join('');
  }
};

function buildValues(diff, components, newString, oldString, useLongestToken) {
  var componentPos = 0,
      componentLen = components.length,
      newPos = 0,
      oldPos = 0;

  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];

    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function (value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        });
        component.value = diff.join(value);
      } else {
        component.value = diff.join(newString.slice(newPos, newPos + component.count));
      }

      newPos += component.count; // Common case

      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
      // The diffing algorithm is tied to add then remove output and this is the simplest
      // route to get the desired output with minimal overhead.

      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  } // Special case handle for when one terminal is ignored (i.e. whitespace).
  // For this case we merge the terminal into the prior string and drop the change.
  // This is only available for string mode.


  var lastComponent = components[componentLen - 1];

  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
    components[componentLen - 2].value += lastComponent.value;
    components.pop();
  }

  return components;
}

function clonePath(path) {
  return {
    newPos: path.newPos,
    components: path.components.slice(0)
  };
}


/***/ }),

/***/ "tI+e":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["components"]; }());

/***/ }),

/***/ "tr0p":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "__experimentalGetBorderClassesAndStyles", function() { return /* reexport */ getBorderClassesAndStyles; });
__webpack_require__.d(__webpack_exports__, "__experimentalUseBorderProps", function() { return /* reexport */ useBorderProps; });
__webpack_require__.d(__webpack_exports__, "__experimentalGetColorClassesAndStyles", function() { return /* reexport */ getColorClassesAndStyles; });
__webpack_require__.d(__webpack_exports__, "__experimentalUseColorProps", function() { return /* reexport */ useColorProps; });
__webpack_require__.d(__webpack_exports__, "__experimentalUseCustomSides", function() { return /* reexport */ useCustomSides; });
__webpack_require__.d(__webpack_exports__, "getColorClassName", function() { return /* reexport */ getColorClassName; });
__webpack_require__.d(__webpack_exports__, "getColorObjectByAttributeValues", function() { return /* reexport */ getColorObjectByAttributeValues; });
__webpack_require__.d(__webpack_exports__, "getColorObjectByColorValue", function() { return /* reexport */ getColorObjectByColorValue; });
__webpack_require__.d(__webpack_exports__, "createCustomColorsHOC", function() { return /* reexport */ createCustomColorsHOC; });
__webpack_require__.d(__webpack_exports__, "withColors", function() { return /* reexport */ withColors; });
__webpack_require__.d(__webpack_exports__, "__experimentalUseColors", function() { return /* reexport */ __experimentalUseColors; });
__webpack_require__.d(__webpack_exports__, "__experimentalGetGradientClass", function() { return /* reexport */ __experimentalGetGradientClass; });
__webpack_require__.d(__webpack_exports__, "getGradientValueBySlug", function() { return /* reexport */ getGradientValueBySlug; });
__webpack_require__.d(__webpack_exports__, "__experimentalGetGradientObjectByGradientValue", function() { return /* reexport */ __experimentalGetGradientObjectByGradientValue; });
__webpack_require__.d(__webpack_exports__, "getGradientSlugByValue", function() { return /* reexport */ getGradientSlugByValue; });
__webpack_require__.d(__webpack_exports__, "__experimentalUseGradient", function() { return /* reexport */ __experimentalUseGradient; });
__webpack_require__.d(__webpack_exports__, "getFontSize", function() { return /* reexport */ getFontSize; });
__webpack_require__.d(__webpack_exports__, "getFontSizeClass", function() { return /* reexport */ getFontSizeClass; });
__webpack_require__.d(__webpack_exports__, "getFontSizeObjectByValue", function() { return /* reexport */ getFontSizeObjectByValue; });
__webpack_require__.d(__webpack_exports__, "FontSizePicker", function() { return /* reexport */ font_size_picker; });
__webpack_require__.d(__webpack_exports__, "withFontSizes", function() { return /* reexport */ with_font_sizes; });
__webpack_require__.d(__webpack_exports__, "AlignmentControl", function() { return /* reexport */ AlignmentControl; });
__webpack_require__.d(__webpack_exports__, "AlignmentToolbar", function() { return /* reexport */ AlignmentToolbar; });
__webpack_require__.d(__webpack_exports__, "Autocomplete", function() { return /* reexport */ autocomplete; });
__webpack_require__.d(__webpack_exports__, "BlockAlignmentControl", function() { return /* reexport */ BlockAlignmentControl; });
__webpack_require__.d(__webpack_exports__, "BlockAlignmentToolbar", function() { return /* reexport */ BlockAlignmentToolbar; });
__webpack_require__.d(__webpack_exports__, "__experimentalBlockFullHeightAligmentControl", function() { return /* reexport */ block_full_height_alignment_control; });
__webpack_require__.d(__webpack_exports__, "__experimentalBlockAlignmentMatrixControl", function() { return /* reexport */ block_alignment_matrix_control; });
__webpack_require__.d(__webpack_exports__, "BlockBreadcrumb", function() { return /* reexport */ block_breadcrumb; });
__webpack_require__.d(__webpack_exports__, "BlockContextProvider", function() { return /* reexport */ BlockContextProvider; });
__webpack_require__.d(__webpack_exports__, "BlockControls", function() { return /* reexport */ block_controls; });
__webpack_require__.d(__webpack_exports__, "BlockFormatControls", function() { return /* reexport */ BlockFormatControls; });
__webpack_require__.d(__webpack_exports__, "BlockColorsStyleSelector", function() { return /* reexport */ color_style_selector; });
__webpack_require__.d(__webpack_exports__, "BlockEdit", function() { return /* reexport */ block_edit_BlockEdit; });
__webpack_require__.d(__webpack_exports__, "useBlockEditContext", function() { return /* reexport */ useBlockEditContext; });
__webpack_require__.d(__webpack_exports__, "BlockIcon", function() { return /* reexport */ BlockIcon; });
__webpack_require__.d(__webpack_exports__, "BlockNavigationDropdown", function() { return /* reexport */ dropdown; });
__webpack_require__.d(__webpack_exports__, "__experimentalBlockNavigationBlockFill", function() { return /* reexport */ BlockNavigationBlockFill; });
__webpack_require__.d(__webpack_exports__, "__experimentalBlockNavigationEditor", function() { return /* reexport */ BlockNavigationEditor; });
__webpack_require__.d(__webpack_exports__, "__experimentalBlockNavigationTree", function() { return /* reexport */ BlockNavigationTree; });
__webpack_require__.d(__webpack_exports__, "__experimentalBlockVariationPicker", function() { return /* reexport */ block_variation_picker; });
__webpack_require__.d(__webpack_exports__, "__experimentalBlockPatternSetup", function() { return /* reexport */ block_pattern_setup; });
__webpack_require__.d(__webpack_exports__, "__experimentalBlockVariationTransforms", function() { return /* reexport */ block_variation_transforms; });
__webpack_require__.d(__webpack_exports__, "BlockVerticalAlignmentToolbar", function() { return /* reexport */ BlockVerticalAlignmentToolbar; });
__webpack_require__.d(__webpack_exports__, "BlockVerticalAlignmentControl", function() { return /* reexport */ BlockVerticalAlignmentControl; });
__webpack_require__.d(__webpack_exports__, "__experimentalBorderStyleControl", function() { return /* reexport */ BorderStyleControl; });
__webpack_require__.d(__webpack_exports__, "ButtonBlockerAppender", function() { return /* reexport */ ButtonBlockerAppender; });
__webpack_require__.d(__webpack_exports__, "ButtonBlockAppender", function() { return /* reexport */ button_block_appender; });
__webpack_require__.d(__webpack_exports__, "ColorPalette", function() { return /* reexport */ color_palette; });
__webpack_require__.d(__webpack_exports__, "ColorPaletteControl", function() { return /* reexport */ ColorPaletteControl; });
__webpack_require__.d(__webpack_exports__, "ContrastChecker", function() { return /* reexport */ contrast_checker; });
__webpack_require__.d(__webpack_exports__, "__experimentalDuotoneControl", function() { return /* reexport */ duotone_control; });
__webpack_require__.d(__webpack_exports__, "__experimentalGradientPicker", function() { return /* reexport */ gradient_picker; });
__webpack_require__.d(__webpack_exports__, "__experimentalGradientPickerControl", function() { return /* reexport */ GradientPickerControl; });
__webpack_require__.d(__webpack_exports__, "__experimentalGradientPickerPanel", function() { return /* reexport */ GradientPanel; });
__webpack_require__.d(__webpack_exports__, "__experimentalFontAppearanceControl", function() { return /* reexport */ FontAppearanceControl; });
__webpack_require__.d(__webpack_exports__, "__experimentalFontFamilyControl", function() { return /* reexport */ FontFamilyControl; });
__webpack_require__.d(__webpack_exports__, "__experimentalColorGradientControl", function() { return /* reexport */ control; });
__webpack_require__.d(__webpack_exports__, "__experimentalPanelColorGradientSettings", function() { return /* reexport */ panel_color_gradient_settings; });
__webpack_require__.d(__webpack_exports__, "__experimentalImageSizeControl", function() { return /* reexport */ ImageSizeControl; });
__webpack_require__.d(__webpack_exports__, "InnerBlocks", function() { return /* reexport */ inner_blocks; });
__webpack_require__.d(__webpack_exports__, "__experimentalUseInnerBlocksProps", function() { return /* reexport */ useInnerBlocksProps; });
__webpack_require__.d(__webpack_exports__, "InspectorAdvancedControls", function() { return /* reexport */ inspector_advanced_controls; });
__webpack_require__.d(__webpack_exports__, "InspectorControls", function() { return /* reexport */ inspector_controls; });
__webpack_require__.d(__webpack_exports__, "JustifyToolbar", function() { return /* reexport */ JustifyToolbar; });
__webpack_require__.d(__webpack_exports__, "JustifyContentControl", function() { return /* reexport */ JustifyContentControl; });
__webpack_require__.d(__webpack_exports__, "__experimentalLinkControl", function() { return /* reexport */ link_control; });
__webpack_require__.d(__webpack_exports__, "__experimentalLinkControlSearchInput", function() { return /* reexport */ search_input; });
__webpack_require__.d(__webpack_exports__, "__experimentalLinkControlSearchResults", function() { return /* reexport */ LinkControlSearchResults; });
__webpack_require__.d(__webpack_exports__, "__experimentalLinkControlSearchItem", function() { return /* reexport */ search_item; });
__webpack_require__.d(__webpack_exports__, "LineHeightControl", function() { return /* reexport */ LineHeightControl; });
__webpack_require__.d(__webpack_exports__, "MediaReplaceFlow", function() { return /* reexport */ media_replace_flow; });
__webpack_require__.d(__webpack_exports__, "MediaPlaceholder", function() { return /* reexport */ media_placeholder; });
__webpack_require__.d(__webpack_exports__, "MediaUpload", function() { return /* reexport */ media_upload; });
__webpack_require__.d(__webpack_exports__, "MediaUploadCheck", function() { return /* reexport */ check; });
__webpack_require__.d(__webpack_exports__, "PanelColorSettings", function() { return /* reexport */ panel_color_settings; });
__webpack_require__.d(__webpack_exports__, "PlainText", function() { return /* reexport */ plain_text; });
__webpack_require__.d(__webpack_exports__, "__experimentalResponsiveBlockControl", function() { return /* reexport */ responsive_block_control; });
__webpack_require__.d(__webpack_exports__, "RichText", function() { return /* reexport */ rich_text; });
__webpack_require__.d(__webpack_exports__, "RichTextShortcut", function() { return /* reexport */ RichTextShortcut; });
__webpack_require__.d(__webpack_exports__, "RichTextToolbarButton", function() { return /* reexport */ RichTextToolbarButton; });
__webpack_require__.d(__webpack_exports__, "__unstableRichTextInputEvent", function() { return /* reexport */ input_event_unstableRichTextInputEvent; });
__webpack_require__.d(__webpack_exports__, "ToolSelector", function() { return /* reexport */ tool_selector; });
__webpack_require__.d(__webpack_exports__, "__experimentalUnitControl", function() { return /* reexport */ UnitControl; });
__webpack_require__.d(__webpack_exports__, "URLInput", function() { return /* reexport */ url_input; });
__webpack_require__.d(__webpack_exports__, "URLInputButton", function() { return /* reexport */ url_input_button; });
__webpack_require__.d(__webpack_exports__, "URLPopover", function() { return /* reexport */ url_popover; });
__webpack_require__.d(__webpack_exports__, "__experimentalImageURLInputUI", function() { return /* reexport */ ImageURLInputUI; });
__webpack_require__.d(__webpack_exports__, "withColorContext", function() { return /* reexport */ with_color_context; });
__webpack_require__.d(__webpack_exports__, "__unstableBlockSettingsMenuFirstItem", function() { return /* reexport */ block_settings_menu_first_item; });
__webpack_require__.d(__webpack_exports__, "__unstableInserterMenuExtension", function() { return /* reexport */ inserter_menu_extension; });
__webpack_require__.d(__webpack_exports__, "__experimentalPreviewOptions", function() { return /* reexport */ PreviewOptions; });
__webpack_require__.d(__webpack_exports__, "__experimentalUseResizeCanvas", function() { return /* reexport */ useResizeCanvas; });
__webpack_require__.d(__webpack_exports__, "BlockInspector", function() { return /* reexport */ block_inspector; });
__webpack_require__.d(__webpack_exports__, "BlockList", function() { return /* reexport */ BlockList; });
__webpack_require__.d(__webpack_exports__, "useBlockProps", function() { return /* reexport */ useBlockProps; });
__webpack_require__.d(__webpack_exports__, "__experimentalLayoutStyle", function() { return /* reexport */ LayoutStyle; });
__webpack_require__.d(__webpack_exports__, "BlockMover", function() { return /* reexport */ block_mover; });
__webpack_require__.d(__webpack_exports__, "BlockPreview", function() { return /* reexport */ block_preview; });
__webpack_require__.d(__webpack_exports__, "BlockSelectionClearer", function() { return /* reexport */ BlockSelectionClearer; });
__webpack_require__.d(__webpack_exports__, "__unstableUseBlockSelectionClearer", function() { return /* reexport */ useBlockSelectionClearer; });
__webpack_require__.d(__webpack_exports__, "BlockSettingsMenu", function() { return /* reexport */ block_settings_menu; });
__webpack_require__.d(__webpack_exports__, "BlockSettingsMenuControls", function() { return /* reexport */ block_settings_menu_controls; });
__webpack_require__.d(__webpack_exports__, "BlockTitle", function() { return /* reexport */ BlockTitle; });
__webpack_require__.d(__webpack_exports__, "BlockToolbar", function() { return /* reexport */ BlockToolbar; });
__webpack_require__.d(__webpack_exports__, "BlockTools", function() { return /* reexport */ BlockTools; });
__webpack_require__.d(__webpack_exports__, "CopyHandler", function() { return /* reexport */ copy_handler; });
__webpack_require__.d(__webpack_exports__, "__unstableUseClipboardHandler", function() { return /* reexport */ useClipboardHandler; });
__webpack_require__.d(__webpack_exports__, "DefaultBlockAppender", function() { return /* reexport */ default_block_appender; });
__webpack_require__.d(__webpack_exports__, "__unstableEditorStyles", function() { return /* reexport */ EditorStyles; });
__webpack_require__.d(__webpack_exports__, "Inserter", function() { return /* reexport */ inserter; });
__webpack_require__.d(__webpack_exports__, "__experimentalLibrary", function() { return /* reexport */ library; });
__webpack_require__.d(__webpack_exports__, "__experimentalSearchForm", function() { return /* reexport */ search_form; });
__webpack_require__.d(__webpack_exports__, "BlockEditorKeyboardShortcuts", function() { return /* reexport */ keyboard_shortcuts; });
__webpack_require__.d(__webpack_exports__, "MultiSelectScrollIntoView", function() { return /* reexport */ MultiSelectScrollIntoView; });
__webpack_require__.d(__webpack_exports__, "NavigableToolbar", function() { return /* reexport */ navigable_toolbar; });
__webpack_require__.d(__webpack_exports__, "ObserveTyping", function() { return /* reexport */ observe_typing; });
__webpack_require__.d(__webpack_exports__, "__unstableUseTypingObserver", function() { return /* reexport */ useTypingObserver; });
__webpack_require__.d(__webpack_exports__, "__unstableUseMouseMoveTypingReset", function() { return /* reexport */ useMouseMoveTypingReset; });
__webpack_require__.d(__webpack_exports__, "PreserveScrollInReorder", function() { return /* reexport */ PreserveScrollInReorder; });
__webpack_require__.d(__webpack_exports__, "SkipToSelectedBlock", function() { return /* reexport */ skip_to_selected_block; });
__webpack_require__.d(__webpack_exports__, "Typewriter", function() { return /* reexport */ typewriter; });
__webpack_require__.d(__webpack_exports__, "__unstableUseTypewriter", function() { return /* reexport */ useTypewriter; });
__webpack_require__.d(__webpack_exports__, "Warning", function() { return /* reexport */ warning; });
__webpack_require__.d(__webpack_exports__, "WritingFlow", function() { return /* reexport */ writing_flow; });
__webpack_require__.d(__webpack_exports__, "__unstableUseCanvasClickRedirect", function() { return /* reexport */ useCanvasClickRedirect; });
__webpack_require__.d(__webpack_exports__, "useBlockDisplayInformation", function() { return /* reexport */ useBlockDisplayInformation; });
__webpack_require__.d(__webpack_exports__, "__unstableIframe", function() { return /* reexport */ iframe; });
__webpack_require__.d(__webpack_exports__, "__experimentalUseNoRecursiveRenders", function() { return /* reexport */ useNoRecursiveRenders; });
__webpack_require__.d(__webpack_exports__, "BlockEditorProvider", function() { return /* reexport */ provider; });
__webpack_require__.d(__webpack_exports__, "__experimentalUseSimulatedMediaQuery", function() { return /* reexport */ useSimulatedMediaQuery; });
__webpack_require__.d(__webpack_exports__, "useSetting", function() { return /* reexport */ useSetting; });
__webpack_require__.d(__webpack_exports__, "transformStyles", function() { return /* reexport */ transform_styles; });
__webpack_require__.d(__webpack_exports__, "validateThemeColors", function() { return /* reexport */ validateThemeColors; });
__webpack_require__.d(__webpack_exports__, "validateThemeGradients", function() { return /* reexport */ validateThemeGradients; });
__webpack_require__.d(__webpack_exports__, "__experimentalGetMatchingVariation", function() { return /* reexport */ __experimentalGetMatchingVariation; });
__webpack_require__.d(__webpack_exports__, "storeConfig", function() { return /* reexport */ storeConfig; });
__webpack_require__.d(__webpack_exports__, "store", function() { return /* reexport */ store; });
__webpack_require__.d(__webpack_exports__, "SETTINGS_DEFAULTS", function() { return /* reexport */ SETTINGS_DEFAULTS; });

// NAMESPACE OBJECT: ./node_modules/@wordpress/block-editor/build-module/store/selectors.js
var selectors_namespaceObject = {};
__webpack_require__.r(selectors_namespaceObject);
__webpack_require__.d(selectors_namespaceObject, "getBlockName", function() { return selectors_getBlockName; });
__webpack_require__.d(selectors_namespaceObject, "isBlockValid", function() { return selectors_isBlockValid; });
__webpack_require__.d(selectors_namespaceObject, "getBlockAttributes", function() { return selectors_getBlockAttributes; });
__webpack_require__.d(selectors_namespaceObject, "getBlock", function() { return selectors_getBlock; });
__webpack_require__.d(selectors_namespaceObject, "__unstableGetBlockWithoutInnerBlocks", function() { return selectors_unstableGetBlockWithoutInnerBlocks; });
__webpack_require__.d(selectors_namespaceObject, "getBlocks", function() { return selectors_getBlocks; });
__webpack_require__.d(selectors_namespaceObject, "__unstableGetBlockWithBlockTree", function() { return __unstableGetBlockWithBlockTree; });
__webpack_require__.d(selectors_namespaceObject, "__unstableGetBlockTree", function() { return __unstableGetBlockTree; });
__webpack_require__.d(selectors_namespaceObject, "__unstableGetClientIdWithClientIdsTree", function() { return selectors_unstableGetClientIdWithClientIdsTree; });
__webpack_require__.d(selectors_namespaceObject, "__unstableGetClientIdsTree", function() { return selectors_unstableGetClientIdsTree; });
__webpack_require__.d(selectors_namespaceObject, "getClientIdsOfDescendants", function() { return selectors_getClientIdsOfDescendants; });
__webpack_require__.d(selectors_namespaceObject, "getClientIdsWithDescendants", function() { return getClientIdsWithDescendants; });
__webpack_require__.d(selectors_namespaceObject, "getGlobalBlockCount", function() { return selectors_getGlobalBlockCount; });
__webpack_require__.d(selectors_namespaceObject, "getBlocksByClientId", function() { return selectors_getBlocksByClientId; });
__webpack_require__.d(selectors_namespaceObject, "getBlockCount", function() { return selectors_getBlockCount; });
__webpack_require__.d(selectors_namespaceObject, "getSelectionStart", function() { return selectors_getSelectionStart; });
__webpack_require__.d(selectors_namespaceObject, "getSelectionEnd", function() { return selectors_getSelectionEnd; });
__webpack_require__.d(selectors_namespaceObject, "getBlockSelectionStart", function() { return selectors_getBlockSelectionStart; });
__webpack_require__.d(selectors_namespaceObject, "getBlockSelectionEnd", function() { return selectors_getBlockSelectionEnd; });
__webpack_require__.d(selectors_namespaceObject, "getSelectedBlockCount", function() { return selectors_getSelectedBlockCount; });
__webpack_require__.d(selectors_namespaceObject, "hasSelectedBlock", function() { return selectors_hasSelectedBlock; });
__webpack_require__.d(selectors_namespaceObject, "getSelectedBlockClientId", function() { return selectors_getSelectedBlockClientId; });
__webpack_require__.d(selectors_namespaceObject, "getSelectedBlock", function() { return selectors_getSelectedBlock; });
__webpack_require__.d(selectors_namespaceObject, "getBlockRootClientId", function() { return selectors_getBlockRootClientId; });
__webpack_require__.d(selectors_namespaceObject, "getBlockParents", function() { return selectors_getBlockParents; });
__webpack_require__.d(selectors_namespaceObject, "getBlockParentsByBlockName", function() { return getBlockParentsByBlockName; });
__webpack_require__.d(selectors_namespaceObject, "getBlockHierarchyRootClientId", function() { return selectors_getBlockHierarchyRootClientId; });
__webpack_require__.d(selectors_namespaceObject, "getLowestCommonAncestorWithSelectedBlock", function() { return getLowestCommonAncestorWithSelectedBlock; });
__webpack_require__.d(selectors_namespaceObject, "getAdjacentBlockClientId", function() { return getAdjacentBlockClientId; });
__webpack_require__.d(selectors_namespaceObject, "getPreviousBlockClientId", function() { return selectors_getPreviousBlockClientId; });
__webpack_require__.d(selectors_namespaceObject, "getNextBlockClientId", function() { return selectors_getNextBlockClientId; });
__webpack_require__.d(selectors_namespaceObject, "getSelectedBlocksInitialCaretPosition", function() { return selectors_getSelectedBlocksInitialCaretPosition; });
__webpack_require__.d(selectors_namespaceObject, "getSelectedBlockClientIds", function() { return selectors_getSelectedBlockClientIds; });
__webpack_require__.d(selectors_namespaceObject, "getMultiSelectedBlockClientIds", function() { return selectors_getMultiSelectedBlockClientIds; });
__webpack_require__.d(selectors_namespaceObject, "getMultiSelectedBlocks", function() { return selectors_getMultiSelectedBlocks; });
__webpack_require__.d(selectors_namespaceObject, "getFirstMultiSelectedBlockClientId", function() { return selectors_getFirstMultiSelectedBlockClientId; });
__webpack_require__.d(selectors_namespaceObject, "getLastMultiSelectedBlockClientId", function() { return selectors_getLastMultiSelectedBlockClientId; });
__webpack_require__.d(selectors_namespaceObject, "isFirstMultiSelectedBlock", function() { return selectors_isFirstMultiSelectedBlock; });
__webpack_require__.d(selectors_namespaceObject, "isBlockMultiSelected", function() { return selectors_isBlockMultiSelected; });
__webpack_require__.d(selectors_namespaceObject, "isAncestorMultiSelected", function() { return selectors_isAncestorMultiSelected; });
__webpack_require__.d(selectors_namespaceObject, "getMultiSelectedBlocksStartClientId", function() { return selectors_getMultiSelectedBlocksStartClientId; });
__webpack_require__.d(selectors_namespaceObject, "getMultiSelectedBlocksEndClientId", function() { return selectors_getMultiSelectedBlocksEndClientId; });
__webpack_require__.d(selectors_namespaceObject, "getBlockOrder", function() { return selectors_getBlockOrder; });
__webpack_require__.d(selectors_namespaceObject, "getBlockIndex", function() { return selectors_getBlockIndex; });
__webpack_require__.d(selectors_namespaceObject, "isBlockSelected", function() { return selectors_isBlockSelected; });
__webpack_require__.d(selectors_namespaceObject, "hasSelectedInnerBlock", function() { return selectors_hasSelectedInnerBlock; });
__webpack_require__.d(selectors_namespaceObject, "isBlockWithinSelection", function() { return isBlockWithinSelection; });
__webpack_require__.d(selectors_namespaceObject, "hasMultiSelection", function() { return selectors_hasMultiSelection; });
__webpack_require__.d(selectors_namespaceObject, "isMultiSelecting", function() { return selectors_isMultiSelecting; });
__webpack_require__.d(selectors_namespaceObject, "isSelectionEnabled", function() { return selectors_isSelectionEnabled; });
__webpack_require__.d(selectors_namespaceObject, "getBlockMode", function() { return selectors_getBlockMode; });
__webpack_require__.d(selectors_namespaceObject, "isTyping", function() { return selectors_isTyping; });
__webpack_require__.d(selectors_namespaceObject, "isDraggingBlocks", function() { return isDraggingBlocks; });
__webpack_require__.d(selectors_namespaceObject, "getDraggedBlockClientIds", function() { return selectors_getDraggedBlockClientIds; });
__webpack_require__.d(selectors_namespaceObject, "isBlockBeingDragged", function() { return selectors_isBlockBeingDragged; });
__webpack_require__.d(selectors_namespaceObject, "isAncestorBeingDragged", function() { return selectors_isAncestorBeingDragged; });
__webpack_require__.d(selectors_namespaceObject, "isCaretWithinFormattedText", function() { return selectors_isCaretWithinFormattedText; });
__webpack_require__.d(selectors_namespaceObject, "getBlockInsertionPoint", function() { return selectors_getBlockInsertionPoint; });
__webpack_require__.d(selectors_namespaceObject, "isBlockInsertionPointVisible", function() { return selectors_isBlockInsertionPointVisible; });
__webpack_require__.d(selectors_namespaceObject, "isValidTemplate", function() { return selectors_isValidTemplate; });
__webpack_require__.d(selectors_namespaceObject, "getTemplate", function() { return getTemplate; });
__webpack_require__.d(selectors_namespaceObject, "getTemplateLock", function() { return selectors_getTemplateLock; });
__webpack_require__.d(selectors_namespaceObject, "canInsertBlockType", function() { return selectors_canInsertBlockType; });
__webpack_require__.d(selectors_namespaceObject, "canInsertBlocks", function() { return selectors_canInsertBlocks; });
__webpack_require__.d(selectors_namespaceObject, "getInserterItems", function() { return selectors_getInserterItems; });
__webpack_require__.d(selectors_namespaceObject, "getBlockTransformItems", function() { return selectors_getBlockTransformItems; });
__webpack_require__.d(selectors_namespaceObject, "hasInserterItems", function() { return selectors_hasInserterItems; });
__webpack_require__.d(selectors_namespaceObject, "__experimentalGetAllowedBlocks", function() { return selectors_experimentalGetAllowedBlocks; });
__webpack_require__.d(selectors_namespaceObject, "__experimentalGetParsedPattern", function() { return __experimentalGetParsedPattern; });
__webpack_require__.d(selectors_namespaceObject, "__experimentalGetAllowedPatterns", function() { return selectors_experimentalGetAllowedPatterns; });
__webpack_require__.d(selectors_namespaceObject, "__experimentalGetPatternsByBlockTypes", function() { return selectors_experimentalGetPatternsByBlockTypes; });
__webpack_require__.d(selectors_namespaceObject, "__experimentalGetPatternTransformItems", function() { return selectors_experimentalGetPatternTransformItems; });
__webpack_require__.d(selectors_namespaceObject, "getBlockListSettings", function() { return selectors_getBlockListSettings; });
__webpack_require__.d(selectors_namespaceObject, "getSettings", function() { return selectors_getSettings; });
__webpack_require__.d(selectors_namespaceObject, "isLastBlockChangePersistent", function() { return selectors_isLastBlockChangePersistent; });
__webpack_require__.d(selectors_namespaceObject, "__experimentalGetBlockListSettingsForBlocks", function() { return selectors_experimentalGetBlockListSettingsForBlocks; });
__webpack_require__.d(selectors_namespaceObject, "__experimentalGetParsedReusableBlock", function() { return __experimentalGetParsedReusableBlock; });
__webpack_require__.d(selectors_namespaceObject, "__experimentalGetReusableBlockTitle", function() { return selectors_experimentalGetReusableBlockTitle; });
__webpack_require__.d(selectors_namespaceObject, "__unstableIsLastBlockChangeIgnored", function() { return selectors_unstableIsLastBlockChangeIgnored; });
__webpack_require__.d(selectors_namespaceObject, "__experimentalGetLastBlockAttributeChanges", function() { return __experimentalGetLastBlockAttributeChanges; });
__webpack_require__.d(selectors_namespaceObject, "isNavigationMode", function() { return selectors_isNavigationMode; });
__webpack_require__.d(selectors_namespaceObject, "hasBlockMovingClientId", function() { return selectors_hasBlockMovingClientId; });
__webpack_require__.d(selectors_namespaceObject, "didAutomaticChange", function() { return selectors_didAutomaticChange; });
__webpack_require__.d(selectors_namespaceObject, "isBlockHighlighted", function() { return selectors_isBlockHighlighted; });
__webpack_require__.d(selectors_namespaceObject, "areInnerBlocksControlled", function() { return areInnerBlocksControlled; });
__webpack_require__.d(selectors_namespaceObject, "__experimentalGetActiveBlockIdByBlockNames", function() { return __experimentalGetActiveBlockIdByBlockNames; });
__webpack_require__.d(selectors_namespaceObject, "wasBlockJustInserted", function() { return wasBlockJustInserted; });

// NAMESPACE OBJECT: ./node_modules/@wordpress/block-editor/build-module/store/actions.js
var actions_namespaceObject = {};
__webpack_require__.r(actions_namespaceObject);
__webpack_require__.d(actions_namespaceObject, "resetBlocks", function() { return actions_resetBlocks; });
__webpack_require__.d(actions_namespaceObject, "validateBlocksToTemplate", function() { return validateBlocksToTemplate; });
__webpack_require__.d(actions_namespaceObject, "resetSelection", function() { return actions_resetSelection; });
__webpack_require__.d(actions_namespaceObject, "receiveBlocks", function() { return receiveBlocks; });
__webpack_require__.d(actions_namespaceObject, "updateBlockAttributes", function() { return actions_updateBlockAttributes; });
__webpack_require__.d(actions_namespaceObject, "updateBlock", function() { return actions_updateBlock; });
__webpack_require__.d(actions_namespaceObject, "selectBlock", function() { return actions_selectBlock; });
__webpack_require__.d(actions_namespaceObject, "selectPreviousBlock", function() { return selectPreviousBlock; });
__webpack_require__.d(actions_namespaceObject, "selectNextBlock", function() { return selectNextBlock; });
__webpack_require__.d(actions_namespaceObject, "startMultiSelect", function() { return actions_startMultiSelect; });
__webpack_require__.d(actions_namespaceObject, "stopMultiSelect", function() { return actions_stopMultiSelect; });
__webpack_require__.d(actions_namespaceObject, "multiSelect", function() { return actions_multiSelect; });
__webpack_require__.d(actions_namespaceObject, "clearSelectedBlock", function() { return actions_clearSelectedBlock; });
__webpack_require__.d(actions_namespaceObject, "toggleSelection", function() { return actions_toggleSelection; });
__webpack_require__.d(actions_namespaceObject, "replaceBlocks", function() { return actions_replaceBlocks; });
__webpack_require__.d(actions_namespaceObject, "replaceBlock", function() { return actions_replaceBlock; });
__webpack_require__.d(actions_namespaceObject, "moveBlocksDown", function() { return actions_moveBlocksDown; });
__webpack_require__.d(actions_namespaceObject, "moveBlocksUp", function() { return actions_moveBlocksUp; });
__webpack_require__.d(actions_namespaceObject, "moveBlocksToPosition", function() { return actions_moveBlocksToPosition; });
__webpack_require__.d(actions_namespaceObject, "moveBlockToPosition", function() { return actions_moveBlockToPosition; });
__webpack_require__.d(actions_namespaceObject, "insertBlock", function() { return actions_insertBlock; });
__webpack_require__.d(actions_namespaceObject, "insertBlocks", function() { return actions_insertBlocks; });
__webpack_require__.d(actions_namespaceObject, "showInsertionPoint", function() { return actions_showInsertionPoint; });
__webpack_require__.d(actions_namespaceObject, "hideInsertionPoint", function() { return actions_hideInsertionPoint; });
__webpack_require__.d(actions_namespaceObject, "setTemplateValidity", function() { return setTemplateValidity; });
__webpack_require__.d(actions_namespaceObject, "synchronizeTemplate", function() { return synchronizeTemplate; });
__webpack_require__.d(actions_namespaceObject, "mergeBlocks", function() { return actions_mergeBlocks; });
__webpack_require__.d(actions_namespaceObject, "removeBlocks", function() { return actions_removeBlocks; });
__webpack_require__.d(actions_namespaceObject, "removeBlock", function() { return actions_removeBlock; });
__webpack_require__.d(actions_namespaceObject, "replaceInnerBlocks", function() { return actions_replaceInnerBlocks; });
__webpack_require__.d(actions_namespaceObject, "toggleBlockMode", function() { return toggleBlockMode; });
__webpack_require__.d(actions_namespaceObject, "startTyping", function() { return actions_startTyping; });
__webpack_require__.d(actions_namespaceObject, "stopTyping", function() { return actions_stopTyping; });
__webpack_require__.d(actions_namespaceObject, "startDraggingBlocks", function() { return actions_startDraggingBlocks; });
__webpack_require__.d(actions_namespaceObject, "stopDraggingBlocks", function() { return actions_stopDraggingBlocks; });
__webpack_require__.d(actions_namespaceObject, "enterFormattedText", function() { return actions_enterFormattedText; });
__webpack_require__.d(actions_namespaceObject, "exitFormattedText", function() { return actions_exitFormattedText; });
__webpack_require__.d(actions_namespaceObject, "selectionChange", function() { return actions_selectionChange; });
__webpack_require__.d(actions_namespaceObject, "insertDefaultBlock", function() { return actions_insertDefaultBlock; });
__webpack_require__.d(actions_namespaceObject, "updateBlockListSettings", function() { return actions_updateBlockListSettings; });
__webpack_require__.d(actions_namespaceObject, "updateSettings", function() { return actions_updateSettings; });
__webpack_require__.d(actions_namespaceObject, "__unstableSaveReusableBlock", function() { return __unstableSaveReusableBlock; });
__webpack_require__.d(actions_namespaceObject, "__unstableMarkLastChangeAsPersistent", function() { return actions_unstableMarkLastChangeAsPersistent; });
__webpack_require__.d(actions_namespaceObject, "__unstableMarkNextChangeAsNotPersistent", function() { return actions_unstableMarkNextChangeAsNotPersistent; });
__webpack_require__.d(actions_namespaceObject, "__unstableMarkAutomaticChange", function() { return actions_unstableMarkAutomaticChange; });
__webpack_require__.d(actions_namespaceObject, "__unstableMarkAutomaticChangeFinal", function() { return __unstableMarkAutomaticChangeFinal; });
__webpack_require__.d(actions_namespaceObject, "setNavigationMode", function() { return actions_setNavigationMode; });
__webpack_require__.d(actions_namespaceObject, "setBlockMovingClientId", function() { return actions_setBlockMovingClientId; });
__webpack_require__.d(actions_namespaceObject, "duplicateBlocks", function() { return actions_duplicateBlocks; });
__webpack_require__.d(actions_namespaceObject, "insertBeforeBlock", function() { return actions_insertBeforeBlock; });
__webpack_require__.d(actions_namespaceObject, "insertAfterBlock", function() { return actions_insertAfterBlock; });
__webpack_require__.d(actions_namespaceObject, "toggleBlockHighlight", function() { return actions_toggleBlockHighlight; });
__webpack_require__.d(actions_namespaceObject, "flashBlock", function() { return actions_flashBlock; });
__webpack_require__.d(actions_namespaceObject, "setHasControlledInnerBlocks", function() { return actions_setHasControlledInnerBlocks; });

// EXTERNAL MODULE: external ["wp","richText"]
var external_wp_richText_ = __webpack_require__("qRz9");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__("wx14");

// EXTERNAL MODULE: external ["wp","element"]
var external_wp_element_ = __webpack_require__("GRId");

// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__("TSYQ");
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// EXTERNAL MODULE: external "lodash"
var external_lodash_ = __webpack_require__("YLtl");

// EXTERNAL MODULE: external ["wp","compose"]
var external_wp_compose_ = __webpack_require__("K9lf");

// EXTERNAL MODULE: external ["wp","hooks"]
var external_wp_hooks_ = __webpack_require__("g56x");

// EXTERNAL MODULE: external ["wp","blocks"]
var external_wp_blocks_ = __webpack_require__("HSyU");

// EXTERNAL MODULE: external ["wp","components"]
var external_wp_components_ = __webpack_require__("tI+e");

// EXTERNAL MODULE: external ["wp","data"]
var external_wp_data_ = __webpack_require__("1ZqX");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-edit/context.js
/**
 * WordPress dependencies
 */

const Context = Object(external_wp_element_["createContext"])({
  name: '',
  isSelected: false,
  clientId: null
});
const {
  Provider: context_Provider
} = Context;

/**
 * A hook that returns the block edit context.
 *
 * @return {Object} Block edit context
 */

function useBlockEditContext() {
  return Object(external_wp_element_["useContext"])(Context);
}

// EXTERNAL MODULE: external ["wp","i18n"]
var external_wp_i18n_ = __webpack_require__("l3Sj");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/store/defaults.js
/**
 * WordPress dependencies
 */

const PREFERENCES_DEFAULTS = {
  insertUsage: {}
};
/**
 * The default editor settings
 *
 * @typedef {Object} SETTINGS_DEFAULT
 * @property {boolean} alignWide Enable/Disable Wide/Full Alignments
 * @property {boolean} supportsLayout Enable/disable layouts support in container blocks.
 * @property {boolean} imageEditing Image Editing settings set to false to disable.
 * @property {Array} imageSizes Available image sizes
 * @property {number} maxWidth Max width to constraint resizing
 * @property {boolean|Array} allowedBlockTypes Allowed block types
 * @property {boolean} hasFixedToolbar Whether or not the editor toolbar is fixed
 * @property {boolean} focusMode Whether the focus mode is enabled or not
 * @property {Array} styles Editor Styles
 * @property {boolean} keepCaretInsideBlock Whether caret should move between blocks in edit mode
 * @property {string} bodyPlaceholder Empty post placeholder
 * @property {string} titlePlaceholder Empty title placeholder
 * @property {boolean} codeEditingEnabled Whether or not the user can switch to the code editor
 * @property {boolean} __experimentalCanUserUseUnfilteredHTML Whether the user should be able to use unfiltered HTML or the HTML should be filtered e.g., to remove elements considered insecure like iframes.
 * @property {boolean} __experimentalBlockDirectory Whether the user has enabled the Block Directory
 * @property {Array} __experimentalBlockPatterns Array of objects representing the block patterns
 * @property {Array} __experimentalBlockPatternCategories Array of objects representing the block pattern categories
 */

const SETTINGS_DEFAULTS = {
  alignWide: false,
  supportsLayout: true,
  // colors setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
  // The setting is only kept for backward compatibility purposes.
  colors: [{
    name: Object(external_wp_i18n_["__"])('Black'),
    slug: 'black',
    color: '#000000'
  }, {
    name: Object(external_wp_i18n_["__"])('Cyan bluish gray'),
    slug: 'cyan-bluish-gray',
    color: '#abb8c3'
  }, {
    name: Object(external_wp_i18n_["__"])('White'),
    slug: 'white',
    color: '#ffffff'
  }, {
    name: Object(external_wp_i18n_["__"])('Pale pink'),
    slug: 'pale-pink',
    color: '#f78da7'
  }, {
    name: Object(external_wp_i18n_["__"])('Vivid red'),
    slug: 'vivid-red',
    color: '#cf2e2e'
  }, {
    name: Object(external_wp_i18n_["__"])('Luminous vivid orange'),
    slug: 'luminous-vivid-orange',
    color: '#ff6900'
  }, {
    name: Object(external_wp_i18n_["__"])('Luminous vivid amber'),
    slug: 'luminous-vivid-amber',
    color: '#fcb900'
  }, {
    name: Object(external_wp_i18n_["__"])('Light green cyan'),
    slug: 'light-green-cyan',
    color: '#7bdcb5'
  }, {
    name: Object(external_wp_i18n_["__"])('Vivid green cyan'),
    slug: 'vivid-green-cyan',
    color: '#00d084'
  }, {
    name: Object(external_wp_i18n_["__"])('Pale cyan blue'),
    slug: 'pale-cyan-blue',
    color: '#8ed1fc'
  }, {
    name: Object(external_wp_i18n_["__"])('Vivid cyan blue'),
    slug: 'vivid-cyan-blue',
    color: '#0693e3'
  }, {
    name: Object(external_wp_i18n_["__"])('Vivid purple'),
    slug: 'vivid-purple',
    color: '#9b51e0'
  }],
  // fontSizes setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
  // The setting is only kept for backward compatibility purposes.
  fontSizes: [{
    name: Object(external_wp_i18n_["_x"])('Small', 'font size name'),
    size: 13,
    slug: 'small'
  }, {
    name: Object(external_wp_i18n_["_x"])('Normal', 'font size name'),
    size: 16,
    slug: 'normal'
  }, {
    name: Object(external_wp_i18n_["_x"])('Medium', 'font size name'),
    size: 20,
    slug: 'medium'
  }, {
    name: Object(external_wp_i18n_["_x"])('Large', 'font size name'),
    size: 36,
    slug: 'large'
  }, {
    name: Object(external_wp_i18n_["_x"])('Huge', 'font size name'),
    size: 42,
    slug: 'huge'
  }],
  // Image default size slug.
  imageDefaultSize: 'large',
  imageSizes: [{
    slug: 'thumbnail',
    name: Object(external_wp_i18n_["__"])('Thumbnail')
  }, {
    slug: 'medium',
    name: Object(external_wp_i18n_["__"])('Medium')
  }, {
    slug: 'large',
    name: Object(external_wp_i18n_["__"])('Large')
  }, {
    slug: 'full',
    name: Object(external_wp_i18n_["__"])('Full Size')
  }],
  // Allow plugin to disable Image Editor if need be
  imageEditing: true,
  // This is current max width of the block inner area
  // It's used to constraint image resizing and this value could be overridden later by themes
  maxWidth: 580,
  // Allowed block types for the editor, defaulting to true (all supported).
  allowedBlockTypes: true,
  // Maximum upload size in bytes allowed for the site.
  maxUploadFileSize: 0,
  // List of allowed mime types and file extensions.
  allowedMimeTypes: null,
  __experimentalCanUserUseUnfilteredHTML: false,
  __experimentalBlockDirectory: false,
  __mobileEnablePageTemplates: false,
  __experimentalBlockPatterns: [],
  __experimentalBlockPatternCategories: [],
  __experimentalSpotlightEntityBlocks: [],
  // gradients setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
  // The setting is only kept for backward compatibility purposes.
  gradients: [{
    name: Object(external_wp_i18n_["__"])('Vivid cyan blue to vivid purple'),
    gradient: 'linear-gradient(135deg,rgba(6,147,227,1) 0%,rgb(155,81,224) 100%)',
    slug: 'vivid-cyan-blue-to-vivid-purple'
  }, {
    name: Object(external_wp_i18n_["__"])('Light green cyan to vivid green cyan'),
    gradient: 'linear-gradient(135deg,rgb(122,220,180) 0%,rgb(0,208,130) 100%)',
    slug: 'light-green-cyan-to-vivid-green-cyan'
  }, {
    name: Object(external_wp_i18n_["__"])('Luminous vivid amber to luminous vivid orange'),
    gradient: 'linear-gradient(135deg,rgba(252,185,0,1) 0%,rgba(255,105,0,1) 100%)',
    slug: 'luminous-vivid-amber-to-luminous-vivid-orange'
  }, {
    name: Object(external_wp_i18n_["__"])('Luminous vivid orange to vivid red'),
    gradient: 'linear-gradient(135deg,rgba(255,105,0,1) 0%,rgb(207,46,46) 100%)',
    slug: 'luminous-vivid-orange-to-vivid-red'
  }, {
    name: Object(external_wp_i18n_["__"])('Very light gray to cyan bluish gray'),
    gradient: 'linear-gradient(135deg,rgb(238,238,238) 0%,rgb(169,184,195) 100%)',
    slug: 'very-light-gray-to-cyan-bluish-gray'
  }, {
    name: Object(external_wp_i18n_["__"])('Cool to warm spectrum'),
    gradient: 'linear-gradient(135deg,rgb(74,234,220) 0%,rgb(151,120,209) 20%,rgb(207,42,186) 40%,rgb(238,44,130) 60%,rgb(251,105,98) 80%,rgb(254,248,76) 100%)',
    slug: 'cool-to-warm-spectrum'
  }, {
    name: Object(external_wp_i18n_["__"])('Blush light purple'),
    gradient: 'linear-gradient(135deg,rgb(255,206,236) 0%,rgb(152,150,240) 100%)',
    slug: 'blush-light-purple'
  }, {
    name: Object(external_wp_i18n_["__"])('Blush bordeaux'),
    gradient: 'linear-gradient(135deg,rgb(254,205,165) 0%,rgb(254,45,45) 50%,rgb(107,0,62) 100%)',
    slug: 'blush-bordeaux'
  }, {
    name: Object(external_wp_i18n_["__"])('Luminous dusk'),
    gradient: 'linear-gradient(135deg,rgb(255,203,112) 0%,rgb(199,81,192) 50%,rgb(65,88,208) 100%)',
    slug: 'luminous-dusk'
  }, {
    name: Object(external_wp_i18n_["__"])('Pale ocean'),
    gradient: 'linear-gradient(135deg,rgb(255,245,203) 0%,rgb(182,227,212) 50%,rgb(51,167,181) 100%)',
    slug: 'pale-ocean'
  }, {
    name: Object(external_wp_i18n_["__"])('Electric grass'),
    gradient: 'linear-gradient(135deg,rgb(202,248,128) 0%,rgb(113,206,126) 100%)',
    slug: 'electric-grass'
  }, {
    name: Object(external_wp_i18n_["__"])('Midnight'),
    gradient: 'linear-gradient(135deg,rgb(2,3,129) 0%,rgb(40,116,252) 100%)',
    slug: 'midnight'
  }]
};

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/store/array.js
/**
 * External dependencies
 */

/**
 * Insert one or multiple elements into a given position of an array.
 *
 * @param {Array}  array    Source array.
 * @param {*}      elements Elements to insert.
 * @param {number} index    Insert Position.
 *
 * @return {Array}          Result.
 */

function insertAt(array, elements, index) {
  return [...array.slice(0, index), ...Object(external_lodash_["castArray"])(elements), ...array.slice(index)];
}
/**
 * Moves an element in an array.
 *
 * @param {Array}  array Source array.
 * @param {number} from  Source index.
 * @param {number} to    Destination index.
 * @param {number} count Number of elements to move.
 *
 * @return {Array}       Result.
 */

function moveTo(array, from, to, count = 1) {
  const withoutMovedElements = [...array];
  withoutMovedElements.splice(from, count);
  return insertAt(withoutMovedElements, array.slice(from, from + count), to);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/store/reducer.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/**
 * Given an array of blocks, returns an object where each key is a nesting
 * context, the value of which is an array of block client IDs existing within
 * that nesting context.
 *
 * @param {Array}   blocks       Blocks to map.
 * @param {?string} rootClientId Assumed root client ID.
 *
 * @return {Object} Block order map object.
 */

function mapBlockOrder(blocks, rootClientId = '') {
  const result = {
    [rootClientId]: []
  };
  blocks.forEach(block => {
    const {
      clientId,
      innerBlocks
    } = block;
    result[rootClientId].push(clientId);
    Object.assign(result, mapBlockOrder(innerBlocks, clientId));
  });
  return result;
}
/**
 * Given an array of blocks, returns an object where each key contains
 * the clientId of the block and the value is the parent of the block.
 *
 * @param {Array}   blocks       Blocks to map.
 * @param {?string} rootClientId Assumed root client ID.
 *
 * @return {Object} Block order map object.
 */


function mapBlockParents(blocks, rootClientId = '') {
  return blocks.reduce((result, block) => Object.assign(result, {
    [block.clientId]: rootClientId
  }, mapBlockParents(block.innerBlocks, block.clientId)), {});
}
/**
 * Helper method to iterate through all blocks, recursing into inner blocks,
 * applying a transformation function to each one.
 * Returns a flattened object with the transformed blocks.
 *
 * @param {Array} blocks Blocks to flatten.
 * @param {Function} transform Transforming function to be applied to each block.
 *
 * @return {Object} Flattened object.
 */


function flattenBlocks(blocks, transform = external_lodash_["identity"]) {
  const result = {};
  const stack = [...blocks];

  while (stack.length) {
    const {
      innerBlocks,
      ...block
    } = stack.shift();
    stack.push(...innerBlocks);
    result[block.clientId] = transform(block);
  }

  return result;
}
/**
 * Given an array of blocks, returns an object containing all blocks, without
 * attributes, recursing into inner blocks. Keys correspond to the block client
 * ID, the value of which is the attributes object.
 *
 * @param {Array} blocks Blocks to flatten.
 *
 * @return {Object} Flattened block attributes object.
 */


function getFlattenedBlocksWithoutAttributes(blocks) {
  return flattenBlocks(blocks, block => Object(external_lodash_["omit"])(block, 'attributes'));
}
/**
 * Given an array of blocks, returns an object containing all block attributes,
 * recursing into inner blocks. Keys correspond to the block client ID, the
 * value of which is the attributes object.
 *
 * @param {Array} blocks Blocks to flatten.
 *
 * @return {Object} Flattened block attributes object.
 */


function getFlattenedBlockAttributes(blocks) {
  return flattenBlocks(blocks, block => block.attributes);
}
/**
 * Given a block order map object, returns *all* of the block client IDs that are
 * a descendant of the given root client ID.
 *
 * Calling this with `rootClientId` set to `''` results in a list of client IDs
 * that are in the post. That is, it excludes blocks like fetched reusable
 * blocks which are stored into state but not visible. It also excludes
 * InnerBlocks controllers, like template parts.
 *
 * It is important to exclude the full inner block controller and not just the
 * inner blocks because in many cases, we need to persist the previous value of
 * an inner block controller. To do so, it must be excluded from the list of
 * client IDs which are considered to be part of the top-level entity.
 *
 * @param {Object}  blocksOrder  Object that maps block client IDs to a list of
 *                               nested block client IDs.
 * @param {?string} rootClientId The root client ID to search. Defaults to ''.
 * @param {?Object} controlledInnerBlocks The InnerBlocks controller state.
 *
 * @return {Array} List of descendant client IDs.
 */


function getNestedBlockClientIds(blocksOrder, rootClientId = '', controlledInnerBlocks = {}) {
  return Object(external_lodash_["reduce"])(blocksOrder[rootClientId], (result, clientId) => {
    if (!!controlledInnerBlocks[clientId]) {
      return result;
    }

    return [...result, clientId, ...getNestedBlockClientIds(blocksOrder, clientId)];
  }, []);
}
/**
 * Returns an object against which it is safe to perform mutating operations,
 * given the original object and its current working copy.
 *
 * @param {Object} original Original object.
 * @param {Object} working  Working object.
 *
 * @return {Object} Mutation-safe object.
 */


function getMutateSafeObject(original, working) {
  if (original === working) {
    return { ...original
    };
  }

  return working;
}
/**
 * Returns true if the two object arguments have the same keys, or false
 * otherwise.
 *
 * @param {Object} a First object.
 * @param {Object} b Second object.
 *
 * @return {boolean} Whether the two objects have the same keys.
 */


function hasSameKeys(a, b) {
  return Object(external_lodash_["isEqual"])(Object(external_lodash_["keys"])(a), Object(external_lodash_["keys"])(b));
}
/**
 * Returns true if, given the currently dispatching action and the previously
 * dispatched action, the two actions are updating the same block attribute, or
 * false otherwise.
 *
 * @param {Object} action     Currently dispatching action.
 * @param {Object} lastAction Previously dispatched action.
 *
 * @return {boolean} Whether actions are updating the same block attribute.
 */

function isUpdatingSameBlockAttribute(action, lastAction) {
  return action.type === 'UPDATE_BLOCK_ATTRIBUTES' && lastAction !== undefined && lastAction.type === 'UPDATE_BLOCK_ATTRIBUTES' && Object(external_lodash_["isEqual"])(action.clientIds, lastAction.clientIds) && hasSameKeys(action.attributes, lastAction.attributes);
}
/**
 * Utility returning an object with an empty object value for each key.
 *
 * @param {Array} objectKeys Keys to fill.
 * @return {Object} Object filled with empty object as values for each clientId.
 */

const fillKeysWithEmptyObject = objectKeys => {
  return objectKeys.reduce((result, key) => {
    result[key] = {};
    return result;
  }, {});
};
/**
 * Higher-order reducer intended to compute a cache key for each block in the post.
 * A new instance of the cache key (empty object) is created each time the block object
 * needs to be refreshed (for any change in the block or its children).
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withBlockCache = reducer => (state = {}, action) => {
  const newState = reducer(state, action);

  if (newState === state) {
    return state;
  }

  newState.cache = state.cache ? state.cache : {};
  /**
   * For each clientId provided, traverses up parents, adding the provided clientIds
   * and each parent's clientId to the returned array.
   *
   * When calling this function consider that it uses the old state, so any state
   * modifications made by the `reducer` will not be present.
   *
   * @param {Array} clientIds an Array of block clientIds.
   *
   * @return {Array} The provided clientIds and all of their parent clientIds.
   */

  const getBlocksWithParentsClientIds = clientIds => {
    return clientIds.reduce((result, clientId) => {
      let current = clientId;

      do {
        result.push(current);
        current = state.parents[current];
      } while (current && !state.controlledInnerBlocks[current]);

      return result;
    }, []);
  };

  switch (action.type) {
    case 'RESET_BLOCKS':
      newState.cache = Object(external_lodash_["mapValues"])(flattenBlocks(action.blocks), () => ({}));
      break;

    case 'RECEIVE_BLOCKS':
    case 'INSERT_BLOCKS':
      {
        const updatedBlockUids = Object(external_lodash_["keys"])(flattenBlocks(action.blocks));

        if (action.rootClientId && !state.controlledInnerBlocks[action.rootClientId]) {
          updatedBlockUids.push(action.rootClientId);
        }

        newState.cache = { ...newState.cache,
          ...fillKeysWithEmptyObject(getBlocksWithParentsClientIds(updatedBlockUids))
        };
        break;
      }

    case 'UPDATE_BLOCK':
      newState.cache = { ...newState.cache,
        ...fillKeysWithEmptyObject(getBlocksWithParentsClientIds([action.clientId]))
      };
      break;

    case 'UPDATE_BLOCK_ATTRIBUTES':
      newState.cache = { ...newState.cache,
        ...fillKeysWithEmptyObject(getBlocksWithParentsClientIds(action.clientIds))
      };
      break;

    case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
      const parentClientIds = fillKeysWithEmptyObject(getBlocksWithParentsClientIds(action.replacedClientIds));
      newState.cache = { ...Object(external_lodash_["omit"])(newState.cache, action.replacedClientIds),
        ...Object(external_lodash_["omit"])(parentClientIds, action.replacedClientIds),
        ...fillKeysWithEmptyObject(Object(external_lodash_["keys"])(flattenBlocks(action.blocks)))
      };
      break;

    case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
      newState.cache = { ...Object(external_lodash_["omit"])(newState.cache, action.removedClientIds),
        ...fillKeysWithEmptyObject(Object(external_lodash_["difference"])(getBlocksWithParentsClientIds(action.clientIds), action.clientIds))
      };
      break;

    case 'MOVE_BLOCKS_TO_POSITION':
      {
        const updatedBlockUids = [...action.clientIds];

        if (action.fromRootClientId) {
          updatedBlockUids.push(action.fromRootClientId);
        }

        if (action.toRootClientId) {
          updatedBlockUids.push(action.toRootClientId);
        }

        newState.cache = { ...newState.cache,
          ...fillKeysWithEmptyObject(getBlocksWithParentsClientIds(updatedBlockUids))
        };
        break;
      }

    case 'MOVE_BLOCKS_UP':
    case 'MOVE_BLOCKS_DOWN':
      {
        const updatedBlockUids = [];

        if (action.rootClientId) {
          updatedBlockUids.push(action.rootClientId);
        }

        newState.cache = { ...newState.cache,
          ...fillKeysWithEmptyObject(getBlocksWithParentsClientIds(updatedBlockUids))
        };
        break;
      }

    case 'SAVE_REUSABLE_BLOCK_SUCCESS':
      {
        const updatedBlockUids = Object(external_lodash_["keys"])(Object(external_lodash_["omitBy"])(newState.attributes, (attributes, clientId) => {
          return newState.byClientId[clientId].name !== 'core/block' || attributes.ref !== action.updatedId;
        }));
        newState.cache = { ...newState.cache,
          ...fillKeysWithEmptyObject(getBlocksWithParentsClientIds(updatedBlockUids))
        };
      }
  }

  return newState;
};
/**
 * Higher-order reducer intended to augment the blocks reducer, assigning an
 * `isPersistentChange` property value corresponding to whether a change in
 * state can be considered as persistent. All changes are considered persistent
 * except when updating the same block attribute as in the previous action.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


function withPersistentBlockChange(reducer) {
  let lastAction;
  let markNextChangeAsNotPersistent = false;
  return (state, action) => {
    let nextState = reducer(state, action);
    const isExplicitPersistentChange = action.type === 'MARK_LAST_CHANGE_AS_PERSISTENT' || markNextChangeAsNotPersistent; // Defer to previous state value (or default) unless changing or
    // explicitly marking as persistent.

    if (state === nextState && !isExplicitPersistentChange) {
      var _state$isPersistentCh;

      markNextChangeAsNotPersistent = action.type === 'MARK_NEXT_CHANGE_AS_NOT_PERSISTENT';
      const nextIsPersistentChange = (_state$isPersistentCh = state === null || state === void 0 ? void 0 : state.isPersistentChange) !== null && _state$isPersistentCh !== void 0 ? _state$isPersistentCh : true;

      if (state.isPersistentChange === nextIsPersistentChange) {
        return state;
      }

      return { ...nextState,
        isPersistentChange: nextIsPersistentChange
      };
    }

    nextState = { ...nextState,
      isPersistentChange: isExplicitPersistentChange ? !markNextChangeAsNotPersistent : !isUpdatingSameBlockAttribute(action, lastAction)
    }; // In comparing against the previous action, consider only those which
    // would have qualified as one which would have been ignored or not
    // have resulted in a changed state.

    lastAction = action;
    markNextChangeAsNotPersistent = action.type === 'MARK_NEXT_CHANGE_AS_NOT_PERSISTENT';
    return nextState;
  };
}
/**
 * Higher-order reducer intended to augment the blocks reducer, assigning an
 * `isIgnoredChange` property value corresponding to whether a change in state
 * can be considered as ignored. A change is considered ignored when the result
 * of an action not incurred by direct user interaction.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


function withIgnoredBlockChange(reducer) {
  /**
   * Set of action types for which a blocks state change should be ignored.
   *
   * @type {Set}
   */
  const IGNORED_ACTION_TYPES = new Set(['RECEIVE_BLOCKS']);
  return (state, action) => {
    const nextState = reducer(state, action);

    if (nextState !== state) {
      nextState.isIgnoredChange = IGNORED_ACTION_TYPES.has(action.type);
    }

    return nextState;
  };
}
/**
 * Higher-order reducer targeting the combined blocks reducer, augmenting
 * block client IDs in remove action to include cascade of inner blocks.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withInnerBlocksRemoveCascade = reducer => (state, action) => {
  // Gets all children which need to be removed.
  const getAllChildren = clientIds => {
    let result = clientIds;

    for (let i = 0; i < result.length; i++) {
      if (!state.order[result[i]] || action.keepControlledInnerBlocks && action.keepControlledInnerBlocks[result[i]]) {
        continue;
      }

      if (result === clientIds) {
        result = [...result];
      }

      result.push(...state.order[result[i]]);
    }

    return result;
  };

  if (state) {
    switch (action.type) {
      case 'REMOVE_BLOCKS':
        action = { ...action,
          type: 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN',
          removedClientIds: getAllChildren(action.clientIds)
        };
        break;

      case 'REPLACE_BLOCKS':
        action = { ...action,
          type: 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN',
          replacedClientIds: getAllChildren(action.clientIds)
        };
        break;
    }
  }

  return reducer(state, action);
};
/**
 * Higher-order reducer which targets the combined blocks reducer and handles
 * the `RESET_BLOCKS` action. When dispatched, this action will replace all
 * blocks that exist in the post, leaving blocks that exist only in state (e.g.
 * reusable blocks and blocks controlled by inner blocks controllers) alone.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withBlockReset = reducer => (state, action) => {
  if (state && action.type === 'RESET_BLOCKS') {
    /**
     * A list of client IDs associated with the top level entity (like a
     * post or template). It excludes the client IDs of blocks associated
     * with other entities, like inner block controllers or reusable blocks.
     */
    const visibleClientIds = getNestedBlockClientIds(state.order, '', state.controlledInnerBlocks); // pickBy returns only the truthy values from controlledInnerBlocks

    const controlledInnerBlocks = Object.keys(Object(external_lodash_["pickBy"])(state.controlledInnerBlocks));
    /**
     * Each update operation consists of a few parts:
     * 1. First, the client IDs associated with the top level entity are
     *    removed from the existing state key, leaving in place controlled
     *    blocks (like reusable blocks and inner block controllers).
     * 2. Second, the blocks from the reset action are used to calculate the
     *    individual state keys. This will re-populate the clientIDs which
     *    were removed in step 1.
     * 3. In some cases, we remove the recalculated inner block controllers,
     *    letting their old values persist. We need to do this because the
     *    reset block action from a top-level entity is not aware of any
     *    inner blocks inside InnerBlock controllers. So if the new values
     *    were used, it would not take into account the existing InnerBlocks
     *    which already exist in the state for inner block controllers. For
     *    example, `attributes` uses the newly computed value for controllers
     *    since attributes are stored in the top-level entity. But `order`
     *    uses the previous value for the controllers since the new value
     *    does not include the order of controlled inner blocks. So if the
     *    new value was used, template parts would disappear from the editor
     *    whenever you try to undo a change in the top level entity.
     */

    return { ...state,
      byClientId: { ...Object(external_lodash_["omit"])(state.byClientId, visibleClientIds),
        ...getFlattenedBlocksWithoutAttributes(action.blocks)
      },
      attributes: { ...Object(external_lodash_["omit"])(state.attributes, visibleClientIds),
        ...getFlattenedBlockAttributes(action.blocks)
      },
      order: { ...Object(external_lodash_["omit"])(state.order, visibleClientIds),
        ...Object(external_lodash_["omit"])(mapBlockOrder(action.blocks), controlledInnerBlocks)
      },
      parents: { ...Object(external_lodash_["omit"])(state.parents, visibleClientIds),
        ...mapBlockParents(action.blocks)
      },
      cache: { ...Object(external_lodash_["omit"])(state.cache, visibleClientIds),
        ...Object(external_lodash_["omit"])(Object(external_lodash_["mapValues"])(flattenBlocks(action.blocks), () => ({})), controlledInnerBlocks)
      }
    };
  }

  return reducer(state, action);
};
/**
 * Higher-order reducer which targets the combined blocks reducer and handles
 * the `REPLACE_INNER_BLOCKS` action. When dispatched, this action the state
 * should become equivalent to the execution of a `REMOVE_BLOCKS` action
 * containing all the child's of the root block followed by the execution of
 * `INSERT_BLOCKS` with the new blocks.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withReplaceInnerBlocks = reducer => (state, action) => {
  if (action.type !== 'REPLACE_INNER_BLOCKS') {
    return reducer(state, action);
  } // Finds every nested inner block controller. We must check the action blocks
  // and not just the block parent state because some inner block controllers
  // should be deleted if specified, whereas others should not be deleted. If
  // a controlled should not be deleted, then we need to avoid deleting its
  // inner blocks from the block state because its inner blocks will not be
  // attached to the block in the action.


  const nestedControllers = {};

  if (Object.keys(state.controlledInnerBlocks).length) {
    const stack = [...action.blocks];

    while (stack.length) {
      const {
        innerBlocks,
        ...block
      } = stack.shift();
      stack.push(...innerBlocks);

      if (!!state.controlledInnerBlocks[block.clientId]) {
        nestedControllers[block.clientId] = true;
      }
    }
  } // The `keepControlledInnerBlocks` prop will keep the inner blocks of the
  // marked block in the block state so that they can be reattached to the
  // marked block when we re-insert everything a few lines below.


  let stateAfterBlocksRemoval = state;

  if (state.order[action.rootClientId]) {
    stateAfterBlocksRemoval = reducer(stateAfterBlocksRemoval, {
      type: 'REMOVE_BLOCKS',
      keepControlledInnerBlocks: nestedControllers,
      clientIds: state.order[action.rootClientId]
    });
  }

  let stateAfterInsert = stateAfterBlocksRemoval;

  if (action.blocks.length) {
    stateAfterInsert = reducer(stateAfterInsert, { ...action,
      type: 'INSERT_BLOCKS',
      index: 0
    }); // We need to re-attach the block order of the controlled inner blocks.
    // Otherwise, an inner block controller's blocks will be deleted entirely
    // from its entity..

    stateAfterInsert.order = { ...stateAfterInsert.order,
      ...Object(external_lodash_["reduce"])(nestedControllers, (result, value, key) => {
        if (state.order[key]) {
          result[key] = state.order[key];
        }

        return result;
      }, {})
    };
  }

  return stateAfterInsert;
};
/**
 * Higher-order reducer which targets the combined blocks reducer and handles
 * the `SAVE_REUSABLE_BLOCK_SUCCESS` action. This action can't be handled by
 * regular reducers and needs a higher-order reducer since it needs access to
 * both `byClientId` and `attributes` simultaneously.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withSaveReusableBlock = reducer => (state, action) => {
  if (state && action.type === 'SAVE_REUSABLE_BLOCK_SUCCESS') {
    const {
      id,
      updatedId
    } = action; // If a temporary reusable block is saved, we swap the temporary id with the final one

    if (id === updatedId) {
      return state;
    }

    state = { ...state
    };
    state.attributes = Object(external_lodash_["mapValues"])(state.attributes, (attributes, clientId) => {
      const {
        name
      } = state.byClientId[clientId];

      if (name === 'core/block' && attributes.ref === id) {
        return { ...attributes,
          ref: updatedId
        };
      }

      return attributes;
    });
  }

  return reducer(state, action);
};
/**
 * Reducer returning the blocks state.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */


const reducer_blocks = Object(external_lodash_["flow"])(external_wp_data_["combineReducers"], withSaveReusableBlock, // needs to be before withBlockCache
withBlockCache, // needs to be before withInnerBlocksRemoveCascade
withInnerBlocksRemoveCascade, withReplaceInnerBlocks, // needs to be after withInnerBlocksRemoveCascade
withBlockReset, withPersistentBlockChange, withIgnoredBlockChange)({
  byClientId(state = {}, action) {
    switch (action.type) {
      case 'RESET_BLOCKS':
        return getFlattenedBlocksWithoutAttributes(action.blocks);

      case 'RECEIVE_BLOCKS':
      case 'INSERT_BLOCKS':
        return { ...state,
          ...getFlattenedBlocksWithoutAttributes(action.blocks)
        };

      case 'UPDATE_BLOCK':
        // Ignore updates if block isn't known
        if (!state[action.clientId]) {
          return state;
        } // Do nothing if only attributes change.


        const changes = Object(external_lodash_["omit"])(action.updates, 'attributes');

        if (Object(external_lodash_["isEmpty"])(changes)) {
          return state;
        }

        return { ...state,
          [action.clientId]: { ...state[action.clientId],
            ...changes
          }
        };

      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        if (!action.blocks) {
          return state;
        }

        return { ...Object(external_lodash_["omit"])(state, action.replacedClientIds),
          ...getFlattenedBlocksWithoutAttributes(action.blocks)
        };

      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        return Object(external_lodash_["omit"])(state, action.removedClientIds);
    }

    return state;
  },

  attributes(state = {}, action) {
    switch (action.type) {
      case 'RESET_BLOCKS':
        return getFlattenedBlockAttributes(action.blocks);

      case 'RECEIVE_BLOCKS':
      case 'INSERT_BLOCKS':
        return { ...state,
          ...getFlattenedBlockAttributes(action.blocks)
        };

      case 'UPDATE_BLOCK':
        // Ignore updates if block isn't known or there are no attribute changes.
        if (!state[action.clientId] || !action.updates.attributes) {
          return state;
        }

        return { ...state,
          [action.clientId]: { ...state[action.clientId],
            ...action.updates.attributes
          }
        };

      case 'UPDATE_BLOCK_ATTRIBUTES':
        {
          // Avoid a state change if none of the block IDs are known.
          if (action.clientIds.every(id => !state[id])) {
            return state;
          }

          const next = action.clientIds.reduce((accumulator, id) => ({ ...accumulator,
            [id]: Object(external_lodash_["reduce"])(action.uniqueByBlock ? action.attributes[id] : action.attributes, (result, value, key) => {
              // Consider as updates only changed values.
              if (value !== result[key]) {
                result = getMutateSafeObject(state[id], result);
                result[key] = value;
              }

              return result;
            }, state[id])
          }), {});

          if (action.clientIds.every(id => next[id] === state[id])) {
            return state;
          }

          return { ...state,
            ...next
          };
        }

      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        if (!action.blocks) {
          return state;
        }

        return { ...Object(external_lodash_["omit"])(state, action.replacedClientIds),
          ...getFlattenedBlockAttributes(action.blocks)
        };

      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        return Object(external_lodash_["omit"])(state, action.removedClientIds);
    }

    return state;
  },

  order(state = {}, action) {
    switch (action.type) {
      case 'RESET_BLOCKS':
        return mapBlockOrder(action.blocks);

      case 'RECEIVE_BLOCKS':
        return { ...state,
          ...Object(external_lodash_["omit"])(mapBlockOrder(action.blocks), '')
        };

      case 'INSERT_BLOCKS':
        {
          const {
            rootClientId = ''
          } = action;
          const subState = state[rootClientId] || [];
          const mappedBlocks = mapBlockOrder(action.blocks, rootClientId);
          const {
            index = subState.length
          } = action;
          return { ...state,
            ...mappedBlocks,
            [rootClientId]: insertAt(subState, mappedBlocks[rootClientId], index)
          };
        }

      case 'MOVE_BLOCKS_TO_POSITION':
        {
          const {
            fromRootClientId = '',
            toRootClientId = '',
            clientIds
          } = action;
          const {
            index = state[toRootClientId].length
          } = action; // Moving inside the same parent block

          if (fromRootClientId === toRootClientId) {
            const subState = state[toRootClientId];
            const fromIndex = subState.indexOf(clientIds[0]);
            return { ...state,
              [toRootClientId]: moveTo(state[toRootClientId], fromIndex, index, clientIds.length)
            };
          } // Moving from a parent block to another


          return { ...state,
            [fromRootClientId]: Object(external_lodash_["without"])(state[fromRootClientId], ...clientIds),
            [toRootClientId]: insertAt(state[toRootClientId], clientIds, index)
          };
        }

      case 'MOVE_BLOCKS_UP':
        {
          const {
            clientIds,
            rootClientId = ''
          } = action;
          const firstClientId = Object(external_lodash_["first"])(clientIds);
          const subState = state[rootClientId];

          if (!subState.length || firstClientId === Object(external_lodash_["first"])(subState)) {
            return state;
          }

          const firstIndex = subState.indexOf(firstClientId);
          return { ...state,
            [rootClientId]: moveTo(subState, firstIndex, firstIndex - 1, clientIds.length)
          };
        }

      case 'MOVE_BLOCKS_DOWN':
        {
          const {
            clientIds,
            rootClientId = ''
          } = action;
          const firstClientId = Object(external_lodash_["first"])(clientIds);
          const lastClientId = Object(external_lodash_["last"])(clientIds);
          const subState = state[rootClientId];

          if (!subState.length || lastClientId === Object(external_lodash_["last"])(subState)) {
            return state;
          }

          const firstIndex = subState.indexOf(firstClientId);
          return { ...state,
            [rootClientId]: moveTo(subState, firstIndex, firstIndex + 1, clientIds.length)
          };
        }

      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        {
          const {
            clientIds
          } = action;

          if (!action.blocks) {
            return state;
          }

          const mappedBlocks = mapBlockOrder(action.blocks);
          return Object(external_lodash_["flow"])([nextState => Object(external_lodash_["omit"])(nextState, action.replacedClientIds), nextState => ({ ...nextState,
            ...Object(external_lodash_["omit"])(mappedBlocks, '')
          }), nextState => Object(external_lodash_["mapValues"])(nextState, subState => Object(external_lodash_["reduce"])(subState, (result, clientId) => {
            if (clientId === clientIds[0]) {
              return [...result, ...mappedBlocks['']];
            }

            if (clientIds.indexOf(clientId) === -1) {
              result.push(clientId);
            }

            return result;
          }, []))])(state);
        }

      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        return Object(external_lodash_["flow"])([// Remove inner block ordering for removed blocks
        nextState => Object(external_lodash_["omit"])(nextState, action.removedClientIds), // Remove deleted blocks from other blocks' orderings
        nextState => Object(external_lodash_["mapValues"])(nextState, subState => Object(external_lodash_["without"])(subState, ...action.removedClientIds))])(state);
    }

    return state;
  },

  // While technically redundant data as the inverse of `order`, it serves as
  // an optimization for the selectors which derive the ancestry of a block.
  parents(state = {}, action) {
    switch (action.type) {
      case 'RESET_BLOCKS':
        return mapBlockParents(action.blocks);

      case 'RECEIVE_BLOCKS':
        return { ...state,
          ...mapBlockParents(action.blocks)
        };

      case 'INSERT_BLOCKS':
        return { ...state,
          ...mapBlockParents(action.blocks, action.rootClientId || '')
        };

      case 'MOVE_BLOCKS_TO_POSITION':
        {
          return { ...state,
            ...action.clientIds.reduce((accumulator, id) => {
              accumulator[id] = action.toRootClientId || '';
              return accumulator;
            }, {})
          };
        }

      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        return { ...Object(external_lodash_["omit"])(state, action.replacedClientIds),
          ...mapBlockParents(action.blocks, state[action.clientIds[0]])
        };

      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        return Object(external_lodash_["omit"])(state, action.removedClientIds);
    }

    return state;
  },

  controlledInnerBlocks(state = {}, {
    type,
    clientId,
    hasControlledInnerBlocks
  }) {
    if (type === 'SET_HAS_CONTROLLED_INNER_BLOCKS') {
      return { ...state,
        [clientId]: hasControlledInnerBlocks
      };
    }

    return state;
  }

});
/**
 * Reducer returning typing state.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */

function reducer_isTyping(state = false, action) {
  switch (action.type) {
    case 'START_TYPING':
      return true;

    case 'STOP_TYPING':
      return false;
  }

  return state;
}
/**
 * Reducer returning dragged block client id.
 *
 * @param {string[]} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {string[]} Updated state.
 */

function draggedBlocks(state = [], action) {
  switch (action.type) {
    case 'START_DRAGGING_BLOCKS':
      return action.clientIds;

    case 'STOP_DRAGGING_BLOCKS':
      return [];
  }

  return state;
}
/**
 * Reducer returning whether the caret is within formatted text.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */

function reducer_isCaretWithinFormattedText(state = false, action) {
  switch (action.type) {
    case 'ENTER_FORMATTED_TEXT':
      return true;

    case 'EXIT_FORMATTED_TEXT':
      return false;
  }

  return state;
}
/**
 * Internal helper reducer for selectionStart and selectionEnd. Can hold a block
 * selection, represented by an object with property clientId.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function selectionHelper(state = {}, action) {
  switch (action.type) {
    case 'CLEAR_SELECTED_BLOCK':
      {
        if (state.clientId) {
          return {};
        }

        return state;
      }

    case 'SELECT_BLOCK':
      if (action.clientId === state.clientId) {
        return state;
      }

      return {
        clientId: action.clientId
      };

    case 'REPLACE_INNER_BLOCKS':
    case 'INSERT_BLOCKS':
      {
        if (!action.updateSelection || !action.blocks.length) {
          return state;
        }

        return {
          clientId: action.blocks[0].clientId
        };
      }

    case 'REMOVE_BLOCKS':
      if (!action.clientIds || !action.clientIds.length || action.clientIds.indexOf(state.clientId) === -1) {
        return state;
      }

      return {};

    case 'REPLACE_BLOCKS':
      {
        if (action.clientIds.indexOf(state.clientId) === -1) {
          return state;
        }

        const indexToSelect = action.indexToSelect || action.blocks.length - 1;
        const blockToSelect = action.blocks[indexToSelect];

        if (!blockToSelect) {
          return {};
        }

        if (blockToSelect.clientId === state.clientId) {
          return state;
        }

        return {
          clientId: blockToSelect.clientId
        };
      }
  }

  return state;
}
/**
 * Reducer returning the selection state.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */


function reducer_selection(state = {}, action) {
  var _state$selectionStart, _state$selectionEnd;

  switch (action.type) {
    case 'SELECTION_CHANGE':
      return {
        selectionStart: {
          clientId: action.clientId,
          attributeKey: action.attributeKey,
          offset: action.startOffset
        },
        selectionEnd: {
          clientId: action.clientId,
          attributeKey: action.attributeKey,
          offset: action.endOffset
        }
      };

    case 'RESET_SELECTION':
      const {
        selectionStart,
        selectionEnd
      } = action;
      return {
        selectionStart,
        selectionEnd
      };

    case 'MULTI_SELECT':
      const {
        start,
        end
      } = action;
      return {
        selectionStart: {
          clientId: start
        },
        selectionEnd: {
          clientId: end
        }
      };

    case 'RESET_BLOCKS':
      const startClientId = state === null || state === void 0 ? void 0 : (_state$selectionStart = state.selectionStart) === null || _state$selectionStart === void 0 ? void 0 : _state$selectionStart.clientId;
      const endClientId = state === null || state === void 0 ? void 0 : (_state$selectionEnd = state.selectionEnd) === null || _state$selectionEnd === void 0 ? void 0 : _state$selectionEnd.clientId; // Do nothing if there's no selected block.

      if (!startClientId && !endClientId) {
        return state;
      } // If the start of the selection won't exist after reset, remove selection.


      if (!action.blocks.some(block => block.clientId === startClientId)) {
        return {
          selectionStart: {},
          selectionEnd: {}
        };
      } // If the end of the selection won't exist after reset, collapse selection.


      if (!action.blocks.some(block => block.clientId === endClientId)) {
        return { ...state,
          selectionEnd: state.selectionStart
        };
      }

  }

  return {
    selectionStart: selectionHelper(state.selectionStart, action),
    selectionEnd: selectionHelper(state.selectionEnd, action)
  };
}
/**
 * Reducer returning whether the user is multi-selecting.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */

function reducer_isMultiSelecting(state = false, action) {
  switch (action.type) {
    case 'START_MULTI_SELECT':
      return true;

    case 'STOP_MULTI_SELECT':
      return false;
  }

  return state;
}
/**
 * Reducer returning whether selection is enabled.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */

function reducer_isSelectionEnabled(state = true, action) {
  switch (action.type) {
    case 'TOGGLE_SELECTION':
      return action.isSelectionEnabled;
  }

  return state;
}
/**
 * Reducer returning the intial block selection.
 *
 * Currently this in only used to restore the selection after block deletion and
 * pasting new content.This reducer should eventually be removed in favour of setting
 * selection directly.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {number|null} Initial position: 0, -1 or null.
 */

function reducer_initialPosition(state = null, action) {
  if (action.type === 'REPLACE_BLOCKS' && action.initialPosition !== undefined) {
    return action.initialPosition;
  } else if (['SELECT_BLOCK', 'RESET_SELECTION', 'INSERT_BLOCKS', 'REPLACE_INNER_BLOCKS'].includes(action.type)) {
    return action.initialPosition;
  }

  return state;
}
function blocksMode(state = {}, action) {
  if (action.type === 'TOGGLE_BLOCK_MODE') {
    const {
      clientId
    } = action;
    return { ...state,
      [clientId]: state[clientId] && state[clientId] === 'html' ? 'visual' : 'html'
    };
  }

  return state;
}
/**
 * Reducer returning the block insertion point visibility, either null if there
 * is not an explicit insertion point assigned, or an object of its `index` and
 * `rootClientId`.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function reducer_insertionPoint(state = null, action) {
  switch (action.type) {
    case 'SHOW_INSERTION_POINT':
      const {
        rootClientId,
        index,
        __unstableWithInserter
      } = action;
      return {
        rootClientId,
        index,
        __unstableWithInserter
      };

    case 'HIDE_INSERTION_POINT':
      return null;
  }

  return state;
}
/**
 * Reducer returning whether the post blocks match the defined template or not.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {boolean} Updated state.
 */

function reducer_template(state = {
  isValid: true
}, action) {
  switch (action.type) {
    case 'SET_TEMPLATE_VALIDITY':
      return { ...state,
        isValid: action.isValid
      };
  }

  return state;
}
/**
 * Reducer returning the editor setting.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function reducer_settings(state = SETTINGS_DEFAULTS, action) {
  switch (action.type) {
    case 'UPDATE_SETTINGS':
      return { ...state,
        ...action.settings
      };
  }

  return state;
}
/**
 * Reducer returning the user preferences.
 *
 * @param {Object}  state                 Current state.
 * @param {Object}  action                Dispatched action.
 *
 * @return {string} Updated state.
 */

function preferences(state = PREFERENCES_DEFAULTS, action) {
  switch (action.type) {
    case 'INSERT_BLOCKS':
    case 'REPLACE_BLOCKS':
      return action.blocks.reduce((prevState, block) => {
        const {
          attributes,
          name: blockName
        } = block;
        const match = Object(external_wp_data_["select"])(external_wp_blocks_["store"]).getActiveBlockVariation(blockName, attributes); // If a block variation match is found change the name to be the same with the
        // one that is used for block variations in the Inserter (`getItemFromVariation`).

        let id = match !== null && match !== void 0 && match.name ? `${blockName}/${match.name}` : blockName;
        const insert = {
          name: id
        };

        if (blockName === 'core/block') {
          insert.ref = attributes.ref;
          id += '/' + attributes.ref;
        }

        return { ...prevState,
          insertUsage: { ...prevState.insertUsage,
            [id]: {
              time: action.time,
              count: prevState.insertUsage[id] ? prevState.insertUsage[id].count + 1 : 1,
              insert
            }
          }
        };
      }, state);
  }

  return state;
}
/**
 * Reducer returning an object where each key is a block client ID, its value
 * representing the settings for its nested blocks.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

const reducer_blockListSettings = (state = {}, action) => {
  switch (action.type) {
    // Even if the replaced blocks have the same client ID, our logic
    // should correct the state.
    case 'REPLACE_BLOCKS':
    case 'REMOVE_BLOCKS':
      {
        return Object(external_lodash_["omit"])(state, action.clientIds);
      }

    case 'UPDATE_BLOCK_LIST_SETTINGS':
      {
        const {
          clientId
        } = action;

        if (!action.settings) {
          if (state.hasOwnProperty(clientId)) {
            return Object(external_lodash_["omit"])(state, clientId);
          }

          return state;
        }

        if (Object(external_lodash_["isEqual"])(state[clientId], action.settings)) {
          return state;
        }

        return { ...state,
          [clientId]: action.settings
        };
      }
  }

  return state;
};
/**
 * Reducer returning whether the navigation mode is enabled or not.
 *
 * @param {string} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {string} Updated state.
 */

function reducer_isNavigationMode(state = false, action) {
  // Let inserting block always trigger Edit mode.
  if (action.type === 'INSERT_BLOCKS') {
    return false;
  }

  if (action.type === 'SET_NAVIGATION_MODE') {
    return action.isNavigationMode;
  }

  return state;
}
/**
 * Reducer returning whether the block moving mode is enabled or not.
 *
 * @param {string|null} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {string|null} Updated state.
 */

function reducer_hasBlockMovingClientId(state = null, action) {
  // Let inserting block always trigger Edit mode.
  if (action.type === 'SET_BLOCK_MOVING_MODE') {
    return action.hasBlockMovingClientId;
  }

  if (action.type === 'SET_NAVIGATION_MODE') {
    return null;
  }

  return state;
}
/**
 * Reducer return an updated state representing the most recent block attribute
 * update. The state is structured as an object where the keys represent the
 * client IDs of blocks, the values a subset of attributes from the most recent
 * block update. The state is always reset to null if the last action is
 * anything other than an attributes update.
 *
 * @param {Object<string,Object>} state  Current state.
 * @param {Object}                action Action object.
 *
 * @return {[string,Object]} Updated state.
 */

function lastBlockAttributesChange(state, action) {
  switch (action.type) {
    case 'UPDATE_BLOCK':
      if (!action.updates.attributes) {
        break;
      }

      return {
        [action.clientId]: action.updates.attributes
      };

    case 'UPDATE_BLOCK_ATTRIBUTES':
      return action.clientIds.reduce((accumulator, id) => ({ ...accumulator,
        [id]: action.uniqueByBlock ? action.attributes[id] : action.attributes
      }), {});
  }

  return null;
}
/**
 * Reducer returning automatic change state.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {string} Updated state.
 */

function automaticChangeStatus(state, action) {
  switch (action.type) {
    case 'MARK_AUTOMATIC_CHANGE':
      return 'pending';

    case 'MARK_AUTOMATIC_CHANGE_FINAL':
      if (state === 'pending') {
        return 'final';
      }

      return;

    case 'SELECTION_CHANGE':
      // As long as the state is not final, ignore any selection changes.
      if (state !== 'final') {
        return state;
      }

      return;
    // Undoing an automatic change should still be possible after mouse
    // move.

    case 'START_TYPING':
    case 'STOP_TYPING':
      return state;
  } // Reset the state by default (for any action not handled).

}
/**
 * Reducer returning current highlighted block.
 *
 * @param {boolean} state  Current highlighted block.
 * @param {Object}  action Dispatched action.
 *
 * @return {string} Updated state.
 */

function highlightedBlock(state, action) {
  switch (action.type) {
    case 'TOGGLE_BLOCK_HIGHLIGHT':
      const {
        clientId,
        isHighlighted
      } = action;

      if (isHighlighted) {
        return clientId;
      } else if (state === clientId) {
        return null;
      }

      return state;

    case 'SELECT_BLOCK':
      if (action.clientId !== state) {
        return null;
      }

  }

  return state;
}
/**
 * Reducer returning the block insertion event list state.
 *
 * @param {Object}  state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function lastBlockInserted(state = {}, action) {
  var _action$meta;

  switch (action.type) {
    case 'INSERT_BLOCKS':
      if (!action.blocks.length) {
        return state;
      }

      const clientId = action.blocks[0].clientId;
      const source = (_action$meta = action.meta) === null || _action$meta === void 0 ? void 0 : _action$meta.source;
      return {
        clientId,
        source
      };

    case 'RESET_BLOCKS':
      return {};
  }

  return state;
}
/* harmony default export */ var store_reducer = (Object(external_wp_data_["combineReducers"])({
  blocks: reducer_blocks,
  isTyping: reducer_isTyping,
  draggedBlocks,
  isCaretWithinFormattedText: reducer_isCaretWithinFormattedText,
  selection: reducer_selection,
  isMultiSelecting: reducer_isMultiSelecting,
  isSelectionEnabled: reducer_isSelectionEnabled,
  initialPosition: reducer_initialPosition,
  blocksMode,
  blockListSettings: reducer_blockListSettings,
  insertionPoint: reducer_insertionPoint,
  template: reducer_template,
  settings: reducer_settings,
  preferences,
  lastBlockAttributesChange,
  isNavigationMode: reducer_isNavigationMode,
  hasBlockMovingClientId: reducer_hasBlockMovingClientId,
  automaticChangeStatus,
  highlightedBlock,
  lastBlockInserted
}));

// EXTERNAL MODULE: ./node_modules/rememo/es/rememo.js
var rememo = __webpack_require__("pPDe");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/store/selectors.js


/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * A block selection object.
 *
 * @typedef {Object} WPBlockSelection
 *
 * @property {string} clientId     A block client ID.
 * @property {string} attributeKey A block attribute key.
 * @property {number} offset       An attribute value offset, based on the rich
 *                                 text value. See `wp.richText.create`.
 */
// Module constants

const MILLISECONDS_PER_HOUR = 3600 * 1000;
const MILLISECONDS_PER_DAY = 24 * 3600 * 1000;
const MILLISECONDS_PER_WEEK = 7 * 24 * 3600 * 1000;
const templateIcon = Object(external_wp_element_["createElement"])(external_wp_components_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_components_["Rect"], {
  x: "0",
  fill: "none",
  width: "24",
  height: "24"
}), Object(external_wp_element_["createElement"])(external_wp_components_["G"], null, Object(external_wp_element_["createElement"])(external_wp_components_["Path"], {
  d: "M19 3H5c-1.105 0-2 .895-2 2v14c0 1.105.895 2 2 2h14c1.105 0 2-.895 2-2V5c0-1.105-.895-2-2-2zM6 6h5v5H6V6zm4.5 13C9.12 19 8 17.88 8 16.5S9.12 14 10.5 14s2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5zm3-6l3-5 3 5h-6z"
})));
/**
 * Shared reference to an empty array for cases where it is important to avoid
 * returning a new array reference on every invocation, as in a connected or
 * other pure component which performs `shouldComponentUpdate` check on props.
 * This should be used as a last resort, since the normalized data should be
 * maintained by the reducer result in state.
 *
 * @type {Array}
 */

const EMPTY_ARRAY = [];
/**
 * Returns a block's name given its client ID, or null if no block exists with
 * the client ID.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {string} Block name.
 */

function selectors_getBlockName(state, clientId) {
  const block = state.blocks.byClientId[clientId];
  const socialLinkName = 'core/social-link';

  if (external_wp_element_["Platform"].OS !== 'web' && (block === null || block === void 0 ? void 0 : block.name) === socialLinkName) {
    const attributes = state.blocks.attributes[clientId];
    const {
      service
    } = attributes;
    return service ? `${socialLinkName}-${service}` : socialLinkName;
  }

  return block ? block.name : null;
}
/**
 * Returns whether a block is valid or not.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Is Valid.
 */

function selectors_isBlockValid(state, clientId) {
  const block = state.blocks.byClientId[clientId];
  return !!block && block.isValid;
}
/**
 * Returns a block's attributes given its client ID, or null if no block exists with
 * the client ID.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {Object?} Block attributes.
 */

function selectors_getBlockAttributes(state, clientId) {
  const block = state.blocks.byClientId[clientId];

  if (!block) {
    return null;
  }

  return state.blocks.attributes[clientId];
}
/**
 * Returns a block given its client ID. This is a parsed copy of the block,
 * containing its `blockName`, `clientId`, and current `attributes` state. This
 * is not the block's registration settings, which must be retrieved from the
 * blocks module registration store.
 *
 * getBlock recurses through its inner blocks until all its children blocks have
 * been retrieved. Note that getBlock will not return the child inner blocks of
 * an inner block controller. This is because an inner block controller syncs
 * itself with its own entity, and should therefore not be included with the
 * blocks of a different entity. For example, say you call `getBlocks( TP )` to
 * get the blocks of a template part. If another template part is a child of TP,
 * then the nested template part's child blocks will not be returned. This way,
 * the template block itself is considered part of the parent, but the children
 * are not.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {Object} Parsed block object.
 */

const selectors_getBlock = Object(rememo["a" /* default */])((state, clientId) => {
  const block = state.blocks.byClientId[clientId];

  if (!block) {
    return null;
  }

  return { ...block,
    attributes: selectors_getBlockAttributes(state, clientId),
    innerBlocks: areInnerBlocksControlled(state, clientId) ? EMPTY_ARRAY : selectors_getBlocks(state, clientId)
  };
}, (state, clientId) => [// Normally, we'd have both `getBlockAttributes` dependencies and
// `getBlocks` (children) dependencies here but for performance reasons
// we use a denormalized cache key computed in the reducer that takes both
// the attributes and inner blocks into account. The value of the cache key
// is being changed whenever one of these dependencies is out of date.
state.blocks.cache[clientId]]);
const selectors_unstableGetBlockWithoutInnerBlocks = Object(rememo["a" /* default */])((state, clientId) => {
  const block = state.blocks.byClientId[clientId];

  if (!block) {
    return null;
  }

  return { ...block,
    attributes: selectors_getBlockAttributes(state, clientId)
  };
}, (state, clientId) => [state.blocks.byClientId[clientId], state.blocks.attributes[clientId]]);
/**
 * Returns all block objects for the current post being edited as an array in
 * the order they appear in the post. Note that this will exclude child blocks
 * of nested inner block controllers.
 *
 * Note: It's important to memoize this selector to avoid return a new instance
 * on each call. We use the block cache state for each top-level block of the
 * given clientID. This way, the selector only refreshes on changes to blocks
 * associated with the given entity, and does not refresh when changes are made
 * to blocks which are part of different inner block controllers.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Object[]} Post blocks.
 */

const selectors_getBlocks = Object(rememo["a" /* default */])((state, rootClientId) => {
  return Object(external_lodash_["map"])(selectors_getBlockOrder(state, rootClientId), clientId => selectors_getBlock(state, clientId));
}, (state, rootClientId) => Object(external_lodash_["map"])(state.blocks.order[rootClientId || ''], id => state.blocks.cache[id]));
/**
 * Similar to getBlock, except it will include the entire nested block tree as
 * inner blocks. The normal getBlock selector will exclude sections of the block
 * tree which belong to different entities.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Client ID of the block to get.
 *
 * @return {Object} The block with all
 */

const __unstableGetBlockWithBlockTree = Object(rememo["a" /* default */])((state, clientId) => {
  const block = state.blocks.byClientId[clientId];

  if (!block) {
    return null;
  }

  return { ...block,
    attributes: selectors_getBlockAttributes(state, clientId),
    innerBlocks: __unstableGetBlockTree(state, clientId)
  };
}, state => [state.blocks.byClientId, state.blocks.order, state.blocks.attributes]);
/**
 * Similar to getBlocks, except this selector returns the entire block tree
 * represented in the block-editor store from the given root regardless of any
 * inner block controllers.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Object[]} Post blocks.
 */

const __unstableGetBlockTree = Object(rememo["a" /* default */])((state, rootClientId = '') => Object(external_lodash_["map"])(selectors_getBlockOrder(state, rootClientId), clientId => __unstableGetBlockWithBlockTree(state, clientId)), state => [state.blocks.byClientId, state.blocks.order, state.blocks.attributes]);
/**
 * Returns a stripped down block object containing only its client ID,
 * and its inner blocks' client IDs.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Client ID of the block to get.
 *
 * @return {Object} Client IDs of the post blocks.
 */

const selectors_unstableGetClientIdWithClientIdsTree = Object(rememo["a" /* default */])((state, clientId) => ({
  clientId,
  innerBlocks: selectors_unstableGetClientIdsTree(state, clientId)
}), state => [state.blocks.order]);
/**
 * Returns the block tree represented in the block-editor store from the
 * given root, consisting of stripped down block objects containing only
 * their client IDs, and their inner blocks' client IDs.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Object[]} Client IDs of the post blocks.
 */

const selectors_unstableGetClientIdsTree = Object(rememo["a" /* default */])((state, rootClientId = '') => Object(external_lodash_["map"])(selectors_getBlockOrder(state, rootClientId), clientId => selectors_unstableGetClientIdWithClientIdsTree(state, clientId)), state => [state.blocks.order]);
/**
 * Returns an array containing the clientIds of all descendants
 * of the blocks given.
 *
 * @param {Object} state Global application state.
 * @param {Array} clientIds Array of blocks to inspect.
 *
 * @return {Array} ids of descendants.
 */

const selectors_getClientIdsOfDescendants = (state, clientIds) => Object(external_lodash_["flatMap"])(clientIds, clientId => {
  const descendants = selectors_getBlockOrder(state, clientId);
  return [...descendants, ...selectors_getClientIdsOfDescendants(state, descendants)];
});
/**
 * Returns an array containing the clientIds of the top-level blocks
 * and their descendants of any depth (for nested blocks).
 *
 * @param {Object} state Global application state.
 *
 * @return {Array} ids of top-level and descendant blocks.
 */

const getClientIdsWithDescendants = Object(rememo["a" /* default */])(state => {
  const topLevelIds = selectors_getBlockOrder(state);
  return [...topLevelIds, ...selectors_getClientIdsOfDescendants(state, topLevelIds)];
}, state => [state.blocks.order]);
/**
 * Returns the total number of blocks, or the total number of blocks with a specific name in a post.
 * The number returned includes nested blocks.
 *
 * @param {Object}  state     Global application state.
 * @param {?string} blockName Optional block name, if specified only blocks of that type will be counted.
 *
 * @return {number} Number of blocks in the post, or number of blocks with name equal to blockName.
 */

const selectors_getGlobalBlockCount = Object(rememo["a" /* default */])((state, blockName) => {
  const clientIds = getClientIdsWithDescendants(state);

  if (!blockName) {
    return clientIds.length;
  }

  return Object(external_lodash_["reduce"])(clientIds, (accumulator, clientId) => {
    const block = state.blocks.byClientId[clientId];
    return block.name === blockName ? accumulator + 1 : accumulator;
  }, 0);
}, state => [state.blocks.order, state.blocks.byClientId]);
/**
 * Given an array of block client IDs, returns the corresponding array of block
 * objects.
 *
 * @param {Object}   state     Editor state.
 * @param {string[]} clientIds Client IDs for which blocks are to be returned.
 *
 * @return {WPBlock[]} Block objects.
 */

const selectors_getBlocksByClientId = Object(rememo["a" /* default */])((state, clientIds) => Object(external_lodash_["map"])(Object(external_lodash_["castArray"])(clientIds), clientId => selectors_getBlock(state, clientId)), state => [state.blocks.byClientId, state.blocks.order, state.blocks.attributes]);
/**
 * Returns the number of blocks currently present in the post.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {number} Number of blocks in the post.
 */

function selectors_getBlockCount(state, rootClientId) {
  return selectors_getBlockOrder(state, rootClientId).length;
}
/**
 * Returns the current selection start block client ID, attribute key and text
 * offset.
 *
 * @param {Object} state Block editor state.
 *
 * @return {WPBlockSelection} Selection start information.
 */

function selectors_getSelectionStart(state) {
  return state.selection.selectionStart;
}
/**
 * Returns the current selection end block client ID, attribute key and text
 * offset.
 *
 * @param {Object} state Block editor state.
 *
 * @return {WPBlockSelection} Selection end information.
 */

function selectors_getSelectionEnd(state) {
  return state.selection.selectionEnd;
}
/**
 * Returns the current block selection start. This value may be null, and it
 * may represent either a singular block selection or multi-selection start.
 * A selection is singular if its start and end match.
 *
 * @param {Object} state Global application state.
 *
 * @return {?string} Client ID of block selection start.
 */

function selectors_getBlockSelectionStart(state) {
  return state.selection.selectionStart.clientId;
}
/**
 * Returns the current block selection end. This value may be null, and it
 * may represent either a singular block selection or multi-selection end.
 * A selection is singular if its start and end match.
 *
 * @param {Object} state Global application state.
 *
 * @return {?string} Client ID of block selection end.
 */

function selectors_getBlockSelectionEnd(state) {
  return state.selection.selectionEnd.clientId;
}
/**
 * Returns the number of blocks currently selected in the post.
 *
 * @param {Object} state Global application state.
 *
 * @return {number} Number of blocks selected in the post.
 */

function selectors_getSelectedBlockCount(state) {
  const multiSelectedBlockCount = selectors_getMultiSelectedBlockClientIds(state).length;

  if (multiSelectedBlockCount) {
    return multiSelectedBlockCount;
  }

  return state.selection.selectionStart.clientId ? 1 : 0;
}
/**
 * Returns true if there is a single selected block, or false otherwise.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Whether a single block is selected.
 */

function selectors_hasSelectedBlock(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  return !!selectionStart.clientId && selectionStart.clientId === selectionEnd.clientId;
}
/**
 * Returns the currently selected block client ID, or null if there is no
 * selected block.
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Selected block client ID.
 */

function selectors_getSelectedBlockClientId(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  const {
    clientId
  } = selectionStart;

  if (!clientId || clientId !== selectionEnd.clientId) {
    return null;
  }

  return clientId;
}
/**
 * Returns the currently selected block, or null if there is no selected block.
 *
 * @param {Object} state Global application state.
 *
 * @return {?Object} Selected block.
 */

function selectors_getSelectedBlock(state) {
  const clientId = selectors_getSelectedBlockClientId(state);
  return clientId ? selectors_getBlock(state, clientId) : null;
}
/**
 * Given a block client ID, returns the root block from which the block is
 * nested, an empty string for top-level blocks, or null if the block does not
 * exist.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find root client ID.
 *
 * @return {?string} Root client ID, if exists
 */

function selectors_getBlockRootClientId(state, clientId) {
  return state.blocks.parents[clientId] !== undefined ? state.blocks.parents[clientId] : null;
}
/**
 * Given a block client ID, returns the list of all its parents from top to bottom.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find root client ID.
 * @param {boolean} ascending Order results from bottom to top (true) or top to bottom (false).
 *
 * @return {Array} ClientIDs of the parent blocks.
 */

const selectors_getBlockParents = Object(rememo["a" /* default */])((state, clientId, ascending = false) => {
  const parents = [];
  let current = clientId;

  while (!!state.blocks.parents[current]) {
    current = state.blocks.parents[current];
    parents.push(current);
  }

  return ascending ? parents : parents.reverse();
}, state => [state.blocks.parents]);
/**
 * Given a block client ID and a block name, returns the list of all its parents
 * from top to bottom, filtered by the given name(s). For example, if passed
 * 'core/group' as the blockName, it will only return parents which are group
 * blocks. If passed `[ 'core/group', 'core/cover']`, as the blockName, it will
 * return parents which are group blocks and parents which are cover blocks.
 *
 * @param {Object}          state     Editor state.
 * @param {string}          clientId  Block from which to find root client ID.
 * @param {string|string[]} blockName Block name(s) to filter.
 * @param {boolean}         ascending Order results from bottom to top (true) or top to bottom (false).
 *
 * @return {Array} ClientIDs of the parent blocks.
 */

const getBlockParentsByBlockName = Object(rememo["a" /* default */])((state, clientId, blockName, ascending = false) => {
  const parents = selectors_getBlockParents(state, clientId, ascending);
  return Object(external_lodash_["map"])(Object(external_lodash_["filter"])(Object(external_lodash_["map"])(parents, id => ({
    id,
    name: selectors_getBlockName(state, id)
  })), ({
    name
  }) => {
    if (Array.isArray(blockName)) {
      return blockName.includes(name);
    }

    return name === blockName;
  }), ({
    id
  }) => id);
}, state => [state.blocks.parents]);
/**
 * Given a block client ID, returns the root of the hierarchy from which the block is nested, return the block itself for root level blocks.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find root client ID.
 *
 * @return {string} Root client ID
 */

function selectors_getBlockHierarchyRootClientId(state, clientId) {
  let current = clientId;
  let parent;

  do {
    parent = current;
    current = state.blocks.parents[current];
  } while (current);

  return parent;
}
/**
 * Given a block client ID, returns the lowest common ancestor with selected client ID.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find common ancestor client ID.
 *
 * @return {string} Common ancestor client ID or undefined
 */

function getLowestCommonAncestorWithSelectedBlock(state, clientId) {
  const selectedId = selectors_getSelectedBlockClientId(state);
  const clientParents = [...selectors_getBlockParents(state, clientId), clientId];
  const selectedParents = [...selectors_getBlockParents(state, selectedId), selectedId];
  let lowestCommonAncestor;
  const maxDepth = Math.min(clientParents.length, selectedParents.length);

  for (let index = 0; index < maxDepth; index++) {
    if (clientParents[index] === selectedParents[index]) {
      lowestCommonAncestor = clientParents[index];
    } else {
      break;
    }
  }

  return lowestCommonAncestor;
}
/**
 * Returns the client ID of the block adjacent one at the given reference
 * startClientId and modifier directionality. Defaults start startClientId to
 * the selected block, and direction as next block. Returns null if there is no
 * adjacent block.
 *
 * @param {Object}  state         Editor state.
 * @param {?string} startClientId Optional client ID of block from which to
 *                                search.
 * @param {?number} modifier      Directionality multiplier (1 next, -1
 *                                previous).
 *
 * @return {?string} Return the client ID of the block, or null if none exists.
 */

function getAdjacentBlockClientId(state, startClientId, modifier = 1) {
  // Default to selected block.
  if (startClientId === undefined) {
    startClientId = selectors_getSelectedBlockClientId(state);
  } // Try multi-selection starting at extent based on modifier.


  if (startClientId === undefined) {
    if (modifier < 0) {
      startClientId = selectors_getFirstMultiSelectedBlockClientId(state);
    } else {
      startClientId = selectors_getLastMultiSelectedBlockClientId(state);
    }
  } // Validate working start client ID.


  if (!startClientId) {
    return null;
  } // Retrieve start block root client ID, being careful to allow the falsey
  // empty string top-level root by explicitly testing against null.


  const rootClientId = selectors_getBlockRootClientId(state, startClientId);

  if (rootClientId === null) {
    return null;
  }

  const {
    order
  } = state.blocks;
  const orderSet = order[rootClientId];
  const index = orderSet.indexOf(startClientId);
  const nextIndex = index + 1 * modifier; // Block was first in set and we're attempting to get previous.

  if (nextIndex < 0) {
    return null;
  } // Block was last in set and we're attempting to get next.


  if (nextIndex === orderSet.length) {
    return null;
  } // Assume incremented index is within the set.


  return orderSet[nextIndex];
}
/**
 * Returns the previous block's client ID from the given reference start ID.
 * Defaults start to the selected block. Returns null if there is no previous
 * block.
 *
 * @param {Object}  state         Editor state.
 * @param {?string} startClientId Optional client ID of block from which to
 *                                search.
 *
 * @return {?string} Adjacent block's client ID, or null if none exists.
 */

function selectors_getPreviousBlockClientId(state, startClientId) {
  return getAdjacentBlockClientId(state, startClientId, -1);
}
/**
 * Returns the next block's client ID from the given reference start ID.
 * Defaults start to the selected block. Returns null if there is no next
 * block.
 *
 * @param {Object}  state         Editor state.
 * @param {?string} startClientId Optional client ID of block from which to
 *                                search.
 *
 * @return {?string} Adjacent block's client ID, or null if none exists.
 */

function selectors_getNextBlockClientId(state, startClientId) {
  return getAdjacentBlockClientId(state, startClientId, 1);
}
/**
 * Returns the initial caret position for the selected block.
 * This position is to used to position the caret properly when the selected block changes.
 * If the current block is not a RichText, having initial position set to 0 means "focus block"
 *
 * @param {Object} state Global application state.
 *
 * @return {0|-1|null} Initial position.
 */

function selectors_getSelectedBlocksInitialCaretPosition(state) {
  return state.initialPosition;
}
/**
 * Returns the current selection set of block client IDs (multiselection or single selection).
 *
 * @param {Object} state Editor state.
 *
 * @return {Array} Multi-selected block client IDs.
 */

const selectors_getSelectedBlockClientIds = Object(rememo["a" /* default */])(state => {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (selectionStart.clientId === undefined || selectionEnd.clientId === undefined) {
    return EMPTY_ARRAY;
  }

  if (selectionStart.clientId === selectionEnd.clientId) {
    return [selectionStart.clientId];
  } // Retrieve root client ID to aid in retrieving relevant nested block
  // order, being careful to allow the falsey empty string top-level root
  // by explicitly testing against null.


  const rootClientId = selectors_getBlockRootClientId(state, selectionStart.clientId);

  if (rootClientId === null) {
    return EMPTY_ARRAY;
  }

  const blockOrder = selectors_getBlockOrder(state, rootClientId);
  const startIndex = blockOrder.indexOf(selectionStart.clientId);
  const endIndex = blockOrder.indexOf(selectionEnd.clientId);

  if (startIndex > endIndex) {
    return blockOrder.slice(endIndex, startIndex + 1);
  }

  return blockOrder.slice(startIndex, endIndex + 1);
}, state => [state.blocks.order, state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId]);
/**
 * Returns the current multi-selection set of block client IDs, or an empty
 * array if there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {Array} Multi-selected block client IDs.
 */

function selectors_getMultiSelectedBlockClientIds(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (selectionStart.clientId === selectionEnd.clientId) {
    return EMPTY_ARRAY;
  }

  return selectors_getSelectedBlockClientIds(state);
}
/**
 * Returns the current multi-selection set of blocks, or an empty array if
 * there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {Array} Multi-selected block objects.
 */

const selectors_getMultiSelectedBlocks = Object(rememo["a" /* default */])(state => {
  const multiSelectedBlockClientIds = selectors_getMultiSelectedBlockClientIds(state);

  if (!multiSelectedBlockClientIds.length) {
    return EMPTY_ARRAY;
  }

  return multiSelectedBlockClientIds.map(clientId => selectors_getBlock(state, clientId));
}, state => [...selectors_getSelectedBlockClientIds.getDependants(state), state.blocks.byClientId, state.blocks.order, state.blocks.attributes]);
/**
 * Returns the client ID of the first block in the multi-selection set, or null
 * if there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} First block client ID in the multi-selection set.
 */

function selectors_getFirstMultiSelectedBlockClientId(state) {
  return Object(external_lodash_["first"])(selectors_getMultiSelectedBlockClientIds(state)) || null;
}
/**
 * Returns the client ID of the last block in the multi-selection set, or null
 * if there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Last block client ID in the multi-selection set.
 */

function selectors_getLastMultiSelectedBlockClientId(state) {
  return Object(external_lodash_["last"])(selectors_getMultiSelectedBlockClientIds(state)) || null;
}
/**
 * Returns true if a multi-selection exists, and the block corresponding to the
 * specified client ID is the first block of the multi-selection set, or false
 * otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is first in multi-selection.
 */

function selectors_isFirstMultiSelectedBlock(state, clientId) {
  return selectors_getFirstMultiSelectedBlockClientId(state) === clientId;
}
/**
 * Returns true if the client ID occurs within the block multi-selection, or
 * false otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is in multi-selection set.
 */

function selectors_isBlockMultiSelected(state, clientId) {
  return selectors_getMultiSelectedBlockClientIds(state).indexOf(clientId) !== -1;
}
/**
 * Returns true if an ancestor of the block is multi-selected, or false
 * otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether an ancestor of the block is in multi-selection
 *                   set.
 */

const selectors_isAncestorMultiSelected = Object(rememo["a" /* default */])((state, clientId) => {
  let ancestorClientId = clientId;
  let isMultiSelected = false;

  while (ancestorClientId && !isMultiSelected) {
    ancestorClientId = selectors_getBlockRootClientId(state, ancestorClientId);
    isMultiSelected = selectors_isBlockMultiSelected(state, ancestorClientId);
  }

  return isMultiSelected;
}, state => [state.blocks.order, state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId]);
/**
 * Returns the client ID of the block which begins the multi-selection set, or
 * null if there is no multi-selection.
 *
 * This is not necessarily the first client ID in the selection.
 *
 * @see getFirstMultiSelectedBlockClientId
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Client ID of block beginning multi-selection.
 */

function selectors_getMultiSelectedBlocksStartClientId(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (selectionStart.clientId === selectionEnd.clientId) {
    return null;
  }

  return selectionStart.clientId || null;
}
/**
 * Returns the client ID of the block which ends the multi-selection set, or
 * null if there is no multi-selection.
 *
 * This is not necessarily the last client ID in the selection.
 *
 * @see getLastMultiSelectedBlockClientId
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Client ID of block ending multi-selection.
 */

function selectors_getMultiSelectedBlocksEndClientId(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (selectionStart.clientId === selectionEnd.clientId) {
    return null;
  }

  return selectionEnd.clientId || null;
}
/**
 * Returns an array containing all block client IDs in the editor in the order
 * they appear. Optionally accepts a root client ID of the block list for which
 * the order should be returned, defaulting to the top-level block order.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Array} Ordered client IDs of editor blocks.
 */

function selectors_getBlockOrder(state, rootClientId) {
  return state.blocks.order[rootClientId || ''] || EMPTY_ARRAY;
}
/**
 * Returns the index at which the block corresponding to the specified client
 * ID occurs within the block order, or `-1` if the block does not exist.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  clientId     Block client ID.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {number} Index at which block exists in order.
 */

function selectors_getBlockIndex(state, clientId, rootClientId) {
  return selectors_getBlockOrder(state, rootClientId).indexOf(clientId);
}
/**
 * Returns true if the block corresponding to the specified client ID is
 * currently selected and no multi-selection exists, or false otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is selected and multi-selection exists.
 */

function selectors_isBlockSelected(state, clientId) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (selectionStart.clientId !== selectionEnd.clientId) {
    return false;
  }

  return selectionStart.clientId === clientId;
}
/**
 * Returns true if one of the block's inner blocks is selected.
 *
 * @param {Object}  state    Editor state.
 * @param {string}  clientId Block client ID.
 * @param {boolean} deep     Perform a deep check.
 *
 * @return {boolean} Whether the block as an inner block selected
 */

function selectors_hasSelectedInnerBlock(state, clientId, deep = false) {
  return Object(external_lodash_["some"])(selectors_getBlockOrder(state, clientId), innerClientId => selectors_isBlockSelected(state, innerClientId) || selectors_isBlockMultiSelected(state, innerClientId) || deep && selectors_hasSelectedInnerBlock(state, innerClientId, deep));
}
/**
 * Returns true if the block corresponding to the specified client ID is
 * currently selected but isn't the last of the selected blocks. Here "last"
 * refers to the block sequence in the document, _not_ the sequence of
 * multi-selection, which is why `state.selectionEnd` isn't used.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is selected and not the last in the
 *                   selection.
 */

function isBlockWithinSelection(state, clientId) {
  if (!clientId) {
    return false;
  }

  const clientIds = selectors_getMultiSelectedBlockClientIds(state);
  const index = clientIds.indexOf(clientId);
  return index > -1 && index < clientIds.length - 1;
}
/**
 * Returns true if a multi-selection has been made, or false otherwise.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Whether multi-selection has been made.
 */

function selectors_hasMultiSelection(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  return selectionStart.clientId !== selectionEnd.clientId;
}
/**
 * Whether in the process of multi-selecting or not. This flag is only true
 * while the multi-selection is being selected (by mouse move), and is false
 * once the multi-selection has been settled.
 *
 * @see hasMultiSelection
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} True if multi-selecting, false if not.
 */

function selectors_isMultiSelecting(state) {
  return state.isMultiSelecting;
}
/**
 * Selector that returns if multi-selection is enabled or not.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} True if it should be possible to multi-select blocks, false if multi-selection is disabled.
 */

function selectors_isSelectionEnabled(state) {
  return state.isSelectionEnabled;
}
/**
 * Returns the block's editing mode, defaulting to "visual" if not explicitly
 * assigned.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {Object} Block editing mode.
 */

function selectors_getBlockMode(state, clientId) {
  return state.blocksMode[clientId] || 'visual';
}
/**
 * Returns true if the user is typing, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether user is typing.
 */

function selectors_isTyping(state) {
  return state.isTyping;
}
/**
 * Returns true if the user is dragging blocks, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether user is dragging blocks.
 */

function isDraggingBlocks(state) {
  return !!state.draggedBlocks.length;
}
/**
 * Returns the client ids of any blocks being directly dragged.
 *
 * This does not include children of a parent being dragged.
 *
 * @param {Object} state Global application state.
 *
 * @return {string[]} Array of dragged block client ids.
 */

function selectors_getDraggedBlockClientIds(state) {
  return state.draggedBlocks;
}
/**
 * Returns whether the block is being dragged.
 *
 * Only returns true if the block is being directly dragged,
 * not if the block is a child of a parent being dragged.
 * See `isAncestorBeingDragged` for child blocks.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId Client id for block to check.
 *
 * @return {boolean} Whether the block is being dragged.
 */

function selectors_isBlockBeingDragged(state, clientId) {
  return state.draggedBlocks.includes(clientId);
}
/**
 * Returns whether a parent/ancestor of the block is being dragged.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId Client id for block to check.
 *
 * @return {boolean} Whether the block's ancestor is being dragged.
 */

function selectors_isAncestorBeingDragged(state, clientId) {
  // Return early if no blocks are being dragged rather than
  // the more expensive check for parents.
  if (!isDraggingBlocks(state)) {
    return false;
  }

  const parents = selectors_getBlockParents(state, clientId);
  return Object(external_lodash_["some"])(parents, parentClientId => selectors_isBlockBeingDragged(state, parentClientId));
}
/**
 * Returns true if the caret is within formatted text, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether the caret is within formatted text.
 */

function selectors_isCaretWithinFormattedText(state) {
  return state.isCaretWithinFormattedText;
}
/**
 * Returns the insertion point, the index at which the new inserted block would
 * be placed. Defaults to the last index.
 *
 * @param {Object} state Editor state.
 *
 * @return {Object} Insertion point object with `rootClientId`, `index`.
 */

function selectors_getBlockInsertionPoint(state) {
  let rootClientId, index;
  const {
    insertionPoint,
    selection: {
      selectionEnd
    }
  } = state;

  if (insertionPoint !== null) {
    return insertionPoint;
  }

  const {
    clientId
  } = selectionEnd;

  if (clientId) {
    rootClientId = selectors_getBlockRootClientId(state, clientId) || undefined;
    index = selectors_getBlockIndex(state, selectionEnd.clientId, rootClientId) + 1;
  } else {
    index = selectors_getBlockOrder(state).length;
  }

  return {
    rootClientId,
    index
  };
}
/**
 * Returns true if we should show the block insertion point.
 *
 * @param {Object} state Global application state.
 *
 * @return {?boolean} Whether the insertion point is visible or not.
 */

function selectors_isBlockInsertionPointVisible(state) {
  return state.insertionPoint !== null;
}
/**
 * Returns whether the blocks matches the template or not.
 *
 * @param {boolean} state
 * @return {?boolean} Whether the template is valid or not.
 */

function selectors_isValidTemplate(state) {
  return state.template.isValid;
}
/**
 * Returns the defined block template
 *
 * @param {boolean} state
 * @return {?Array}        Block Template
 */

function getTemplate(state) {
  return state.settings.template;
}
/**
 * Returns the defined block template lock. Optionally accepts a root block
 * client ID as context, otherwise defaulting to the global context.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional block root client ID.
 *
 * @return {?string} Block Template Lock
 */

function selectors_getTemplateLock(state, rootClientId) {
  if (!rootClientId) {
    return state.settings.templateLock;
  }

  const blockListSettings = selectors_getBlockListSettings(state, rootClientId);

  if (!blockListSettings) {
    return null;
  }

  return blockListSettings.templateLock;
}

const checkAllowList = (list, item, defaultResult = null) => {
  if (Object(external_lodash_["isBoolean"])(list)) {
    return list;
  }

  if (Object(external_lodash_["isArray"])(list)) {
    // TODO: when there is a canonical way to detect that we are editing a post
    // the following check should be changed to something like:
    // if ( list.includes( 'core/post-content' ) && getEditorMode() === 'post-content' && item === null )
    if (list.includes('core/post-content') && item === null) {
      return true;
    }

    return list.includes(item);
  }

  return defaultResult;
};
/**
 * Determines if the given block type is allowed to be inserted into the block list.
 * This function is not exported and not memoized because using a memoized selector
 * inside another memoized selector is just a waste of time.
 *
 * @param {Object}         state        Editor state.
 * @param {string|Object}  blockName    The block type object, e.g., the response
 *                                      from the block directory; or a string name of
 *                                      an installed block type, e.g.' core/paragraph'.
 * @param {?string}        rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block type is allowed to be inserted.
 */


const canInsertBlockTypeUnmemoized = (state, blockName, rootClientId = null) => {
  let blockType;

  if (blockName && 'object' === typeof blockName) {
    blockType = blockName;
    blockName = blockType.name;
  } else {
    blockType = Object(external_wp_blocks_["getBlockType"])(blockName);
  }

  if (!blockType) {
    return false;
  }

  const {
    allowedBlockTypes
  } = selectors_getSettings(state);
  const isBlockAllowedInEditor = checkAllowList(allowedBlockTypes, blockName, true);

  if (!isBlockAllowedInEditor) {
    return false;
  }

  const isLocked = !!selectors_getTemplateLock(state, rootClientId);

  if (isLocked) {
    return false;
  }

  const parentBlockListSettings = selectors_getBlockListSettings(state, rootClientId); // The parent block doesn't have settings indicating it doesn't support
  // inner blocks, return false.

  if (rootClientId && parentBlockListSettings === undefined) {
    return false;
  }

  const parentAllowedBlocks = parentBlockListSettings === null || parentBlockListSettings === void 0 ? void 0 : parentBlockListSettings.allowedBlocks;
  const hasParentAllowedBlock = checkAllowList(parentAllowedBlocks, blockName);
  const blockAllowedParentBlocks = blockType.parent;
  const parentName = selectors_getBlockName(state, rootClientId);
  const hasBlockAllowedParent = checkAllowList(blockAllowedParentBlocks, parentName);

  if (hasParentAllowedBlock !== null && hasBlockAllowedParent !== null) {
    return hasParentAllowedBlock || hasBlockAllowedParent;
  } else if (hasParentAllowedBlock !== null) {
    return hasParentAllowedBlock;
  } else if (hasBlockAllowedParent !== null) {
    return hasBlockAllowedParent;
  }

  return true;
};
/**
 * Determines if the given block type is allowed to be inserted into the block list.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  blockName    The name of the block type, e.g.' core/paragraph'.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block type is allowed to be inserted.
 */


const selectors_canInsertBlockType = Object(rememo["a" /* default */])(canInsertBlockTypeUnmemoized, (state, blockName, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId[rootClientId], state.settings.allowedBlockTypes, state.settings.templateLock]);
/**
 * Determines if the given blocks are allowed to be inserted into the block
 * list.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  clientIds    The block client IDs to be inserted.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given blocks are allowed to be inserted.
 */

function selectors_canInsertBlocks(state, clientIds, rootClientId = null) {
  return clientIds.every(id => selectors_canInsertBlockType(state, selectors_getBlockName(state, id), rootClientId));
}
/**
 * Returns information about how recently and frequently a block has been inserted.
 *
 * @param {Object} state Global application state.
 * @param {string} id    A string which identifies the insert, e.g. 'core/block/12'
 *
 * @return {?{ time: number, count: number }} An object containing `time` which is when the last
 *                                            insert occurred as a UNIX epoch, and `count` which is
 *                                            the number of inserts that have occurred.
 */

function getInsertUsage(state, id) {
  var _state$preferences$in, _state$preferences$in2;

  return (_state$preferences$in = (_state$preferences$in2 = state.preferences.insertUsage) === null || _state$preferences$in2 === void 0 ? void 0 : _state$preferences$in2[id]) !== null && _state$preferences$in !== void 0 ? _state$preferences$in : null;
}
/**
 * Returns whether we can show a block type in the inserter
 *
 * @param {Object} state Global State
 * @param {Object} blockType BlockType
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block type is allowed to be shown in the inserter.
 */


const canIncludeBlockTypeInInserter = (state, blockType, rootClientId) => {
  if (!Object(external_wp_blocks_["hasBlockSupport"])(blockType, 'inserter', true)) {
    return false;
  }

  return canInsertBlockTypeUnmemoized(state, blockType.name, rootClientId);
};
/**
 * Return a function to be used to tranform a block variation to an inserter item
 *
 * @param {Object} state Global State
 * @param {Object} item Denormalized inserter item
 * @return {Function} Function to transform a block variation to inserter item
 */


const getItemFromVariation = (state, item) => variation => {
  const variationId = `${item.id}/${variation.name}`;
  const {
    time,
    count = 0
  } = getInsertUsage(state, variationId) || {};
  return { ...item,
    id: variationId,
    icon: variation.icon || item.icon,
    title: variation.title || item.title,
    description: variation.description || item.description,
    category: variation.category || item.category,
    // If `example` is explicitly undefined for the variation, the preview will not be shown.
    example: variation.hasOwnProperty('example') ? variation.example : item.example,
    initialAttributes: { ...item.initialAttributes,
      ...variation.attributes
    },
    innerBlocks: variation.innerBlocks,
    keywords: variation.keywords || item.keywords,
    frecency: calculateFrecency(time, count)
  };
};
/**
 * Returns the calculated frecency.
 *
 * 'frecency' is a heuristic (https://en.wikipedia.org/wiki/Frecency)
 * that combines block usage frequenty and recency.
 *
 * @param {number} time When the last insert occurred as a UNIX epoch
 * @param {number} count The number of inserts that have occurred.
 *
 * @return {number} The calculated frecency.
 */


const calculateFrecency = (time, count) => {
  if (!time) {
    return count;
  } // The selector is cached, which means Date.now() is the last time that the
  // relevant state changed. This suits our needs.


  const duration = Date.now() - time;

  switch (true) {
    case duration < MILLISECONDS_PER_HOUR:
      return count * 4;

    case duration < MILLISECONDS_PER_DAY:
      return count * 2;

    case duration < MILLISECONDS_PER_WEEK:
      return count / 2;

    default:
      return count / 4;
  }
};
/**
 * Returns a function that accepts a block type and builds an item to be shown
 * in a specific context. It's used for building items for Inserter and available
 * block Transfroms list.
 *
 * @param {Object} state Editor state.
 * @param {Object} options Options object for handling the building of a block type.
 * @param {string} options.buildScope The scope for which the item is going to be used.
 * @return {Function} Function returns an item to be shown in a specific context (Inserter|Transforms list).
 */


const buildBlockTypeItem = (state, {
  buildScope = 'inserter'
}) => blockType => {
  const id = blockType.name;
  let isDisabled = false;

  if (!Object(external_wp_blocks_["hasBlockSupport"])(blockType.name, 'multiple', true)) {
    isDisabled = Object(external_lodash_["some"])(selectors_getBlocksByClientId(state, getClientIdsWithDescendants(state)), {
      name: blockType.name
    });
  }

  const {
    time,
    count = 0
  } = getInsertUsage(state, id) || {};
  const blockItemBase = {
    id,
    name: blockType.name,
    title: blockType.title,
    icon: blockType.icon,
    isDisabled,
    frecency: calculateFrecency(time, count)
  };
  if (buildScope === 'transform') return blockItemBase;
  const inserterVariations = blockType.variations.filter(({
    scope
  }) => !scope || scope.includes('inserter'));
  return { ...blockItemBase,
    initialAttributes: {},
    description: blockType.description,
    category: blockType.category,
    keywords: blockType.keywords,
    variations: inserterVariations,
    example: blockType.example,
    utility: 1 // deprecated

  };
};
/**
 * Determines the items that appear in the inserter. Includes both static
 * items (e.g. a regular block type) and dynamic items (e.g. a reusable block).
 *
 * Each item object contains what's necessary to display a button in the
 * inserter and handle its selection.
 *
 * The 'frecency' property is a heuristic (https://en.wikipedia.org/wiki/Frecency)
 * that combines block usage frequenty and recency.
 *
 * Items are returned ordered descendingly by their 'utility' and 'frecency'.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {WPEditorInserterItem[]} Items that appear in inserter.
 *
 * @typedef {Object} WPEditorInserterItem
 * @property {string}   id                Unique identifier for the item.
 * @property {string}   name              The type of block to create.
 * @property {Object}   initialAttributes Attributes to pass to the newly created block.
 * @property {string}   title             Title of the item, as it appears in the inserter.
 * @property {string}   icon              Dashicon for the item, as it appears in the inserter.
 * @property {string}   category          Block category that the item is associated with.
 * @property {string[]} keywords          Keywords that can be searched to find this item.
 * @property {boolean}  isDisabled        Whether or not the user should be prevented from inserting
 *                                        this item.
 * @property {number}   frecency          Heuristic that combines frequency and recency.
 */


const selectors_getInserterItems = Object(rememo["a" /* default */])((state, rootClientId = null) => {
  const buildBlockTypeInserterItem = buildBlockTypeItem(state, {
    buildScope: 'inserter'
  });

  const buildReusableBlockInserterItem = reusableBlock => {
    const id = `core/block/${reusableBlock.id}`;

    const referencedBlocks = __experimentalGetParsedReusableBlock(state, reusableBlock.id);

    let referencedBlockType;

    if (referencedBlocks.length === 1) {
      referencedBlockType = Object(external_wp_blocks_["getBlockType"])(referencedBlocks[0].name);
    }

    const {
      time,
      count = 0
    } = getInsertUsage(state, id) || {};
    const frecency = calculateFrecency(time, count);
    return {
      id,
      name: 'core/block',
      initialAttributes: {
        ref: reusableBlock.id
      },
      title: reusableBlock.title.raw,
      icon: referencedBlockType ? referencedBlockType.icon : templateIcon,
      category: 'reusable',
      keywords: [],
      isDisabled: false,
      utility: 1,
      // deprecated
      frecency
    };
  };

  const blockTypeInserterItems = Object(external_wp_blocks_["getBlockTypes"])().filter(blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId)).map(buildBlockTypeInserterItem);
  const reusableBlockInserterItems = canInsertBlockTypeUnmemoized(state, 'core/block', rootClientId) ? getReusableBlocks(state).map(buildReusableBlockInserterItem) : []; // Exclude any block type item that is to be replaced by a default
  // variation.

  const visibleBlockTypeInserterItems = blockTypeInserterItems.filter(({
    variations = []
  }) => !variations.some(({
    isDefault
  }) => isDefault));
  const blockVariations = []; // Show all available blocks with variations

  for (const item of blockTypeInserterItems) {
    const {
      variations = []
    } = item;

    if (variations.length) {
      const variationMapper = getItemFromVariation(state, item);
      blockVariations.push(...variations.map(variationMapper));
    }
  } // Prioritize core blocks's display in inserter.


  const prioritizeCoreBlocks = (a, b) => {
    const coreBlockNamePrefix = 'core/';
    const firstIsCoreBlock = a.name.startsWith(coreBlockNamePrefix);
    const secondIsCoreBlock = b.name.startsWith(coreBlockNamePrefix);

    if (firstIsCoreBlock && secondIsCoreBlock) {
      return 0;
    }

    return firstIsCoreBlock && !secondIsCoreBlock ? -1 : 1;
  }; // Ensure core blocks are prioritized in the returned results,
  // because third party blocks can be registered earlier than
  // the core blocks (usually by using the `init` action),
  // thus affecting the display order.
  // We don't sort reusable blocks as they are handled differently.


  const sortedBlockTypes = [...visibleBlockTypeInserterItems, ...blockVariations].sort(prioritizeCoreBlocks);
  return [...sortedBlockTypes, ...reusableBlockInserterItems];
}, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.blocks.order, state.preferences.insertUsage, state.settings.allowedBlockTypes, state.settings.templateLock, getReusableBlocks(state), Object(external_wp_blocks_["getBlockTypes"])()]);
/**
 * Determines the items that appear in the available block transforms list.
 *
 * Each item object contains what's necessary to display a menu item in the
 * transform list and handle its selection.
 *
 * The 'frecency' property is a heuristic (https://en.wikipedia.org/wiki/Frecency)
 * that combines block usage frequenty and recency.
 *
 * Items are returned ordered descendingly by their 'frecency'.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {WPEditorTransformItem[]} Items that appear in inserter.
 *
 * @typedef {Object} WPEditorTransformItem
 * @property {string}   id                Unique identifier for the item.
 * @property {string}   name              The type of block to create.
 * @property {string}   title             Title of the item, as it appears in the inserter.
 * @property {string}   icon              Dashicon for the item, as it appears in the inserter.
 * @property {boolean}  isDisabled        Whether or not the user should be prevented from inserting
 *                                        this item.
 * @property {number}   frecency          Heuristic that combines frequency and recency.
 */

const selectors_getBlockTransformItems = Object(rememo["a" /* default */])((state, blocks, rootClientId = null) => {
  const buildBlockTypeTransformItem = buildBlockTypeItem(state, {
    buildScope: 'transform'
  });
  const blockTypeTransformItems = Object(external_wp_blocks_["getBlockTypes"])().filter(blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId)).map(buildBlockTypeTransformItem);
  const itemsByName = Object(external_lodash_["mapKeys"])(blockTypeTransformItems, ({
    name
  }) => name);
  const possibleTransforms = Object(external_wp_blocks_["getPossibleBlockTransformations"])(blocks).reduce((accumulator, block) => {
    if (itemsByName[block === null || block === void 0 ? void 0 : block.name]) {
      accumulator.push(itemsByName[block.name]);
    }

    return accumulator;
  }, []);
  const possibleBlockTransformations = Object(external_lodash_["orderBy"])(possibleTransforms, block => itemsByName[block.name].frecency, 'desc');
  return possibleBlockTransformations;
}, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.preferences.insertUsage, state.settings.allowedBlockTypes, state.settings.templateLock, Object(external_wp_blocks_["getBlockTypes"])()]);
/**
 * Determines whether there are items to show in the inserter.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Items that appear in inserter.
 */

const selectors_hasInserterItems = Object(rememo["a" /* default */])((state, rootClientId = null) => {
  const hasBlockType = Object(external_lodash_["some"])(Object(external_wp_blocks_["getBlockTypes"])(), blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId));

  if (hasBlockType) {
    return true;
  }

  const hasReusableBlock = canInsertBlockTypeUnmemoized(state, 'core/block', rootClientId) && getReusableBlocks(state).length > 0;
  return hasReusableBlock;
}, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.settings.allowedBlockTypes, state.settings.templateLock, getReusableBlocks(state), Object(external_wp_blocks_["getBlockTypes"])()]);
/**
 * Returns the list of allowed inserter blocks for inner blocks children
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Array?} The list of allowed block types.
 */

const selectors_experimentalGetAllowedBlocks = Object(rememo["a" /* default */])((state, rootClientId = null) => {
  if (!rootClientId) {
    return;
  }

  return Object(external_lodash_["filter"])(Object(external_wp_blocks_["getBlockTypes"])(), blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId));
}, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.settings.allowedBlockTypes, state.settings.templateLock, Object(external_wp_blocks_["getBlockTypes"])()]);

const checkAllowListRecursive = (blocks, allowedBlockTypes) => {
  if (Object(external_lodash_["isBoolean"])(allowedBlockTypes)) {
    return allowedBlockTypes;
  }

  const blocksQueue = [...blocks];

  while (blocksQueue.length > 0) {
    var _block$innerBlocks;

    const block = blocksQueue.shift();
    const isAllowed = checkAllowList(allowedBlockTypes, block.name || block.blockName, true);

    if (!isAllowed) {
      return false;
    }

    (_block$innerBlocks = block.innerBlocks) === null || _block$innerBlocks === void 0 ? void 0 : _block$innerBlocks.forEach(innerBlock => {
      blocksQueue.push(innerBlock);
    });
  }

  return true;
};

const __experimentalGetParsedPattern = Object(rememo["a" /* default */])((state, patternName) => {
  const patterns = state.settings.__experimentalBlockPatterns;
  const pattern = patterns.find(({
    name
  }) => name === patternName);

  if (!pattern) {
    return null;
  }

  return { ...pattern,
    blocks: Object(external_wp_blocks_["parse"])(pattern.content)
  };
}, state => [state.settings.__experimentalBlockPatterns]);
const getAllAllowedPatterns = Object(rememo["a" /* default */])(state => {
  const patterns = state.settings.__experimentalBlockPatterns;
  const {
    allowedBlockTypes
  } = selectors_getSettings(state);
  const parsedPatterns = patterns.map(({
    name
  }) => __experimentalGetParsedPattern(state, name));
  const allowedPatterns = parsedPatterns.filter(({
    blocks
  }) => checkAllowListRecursive(blocks, allowedBlockTypes));
  return allowedPatterns;
}, state => [state.settings.__experimentalBlockPatterns, state.settings.allowedBlockTypes]);
/**
 * Returns the list of allowed patterns for inner blocks children.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional target root client ID.
 *
 * @return {Array?} The list of allowed patterns.
 */

const selectors_experimentalGetAllowedPatterns = Object(rememo["a" /* default */])((state, rootClientId = null) => {
  const availableParsedPatterns = getAllAllowedPatterns(state);
  const patternsAllowed = Object(external_lodash_["filter"])(availableParsedPatterns, ({
    blocks
  }) => blocks.every(({
    name
  }) => selectors_canInsertBlockType(state, name, rootClientId)));
  return patternsAllowed;
}, (state, rootClientId) => [state.settings.__experimentalBlockPatterns, state.settings.allowedBlockTypes, state.settings.templateLock, state.blockListSettings[rootClientId], state.blocks.byClientId[rootClientId]]);
/**
 * Returns the list of patterns based on their declared `blockTypes`
 * and a block's name.
 * Patterns can use `blockTypes` to integrate in work flows like
 * suggesting appropriate patterns in a Placeholder state(during insertion)
 * or blocks transformations.
 *
 * @param {Object} state Editor state.
 * @param {string|string[]} blockNames Block's name or array of block names to find matching pattens.
 * @param {?string} rootClientId Optional target root client ID.
 *
 * @return {Array} The list of matched block patterns based on declared `blockTypes` and block name.
 */

const selectors_experimentalGetPatternsByBlockTypes = Object(rememo["a" /* default */])((state, blockNames, rootClientId = null) => {
  if (!blockNames) return EMPTY_ARRAY;

  const patterns = selectors_experimentalGetAllowedPatterns(state, rootClientId);

  const normalizedBlockNames = Array.isArray(blockNames) ? blockNames : [blockNames];
  return patterns.filter(pattern => {
    var _pattern$blockTypes, _pattern$blockTypes$s;

    return pattern === null || pattern === void 0 ? void 0 : (_pattern$blockTypes = pattern.blockTypes) === null || _pattern$blockTypes === void 0 ? void 0 : (_pattern$blockTypes$s = _pattern$blockTypes.some) === null || _pattern$blockTypes$s === void 0 ? void 0 : _pattern$blockTypes$s.call(_pattern$blockTypes, blockName => normalizedBlockNames.includes(blockName));
  });
}, (state, rootClientId) => [...selectors_experimentalGetAllowedPatterns.getDependants(state, rootClientId)]);
/**
 * Determines the items that appear in the available pattern transforms list.
 *
 * For now we only handle blocks without InnerBlocks and take into account
 * the `__experimentalRole` property of blocks' attributes for the transformation.
 *
 * We return the first set of possible eligible block patterns,
 * by checking the `blockTypes` property. We still have to recurse through
 * block pattern's blocks and try to find matches from the selected blocks.
 * Now this happens in the consumer to avoid heavy operations in the selector.
 *
 * @param {Object}  state Editor state.
 * @param {Object[]} blocks The selected blocks.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {WPBlockPattern[]} Items that are eligible for a pattern transformation.
 */

const selectors_experimentalGetPatternTransformItems = Object(rememo["a" /* default */])((state, blocks, rootClientId = null) => {
  if (!blocks) return EMPTY_ARRAY;
  /**
   * For now we only handle blocks without InnerBlocks and take into account
   * the `__experimentalRole` property of blocks' attributes for the transformation.
   * Note that the blocks have been retrieved through `getBlock`, which doesn't
   * return the inner blocks of an inner block controller, so we still need
   * to check for this case too.
   */

  if (blocks.some(({
    clientId,
    innerBlocks
  }) => innerBlocks.length || areInnerBlocksControlled(state, clientId))) {
    return EMPTY_ARRAY;
  } // Create a Set of the selected block names that is used in patterns filtering.


  const selectedBlockNames = Array.from(new Set(blocks.map(({
    name
  }) => name)));
  /**
   * Here we will return first set of possible eligible block patterns,
   * by checking the `blockTypes` property. We still have to recurse through
   * block pattern's blocks and try to find matches from the selected blocks.
   * Now this happens in the consumer to avoid heavy operations in the selector.
   */

  return selectors_experimentalGetPatternsByBlockTypes(state, selectedBlockNames, rootClientId);
}, (state, rootClientId) => [...selectors_experimentalGetPatternsByBlockTypes.getDependants(state, rootClientId)]);
/**
 * Returns the Block List settings of a block, if any exist.
 *
 * @param {Object}  state    Editor state.
 * @param {?string} clientId Block client ID.
 *
 * @return {?Object} Block settings of the block if set.
 */

function selectors_getBlockListSettings(state, clientId) {
  return state.blockListSettings[clientId];
}
/**
 * Returns the editor settings.
 *
 * @param {Object} state Editor state.
 *
 * @return {Object} The editor settings object.
 */

function selectors_getSettings(state) {
  return state.settings;
}
/**
 * Returns true if the most recent block change is be considered persistent, or
 * false otherwise. A persistent change is one committed by BlockEditorProvider
 * via its `onChange` callback, in addition to `onInput`.
 *
 * @param {Object} state Block editor state.
 *
 * @return {boolean} Whether the most recent block change was persistent.
 */

function selectors_isLastBlockChangePersistent(state) {
  return state.blocks.isPersistentChange;
}
/**
 * Returns the block list settings for an array of blocks, if any exist.
 *
 * @param {Object} state     Editor state.
 * @param {Array}  clientIds Block client IDs.
 *
 * @return {Object} An object where the keys are client ids and the values are
 *                  a block list setting object.
 */

const selectors_experimentalGetBlockListSettingsForBlocks = Object(rememo["a" /* default */])((state, clientIds = []) => {
  return clientIds.reduce((blockListSettingsForBlocks, clientId) => {
    if (!state.blockListSettings[clientId]) {
      return blockListSettingsForBlocks;
    }

    return { ...blockListSettingsForBlocks,
      [clientId]: state.blockListSettings[clientId]
    };
  }, {});
}, state => [state.blockListSettings]);
/**
 * Returns the parsed block saved as shared block with the given ID.
 *
 * @param {Object}        state Global application state.
 * @param {number|string} ref   The shared block's ID.
 *
 * @return {Object} The parsed block.
 */

const __experimentalGetParsedReusableBlock = Object(rememo["a" /* default */])((state, ref) => {
  const reusableBlock = Object(external_lodash_["find"])(getReusableBlocks(state), block => block.id === ref);

  if (!reusableBlock) {
    return null;
  } // Only reusableBlock.content.raw should be used here, `reusableBlock.content` is a
  // workaround until #22127 is fixed.


  return Object(external_wp_blocks_["parse"])(typeof reusableBlock.content.raw === 'string' ? reusableBlock.content.raw : reusableBlock.content);
}, state => [getReusableBlocks(state)]);
/**
 * Returns the title of a given reusable block
 *
 * @param {Object}        state Global application state.
 * @param {number|string} ref   The shared block's ID.
 *
 * @return {string} The reusable block saved title.
 */

const selectors_experimentalGetReusableBlockTitle = Object(rememo["a" /* default */])((state, ref) => {
  var _reusableBlock$title;

  const reusableBlock = Object(external_lodash_["find"])(getReusableBlocks(state), block => block.id === ref);

  if (!reusableBlock) {
    return null;
  }

  return (_reusableBlock$title = reusableBlock.title) === null || _reusableBlock$title === void 0 ? void 0 : _reusableBlock$title.raw;
}, state => [getReusableBlocks(state)]);
/**
 * Returns true if the most recent block change is be considered ignored, or
 * false otherwise. An ignored change is one not to be committed by
 * BlockEditorProvider, neither via `onChange` nor `onInput`.
 *
 * @param {Object} state Block editor state.
 *
 * @return {boolean} Whether the most recent block change was ignored.
 */

function selectors_unstableIsLastBlockChangeIgnored(state) {
  // TODO: Removal Plan: Changes incurred by RECEIVE_BLOCKS should not be
  // ignored if in-fact they result in a change in blocks state. The current
  // need to ignore changes not a result of user interaction should be
  // accounted for in the refactoring of reusable blocks as occurring within
  // their own separate block editor / state (#7119).
  return state.blocks.isIgnoredChange;
}
/**
 * Returns the block attributes changed as a result of the last dispatched
 * action.
 *
 * @param {Object} state Block editor state.
 *
 * @return {Object<string,Object>} Subsets of block attributes changed, keyed
 *                                 by block client ID.
 */

function __experimentalGetLastBlockAttributeChanges(state) {
  return state.lastBlockAttributesChange;
}
/**
 * Returns the available reusable blocks
 *
 * @param {Object} state Global application state.
 *
 * @return {Array} Reusable blocks
 */

function getReusableBlocks(state) {
  var _state$settings$__exp, _state$settings;

  return (_state$settings$__exp = state === null || state === void 0 ? void 0 : (_state$settings = state.settings) === null || _state$settings === void 0 ? void 0 : _state$settings.__experimentalReusableBlocks) !== null && _state$settings$__exp !== void 0 ? _state$settings$__exp : EMPTY_ARRAY;
}
/**
 * Returns whether the navigation mode is enabled.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean}     Is navigation mode enabled.
 */


function selectors_isNavigationMode(state) {
  return state.isNavigationMode;
}
/**
 * Returns whether block moving mode is enabled.
 *
 * @param {Object} state Editor state.
 *
 * @return {string}     Client Id of moving block.
 */

function selectors_hasBlockMovingClientId(state) {
  return state.hasBlockMovingClientId;
}
/**
 * Returns true if the last change was an automatic change, false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether the last change was automatic.
 */

function selectors_didAutomaticChange(state) {
  return !!state.automaticChangeStatus;
}
/**
 * Returns true if the current highlighted block matches the block clientId.
 *
 * @param {Object} state Global application state.
 * @param {string} clientId The block to check.
 *
 * @return {boolean} Whether the block is currently highlighted.
 */

function selectors_isBlockHighlighted(state, clientId) {
  return state.highlightedBlock === clientId;
}
/**
 * Checks if a given block has controlled inner blocks.
 *
 * @param {Object} state Global application state.
 * @param {string} clientId The block to check.
 *
 * @return {boolean} True if the block has controlled inner blocks.
 */

function areInnerBlocksControlled(state, clientId) {
  return !!state.blocks.controlledInnerBlocks[clientId];
}
/**
 * Returns the clientId for the first 'active' block of a given array of block names.
 * A block is 'active' if it (or a child) is the selected block.
 * Returns the first match moving up the DOM from the selected block.
 *
 * @param {Object} state Global application state.
 * @param {string[]} validBlocksNames The names of block types to check for.
 *
 * @return {string} The matching block's clientId.
 */

const __experimentalGetActiveBlockIdByBlockNames = Object(rememo["a" /* default */])((state, validBlockNames) => {
  if (!validBlockNames.length) {
    return null;
  } // Check if selected block is a valid entity area.


  const selectedBlockClientId = selectors_getSelectedBlockClientId(state);

  if (validBlockNames.includes(selectors_getBlockName(state, selectedBlockClientId))) {
    return selectedBlockClientId;
  } // Check if first selected block is a child of a valid entity area.


  const multiSelectedBlockClientIds = selectors_getMultiSelectedBlockClientIds(state);
  const entityAreaParents = getBlockParentsByBlockName(state, selectedBlockClientId || multiSelectedBlockClientIds[0], validBlockNames);

  if (entityAreaParents) {
    // Last parent closest/most interior.
    return Object(external_lodash_["last"])(entityAreaParents);
  }

  return null;
}, (state, validBlockNames) => [state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId, validBlockNames]);
/**
 * Tells if the block with the passed clientId was just inserted.
 *
 * @param {Object} state Global application state.
 * @param {Object} clientId Client Id of the block.
 * @param {?string} source Optional insertion source of the block.
 * @return {boolean} True if the block matches the last block inserted from the specified source.
 */

function wasBlockJustInserted(state, clientId, source) {
  const {
    lastBlockInserted
  } = state;
  return lastBlockInserted.clientId === clientId && lastBlockInserted.source === source;
}

// EXTERNAL MODULE: external ["wp","a11y"]
var external_wp_a11y_ = __webpack_require__("gdqT");

// EXTERNAL MODULE: external ["wp","deprecated"]
var external_wp_deprecated_ = __webpack_require__("NMb1");
var external_wp_deprecated_default = /*#__PURE__*/__webpack_require__.n(external_wp_deprecated_);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/store/controls.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


const __unstableMarkAutomaticChangeFinalControl = function () {
  return {
    type: 'MARK_AUTOMATIC_CHANGE_FINAL_CONTROL'
  };
};
const controls_controls = {
  SLEEP({
    duration
  }) {
    return new Promise(resolve => {
      setTimeout(resolve, duration);
    });
  },

  MARK_AUTOMATIC_CHANGE_FINAL_CONTROL: Object(external_wp_data_["createRegistryControl"])(registry => () => {
    const {
      requestIdleCallback = callback => setTimeout(callback, 100)
    } = window;
    requestIdleCallback(() => registry.dispatch(store).__unstableMarkAutomaticChangeFinal());
  })
};
/* harmony default export */ var store_controls = (controls_controls);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/store/constants.js
const STORE_NAME = 'core/block-editor';

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/store/actions.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */



/**
 * Generator which will yield a default block insert action if there
 * are no other blocks at the root of the editor. This generator should be used
 * in actions which may result in no blocks remaining in the editor (removal,
 * replacement, etc).
 */

function* ensureDefaultBlock() {
  const count = yield external_wp_data_["controls"].select(STORE_NAME, 'getBlockCount'); // To avoid a focus loss when removing the last block, assure there is
  // always a default block if the last of the blocks have been removed.

  if (count === 0) {
    const {
      __unstableHasCustomAppender
    } = yield external_wp_data_["controls"].select(STORE_NAME, 'getSettings'); // If there's an custom appender, don't insert default block.
    // We have to remember to manually move the focus elsewhere to
    // prevent it from being lost though.

    if (__unstableHasCustomAppender) {
      return;
    }

    return yield actions_insertDefaultBlock();
  }
}
/**
 * Returns an action object used in signalling that blocks state should be
 * reset to the specified array of blocks, taking precedence over any other
 * content reflected as an edit in state.
 *
 * @param {Array} blocks Array of blocks.
 */


function* actions_resetBlocks(blocks) {
  yield {
    type: 'RESET_BLOCKS',
    blocks
  };
  return yield* validateBlocksToTemplate(blocks);
}
/**
 * Block validity is a function of blocks state (at the point of a
 * reset) and the template setting. As a compromise to its placement
 * across distinct parts of state, it is implemented here as a side-
 * effect of the block reset action.
 *
 * @param {Array} blocks Array of blocks.
 */

function* validateBlocksToTemplate(blocks) {
  const template = yield external_wp_data_["controls"].select(STORE_NAME, 'getTemplate');
  const templateLock = yield external_wp_data_["controls"].select(STORE_NAME, 'getTemplateLock'); // Unlocked templates are considered always valid because they act
  // as default values only.

  const isBlocksValidToTemplate = !template || templateLock !== 'all' || Object(external_wp_blocks_["doBlocksMatchTemplate"])(blocks, template); // Update if validity has changed.

  const isValidTemplate = yield external_wp_data_["controls"].select(STORE_NAME, 'isValidTemplate');

  if (isBlocksValidToTemplate !== isValidTemplate) {
    yield setTemplateValidity(isBlocksValidToTemplate);
    return isBlocksValidToTemplate;
  }
}
/**
 * A block selection object.
 *
 * @typedef {Object} WPBlockSelection
 *
 * @property {string} clientId     A block client ID.
 * @property {string} attributeKey A block attribute key.
 * @property {number} offset       An attribute value offset, based on the rich
 *                                 text value. See `wp.richText.create`.
 */

/**
 * Returns an action object used in signalling that selection state should be
 * reset to the specified selection.
 *
 * @param {WPBlockSelection} selectionStart  The selection start.
 * @param {WPBlockSelection} selectionEnd    The selection end.
 * @param {0|-1|null}        initialPosition Initial block position.
 *
 * @return {Object} Action object.
 */

function actions_resetSelection(selectionStart, selectionEnd, initialPosition) {
  return {
    type: 'RESET_SELECTION',
    selectionStart,
    selectionEnd,
    initialPosition
  };
}
/**
 * Returns an action object used in signalling that blocks have been received.
 * Unlike resetBlocks, these should be appended to the existing known set, not
 * replacing.
 *
 * @param {Object[]} blocks Array of block objects.
 *
 * @return {Object} Action object.
 */

function receiveBlocks(blocks) {
  return {
    type: 'RECEIVE_BLOCKS',
    blocks
  };
}
/**
 * Returns an action object used in signalling that the multiple blocks'
 * attributes with the specified client IDs have been updated.
 *
 * @param {string|string[]} clientIds  Block client IDs.
 * @param {Object}          attributes Block attributes to be merged. Should be keyed by clientIds if
 * uniqueByBlock is true.
 * @param {boolean}          uniqueByBlock true if each block in clientIds array has a unique set of attributes
 * @return {Object} Action object.
 */

function actions_updateBlockAttributes(clientIds, attributes, uniqueByBlock = false) {
  return {
    type: 'UPDATE_BLOCK_ATTRIBUTES',
    clientIds: Object(external_lodash_["castArray"])(clientIds),
    attributes,
    uniqueByBlock
  };
}
/**
 * Returns an action object used in signalling that the block with the
 * specified client ID has been updated.
 *
 * @param {string} clientId Block client ID.
 * @param {Object} updates  Block attributes to be merged.
 *
 * @return {Object} Action object.
 */

function actions_updateBlock(clientId, updates) {
  return {
    type: 'UPDATE_BLOCK',
    clientId,
    updates
  };
}
/**
 * Returns an action object used in signalling that the block with the
 * specified client ID has been selected, optionally accepting a position
 * value reflecting its selection directionality. An initialPosition of -1
 * reflects a reverse selection.
 *
 * @param {string}    clientId        Block client ID.
 * @param {0|-1|null} initialPosition Optional initial position. Pass as -1 to
 *                                  reflect reverse selection.
 *
 * @return {Object} Action object.
 */

function actions_selectBlock(clientId, initialPosition = 0) {
  return {
    type: 'SELECT_BLOCK',
    initialPosition,
    clientId
  };
}
/**
 * Yields action objects used in signalling that the block preceding the given
 * clientId should be selected.
 *
 * @param {string} clientId Block client ID.
 */

function* selectPreviousBlock(clientId) {
  const previousBlockClientId = yield external_wp_data_["controls"].select(STORE_NAME, 'getPreviousBlockClientId', clientId);

  if (previousBlockClientId) {
    yield actions_selectBlock(previousBlockClientId, -1);
    return [previousBlockClientId];
  }
}
/**
 * Yields action objects used in signalling that the block following the given
 * clientId should be selected.
 *
 * @param {string} clientId Block client ID.
 */

function* selectNextBlock(clientId) {
  const nextBlockClientId = yield external_wp_data_["controls"].select(STORE_NAME, 'getNextBlockClientId', clientId);

  if (nextBlockClientId) {
    yield actions_selectBlock(nextBlockClientId);
    return [nextBlockClientId];
  }
}
/**
 * Returns an action object used in signalling that a block multi-selection has started.
 *
 * @return {Object} Action object.
 */

function actions_startMultiSelect() {
  return {
    type: 'START_MULTI_SELECT'
  };
}
/**
 * Returns an action object used in signalling that block multi-selection stopped.
 *
 * @return {Object} Action object.
 */

function actions_stopMultiSelect() {
  return {
    type: 'STOP_MULTI_SELECT'
  };
}
/**
 * Returns an action object used in signalling that block multi-selection changed.
 *
 * @param {string} start First block of the multi selection.
 * @param {string} end   Last block of the multiselection.
 */

function* actions_multiSelect(start, end) {
  const startBlockRootClientId = yield external_wp_data_["controls"].select(STORE_NAME, 'getBlockRootClientId', start);
  const endBlockRootClientId = yield external_wp_data_["controls"].select(STORE_NAME, 'getBlockRootClientId', end); // Only allow block multi-selections at the same level.

  if (startBlockRootClientId !== endBlockRootClientId) {
    return;
  }

  yield {
    type: 'MULTI_SELECT',
    start,
    end
  };
  const blockCount = yield external_wp_data_["controls"].select(STORE_NAME, 'getSelectedBlockCount');
  Object(external_wp_a11y_["speak"])(Object(external_wp_i18n_["sprintf"])(
  /* translators: %s: number of selected blocks */
  Object(external_wp_i18n_["_n"])('%s block selected.', '%s blocks selected.', blockCount), blockCount), 'assertive');
}
/**
 * Returns an action object used in signalling that the block selection is cleared.
 *
 * @return {Object} Action object.
 */

function actions_clearSelectedBlock() {
  return {
    type: 'CLEAR_SELECTED_BLOCK'
  };
}
/**
 * Returns an action object that enables or disables block selection.
 *
 * @param {boolean} [isSelectionEnabled=true] Whether block selection should
 *                                            be enabled.
 *
 * @return {Object} Action object.
 */

function actions_toggleSelection(isSelectionEnabled = true) {
  return {
    type: 'TOGGLE_SELECTION',
    isSelectionEnabled
  };
}

function getBlocksWithDefaultStylesApplied(blocks, blockEditorSettings) {
  var _blockEditorSettings$, _blockEditorSettings$2;

  const preferredStyleVariations = (_blockEditorSettings$ = blockEditorSettings === null || blockEditorSettings === void 0 ? void 0 : (_blockEditorSettings$2 = blockEditorSettings.__experimentalPreferredStyleVariations) === null || _blockEditorSettings$2 === void 0 ? void 0 : _blockEditorSettings$2.value) !== null && _blockEditorSettings$ !== void 0 ? _blockEditorSettings$ : {};
  return blocks.map(block => {
    var _block$attributes;

    const blockName = block.name;

    if (!Object(external_wp_blocks_["hasBlockSupport"])(blockName, 'defaultStylePicker', true)) {
      return block;
    }

    if (!preferredStyleVariations[blockName]) {
      return block;
    }

    const className = (_block$attributes = block.attributes) === null || _block$attributes === void 0 ? void 0 : _block$attributes.className;

    if (className !== null && className !== void 0 && className.includes('is-style-')) {
      return block;
    }

    const {
      attributes = {}
    } = block;
    const blockStyle = preferredStyleVariations[blockName];
    return { ...block,
      attributes: { ...attributes,
        className: `${className || ''} is-style-${blockStyle}`.trim()
      }
    };
  });
}
/**
 * Returns an action object signalling that a blocks should be replaced with
 * one or more replacement blocks.
 *
 * @param {(string|string[])} clientIds       Block client ID(s) to replace.
 * @param {(Object|Object[])} blocks          Replacement block(s).
 * @param {number}            indexToSelect   Index of replacement block to select.
 * @param {0|-1|null}         initialPosition Index of caret after in the selected block after the operation.
 * @param {?Object}           meta            Optional Meta values to be passed to the action object.
 *
 * @yield {Object} Action object.
 */


function* actions_replaceBlocks(clientIds, blocks, indexToSelect, initialPosition = 0, meta) {
  clientIds = Object(external_lodash_["castArray"])(clientIds);
  blocks = getBlocksWithDefaultStylesApplied(Object(external_lodash_["castArray"])(blocks), yield external_wp_data_["controls"].select(STORE_NAME, 'getSettings'));
  const rootClientId = yield external_wp_data_["controls"].select(STORE_NAME, 'getBlockRootClientId', Object(external_lodash_["first"])(clientIds)); // Replace is valid if the new blocks can be inserted in the root block.

  for (let index = 0; index < blocks.length; index++) {
    const block = blocks[index];
    const canInsertBlock = yield external_wp_data_["controls"].select(STORE_NAME, 'canInsertBlockType', block.name, rootClientId);

    if (!canInsertBlock) {
      return;
    }
  }

  yield {
    type: 'REPLACE_BLOCKS',
    clientIds,
    blocks,
    time: Date.now(),
    indexToSelect,
    initialPosition,
    meta
  };
  yield* ensureDefaultBlock();
}
/**
 * Returns an action object signalling that a single block should be replaced
 * with one or more replacement blocks.
 *
 * @param {(string|string[])} clientId Block client ID to replace.
 * @param {(Object|Object[])} block    Replacement block(s).
 *
 * @return {Object} Action object.
 */

function actions_replaceBlock(clientId, block) {
  return actions_replaceBlocks(clientId, block);
}
/**
 * Higher-order action creator which, given the action type to dispatch creates
 * an action creator for managing block movement.
 *
 * @param {string} type Action type to dispatch.
 *
 * @return {Function} Action creator.
 */

function createOnMove(type) {
  return (clientIds, rootClientId) => {
    return {
      clientIds: Object(external_lodash_["castArray"])(clientIds),
      type,
      rootClientId
    };
  };
}

const actions_moveBlocksDown = createOnMove('MOVE_BLOCKS_DOWN');
const actions_moveBlocksUp = createOnMove('MOVE_BLOCKS_UP');
/**
 * Returns an action object signalling that the given blocks should be moved to
 * a new position.
 *
 * @param  {?string} clientIds        The client IDs of the blocks.
 * @param  {?string} fromRootClientId Root client ID source.
 * @param  {?string} toRootClientId   Root client ID destination.
 * @param  {number}  index            The index to move the blocks to.
 *
 * @yield {Object} Action object.
 */

function* actions_moveBlocksToPosition(clientIds, fromRootClientId = '', toRootClientId = '', index) {
  const templateLock = yield external_wp_data_["controls"].select(STORE_NAME, 'getTemplateLock', fromRootClientId); // If locking is equal to all on the original clientId (fromRootClientId),
  // it is not possible to move the block to any other position.

  if (templateLock === 'all') {
    return;
  }

  const action = {
    type: 'MOVE_BLOCKS_TO_POSITION',
    fromRootClientId,
    toRootClientId,
    clientIds,
    index
  }; // If moving inside the same root block the move is always possible.

  if (fromRootClientId === toRootClientId) {
    yield action;
    return;
  } // If templateLock is insert we can not remove the block from the parent.
  // Given that here we know that we are moving the block to a different
  // parent, the move should not be possible if the condition is true.


  if (templateLock === 'insert') {
    return;
  }

  const canInsertBlocks = yield external_wp_data_["controls"].select(STORE_NAME, 'canInsertBlocks', clientIds, toRootClientId); // If moving to other parent block, the move is possible if we can insert a block of the same type inside the new parent block.

  if (canInsertBlocks) {
    yield action;
  }
}
/**
 * Returns an action object signalling that the given block should be moved to a
 * new position.
 *
 * @param  {?string} clientId         The client ID of the block.
 * @param  {?string} fromRootClientId Root client ID source.
 * @param  {?string} toRootClientId   Root client ID destination.
 * @param  {number}  index            The index to move the block to.
 *
 * @yield {Object} Action object.
 */

function* actions_moveBlockToPosition(clientId, fromRootClientId = '', toRootClientId = '', index) {
  yield actions_moveBlocksToPosition([clientId], fromRootClientId, toRootClientId, index);
}
/**
 * Returns an action object used in signalling that a single block should be
 * inserted, optionally at a specific index respective a root block list.
 *
 * @param {Object}  block            Block object to insert.
 * @param {?number} index            Index at which block should be inserted.
 * @param {?string} rootClientId     Optional root client ID of block list on which to insert.
 * @param {?boolean} updateSelection If true block selection will be updated. If false, block selection will not change. Defaults to true.
 * @param {?Object} meta             Optional Meta values to be passed to the action object.
 *
 * @return {Object} Action object.
 */

function actions_insertBlock(block, index, rootClientId, updateSelection = true, meta) {
  return actions_insertBlocks([block], index, rootClientId, updateSelection, 0, meta);
}
/**
 * Returns an action object used in signalling that an array of blocks should
 * be inserted, optionally at a specific index respective a root block list.
 *
 * @param {Object[]}  blocks          Block objects to insert.
 * @param {?number}   index           Index at which block should be inserted.
 * @param {?string}   rootClientId    Optional root client ID of block list on which to insert.
 * @param {?boolean}  updateSelection If true block selection will be updated.  If false, block selection will not change. Defaults to true.
 * @param {0|-1|null} initialPosition Initial focus position. Setting it to null prevent focusing the inserted block.
 * @param {?Object}   meta            Optional Meta values to be passed to the action object.
 * @return {Object} Action object.
 */

function* actions_insertBlocks(blocks, index, rootClientId, updateSelection = true, initialPosition = 0, meta) {
  if (Object(external_lodash_["isObject"])(initialPosition)) {
    meta = initialPosition;
    initialPosition = 0;
    external_wp_deprecated_default()("meta argument in wp.data.dispatch('core/block-editor')", {
      since: '10.1',
      plugin: 'Gutenberg',
      hint: 'The meta argument is now the 6th argument of the function'
    });
  }

  blocks = getBlocksWithDefaultStylesApplied(Object(external_lodash_["castArray"])(blocks), yield external_wp_data_["controls"].select(STORE_NAME, 'getSettings'));
  const allowedBlocks = [];

  for (const block of blocks) {
    const isValid = yield external_wp_data_["controls"].select(STORE_NAME, 'canInsertBlockType', block.name, rootClientId);

    if (isValid) {
      allowedBlocks.push(block);
    }
  }

  if (allowedBlocks.length) {
    return {
      type: 'INSERT_BLOCKS',
      blocks: allowedBlocks,
      index,
      rootClientId,
      time: Date.now(),
      updateSelection,
      initialPosition: updateSelection ? initialPosition : null,
      meta
    };
  }
}
/**
 * Returns an action object used in signalling that the insertion point should
 * be shown.
 *
 * @param {?string} rootClientId Optional root client ID of block list on
 *                               which to insert.
 * @param {?number} index        Index at which block should be inserted.
 * @param {Object}  __unstableOptions Wether or not to show an inserter button.
 *
 * @return {Object} Action object.
 */

function actions_showInsertionPoint(rootClientId, index, __unstableOptions = {}) {
  const {
    __unstableWithInserter
  } = __unstableOptions;
  return {
    type: 'SHOW_INSERTION_POINT',
    rootClientId,
    index,
    __unstableWithInserter
  };
}
/**
 * Returns an action object hiding the insertion point.
 *
 * @return {Object} Action object.
 */

function actions_hideInsertionPoint() {
  return {
    type: 'HIDE_INSERTION_POINT'
  };
}
/**
 * Returns an action object resetting the template validity.
 *
 * @param {boolean}  isValid  template validity flag.
 *
 * @return {Object} Action object.
 */

function setTemplateValidity(isValid) {
  return {
    type: 'SET_TEMPLATE_VALIDITY',
    isValid
  };
}
/**
 * Returns an action object synchronize the template with the list of blocks
 *
 * @return {Object} Action object.
 */

function* synchronizeTemplate() {
  yield {
    type: 'SYNCHRONIZE_TEMPLATE'
  };
  const blocks = yield external_wp_data_["controls"].select(STORE_NAME, 'getBlocks');
  const template = yield external_wp_data_["controls"].select(STORE_NAME, 'getTemplate');
  const updatedBlockList = Object(external_wp_blocks_["synchronizeBlocksWithTemplate"])(blocks, template);
  return yield actions_resetBlocks(updatedBlockList);
}
/**
 * Returns an action object used in signalling that two blocks should be merged
 *
 * @param {string} firstBlockClientId  Client ID of the first block to merge.
 * @param {string} secondBlockClientId Client ID of the second block to merge.
 */

function* actions_mergeBlocks(firstBlockClientId, secondBlockClientId) {
  const blocks = [firstBlockClientId, secondBlockClientId];
  yield {
    type: 'MERGE_BLOCKS',
    blocks
  };
  const [clientIdA, clientIdB] = blocks;
  const blockA = yield external_wp_data_["controls"].select(STORE_NAME, 'getBlock', clientIdA);
  const blockAType = Object(external_wp_blocks_["getBlockType"])(blockA.name); // Only focus the previous block if it's not mergeable

  if (!blockAType.merge) {
    yield actions_selectBlock(blockA.clientId);
    return;
  }

  const blockB = yield external_wp_data_["controls"].select(STORE_NAME, 'getBlock', clientIdB);
  const blockBType = Object(external_wp_blocks_["getBlockType"])(blockB.name);
  const {
    clientId,
    attributeKey,
    offset
  } = yield external_wp_data_["controls"].select(STORE_NAME, 'getSelectionStart');
  const selectedBlockType = clientId === clientIdA ? blockAType : blockBType;
  const attributeDefinition = selectedBlockType.attributes[attributeKey];
  const canRestoreTextSelection = (clientId === clientIdA || clientId === clientIdB) && attributeKey !== undefined && offset !== undefined && // We cannot restore text selection if the RichText identifier
  // is not a defined block attribute key. This can be the case if the
  // fallback intance ID is used to store selection (and no RichText
  // identifier is set), or when the identifier is wrong.
  !!attributeDefinition;

  if (!attributeDefinition) {
    if (typeof attributeKey === 'number') {
      window.console.error(`RichText needs an identifier prop that is the block attribute key of the attribute it controls. Its type is expected to be a string, but was ${typeof attributeKey}`);
    } else {
      window.console.error('The RichText identifier prop does not match any attributes defined by the block.');
    }
  } // A robust way to retain selection position through various transforms
  // is to insert a special character at the position and then recover it.


  const START_OF_SELECTED_AREA = '\u0086'; // Clone the blocks so we don't insert the character in a "live" block.

  const cloneA = Object(external_wp_blocks_["cloneBlock"])(blockA);
  const cloneB = Object(external_wp_blocks_["cloneBlock"])(blockB);

  if (canRestoreTextSelection) {
    const selectedBlock = clientId === clientIdA ? cloneA : cloneB;
    const html = selectedBlock.attributes[attributeKey];
    const {
      multiline: multilineTag,
      __unstableMultilineWrapperTags: multilineWrapperTags,
      __unstablePreserveWhiteSpace: preserveWhiteSpace
    } = attributeDefinition;
    const value = Object(external_wp_richText_["insert"])(Object(external_wp_richText_["create"])({
      html,
      multilineTag,
      multilineWrapperTags,
      preserveWhiteSpace
    }), START_OF_SELECTED_AREA, offset, offset);
    selectedBlock.attributes[attributeKey] = Object(external_wp_richText_["toHTMLString"])({
      value,
      multilineTag,
      preserveWhiteSpace
    });
  } // We can only merge blocks with similar types
  // thus, we transform the block to merge first


  const blocksWithTheSameType = blockA.name === blockB.name ? [cloneB] : Object(external_wp_blocks_["switchToBlockType"])(cloneB, blockA.name); // If the block types can not match, do nothing

  if (!blocksWithTheSameType || !blocksWithTheSameType.length) {
    return;
  } // Calling the merge to update the attributes and remove the block to be merged


  const updatedAttributes = blockAType.merge(cloneA.attributes, blocksWithTheSameType[0].attributes);

  if (canRestoreTextSelection) {
    const newAttributeKey = Object(external_lodash_["findKey"])(updatedAttributes, v => typeof v === 'string' && v.indexOf(START_OF_SELECTED_AREA) !== -1);
    const convertedHtml = updatedAttributes[newAttributeKey];
    const {
      multiline: multilineTag,
      __unstableMultilineWrapperTags: multilineWrapperTags,
      __unstablePreserveWhiteSpace: preserveWhiteSpace
    } = blockAType.attributes[newAttributeKey];
    const convertedValue = Object(external_wp_richText_["create"])({
      html: convertedHtml,
      multilineTag,
      multilineWrapperTags,
      preserveWhiteSpace
    });
    const newOffset = convertedValue.text.indexOf(START_OF_SELECTED_AREA);
    const newValue = Object(external_wp_richText_["remove"])(convertedValue, newOffset, newOffset + 1);
    const newHtml = Object(external_wp_richText_["toHTMLString"])({
      value: newValue,
      multilineTag,
      preserveWhiteSpace
    });
    updatedAttributes[newAttributeKey] = newHtml;
    yield actions_selectionChange(blockA.clientId, newAttributeKey, newOffset, newOffset);
  }

  yield* actions_replaceBlocks([blockA.clientId, blockB.clientId], [{ ...blockA,
    attributes: { ...blockA.attributes,
      ...updatedAttributes
    }
  }, ...blocksWithTheSameType.slice(1)]);
}
/**
 * Yields action objects used in signalling that the blocks corresponding to
 * the set of specified client IDs are to be removed.
 *
 * @param {string|string[]} clientIds      Client IDs of blocks to remove.
 * @param {boolean}         selectPrevious True if the previous block should be
 *                                         selected when a block is removed.
 */

function* actions_removeBlocks(clientIds, selectPrevious = true) {
  if (!clientIds || !clientIds.length) {
    return;
  }

  clientIds = Object(external_lodash_["castArray"])(clientIds);
  const rootClientId = yield external_wp_data_["controls"].select(STORE_NAME, 'getBlockRootClientId', clientIds[0]);
  const isLocked = yield external_wp_data_["controls"].select(STORE_NAME, 'getTemplateLock', rootClientId);

  if (isLocked) {
    return;
  }

  let previousBlockId;

  if (selectPrevious) {
    previousBlockId = yield selectPreviousBlock(clientIds[0]);
  } else {
    previousBlockId = yield external_wp_data_["controls"].select(STORE_NAME, 'getPreviousBlockClientId', clientIds[0]);
  }

  yield {
    type: 'REMOVE_BLOCKS',
    clientIds
  }; // To avoid a focus loss when removing the last block, assure there is
  // always a default block if the last of the blocks have been removed.

  const defaultBlockId = yield* ensureDefaultBlock();
  return [previousBlockId || defaultBlockId];
}
/**
 * Returns an action object used in signalling that the block with the
 * specified client ID is to be removed.
 *
 * @param {string}  clientId       Client ID of block to remove.
 * @param {boolean} selectPrevious True if the previous block should be
 *                                 selected when a block is removed.
 *
 * @return {Object} Action object.
 */

function actions_removeBlock(clientId, selectPrevious) {
  return actions_removeBlocks([clientId], selectPrevious);
}
/**
 * Returns an action object used in signalling that the inner blocks with the
 * specified client ID should be replaced.
 *
 * @param {string}    rootClientId    Client ID of the block whose InnerBlocks will re replaced.
 * @param {Object[]}  blocks          Block objects to insert as new InnerBlocks
 * @param {?boolean}  updateSelection If true block selection will be updated. If false, block selection will not change. Defaults to false.
 * @param {0|-1|null} initialPosition Initial block position.
 * @return {Object} Action object.
 */

function actions_replaceInnerBlocks(rootClientId, blocks, updateSelection = false, initialPosition = 0) {
  return {
    type: 'REPLACE_INNER_BLOCKS',
    rootClientId,
    blocks,
    updateSelection,
    initialPosition: updateSelection ? initialPosition : null,
    time: Date.now()
  };
}
/**
 * Returns an action object used to toggle the block editing mode between
 * visual and HTML modes.
 *
 * @param {string} clientId Block client ID.
 *
 * @return {Object} Action object.
 */

function toggleBlockMode(clientId) {
  return {
    type: 'TOGGLE_BLOCK_MODE',
    clientId
  };
}
/**
 * Returns an action object used in signalling that the user has begun to type.
 *
 * @return {Object} Action object.
 */

function actions_startTyping() {
  return {
    type: 'START_TYPING'
  };
}
/**
 * Returns an action object used in signalling that the user has stopped typing.
 *
 * @return {Object} Action object.
 */

function actions_stopTyping() {
  return {
    type: 'STOP_TYPING'
  };
}
/**
 * Returns an action object used in signalling that the user has begun to drag blocks.
 *
 * @param {string[]} clientIds An array of client ids being dragged
 *
 * @return {Object} Action object.
 */

function actions_startDraggingBlocks(clientIds = []) {
  return {
    type: 'START_DRAGGING_BLOCKS',
    clientIds
  };
}
/**
 * Returns an action object used in signalling that the user has stopped dragging blocks.
 *
 * @return {Object} Action object.
 */

function actions_stopDraggingBlocks() {
  return {
    type: 'STOP_DRAGGING_BLOCKS'
  };
}
/**
 * Returns an action object used in signalling that the caret has entered formatted text.
 *
 * @return {Object} Action object.
 */

function actions_enterFormattedText() {
  return {
    type: 'ENTER_FORMATTED_TEXT'
  };
}
/**
 * Returns an action object used in signalling that the user caret has exited formatted text.
 *
 * @return {Object} Action object.
 */

function actions_exitFormattedText() {
  return {
    type: 'EXIT_FORMATTED_TEXT'
  };
}
/**
 * Returns an action object used in signalling that the user caret has changed
 * position.
 *
 * @param {string} clientId     The selected block client ID.
 * @param {string} attributeKey The selected block attribute key.
 * @param {number} startOffset  The start offset.
 * @param {number} endOffset    The end offset.
 *
 * @return {Object} Action object.
 */

function actions_selectionChange(clientId, attributeKey, startOffset, endOffset) {
  return {
    type: 'SELECTION_CHANGE',
    clientId,
    attributeKey,
    startOffset,
    endOffset
  };
}
/**
 * Returns an action object used in signalling that a new block of the default
 * type should be added to the block list.
 *
 * @param {?Object} attributes   Optional attributes of the block to assign.
 * @param {?string} rootClientId Optional root client ID of block list on which
 *                               to append.
 * @param {?number} index        Optional index where to insert the default block
 *
 * @return {Object} Action object
 */

function actions_insertDefaultBlock(attributes, rootClientId, index) {
  // Abort if there is no default block type (if it has been unregistered).
  const defaultBlockName = Object(external_wp_blocks_["getDefaultBlockName"])();

  if (!defaultBlockName) {
    return;
  }

  const block = Object(external_wp_blocks_["createBlock"])(defaultBlockName, attributes);
  return actions_insertBlock(block, index, rootClientId);
}
/**
 * Returns an action object that changes the nested settings of a given block.
 *
 * @param {string} clientId Client ID of the block whose nested setting are
 *                          being received.
 * @param {Object} settings Object with the new settings for the nested block.
 *
 * @return {Object} Action object
 */

function actions_updateBlockListSettings(clientId, settings) {
  return {
    type: 'UPDATE_BLOCK_LIST_SETTINGS',
    clientId,
    settings
  };
}
/**
 * Returns an action object used in signalling that the block editor settings have been updated.
 *
 * @param {Object} settings Updated settings
 *
 * @return {Object} Action object
 */

function actions_updateSettings(settings) {
  return {
    type: 'UPDATE_SETTINGS',
    settings
  };
}
/**
 * Returns an action object used in signalling that a temporary reusable blocks have been saved
 * in order to switch its temporary id with the real id.
 *
 * @param {string} id        Reusable block's id.
 * @param {string} updatedId Updated block's id.
 *
 * @return {Object} Action object.
 */

function __unstableSaveReusableBlock(id, updatedId) {
  return {
    type: 'SAVE_REUSABLE_BLOCK_SUCCESS',
    id,
    updatedId
  };
}
/**
 * Returns an action object used in signalling that the last block change should be marked explicitly as persistent.
 *
 * @return {Object} Action object.
 */

function actions_unstableMarkLastChangeAsPersistent() {
  return {
    type: 'MARK_LAST_CHANGE_AS_PERSISTENT'
  };
}
/**
 * Returns an action object used in signalling that the next block change should be marked explicitly as not persistent.
 *
 * @return {Object} Action object.
 */

function actions_unstableMarkNextChangeAsNotPersistent() {
  return {
    type: 'MARK_NEXT_CHANGE_AS_NOT_PERSISTENT'
  };
}
/**
 * Returns an action object used in signalling that the last block change is
 * an automatic change, meaning it was not performed by the user, and can be
 * undone using the `Escape` and `Backspace` keys. This action must be called
 * after the change was made, and any actions that are a consequence of it, so
 * it is recommended to be called at the next idle period to ensure all
 * selection changes have been recorded.
 */

function* actions_unstableMarkAutomaticChange() {
  yield {
    type: 'MARK_AUTOMATIC_CHANGE'
  };
  yield __unstableMarkAutomaticChangeFinalControl();
}
function __unstableMarkAutomaticChangeFinal() {
  return {
    type: 'MARK_AUTOMATIC_CHANGE_FINAL'
  };
}
/**
 * Generators that triggers an action used to enable or disable the navigation mode.
 *
 * @param {string} isNavigationMode Enable/Disable navigation mode.
 */

function* actions_setNavigationMode(isNavigationMode = true) {
  yield {
    type: 'SET_NAVIGATION_MODE',
    isNavigationMode
  };

  if (isNavigationMode) {
    Object(external_wp_a11y_["speak"])(Object(external_wp_i18n_["__"])('You are currently in navigation mode. Navigate blocks using the Tab key and Arrow keys. Use Left and Right Arrow keys to move between nesting levels. To exit navigation mode and edit the selected block, press Enter.'));
  } else {
    Object(external_wp_a11y_["speak"])(Object(external_wp_i18n_["__"])('You are currently in edit mode. To return to the navigation mode, press Escape.'));
  }
}
/**
 * Generator that triggers an action used to enable or disable the block moving mode.
 *
 * @param {string|null} hasBlockMovingClientId Enable/Disable block moving mode.
 */

function* actions_setBlockMovingClientId(hasBlockMovingClientId = null) {
  yield {
    type: 'SET_BLOCK_MOVING_MODE',
    hasBlockMovingClientId
  };

  if (hasBlockMovingClientId) {
    Object(external_wp_a11y_["speak"])(Object(external_wp_i18n_["__"])('Use the Tab key and Arrow keys to choose new block location. Use Left and Right Arrow keys to move between nesting levels. Once location is selected press Enter or Space to move the block.'));
  }
}
/**
 * Generator that triggers an action used to duplicate a list of blocks.
 *
 * @param {string[]} clientIds
 * @param {boolean} updateSelection
 */

function* actions_duplicateBlocks(clientIds, updateSelection = true) {
  if (!clientIds && !clientIds.length) {
    return;
  }

  const blocks = yield external_wp_data_["controls"].select(STORE_NAME, 'getBlocksByClientId', clientIds);
  const rootClientId = yield external_wp_data_["controls"].select(STORE_NAME, 'getBlockRootClientId', clientIds[0]); // Return early if blocks don't exist.

  if (Object(external_lodash_["some"])(blocks, block => !block)) {
    return;
  }

  const blockNames = blocks.map(block => block.name); // Return early if blocks don't support multiple usage.

  if (Object(external_lodash_["some"])(blockNames, blockName => !Object(external_wp_blocks_["hasBlockSupport"])(blockName, 'multiple', true))) {
    return;
  }

  const lastSelectedIndex = yield external_wp_data_["controls"].select(STORE_NAME, 'getBlockIndex', Object(external_lodash_["last"])(Object(external_lodash_["castArray"])(clientIds)), rootClientId);
  const clonedBlocks = blocks.map(block => Object(external_wp_blocks_["__experimentalCloneSanitizedBlock"])(block));
  yield actions_insertBlocks(clonedBlocks, lastSelectedIndex + 1, rootClientId, updateSelection);

  if (clonedBlocks.length > 1 && updateSelection) {
    yield actions_multiSelect(Object(external_lodash_["first"])(clonedBlocks).clientId, Object(external_lodash_["last"])(clonedBlocks).clientId);
  }

  return clonedBlocks.map(block => block.clientId);
}
/**
 * Generator used to insert an empty block after a given block.
 *
 * @param {string} clientId
 */

function* actions_insertBeforeBlock(clientId) {
  if (!clientId) {
    return;
  }

  const rootClientId = yield external_wp_data_["controls"].select(STORE_NAME, 'getBlockRootClientId', clientId);
  const isLocked = yield external_wp_data_["controls"].select(STORE_NAME, 'getTemplateLock', rootClientId);

  if (isLocked) {
    return;
  }

  const firstSelectedIndex = yield external_wp_data_["controls"].select(STORE_NAME, 'getBlockIndex', clientId, rootClientId);
  return yield actions_insertDefaultBlock({}, rootClientId, firstSelectedIndex);
}
/**
 * Generator used to insert an empty block before a given block.
 *
 * @param {string} clientId
 */

function* actions_insertAfterBlock(clientId) {
  if (!clientId) {
    return;
  }

  const rootClientId = yield external_wp_data_["controls"].select(STORE_NAME, 'getBlockRootClientId', clientId);
  const isLocked = yield external_wp_data_["controls"].select(STORE_NAME, 'getTemplateLock', rootClientId);

  if (isLocked) {
    return;
  }

  const firstSelectedIndex = yield external_wp_data_["controls"].select(STORE_NAME, 'getBlockIndex', clientId, rootClientId);
  return yield actions_insertDefaultBlock({}, rootClientId, firstSelectedIndex + 1);
}
/**
 * Returns an action object that toggles the highlighted block state.
 *
 * @param {string} clientId The block's clientId.
 * @param {boolean} isHighlighted The highlight state.
 */

function actions_toggleBlockHighlight(clientId, isHighlighted) {
  return {
    type: 'TOGGLE_BLOCK_HIGHLIGHT',
    clientId,
    isHighlighted
  };
}
/**
 * Yields action objects used in signalling that the block corresponding to the
 * given clientId should appear to "flash" by rhythmically highlighting it.
 *
 * @param {string} clientId Target block client ID.
 */

function* actions_flashBlock(clientId) {
  yield actions_toggleBlockHighlight(clientId, true);
  yield {
    type: 'SLEEP',
    duration: 150
  };
  yield actions_toggleBlockHighlight(clientId, false);
}
/**
 * Returns an action object that sets whether the block has controlled innerblocks.
 *
 * @param {string} clientId The block's clientId.
 * @param {boolean} hasControlledInnerBlocks True if the block's inner blocks are controlled.
 */

function actions_setHasControlledInnerBlocks(clientId, hasControlledInnerBlocks) {
  return {
    type: 'SET_HAS_CONTROLLED_INNER_BLOCKS',
    hasControlledInnerBlocks,
    clientId
  };
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/store/index.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */






/**
 * Block editor data store configuration.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#registerStore
 *
 * @type {Object}
 */

const storeConfig = {
  reducer: store_reducer,
  selectors: selectors_namespaceObject,
  actions: actions_namespaceObject,
  controls: store_controls
};
/**
 * Store definition for the block editor namespace.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore
 *
 * @type {Object}
 */

const store = Object(external_wp_data_["createReduxStore"])(STORE_NAME, { ...storeConfig,
  persist: ['preferences']
}); // Ideally we'd use register instead of register stores.

Object(external_wp_data_["registerStore"])(STORE_NAME, { ...storeConfig,
  persist: ['preferences']
});

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/use-display-block-controls/index.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



function useDisplayBlockControls() {
  const {
    isSelected,
    clientId,
    name
  } = useBlockEditContext();
  const isFirstAndSameTypeMultiSelected = Object(external_wp_data_["useSelect"])(select => {
    // Don't bother checking, see OR statement below.
    if (isSelected) {
      return;
    }

    const {
      getBlockName,
      isFirstMultiSelectedBlock,
      getMultiSelectedBlockClientIds
    } = select(store);

    if (!isFirstMultiSelectedBlock(clientId)) {
      return false;
    }

    return getMultiSelectedBlockClientIds().every(id => getBlockName(id) === name);
  }, [clientId, isSelected, name]);
  return isSelected || isFirstAndSameTypeMultiSelected;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-controls/groups.js
/**
 * WordPress dependencies
 */

const BlockControlsDefault = Object(external_wp_components_["createSlotFill"])('BlockControls');
const BlockControlsBlock = Object(external_wp_components_["createSlotFill"])('BlockControlsBlock');
const BlockControlsInline = Object(external_wp_components_["createSlotFill"])('BlockFormatControls');
const BlockControlsOther = Object(external_wp_components_["createSlotFill"])('BlockControlsOther');
const groups = {
  default: BlockControlsDefault,
  block: BlockControlsBlock,
  inline: BlockControlsInline,
  other: BlockControlsOther
};
/* harmony default export */ var block_controls_groups = (groups);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-controls/fill.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function BlockControlsFill({
  group = 'default',
  controls,
  children
}) {
  if (!useDisplayBlockControls()) {
    return null;
  }

  const Fill = block_controls_groups[group].Fill;
  return Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalStyleProvider"], {
    document: document
  }, Object(external_wp_element_["createElement"])(Fill, null, fillProps => {
    // Children passed to BlockControlsFill will not have access to any
    // React Context whose Provider is part of the BlockControlsSlot tree.
    // So we re-create the Provider in this subtree.
    const value = !Object(external_lodash_["isEmpty"])(fillProps) ? fillProps : null;
    return Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalToolbarContext"].Provider, {
      value: value
    }, group === 'default' && Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarGroup"], {
      controls: controls
    }), children);
  }));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-controls/slot.js



/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function BlockControlsSlot({
  group = 'default',
  ...props
}) {
  const accessibleToolbarState = Object(external_wp_element_["useContext"])(external_wp_components_["__experimentalToolbarContext"]);
  const Slot = block_controls_groups[group].Slot;
  const slot = Object(external_wp_components_["__experimentalUseSlot"])(Slot.__unstableName);
  const hasFills = Boolean(slot.fills && slot.fills.length);

  if (!hasFills) {
    return null;
  }

  if (group === 'default') {
    return Object(external_wp_element_["createElement"])(Slot, Object(esm_extends["a" /* default */])({}, props, {
      bubblesVirtually: true,
      fillProps: accessibleToolbarState
    }));
  }

  return Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarGroup"], null, Object(external_wp_element_["createElement"])(Slot, Object(esm_extends["a" /* default */])({}, props, {
    bubblesVirtually: true,
    fillProps: accessibleToolbarState
  })));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-controls/index.js



/**
 * Internal dependencies
 */


const BlockControls = BlockControlsFill;
BlockControls.Slot = BlockControlsSlot; // This is just here for backward compatibility

const BlockFormatControls = props => {
  return Object(external_wp_element_["createElement"])(BlockControlsFill, Object(esm_extends["a" /* default */])({
    group: "inline"
  }, props));
};

BlockFormatControls.Slot = props => {
  return Object(external_wp_element_["createElement"])(BlockControlsSlot, Object(esm_extends["a" /* default */])({
    group: "inline"
  }, props));
};

/* harmony default export */ var block_controls = (BlockControls);

// EXTERNAL MODULE: external ["wp","primitives"]
var external_wp_primitives_ = __webpack_require__("Tqx9");

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/position-left.js


/**
 * WordPress dependencies
 */

const positionLeft = Object(external_wp_element_["createElement"])(external_wp_primitives_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_primitives_["Path"], {
  d: "M4 9v6h14V9H4zm8-4.8H4v1.5h8V4.2zM4 19.8h8v-1.5H4v1.5z"
}));
/* harmony default export */ var position_left = (positionLeft);

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/position-center.js


/**
 * WordPress dependencies
 */

const positionCenter = Object(external_wp_element_["createElement"])(external_wp_primitives_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_primitives_["Path"], {
  d: "M5 15h14V9H5v6zm0 4.8h14v-1.5H5v1.5zM5 4.2v1.5h14V4.2H5z"
}));
/* harmony default export */ var position_center = (positionCenter);

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/position-right.js


/**
 * WordPress dependencies
 */

const positionRight = Object(external_wp_element_["createElement"])(external_wp_primitives_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_primitives_["Path"], {
  d: "M6 15h14V9H6v6zm6-10.8v1.5h8V4.2h-8zm0 15.6h8v-1.5h-8v1.5z"
}));
/* harmony default export */ var position_right = (positionRight);

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/stretch-wide.js


/**
 * WordPress dependencies
 */

const stretchWide = Object(external_wp_element_["createElement"])(external_wp_primitives_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_primitives_["Path"], {
  d: "M5 9v6h14V9H5zm11-4.8H8v1.5h8V4.2zM8 19.8h8v-1.5H8v1.5z"
}));
/* harmony default export */ var stretch_wide = (stretchWide);

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/stretch-full-width.js


/**
 * WordPress dependencies
 */

const stretchFullWidth = Object(external_wp_element_["createElement"])(external_wp_primitives_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_primitives_["Path"], {
  d: "M5 4v11h14V4H5zm3 15.8h8v-1.5H8v1.5z"
}));
/* harmony default export */ var stretch_full_width = (stretchFullWidth);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/layout.js


/**
 * WordPress dependencies
 */

const layout_defaultLayout = {
  type: 'default'
};
const Layout = Object(external_wp_element_["createContext"])(layout_defaultLayout);

function appendSelectors(selectors, append) {
  // Ideally we shouldn't need the `.editor-styles-wrapper` increased specificity here
  // The problem though is that we have a `.editor-styles-wrapper p { margin: reset; }` style
  // it's used to reset the default margin added by wp-admin to paragraphs
  // so we need this to be higher speficity otherwise, it won't be applied to paragraphs inside containers
  // When the post editor is fully iframed, this extra classname could be removed.
  return selectors.split(',').map(subselector => `.editor-styles-wrapper ${subselector} ${append}`).join(',');
}
/**
 * Allows to define the layout.
 */


const LayoutProvider = Layout.Provider;
/**
 * React hook used to retrieve the layout config.
 */

function useLayout() {
  return Object(external_wp_element_["useContext"])(Layout);
}
function LayoutStyle({
  selector,
  layout = {}
}) {
  const {
    contentSize,
    wideSize
  } = layout;
  let style = !!contentSize || !!wideSize ? `
				${appendSelectors(selector, '> *')} {
					max-width: ${contentSize !== null && contentSize !== void 0 ? contentSize : wideSize};
					margin-left: auto !important;
					margin-right: auto !important;
				}

				${appendSelectors(selector, '> [data-align="wide"]')}  {
					max-width: ${wideSize !== null && wideSize !== void 0 ? wideSize : contentSize};
				}

				${appendSelectors(selector, '> [data-align="full"]')} {
					max-width: none;
				}
			` : '';
  style += `
		${appendSelectors(selector, '> [data-align="left"]')} {
			float: left;
			margin-right: 2em;
		}

		${appendSelectors(selector, '> [data-align="right"]')} {
			float: right;
			margin-left: 2em;
		}
	`;
  return Object(external_wp_element_["createElement"])("style", null, style);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-alignment-control/use-available-alignments.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



const DEFAULT_CONTROLS = ['left', 'center', 'right', 'wide', 'full'];
const WIDE_CONTROLS = ['wide', 'full'];
function useAvailableAlignments(controls = DEFAULT_CONTROLS) {
  const {
    wideControlsEnabled = false
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getSettings
    } = select(store);
    const settings = getSettings();
    return {
      wideControlsEnabled: settings.alignWide
    };
  }, []);
  const layout = useLayout();
  const supportsAlignments = layout.type === 'default';

  if (!supportsAlignments) {
    return [];
  }

  const {
    alignments: availableAlignments = DEFAULT_CONTROLS
  } = layout;
  const enabledControls = controls.filter(control => (layout.alignments || // Ignore the global wideAlignment check if the layout explicitely defines alignments.
  wideControlsEnabled || !WIDE_CONTROLS.includes(control)) && availableAlignments.includes(control));
  return enabledControls;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-alignment-control/ui.js



/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


const BLOCK_ALIGNMENTS_CONTROLS = {
  left: {
    icon: position_left,
    title: Object(external_wp_i18n_["__"])('Align left')
  },
  center: {
    icon: position_center,
    title: Object(external_wp_i18n_["__"])('Align center')
  },
  right: {
    icon: position_right,
    title: Object(external_wp_i18n_["__"])('Align right')
  },
  wide: {
    icon: stretch_wide,
    title: Object(external_wp_i18n_["__"])('Wide width')
  },
  full: {
    icon: stretch_full_width,
    title: Object(external_wp_i18n_["__"])('Full width')
  }
};
const DEFAULT_CONTROL = 'center';
const ui_POPOVER_PROPS = {
  isAlternate: true
};

function BlockAlignmentUI({
  value,
  onChange,
  controls,
  isToolbar,
  isCollapsed = true
}) {
  const enabledControls = useAvailableAlignments(controls);

  if (enabledControls.length === 0) {
    return null;
  }

  function applyOrUnset(align) {
    return () => onChange(value === align ? undefined : align);
  }

  const activeAlignmentControl = BLOCK_ALIGNMENTS_CONTROLS[value];
  const defaultAlignmentControl = BLOCK_ALIGNMENTS_CONTROLS[DEFAULT_CONTROL];
  const UIComponent = isToolbar ? external_wp_components_["ToolbarGroup"] : external_wp_components_["ToolbarDropdownMenu"];
  const extraProps = isToolbar ? {
    isCollapsed
  } : {};
  return Object(external_wp_element_["createElement"])(UIComponent, Object(esm_extends["a" /* default */])({
    popoverProps: ui_POPOVER_PROPS,
    icon: activeAlignmentControl ? activeAlignmentControl.icon : defaultAlignmentControl.icon,
    label: Object(external_wp_i18n_["__"])('Align'),
    toggleProps: {
      describedBy: Object(external_wp_i18n_["__"])('Change alignment')
    },
    controls: enabledControls.map(control => {
      return { ...BLOCK_ALIGNMENTS_CONTROLS[control],
        isActive: value === control,
        role: isCollapsed ? 'menuitemradio' : undefined,
        onClick: applyOrUnset(control)
      };
    })
  }, extraProps));
}

/* harmony default export */ var ui = (BlockAlignmentUI);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-alignment-control/index.js



/**
 * Internal dependencies
 */

function BlockAlignmentControl(props) {
  return Object(external_wp_element_["createElement"])(ui, Object(esm_extends["a" /* default */])({}, props, {
    isToolbar: false
  }));
}
function BlockAlignmentToolbar(props) {
  return Object(external_wp_element_["createElement"])(ui, Object(esm_extends["a" /* default */])({}, props, {
    isToolbar: true
  }));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/align.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



/**
 * An array which includes all possible valid alignments,
 * used to validate if an alignment is valid or not.
 *
 * @constant
 * @type {string[]}
 */

const ALL_ALIGNMENTS = ['left', 'center', 'right', 'wide', 'full'];
/**
 * An array which includes all wide alignments.
 * In order for this alignments to be valid they need to be supported by the block,
 * and by the theme.
 *
 * @constant
 * @type {string[]}
 */

const WIDE_ALIGNMENTS = ['wide', 'full'];
/**
 * Returns the valid alignments.
 * Takes into consideration the aligns supported by a block, if the block supports wide controls or not and if theme supports wide controls or not.
 * Exported just for testing purposes, not exported outside the module.
 *
 * @param {?boolean|string[]} blockAlign          Aligns supported by the block.
 * @param {?boolean}          hasWideBlockSupport True if block supports wide alignments. And False otherwise.
 * @param {?boolean}          hasWideEnabled      True if theme supports wide alignments. And False otherwise.
 *
 * @return {string[]} Valid alignments.
 */

function getValidAlignments(blockAlign, hasWideBlockSupport = true, hasWideEnabled = true) {
  let validAlignments;

  if (Array.isArray(blockAlign)) {
    validAlignments = ALL_ALIGNMENTS.filter(value => blockAlign.includes(value));
  } else if (blockAlign === true) {
    // `true` includes all alignments...
    validAlignments = ALL_ALIGNMENTS;
  } else {
    validAlignments = [];
  }

  if (!hasWideEnabled || blockAlign === true && !hasWideBlockSupport) {
    return Object(external_lodash_["without"])(validAlignments, ...WIDE_ALIGNMENTS);
  }

  return validAlignments;
}
/**
 * Filters registered block settings, extending attributes to include `align`.
 *
 * @param  {Object} settings Original block settings
 * @return {Object}          Filtered block settings
 */

function addAttribute(settings) {
  // allow blocks to specify their own attribute definition with default values if needed.
  if (Object(external_lodash_["has"])(settings.attributes, ['align', 'type'])) {
    return settings;
  }

  if (Object(external_wp_blocks_["hasBlockSupport"])(settings, 'align')) {
    // Gracefully handle if settings.attributes is undefined.
    settings.attributes = { ...settings.attributes,
      align: {
        type: 'string',
        // Allow for '' since it is used by updateAlignment function
        // in withToolbarControls for special cases with defined default values.
        enum: [...ALL_ALIGNMENTS, '']
      }
    };
  }

  return settings;
}
/**
 * Override the default edit UI to include new toolbar controls for block
 * alignment, if block defines support.
 *
 * @param  {Function} BlockEdit Original component
 * @return {Function}           Wrapped component
 */

const withToolbarControls = Object(external_wp_compose_["createHigherOrderComponent"])(BlockEdit => props => {
  const {
    name: blockName
  } = props; // Compute the block allowed alignments without taking into account,
  // if the theme supports wide alignments or not
  // and without checking the layout for availble alignments.
  // BlockAlignmentToolbar takes both of these into account.

  const blockAllowedAlignments = getValidAlignments(Object(external_wp_blocks_["getBlockSupport"])(blockName, 'align'), Object(external_wp_blocks_["hasBlockSupport"])(blockName, 'alignWide', true));
  const validAlignments = useAvailableAlignments(blockAllowedAlignments);

  const updateAlignment = nextAlign => {
    if (!nextAlign) {
      var _blockType$attributes, _blockType$attributes2;

      const blockType = Object(external_wp_blocks_["getBlockType"])(props.name);
      const blockDefaultAlign = (_blockType$attributes = blockType.attributes) === null || _blockType$attributes === void 0 ? void 0 : (_blockType$attributes2 = _blockType$attributes.align) === null || _blockType$attributes2 === void 0 ? void 0 : _blockType$attributes2.default;

      if (blockDefaultAlign) {
        nextAlign = '';
      }
    }

    props.setAttributes({
      align: nextAlign
    });
  };

  return [validAlignments.length > 0 && props.isSelected && Object(external_wp_element_["createElement"])(block_controls, {
    key: "align-controls",
    group: "block"
  }, Object(external_wp_element_["createElement"])(BlockAlignmentControl, {
    value: props.attributes.align,
    onChange: updateAlignment,
    controls: validAlignments
  })), Object(external_wp_element_["createElement"])(BlockEdit, Object(esm_extends["a" /* default */])({
    key: "edit"
  }, props))];
}, 'withToolbarControls');
/**
 * Override the default block element to add alignment wrapper props.
 *
 * @param  {Function} BlockListBlock Original component
 * @return {Function}                Wrapped component
 */

const withDataAlign = Object(external_wp_compose_["createHigherOrderComponent"])(BlockListBlock => props => {
  const {
    name,
    attributes
  } = props;
  const {
    align
  } = attributes;
  const blockAllowedAlignments = getValidAlignments(Object(external_wp_blocks_["getBlockSupport"])(name, 'align'), Object(external_wp_blocks_["hasBlockSupport"])(name, 'alignWide', true));
  const validAlignments = useAvailableAlignments(blockAllowedAlignments); // If an alignment is not assigned, there's no need to go through the
  // effort to validate or assign its value.

  if (align === undefined) {
    return Object(external_wp_element_["createElement"])(BlockListBlock, props);
  }

  let wrapperProps = props.wrapperProps;

  if (validAlignments.includes(align)) {
    wrapperProps = { ...wrapperProps,
      'data-align': align
    };
  }

  return Object(external_wp_element_["createElement"])(BlockListBlock, Object(esm_extends["a" /* default */])({}, props, {
    wrapperProps: wrapperProps
  }));
});
/**
 * Override props assigned to save component to inject alignment class name if
 * block supports it.
 *
 * @param  {Object} props      Additional props applied to save element
 * @param  {Object} blockType  Block type
 * @param  {Object} attributes Block attributes
 * @return {Object}            Filtered props applied to save element
 */

function addAssignedAlign(props, blockType, attributes) {
  const {
    align
  } = attributes;
  const blockAlign = Object(external_wp_blocks_["getBlockSupport"])(blockType, 'align');
  const hasWideBlockSupport = Object(external_wp_blocks_["hasBlockSupport"])(blockType, 'alignWide', true); // Compute valid alignments without taking into account if
  // the theme supports wide alignments or not.
  // This way changing themes does not impact the block save.

  const isAlignValid = getValidAlignments(blockAlign, hasWideBlockSupport).includes(align);

  if (isAlignValid) {
    props.className = classnames_default()(`align${align}`, props.className);
  }

  return props;
}
Object(external_wp_hooks_["addFilter"])('blocks.registerBlockType', 'core/align/addAttribute', addAttribute);
Object(external_wp_hooks_["addFilter"])('editor.BlockListBlock', 'core/editor/align/with-data-align', withDataAlign);
Object(external_wp_hooks_["addFilter"])('editor.BlockEdit', 'core/editor/align/with-toolbar-controls', withToolbarControls);
Object(external_wp_hooks_["addFilter"])('blocks.getSaveContent.extraProps', 'core/align/addAssignedAlign', addAssignedAlign);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inspector-advanced-controls/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


const inspector_advanced_controls_name = 'InspectorAdvancedControls';
const {
  Fill: inspector_advanced_controls_Fill,
  Slot: inspector_advanced_controls_Slot
} = Object(external_wp_components_["createSlotFill"])(inspector_advanced_controls_name);

function InspectorAdvancedControls({
  children
}) {
  const {
    isSelected
  } = useBlockEditContext();
  return isSelected ? Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalStyleProvider"], {
    document: document
  }, Object(external_wp_element_["createElement"])(inspector_advanced_controls_Fill, null, children)) : null;
}

InspectorAdvancedControls.slotName = inspector_advanced_controls_name;
InspectorAdvancedControls.Slot = inspector_advanced_controls_Slot;
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/inspector-advanced-controls/README.md
 */

/* harmony default export */ var inspector_advanced_controls = (InspectorAdvancedControls);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


const {
  Fill: inspector_controls_Fill,
  Slot: inspector_controls_Slot
} = Object(external_wp_components_["createSlotFill"])('InspectorControls');

function InspectorControls({
  children
}) {
  return useDisplayBlockControls() ? Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalStyleProvider"], {
    document: document
  }, Object(external_wp_element_["createElement"])(inspector_controls_Fill, null, children)) : null;
}

InspectorControls.Slot = inspector_controls_Slot;
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/inspector-controls/README.md
 */

/* harmony default export */ var inspector_controls = (InspectorControls);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/anchor.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */


/**
 * Regular expression matching invalid anchor characters for replacement.
 *
 * @type {RegExp}
 */

const ANCHOR_REGEX = /[\s#]/g;
/**
 * Filters registered block settings, extending attributes with anchor using ID
 * of the first node.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function anchor_addAttribute(settings) {
  // allow blocks to specify their own attribute definition with default values if needed.
  if (Object(external_lodash_["has"])(settings.attributes, ['anchor', 'type'])) {
    return settings;
  }

  if (Object(external_wp_blocks_["hasBlockSupport"])(settings, 'anchor')) {
    // Gracefully handle if settings.attributes is undefined.
    settings.attributes = { ...settings.attributes,
      anchor: {
        type: 'string',
        source: 'attribute',
        attribute: 'id',
        selector: '*'
      }
    };
  }

  return settings;
}
/**
 * Override the default edit UI to include a new block inspector control for
 * assigning the anchor ID, if block supports anchor.
 *
 * @param {WPComponent} BlockEdit Original component.
 *
 * @return {WPComponent} Wrapped component.
 */

const withInspectorControl = Object(external_wp_compose_["createHigherOrderComponent"])(BlockEdit => {
  return props => {
    const hasAnchor = Object(external_wp_blocks_["hasBlockSupport"])(props.name, 'anchor');

    if (hasAnchor && props.isSelected) {
      const isWeb = external_wp_element_["Platform"].OS === 'web';
      const textControl = Object(external_wp_element_["createElement"])(external_wp_components_["TextControl"], {
        className: "html-anchor-control",
        label: Object(external_wp_i18n_["__"])('HTML anchor'),
        help: Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_i18n_["__"])('Enter a word or two — without spaces — to make a unique web address just for this block, called an “anchor.” Then, you’ll be able to link directly to this section of your page.'), Object(external_wp_element_["createElement"])(external_wp_components_["ExternalLink"], {
          href: 'https://wordpress.org/support/article/page-jumps/'
        }, Object(external_wp_i18n_["__"])('Learn more about anchors'))),
        value: props.attributes.anchor || '',
        placeholder: !isWeb ? Object(external_wp_i18n_["__"])('Add an anchor') : null,
        onChange: nextValue => {
          nextValue = nextValue.replace(ANCHOR_REGEX, '-');
          props.setAttributes({
            anchor: nextValue
          });
        },
        autoCapitalize: "none",
        autoComplete: "off"
      });
      return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(BlockEdit, props), isWeb && Object(external_wp_element_["createElement"])(inspector_advanced_controls, null, textControl), !isWeb && props.name === 'core/heading' && Object(external_wp_element_["createElement"])(inspector_controls, null, Object(external_wp_element_["createElement"])(external_wp_components_["PanelBody"], {
        title: Object(external_wp_i18n_["__"])('Heading settings')
      }, textControl)));
    }

    return Object(external_wp_element_["createElement"])(BlockEdit, props);
  };
}, 'withInspectorControl');
/**
 * Override props assigned to save component to inject anchor ID, if block
 * supports anchor. This is only applied if the block's save result is an
 * element and not a markup string.
 *
 * @param {Object} extraProps Additional props applied to save element.
 * @param {Object} blockType  Block type.
 * @param {Object} attributes Current block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */

function addSaveProps(extraProps, blockType, attributes) {
  if (Object(external_wp_blocks_["hasBlockSupport"])(blockType, 'anchor')) {
    extraProps.id = attributes.anchor === '' ? null : attributes.anchor;
  }

  return extraProps;
}
Object(external_wp_hooks_["addFilter"])('blocks.registerBlockType', 'core/anchor/attribute', anchor_addAttribute);
Object(external_wp_hooks_["addFilter"])('editor.BlockEdit', 'core/editor/anchor/with-inspector-control', withInspectorControl);
Object(external_wp_hooks_["addFilter"])('blocks.getSaveContent.extraProps', 'core/anchor/save-props', addSaveProps);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/custom-class-name.js


/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */


/**
 * Filters registered block settings, extending attributes with anchor using ID
 * of the first node.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function custom_class_name_addAttribute(settings) {
  if (Object(external_wp_blocks_["hasBlockSupport"])(settings, 'customClassName', true)) {
    // Gracefully handle if settings.attributes is undefined.
    settings.attributes = { ...settings.attributes,
      className: {
        type: 'string'
      }
    };
  }

  return settings;
}
/**
 * Override the default edit UI to include a new block inspector control for
 * assigning the custom class name, if block supports custom class name.
 *
 * @param {WPComponent} BlockEdit Original component.
 *
 * @return {WPComponent} Wrapped component.
 */

const custom_class_name_withInspectorControl = Object(external_wp_compose_["createHigherOrderComponent"])(BlockEdit => {
  return props => {
    const hasCustomClassName = Object(external_wp_blocks_["hasBlockSupport"])(props.name, 'customClassName', true);

    if (hasCustomClassName && props.isSelected) {
      return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(BlockEdit, props), Object(external_wp_element_["createElement"])(inspector_advanced_controls, null, Object(external_wp_element_["createElement"])(external_wp_components_["TextControl"], {
        autoComplete: "off",
        label: Object(external_wp_i18n_["__"])('Additional CSS class(es)'),
        value: props.attributes.className || '',
        onChange: nextValue => {
          props.setAttributes({
            className: nextValue !== '' ? nextValue : undefined
          });
        },
        help: Object(external_wp_i18n_["__"])('Separate multiple classes with spaces.')
      })));
    }

    return Object(external_wp_element_["createElement"])(BlockEdit, props);
  };
}, 'withInspectorControl');
/**
 * Override props assigned to save component to inject anchor ID, if block
 * supports anchor. This is only applied if the block's save result is an
 * element and not a markup string.
 *
 * @param {Object} extraProps Additional props applied to save element.
 * @param {Object} blockType  Block type.
 * @param {Object} attributes Current block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */

function custom_class_name_addSaveProps(extraProps, blockType, attributes) {
  if (Object(external_wp_blocks_["hasBlockSupport"])(blockType, 'customClassName', true) && attributes.className) {
    extraProps.className = classnames_default()(extraProps.className, attributes.className);
  }

  return extraProps;
}
/**
 * Given an HTML string, returns an array of class names assigned to the root
 * element in the markup.
 *
 * @param {string} innerHTML Markup string from which to extract classes.
 *
 * @return {string[]} Array of class names assigned to the root element.
 */

function getHTMLRootElementClasses(innerHTML) {
  innerHTML = `<div data-custom-class-name>${innerHTML}</div>`;
  const parsed = Object(external_wp_blocks_["parseWithAttributeSchema"])(innerHTML, {
    type: 'string',
    source: 'attribute',
    selector: '[data-custom-class-name] > *',
    attribute: 'class'
  });
  return parsed ? parsed.trim().split(/\s+/) : [];
}
/**
 * Given a parsed set of block attributes, if the block supports custom class
 * names and an unknown class (per the block's serialization behavior) is
 * found, the unknown classes are treated as custom classes. This prevents the
 * block from being considered as invalid.
 *
 * @param {Object} blockAttributes Original block attributes.
 * @param {Object} blockType       Block type settings.
 * @param {string} innerHTML       Original block markup.
 *
 * @return {Object} Filtered block attributes.
 */

function addParsedDifference(blockAttributes, blockType, innerHTML) {
  if (Object(external_wp_blocks_["hasBlockSupport"])(blockType, 'customClassName', true)) {
    // To determine difference, serialize block given the known set of
    // attributes, with the exception of `className`. This will determine
    // the default set of classes. From there, any difference in innerHTML
    // can be considered as custom classes.
    const attributesSansClassName = Object(external_lodash_["omit"])(blockAttributes, ['className']);
    const serialized = Object(external_wp_blocks_["getSaveContent"])(blockType, attributesSansClassName);
    const defaultClasses = getHTMLRootElementClasses(serialized);
    const actualClasses = getHTMLRootElementClasses(innerHTML);
    const customClasses = Object(external_lodash_["difference"])(actualClasses, defaultClasses);

    if (customClasses.length) {
      blockAttributes.className = customClasses.join(' ');
    } else if (serialized) {
      delete blockAttributes.className;
    }
  }

  return blockAttributes;
}
Object(external_wp_hooks_["addFilter"])('blocks.registerBlockType', 'core/custom-class-name/attribute', custom_class_name_addAttribute);
Object(external_wp_hooks_["addFilter"])('editor.BlockEdit', 'core/editor/custom-class-name/with-inspector-control', custom_class_name_withInspectorControl);
Object(external_wp_hooks_["addFilter"])('blocks.getSaveContent.extraProps', 'core/custom-class-name/save-props', custom_class_name_addSaveProps);
Object(external_wp_hooks_["addFilter"])('blocks.getBlockAttributes', 'core/custom-class-name/addParsedDifference', addParsedDifference);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/generated-class-name.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Override props assigned to save component to inject generated className if
 * block supports it. This is only applied if the block's save result is an
 * element and not a markup string.
 *
 * @param {Object} extraProps Additional props applied to save element.
 * @param {Object} blockType  Block type.
 *
 * @return {Object} Filtered props applied to save element.
 */

function addGeneratedClassName(extraProps, blockType) {
  // Adding the generated className
  if (Object(external_wp_blocks_["hasBlockSupport"])(blockType, 'className', true)) {
    if (typeof extraProps.className === 'string') {
      // We have some extra classes and want to add the default classname
      // We use uniq to prevent duplicate classnames
      extraProps.className = Object(external_lodash_["uniq"])([Object(external_wp_blocks_["getBlockDefaultClassName"])(blockType.name), ...extraProps.className.split(' ')]).join(' ').trim();
    } else {
      // There is no string in the className variable,
      // so we just dump the default name in there
      extraProps.className = Object(external_wp_blocks_["getBlockDefaultClassName"])(blockType.name);
    }
  }

  return extraProps;
}
Object(external_wp_hooks_["addFilter"])('blocks.getSaveContent.extraProps', 'core/generated-class-name/save-props', addGeneratedClassName);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/use-setting/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const deprecatedFlags = {
  'color.palette': settings => settings.colors === undefined ? undefined : settings.colors,
  'color.gradients': settings => settings.gradients === undefined ? undefined : settings.gradients,
  'color.custom': settings => settings.disableCustomColors === undefined ? undefined : !settings.disableCustomColors,
  'color.customGradient': settings => settings.disableCustomGradients === undefined ? undefined : !settings.disableCustomGradients,
  'typography.fontSizes': settings => settings.fontSizes === undefined ? undefined : settings.fontSizes,
  'typography.customFontSize': settings => settings.disableCustomFontSizes === undefined ? undefined : !settings.disableCustomFontSizes,
  'typography.customLineHeight': settings => settings.enableCustomLineHeight,
  'spacing.units': settings => {
    if (settings.enableCustomUnits === undefined) {
      return;
    }

    if (settings.enableCustomUnits === true) {
      return ['px', 'em', 'rem', 'vh', 'vw', '%'];
    }

    return settings.enableCustomUnits;
  },
  'spacing.customPadding': settings => settings.enableCustomSpacing
};
const PATHS_WITH_MERGE = {
  'color.gradients': true,
  'color.palette': true,
  'typography.fontFamilies': true,
  'typography.fontSizes': true
};
/**
 * Hook that retrieves the editor setting.
 * It works with nested objects using by finding the value at path.
 *
 * @param {string} path The path to the setting.
 *
 * @return {any} Returns the value defined for the setting.
 *
 * @example
 * ```js
 * const isEnabled = useSetting( 'typography.dropCap' );
 * ```
 */

function useSetting(path) {
  const {
    name: blockName
  } = useBlockEditContext();
  const setting = Object(external_wp_data_["useSelect"])(select => {
    var _get;

    const settings = select(store).getSettings(); // 1 - Use __experimental features, if available.
    // We cascade to the all value if the block one is not available.

    const defaultsPath = `__experimentalFeatures.${path}`;
    const blockPath = `__experimentalFeatures.blocks.${blockName}.${path}`;
    const experimentalFeaturesResult = (_get = Object(external_lodash_["get"])(settings, blockPath)) !== null && _get !== void 0 ? _get : Object(external_lodash_["get"])(settings, defaultsPath);

    if (experimentalFeaturesResult !== undefined) {
      if (PATHS_WITH_MERGE[path]) {
        var _ref, _experimentalFeatures;

        return (_ref = (_experimentalFeatures = experimentalFeaturesResult.user) !== null && _experimentalFeatures !== void 0 ? _experimentalFeatures : experimentalFeaturesResult.theme) !== null && _ref !== void 0 ? _ref : experimentalFeaturesResult.core;
      }

      return experimentalFeaturesResult;
    } // 2 - Use deprecated settings, otherwise.


    const deprecatedSettingsValue = deprecatedFlags[path] ? deprecatedFlags[path](settings) : undefined;

    if (deprecatedSettingsValue !== undefined) {
      return deprecatedSettingsValue;
    } // 3 - Fall back for typography.dropCap:
    // This is only necessary to support typography.dropCap.
    // when __experimentalFeatures are not present (core without plugin).
    // To remove when __experimentalFeatures are ported to core.


    return path === 'typography.dropCap' ? true : undefined;
  }, [blockName, path]);
  return setting;
}

// EXTERNAL MODULE: ./node_modules/tinycolor2/tinycolor.js
var tinycolor = __webpack_require__("Zss7");
var tinycolor_default = /*#__PURE__*/__webpack_require__.n(tinycolor);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/colors/utils.js
/**
 * External dependencies
 */


/**
 * Provided an array of color objects as set by the theme or by the editor defaults,
 * and the values of the defined color or custom color returns a color object describing the color.
 *
 * @param {Array}   colors       Array of color objects as set by the theme or by the editor defaults.
 * @param {?string} definedColor A string containing the color slug.
 * @param {?string} customColor  A string containing the customColor value.
 *
 * @return {?Object} If definedColor is passed and the name is found in colors,
 *                   the color object exactly as set by the theme or editor defaults is returned.
 *                   Otherwise, an object that just sets the color is defined.
 */

const getColorObjectByAttributeValues = (colors, definedColor, customColor) => {
  if (definedColor) {
    const colorObj = Object(external_lodash_["find"])(colors, {
      slug: definedColor
    });

    if (colorObj) {
      return colorObj;
    }
  }

  return {
    color: customColor
  };
};
/**
 * Provided an array of color objects as set by the theme or by the editor defaults, and a color value returns the color object matching that value or undefined.
 *
 * @param {Array}   colors      Array of color objects as set by the theme or by the editor defaults.
 * @param {?string} colorValue  A string containing the color value.
 *
 * @return {?Object} Color object included in the colors array whose color property equals colorValue.
 *                   Returns undefined if no color object matches this requirement.
 */

const getColorObjectByColorValue = (colors, colorValue) => {
  return Object(external_lodash_["find"])(colors, {
    color: colorValue
  });
};
/**
 * Returns a class based on the context a color is being used and its slug.
 *
 * @param {string} colorContextName Context/place where color is being used e.g: background, text etc...
 * @param {string} colorSlug        Slug of the color.
 *
 * @return {?string} String with the class corresponding to the color in the provided context.
 *                   Returns undefined if either colorContextName or colorSlug are not provided.
 */

function getColorClassName(colorContextName, colorSlug) {
  if (!colorContextName || !colorSlug) {
    return undefined;
  }

  return `has-${Object(external_lodash_["kebabCase"])(colorSlug)}-${colorContextName}`;
}
/**
 * Given an array of color objects and a color value returns the color value of the most readable color in the array.
 *
 * @param {Array}   colors     Array of color objects as set by the theme or by the editor defaults.
 * @param {?string} colorValue A string containing the color value.
 *
 * @return {string} String with the color value of the most readable color.
 */

function getMostReadableColor(colors, colorValue) {
  return tinycolor_default.a.mostReadable(colorValue, Object(external_lodash_["map"])(colors, 'color')).toHexString();
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/gradients/use-gradient.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




const use_gradient_EMPTY_ARRAY = [];
function __experimentalGetGradientClass(gradientSlug) {
  if (!gradientSlug) {
    return undefined;
  }

  return `has-${gradientSlug}-gradient-background`;
}
/**
 * Retrieves the gradient value per slug.
 *
 * @param {Array} gradients Gradient Palette
 * @param {string} slug Gradient slug
 *
 * @return {string} Gradient value.
 */

function getGradientValueBySlug(gradients, slug) {
  const gradient = Object(external_lodash_["find"])(gradients, ['slug', slug]);
  return gradient && gradient.gradient;
}
function __experimentalGetGradientObjectByGradientValue(gradients, value) {
  const gradient = Object(external_lodash_["find"])(gradients, ['gradient', value]);
  return gradient;
}
/**
 * Retrieves the gradient slug per slug.
 *
 * @param {Array} gradients Gradient Palette
 * @param {string} value Gradient value
 * @return {string} Gradient slug.
 */

function getGradientSlugByValue(gradients, value) {
  const gradient = __experimentalGetGradientObjectByGradientValue(gradients, value);

  return gradient && gradient.slug;
}
function __experimentalUseGradient({
  gradientAttribute = 'gradient',
  customGradientAttribute = 'customGradient'
} = {}) {
  const {
    clientId
  } = useBlockEditContext();
  const gradients = useSetting('color.gradients') || use_gradient_EMPTY_ARRAY;
  const {
    gradient,
    customGradient
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getBlockAttributes
    } = select(store);
    const attributes = getBlockAttributes(clientId) || {};
    return {
      customGradient: attributes[customGradientAttribute],
      gradient: attributes[gradientAttribute]
    };
  }, [clientId, gradientAttribute, customGradientAttribute]);
  const {
    updateBlockAttributes
  } = Object(external_wp_data_["useDispatch"])(store);
  const setGradient = Object(external_wp_element_["useCallback"])(newGradientValue => {
    const slug = getGradientSlugByValue(gradients, newGradientValue);

    if (slug) {
      updateBlockAttributes(clientId, {
        [gradientAttribute]: slug,
        [customGradientAttribute]: undefined
      });
      return;
    }

    updateBlockAttributes(clientId, {
      [gradientAttribute]: undefined,
      [customGradientAttribute]: newGradientValue
    });
  }, [gradients, clientId, updateBlockAttributes]);

  const gradientClass = __experimentalGetGradientClass(gradient);

  let gradientValue;

  if (gradient) {
    gradientValue = getGradientValueBySlug(gradients, gradient);
  } else {
    gradientValue = customGradient;
  }

  return {
    gradientClass,
    gradientValue,
    setGradient
  };
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/colors-gradients/control.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



 // translators: first %s: the color name or value (e.g. red or #ff0000)

const colorIndicatorAriaLabel = Object(external_wp_i18n_["__"])('(Color: %s)'); // translators: first %s: the gradient name or value (e.g. red to green or linear-gradient(135deg,rgba(6,147,227,1) 0%,rgb(155,81,224) 100%)


const gradientIndicatorAriaLabel = Object(external_wp_i18n_["__"])('(Gradient: %s)');

const colorsAndGradientKeys = ['colors', 'disableCustomColors', 'gradients', 'disableCustomGradients'];

function VisualLabel({
  colors,
  gradients,
  label,
  currentTab,
  colorValue,
  gradientValue
}) {
  let value, ariaLabel;

  if (currentTab === 'color') {
    if (colorValue) {
      value = colorValue;
      const colorObject = getColorObjectByColorValue(colors, value);
      const colorName = colorObject && colorObject.name;
      ariaLabel = Object(external_wp_i18n_["sprintf"])(colorIndicatorAriaLabel, colorName || value);
    }
  } else if (currentTab === 'gradient' && gradientValue) {
    value = gradientValue;

    const gradientObject = __experimentalGetGradientObjectByGradientValue(gradients, value);

    const gradientName = gradientObject && gradientObject.name;
    ariaLabel = Object(external_wp_i18n_["sprintf"])(gradientIndicatorAriaLabel, gradientName || value);
  }

  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, label, !!value && Object(external_wp_element_["createElement"])(external_wp_components_["ColorIndicator"], {
    colorValue: value,
    "aria-label": ariaLabel
  }));
}

function ColorGradientControlInner({
  colors,
  gradients,
  disableCustomColors,
  disableCustomGradients,
  className,
  label,
  onColorChange,
  onGradientChange,
  colorValue,
  gradientValue,
  clearable
}) {
  const canChooseAColor = onColorChange && (!Object(external_lodash_["isEmpty"])(colors) || !disableCustomColors);
  const canChooseAGradient = onGradientChange && (!Object(external_lodash_["isEmpty"])(gradients) || !disableCustomGradients);
  const [currentTab, setCurrentTab] = Object(external_wp_element_["useState"])(gradientValue ? 'gradient' : !!canChooseAColor && 'color');

  if (!canChooseAColor && !canChooseAGradient) {
    return null;
  }

  return Object(external_wp_element_["createElement"])(external_wp_components_["BaseControl"], {
    className: classnames_default()('block-editor-color-gradient-control', className)
  }, Object(external_wp_element_["createElement"])("fieldset", null, Object(external_wp_element_["createElement"])("legend", null, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-color-gradient-control__color-indicator"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["BaseControl"].VisualLabel, null, Object(external_wp_element_["createElement"])(VisualLabel, {
    currentTab: currentTab,
    label: label,
    colorValue: colorValue,
    gradientValue: gradientValue
  })))), canChooseAColor && canChooseAGradient && Object(external_wp_element_["createElement"])(external_wp_components_["ButtonGroup"], {
    className: "block-editor-color-gradient-control__button-tabs"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    isSmall: true,
    isPressed: currentTab === 'color',
    onClick: () => setCurrentTab('color')
  }, Object(external_wp_i18n_["__"])('Solid')), Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    isSmall: true,
    isPressed: currentTab === 'gradient',
    onClick: () => setCurrentTab('gradient')
  }, Object(external_wp_i18n_["__"])('Gradient'))), (currentTab === 'color' || !canChooseAGradient) && Object(external_wp_element_["createElement"])(external_wp_components_["ColorPalette"], {
    value: colorValue,
    onChange: canChooseAGradient ? newColor => {
      onColorChange(newColor);
      onGradientChange();
    } : onColorChange,
    colors,
    disableCustomColors,
    clearable: clearable
  }), (currentTab === 'gradient' || !canChooseAColor) && Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalGradientPicker"], {
    value: gradientValue,
    onChange: canChooseAColor ? newGradient => {
      onGradientChange(newGradient);
      onColorChange();
    } : onGradientChange,
    gradients,
    disableCustomGradients,
    clearable: clearable
  })));
}

function ColorGradientControlSelect(props) {
  const colorGradientSettings = {};
  colorGradientSettings.colors = useSetting('color.palette');
  colorGradientSettings.gradients = useSetting('color.gradients');
  colorGradientSettings.disableCustomColors = !useSetting('color.custom');
  colorGradientSettings.disableCustomGradients = !useSetting('color.customGradient');
  return Object(external_wp_element_["createElement"])(ColorGradientControlInner, Object(esm_extends["a" /* default */])({}, colorGradientSettings, props));
}

function ColorGradientControl(props) {
  if (Object(external_lodash_["every"])(colorsAndGradientKeys, key => props.hasOwnProperty(key))) {
    return Object(external_wp_element_["createElement"])(ColorGradientControlInner, props);
  }

  return Object(external_wp_element_["createElement"])(ColorGradientControlSelect, props);
}

/* harmony default export */ var control = (ColorGradientControl);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/utils.js
/**
 * External dependencies
 */

/**
 * Removed falsy values from nested object.
 *
 * @param {*} object
 * @return {*} Object cleaned from falsy values
 */

const cleanEmptyObject = object => {
  if (!Object(external_lodash_["isObject"])(object) || Array.isArray(object)) {
    return object;
  }

  const cleanedNestedObjects = Object(external_lodash_["pickBy"])(Object(external_lodash_["mapValues"])(object, cleanEmptyObject), external_lodash_["identity"]);
  return Object(external_lodash_["isEmpty"])(cleanedNestedObjects) ? undefined : cleanedNestedObjects;
};

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/border-color.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





 // Defining empty array here instead of inline avoids unnecessary re-renders of
// color control.

const border_color_EMPTY_ARRAY = [];
/**
 * Inspector control panel containing the border color related configuration.
 *
 * There is deliberate overlap between the colors and borders block supports
 * relating to border color. It can be argued the border color controls could
 * be included within either, or both, the colors and borders panels in the
 * inspector controls. If they share the same block attributes it should not
 * matter.
 *
 * @param  {Object} props Block properties.
 * @return {WPElement}    Border color edit element.
 */

function BorderColorEdit(props) {
  var _style$border;

  const {
    attributes: {
      borderColor,
      style
    },
    setAttributes
  } = props;
  const colors = useSetting('color.palette') || border_color_EMPTY_ARRAY;
  const disableCustomColors = !useSetting('color.custom');
  const disableCustomGradients = !useSetting('color.customGradient');

  const onChangeColor = value => {
    const colorObject = getColorObjectByColorValue(colors, value);
    const newStyle = { ...style,
      border: { ...(style === null || style === void 0 ? void 0 : style.border),
        color: colorObject !== null && colorObject !== void 0 && colorObject.slug ? undefined : value
      }
    }; // If empty slug, ensure undefined to remove attribute.

    const newNamedColor = colorObject !== null && colorObject !== void 0 && colorObject.slug ? colorObject.slug : undefined;
    setAttributes({
      style: cleanEmptyObject(newStyle),
      borderColor: newNamedColor
    });
  };

  return Object(external_wp_element_["createElement"])(control, {
    label: Object(external_wp_i18n_["__"])('Border color'),
    value: borderColor || (style === null || style === void 0 ? void 0 : (_style$border = style.border) === null || _style$border === void 0 ? void 0 : _style$border.color),
    colors: colors,
    gradients: undefined,
    disableCustomColors: disableCustomColors,
    disableCustomGradients: disableCustomGradients,
    onColorChange: onChangeColor
  });
}
/**
 * Filters registered block settings, extending attributes to include
 * `borderColor` if needed.
 *
 * @param  {Object} settings Original block settings.
 * @return {Object}          Updated block settings.
 */

function addAttributes(settings) {
  if (!hasBorderSupport(settings, 'color')) {
    return settings;
  } // Allow blocks to specify default value if needed.


  if (settings.attributes.borderColor) {
    return settings;
  } // Add new borderColor attribute to block settings.


  return { ...settings,
    attributes: { ...settings.attributes,
      borderColor: {
        type: 'string'
      }
    }
  };
}
/**
 * Override props assigned to save component to inject border color.
 *
 * @param  {Object} props      Additional props applied to save element.
 * @param  {Object} blockType  Block type definition.
 * @param  {Object} attributes Block's attributes
 * @return {Object}            Filtered props to apply to save element.
 */


function border_color_addSaveProps(props, blockType, attributes) {
  var _style$border2;

  if (!hasBorderSupport(blockType, 'color') || shouldSkipSerialization(blockType)) {
    return props;
  }

  const {
    borderColor,
    style
  } = attributes;
  const borderColorClass = getColorClassName('border-color', borderColor);
  const newClassName = classnames_default()(props.className, {
    'has-border-color': borderColor || (style === null || style === void 0 ? void 0 : (_style$border2 = style.border) === null || _style$border2 === void 0 ? void 0 : _style$border2.color),
    [borderColorClass]: !!borderColorClass
  }); // If we are clearing the last of the previous classes in `className`
  // set it to `undefined` to avoid rendering empty DOM attributes.

  props.className = newClassName ? newClassName : undefined;
  return props;
}
/**
 * Filters the registered block settings to apply border color styles and
 * classnames to the block edit wrapper.
 *
 * @param {Object} settings Original block settings.
 * @return {Object}         Filtered block settings.
 */


function addEditProps(settings) {
  if (!hasBorderSupport(settings, 'color') || shouldSkipSerialization(settings)) {
    return settings;
  }

  const existingGetEditWrapperProps = settings.getEditWrapperProps;

  settings.getEditWrapperProps = attributes => {
    let props = {};

    if (existingGetEditWrapperProps) {
      props = existingGetEditWrapperProps(attributes);
    }

    return border_color_addSaveProps(props, settings, attributes);
  };

  return settings;
}
/**
 * This adds inline styles for color palette colors.
 * Ideally, this is not needed and themes should load their palettes on the editor.
 *
 * @param  {Function} BlockListBlock Original component
 * @return {Function}                Wrapped component
 */


const withBorderColorPaletteStyles = Object(external_wp_compose_["createHigherOrderComponent"])(BlockListBlock => props => {
  var _getColorObjectByAttr, _props$wrapperProps;

  const {
    name,
    attributes
  } = props;
  const {
    borderColor
  } = attributes;
  const colors = useSetting('color.palette') || border_color_EMPTY_ARRAY;

  if (!hasBorderSupport(name, 'color') || shouldSkipSerialization(name)) {
    return Object(external_wp_element_["createElement"])(BlockListBlock, props);
  }

  const extraStyles = {
    borderColor: borderColor ? (_getColorObjectByAttr = getColorObjectByAttributeValues(colors, borderColor)) === null || _getColorObjectByAttr === void 0 ? void 0 : _getColorObjectByAttr.color : undefined
  };
  let wrapperProps = props.wrapperProps;
  wrapperProps = { ...props.wrapperProps,
    style: { ...extraStyles,
      ...((_props$wrapperProps = props.wrapperProps) === null || _props$wrapperProps === void 0 ? void 0 : _props$wrapperProps.style)
    }
  };
  return Object(external_wp_element_["createElement"])(BlockListBlock, Object(esm_extends["a" /* default */])({}, props, {
    wrapperProps: wrapperProps
  }));
});
Object(external_wp_hooks_["addFilter"])('blocks.registerBlockType', 'core/border/addAttributes', addAttributes);
Object(external_wp_hooks_["addFilter"])('blocks.getSaveContent.extraProps', 'core/border/addSaveProps', border_color_addSaveProps);
Object(external_wp_hooks_["addFilter"])('blocks.registerBlockType', 'core/border/addEditProps', addEditProps);
Object(external_wp_hooks_["addFilter"])('editor.BlockListBlock', 'core/border/with-border-color-palette-styles', withBorderColorPaletteStyles);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/border-radius.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


const MIN_BORDER_RADIUS_VALUE = 0;
const MAX_BORDER_RADIUS_VALUE = 50;
/**
 * Inspector control panel containing the border radius related configuration.
 *
 * @param  {Object} props Block properties.
 * @return {WPElement}    Border radius edit element.
 */

function BorderRadiusEdit(props) {
  var _style$border;

  const {
    attributes: {
      style
    },
    setAttributes
  } = props;

  const onChange = newRadius => {
    let newStyle = { ...style,
      border: { ...(style === null || style === void 0 ? void 0 : style.border),
        radius: newRadius
      }
    };

    if (newRadius === undefined) {
      newStyle = cleanEmptyObject(newStyle);
    }

    setAttributes({
      style: newStyle
    });
  };

  return Object(external_wp_element_["createElement"])(external_wp_components_["RangeControl"], {
    value: style === null || style === void 0 ? void 0 : (_style$border = style.border) === null || _style$border === void 0 ? void 0 : _style$border.radius,
    label: Object(external_wp_i18n_["__"])('Border radius'),
    min: MIN_BORDER_RADIUS_VALUE,
    max: MAX_BORDER_RADIUS_VALUE,
    initialPosition: 0,
    allowReset: true,
    onChange: onChange
  });
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/border-style-control/index.js


/**
 * WordPress dependencies
 */


const DEFAULT_STYLE = {
  key: 'default',
  name: Object(external_wp_i18n_["__"])('Default'),
  style: {
    borderStyle: undefined
  }
};
const BORDER_STYLES = [DEFAULT_STYLE, {
  key: 'none',
  name: Object(external_wp_i18n_["__"])('None'),
  style: {
    borderStyle: 'none'
  }
}, {
  key: 'solid',
  name: Object(external_wp_i18n_["__"])('Solid'),
  style: {
    borderStyle: 'solid'
  }
}, {
  key: 'dashed',
  name: Object(external_wp_i18n_["__"])('Dashed'),
  style: {
    borderStyle: 'dashed'
  }
}, {
  key: 'dotted',
  name: Object(external_wp_i18n_["__"])('Dotted'),
  style: {
    borderStyle: 'dotted'
  }
}];
/**
 * Control to display border style options.
 *
 * @param  {Object}   props          Component props.
 * @param  {Object}   props.onChange Handler for changing border style selection.
 * @param  {Object}   props.value    Currently selected border style value.
 *
 * @return {WPElement}      Custom border style select control.
 */

function BorderStyleControl({
  onChange,
  value
}) {
  const style = BORDER_STYLES.find(option => option.key === value);
  return Object(external_wp_element_["createElement"])("fieldset", {
    className: "components-border-style-control"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["CustomSelectControl"], {
    className: "components-border-style-control__select",
    label: Object(external_wp_i18n_["__"])('Border style'),
    options: BORDER_STYLES,
    value: style || DEFAULT_STYLE,
    onChange: ({
      selectedItem
    }) => selectedItem.key === 'default' ? onChange(undefined) : onChange(selectedItem.key)
  }));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/border-style.js


/**
 * Internal dependencies
 */


/**
 * Inspector control for configuring border style property.
 *
 * @param  {Object} props  Block properties.
 * @return {WPElement}     Border style edit element.
 */

const BorderStyleEdit = props => {
  var _style$border;

  const {
    attributes: {
      style
    },
    setAttributes
  } = props;

  const onChange = newBorderStyle => {
    const newStyleAttributes = { ...style,
      border: { ...(style === null || style === void 0 ? void 0 : style.border),
        style: newBorderStyle
      }
    };
    setAttributes({
      style: cleanEmptyObject(newStyleAttributes)
    });
  };

  return Object(external_wp_element_["createElement"])(BorderStyleControl, {
    value: style === null || style === void 0 ? void 0 : (_style$border = style.border) === null || _style$border === void 0 ? void 0 : _style$border.style,
    onChange: onChange
  });
};

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/border-width.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


const MIN_BORDER_WIDTH = 0;
const MAX_BORDER_WIDTH = 50;
/**
 * Inspector control for configuring border width property.
 *
 * @param  {Object} props  Block properties.
 * @return {WPElement}     Border width edit element.
 */

const BorderWidthEdit = props => {
  var _style$border;

  const {
    attributes: {
      style
    },
    setAttributes
  } = props;

  const onChange = newWidth => {
    const newStyle = { ...style,
      border: { ...(style === null || style === void 0 ? void 0 : style.border),
        width: newWidth
      }
    };
    setAttributes({
      style: cleanEmptyObject(newStyle)
    });
  };

  return Object(external_wp_element_["createElement"])(external_wp_components_["RangeControl"], {
    value: style === null || style === void 0 ? void 0 : (_style$border = style.border) === null || _style$border === void 0 ? void 0 : _style$border.width,
    label: Object(external_wp_i18n_["__"])('Border width'),
    min: MIN_BORDER_WIDTH,
    max: MAX_BORDER_WIDTH,
    initialPosition: 0,
    allowReset: true,
    onChange: onChange
  });
};

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/border.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */







const BORDER_SUPPORT_KEY = '__experimentalBorder';
function BorderPanel(props) {
  const isDisabled = useIsBorderDisabled(props);
  const isSupported = hasBorderSupport(props.name);
  const isColorSupported = useSetting('border.customColor') && hasBorderSupport(props.name, 'color');
  const isRadiusSupported = useSetting('border.customRadius') && hasBorderSupport(props.name, 'radius');
  const isStyleSupported = useSetting('border.customStyle') && hasBorderSupport(props.name, 'style');
  const isWidthSupported = useSetting('border.customWidth') && hasBorderSupport(props.name, 'width');

  if (isDisabled || !isSupported) {
    return null;
  }

  return Object(external_wp_element_["createElement"])(inspector_controls, null, Object(external_wp_element_["createElement"])(external_wp_components_["PanelBody"], {
    title: Object(external_wp_i18n_["__"])('Border settings'),
    initialOpen: false
  }, isStyleSupported && Object(external_wp_element_["createElement"])(BorderStyleEdit, props), isWidthSupported && Object(external_wp_element_["createElement"])(BorderWidthEdit, props), isRadiusSupported && Object(external_wp_element_["createElement"])(BorderRadiusEdit, props), isColorSupported && Object(external_wp_element_["createElement"])(BorderColorEdit, props)));
}
/**
 * Determine whether there is block support for border properties.
 *
 * @param  {string} blockName Block name.
 * @param  {string} feature   Border feature to check support for.
 * @return {boolean}          Whether there is support.
 */

function hasBorderSupport(blockName, feature = 'any') {
  if (external_wp_element_["Platform"].OS !== 'web') {
    return false;
  }

  const support = Object(external_wp_blocks_["getBlockSupport"])(blockName, BORDER_SUPPORT_KEY);

  if (support === true) {
    return true;
  }

  if (feature === 'any') {
    return !!(support !== null && support !== void 0 && support.color || support !== null && support !== void 0 && support.radius || support !== null && support !== void 0 && support.width || support !== null && support !== void 0 && support.style);
  }

  return !!(support !== null && support !== void 0 && support[feature]);
}
/**
 * Check whether serialization of border classes and styles should be skipped.
 *
 * @param  {string|Object} blockType Block name or block type object.
 * @return {boolean}                 Whether serialization of border properties should occur.
 */

function shouldSkipSerialization(blockType) {
  const support = Object(external_wp_blocks_["getBlockSupport"])(blockType, BORDER_SUPPORT_KEY);
  return support === null || support === void 0 ? void 0 : support.__experimentalSkipSerialization;
}
/**
 * Determines if all border support features have been disabled.
 *
 * @return {boolean} If border support is completely disabled.
 */

const useIsBorderDisabled = () => {
  const configs = [!useSetting('border.customColor'), !useSetting('border.customRadius'), !useSetting('border.customStyle'), !useSetting('border.customWidth')];
  return configs.every(Boolean);
};

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/colors-gradients/panel-color-gradient-settings.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




 // translators: first %s: The type of color or gradient (e.g. background, overlay...), second %s: the color name or value (e.g. red or #ff0000)

const panel_color_gradient_settings_colorIndicatorAriaLabel = Object(external_wp_i18n_["__"])('(%s: color %s)'); // translators: first %s: The type of color or gradient (e.g. background, overlay...), second %s: the color name or value (e.g. red or #ff0000)


const panel_color_gradient_settings_gradientIndicatorAriaLabel = Object(external_wp_i18n_["__"])('(%s: gradient %s)');

const panel_color_gradient_settings_colorsAndGradientKeys = ['colors', 'disableCustomColors', 'gradients', 'disableCustomGradients'];

const Indicators = ({
  colors,
  gradients,
  settings
}) => {
  return settings.map(({
    colorValue,
    gradientValue,
    label,
    colors: availableColors,
    gradients: availableGradients
  }, index) => {
    if (!colorValue && !gradientValue) {
      return null;
    }

    let ariaLabel;

    if (colorValue) {
      const colorObject = getColorObjectByColorValue(availableColors || colors, colorValue);
      ariaLabel = Object(external_wp_i18n_["sprintf"])(panel_color_gradient_settings_colorIndicatorAriaLabel, label.toLowerCase(), colorObject && colorObject.name || colorValue);
    } else {
      const gradientObject = __experimentalGetGradientObjectByGradientValue(availableGradients || gradients, colorValue);

      ariaLabel = Object(external_wp_i18n_["sprintf"])(panel_color_gradient_settings_gradientIndicatorAriaLabel, label.toLowerCase(), gradientObject && gradientObject.name || gradientValue);
    }

    return Object(external_wp_element_["createElement"])(external_wp_components_["ColorIndicator"], {
      key: index,
      colorValue: colorValue || gradientValue,
      "aria-label": ariaLabel
    });
  });
};

const PanelColorGradientSettingsInner = ({
  className,
  colors,
  gradients,
  disableCustomColors,
  disableCustomGradients,
  children,
  settings,
  title,
  ...props
}) => {
  if (Object(external_lodash_["isEmpty"])(colors) && Object(external_lodash_["isEmpty"])(gradients) && disableCustomColors && disableCustomGradients && Object(external_lodash_["every"])(settings, setting => Object(external_lodash_["isEmpty"])(setting.colors) && Object(external_lodash_["isEmpty"])(setting.gradients) && (setting.disableCustomColors === undefined || setting.disableCustomColors) && (setting.disableCustomGradients === undefined || setting.disableCustomGradients))) {
    return null;
  }

  const titleElement = Object(external_wp_element_["createElement"])("span", {
    className: "block-editor-panel-color-gradient-settings__panel-title"
  }, title, Object(external_wp_element_["createElement"])(Indicators, {
    colors: colors,
    gradients: gradients,
    settings: settings
  }));
  return Object(external_wp_element_["createElement"])(external_wp_components_["PanelBody"], Object(esm_extends["a" /* default */])({
    className: classnames_default()('block-editor-panel-color-gradient-settings', className),
    title: titleElement
  }, props), settings.map((setting, index) => Object(external_wp_element_["createElement"])(control, Object(esm_extends["a" /* default */])({
    key: index,
    colors,
    gradients,
    disableCustomColors,
    disableCustomGradients
  }, setting))), children);
};

const PanelColorGradientSettingsSelect = props => {
  const colorGradientSettings = {};
  colorGradientSettings.colors = useSetting('color.palette');
  colorGradientSettings.gradients = useSetting('color.gradients');
  colorGradientSettings.disableCustomColors = !useSetting('color.custom');
  colorGradientSettings.disableCustomGradients = !useSetting('color.customGradient');
  return Object(external_wp_element_["createElement"])(PanelColorGradientSettingsInner, Object(esm_extends["a" /* default */])({}, colorGradientSettings, props));
};

const PanelColorGradientSettings = props => {
  if (Object(external_lodash_["every"])(panel_color_gradient_settings_colorsAndGradientKeys, key => props.hasOwnProperty(key))) {
    return Object(external_wp_element_["createElement"])(PanelColorGradientSettingsInner, props);
  }

  return Object(external_wp_element_["createElement"])(PanelColorGradientSettingsSelect, props);
};

/* harmony default export */ var panel_color_gradient_settings = (PanelColorGradientSettings);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/contrast-checker/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






function ContrastCheckerMessage({
  tinyBackgroundColor,
  tinyTextColor,
  backgroundColor,
  textColor
}) {
  const msg = tinyBackgroundColor.getBrightness() < tinyTextColor.getBrightness() ? Object(external_wp_i18n_["__"])('This color combination may be hard for people to read. Try using a darker background color and/or a brighter text color.') : Object(external_wp_i18n_["__"])('This color combination may be hard for people to read. Try using a brighter background color and/or a darker text color.'); // Note: The `Notice` component can speak messages via its `spokenMessage`
  // prop, but the contrast checker requires granular control over when the
  // announcements are made. Notably, the message will be re-announced if a
  // new color combination is selected and the contrast is still insufficient.

  Object(external_wp_element_["useEffect"])(() => {
    Object(external_wp_a11y_["speak"])(Object(external_wp_i18n_["__"])('This color combination may be hard for people to read.'));
  }, [backgroundColor, textColor]);
  return Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-contrast-checker"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["Notice"], {
    spokenMessage: null,
    status: "warning",
    isDismissible: false
  }, msg));
}

function ContrastChecker({
  backgroundColor,
  fallbackBackgroundColor,
  fallbackTextColor,
  fontSize,
  // font size value in pixels
  isLargeText,
  textColor
}) {
  if (!(backgroundColor || fallbackBackgroundColor) || !(textColor || fallbackTextColor)) {
    return null;
  }

  const tinyBackgroundColor = tinycolor_default()(backgroundColor || fallbackBackgroundColor);
  const tinyTextColor = tinycolor_default()(textColor || fallbackTextColor);
  const hasTransparency = tinyBackgroundColor.getAlpha() !== 1 || tinyTextColor.getAlpha() !== 1;

  if (hasTransparency || tinycolor_default.a.isReadable(tinyBackgroundColor, tinyTextColor, {
    level: 'AA',
    size: isLargeText || isLargeText !== false && fontSize >= 24 ? 'large' : 'small'
  })) {
    return null;
  }

  return Object(external_wp_element_["createElement"])(ContrastCheckerMessage, {
    backgroundColor: backgroundColor,
    textColor: textColor,
    tinyBackgroundColor: tinyBackgroundColor,
    tinyTextColor: tinyTextColor
  });
}

/* harmony default export */ var contrast_checker = (ContrastChecker);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/provider/block-refs-provider.js


/**
 * WordPress dependencies
 */

const BlockRefs = Object(external_wp_element_["createContext"])();
function BlockRefsProvider({
  children
}) {
  const value = Object(external_wp_element_["useMemo"])(() => ({
    refs: new Map(),
    callbacks: new Map()
  }), []);
  return Object(external_wp_element_["createElement"])(BlockRefs.Provider, {
    value: value
  }, children);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-refs.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/** @typedef {import('@wordpress/element').RefCallback} RefCallback */

/** @typedef {import('@wordpress/element').RefObject} RefObject */

/**
 * Provides a ref to the BlockRefs context.
 *
 * @param {string} clientId The client ID of the element ref.
 *
 * @return {RefCallback} Ref callback.
 */

function useBlockRefProvider(clientId) {
  const {
    refs,
    callbacks
  } = Object(external_wp_element_["useContext"])(BlockRefs);
  const ref = Object(external_wp_element_["useRef"])();
  Object(external_wp_element_["useLayoutEffect"])(() => {
    refs.set(ref, clientId);
    return () => {
      refs.delete(ref);
    };
  }, [clientId]);
  return Object(external_wp_compose_["useRefEffect"])(element => {
    // Update the ref in the provider.
    ref.current = element; // Call any update functions.

    callbacks.forEach((id, setElement) => {
      if (clientId === id) {
        setElement(element);
      }
    });
  }, [clientId]);
}
/**
 * Gets a ref pointing to the current block element. Continues to return a
 * stable ref even if the block client ID changes.
 *
 * @param {string} clientId The client ID to get a ref for.
 *
 * @return {RefObject} A ref containing the element.
 */

function useBlockRef(clientId) {
  const {
    refs
  } = Object(external_wp_element_["useContext"])(BlockRefs);
  const freshClientId = Object(external_wp_element_["useRef"])();
  freshClientId.current = clientId; // Always return an object, even if no ref exists for a given client ID, so
  // that `current` works at a later point.

  return Object(external_wp_element_["useMemo"])(() => ({
    get current() {
      let element = null; // Multiple refs may be created for a single block. Find the
      // first that has an element set.

      for (const [ref, id] of refs.entries()) {
        if (id === freshClientId.current && ref.current) {
          element = ref.current;
        }
      }

      return element;
    }

  }), []);
}
/**
 * Return the element for a given client ID. Updates whenever the element
 * changes, becomes available, or disappears.
 *
 * @param {string} clientId The client ID to an element for.
 *
 * @return {Element|null} The block's wrapper element.
 */


function useBlockElement(clientId) {
  const {
    callbacks
  } = Object(external_wp_element_["useContext"])(BlockRefs);
  const ref = useBlockRef(clientId);
  const [element, setElement] = Object(external_wp_element_["useState"])(null);
  Object(external_wp_element_["useLayoutEffect"])(() => {
    if (!clientId) {
      return;
    }

    callbacks.set(setElement, clientId);
    return () => {
      callbacks.delete(setElement);
    };
  }, [clientId]);
  return ref.current || element;
}




// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/color-panel.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */






function getComputedStyle(node) {
  return node.ownerDocument.defaultView.getComputedStyle(node);
}

function ColorPanel({
  settings,
  clientId,
  enableContrastChecking = true
}) {
  const [detectedBackgroundColor, setDetectedBackgroundColor] = Object(external_wp_element_["useState"])();
  const [detectedColor, setDetectedColor] = Object(external_wp_element_["useState"])();
  const ref = useBlockRef(clientId);
  Object(external_wp_element_["useEffect"])(() => {
    if (!enableContrastChecking) {
      return;
    }

    if (!ref.current) {
      return;
    }

    setDetectedColor(getComputedStyle(ref.current).color);
    let backgroundColorNode = ref.current;
    let backgroundColor = getComputedStyle(backgroundColorNode).backgroundColor;

    while (backgroundColor === 'rgba(0, 0, 0, 0)' && backgroundColorNode.parentNode && backgroundColorNode.parentNode.nodeType === backgroundColorNode.parentNode.ELEMENT_NODE) {
      backgroundColorNode = backgroundColorNode.parentNode;
      backgroundColor = getComputedStyle(backgroundColorNode).backgroundColor;
    }

    setDetectedBackgroundColor(backgroundColor);
  });
  return Object(external_wp_element_["createElement"])(inspector_controls, null, Object(external_wp_element_["createElement"])(panel_color_gradient_settings, {
    title: Object(external_wp_i18n_["__"])('Color'),
    initialOpen: false,
    settings: settings
  }, enableContrastChecking && Object(external_wp_element_["createElement"])(contrast_checker, {
    backgroundColor: detectedBackgroundColor,
    textColor: detectedColor
  })));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/color.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */






const COLOR_SUPPORT_KEY = 'color';
const color_EMPTY_ARRAY = [];

const hasColorSupport = blockType => {
  const colorSupport = Object(external_wp_blocks_["getBlockSupport"])(blockType, COLOR_SUPPORT_KEY);
  return colorSupport && (colorSupport.link === true || colorSupport.gradient === true || colorSupport.background !== false || colorSupport.text !== false);
};

const color_shouldSkipSerialization = blockType => {
  const colorSupport = Object(external_wp_blocks_["getBlockSupport"])(blockType, COLOR_SUPPORT_KEY);
  return colorSupport === null || colorSupport === void 0 ? void 0 : colorSupport.__experimentalSkipSerialization;
};

const hasLinkColorSupport = blockType => {
  if (external_wp_element_["Platform"].OS !== 'web') {
    return false;
  }

  const colorSupport = Object(external_wp_blocks_["getBlockSupport"])(blockType, COLOR_SUPPORT_KEY);
  return Object(external_lodash_["isObject"])(colorSupport) && !!colorSupport.link;
};

const hasGradientSupport = blockType => {
  if (external_wp_element_["Platform"].OS !== 'web') {
    return false;
  }

  const colorSupport = Object(external_wp_blocks_["getBlockSupport"])(blockType, COLOR_SUPPORT_KEY);
  return Object(external_lodash_["isObject"])(colorSupport) && !!colorSupport.gradients;
};

const hasBackgroundColorSupport = blockType => {
  const colorSupport = Object(external_wp_blocks_["getBlockSupport"])(blockType, COLOR_SUPPORT_KEY);
  return colorSupport && colorSupport.background !== false;
};

const hasTextColorSupport = blockType => {
  const colorSupport = Object(external_wp_blocks_["getBlockSupport"])(blockType, COLOR_SUPPORT_KEY);
  return colorSupport && colorSupport.text !== false;
};
/**
 * Filters registered block settings, extending attributes to include
 * `backgroundColor` and `textColor` attribute.
 *
 * @param  {Object} settings Original block settings
 * @return {Object}          Filtered block settings
 */


function color_addAttributes(settings) {
  if (!hasColorSupport(settings)) {
    return settings;
  } // allow blocks to specify their own attribute definition with default values if needed.


  if (!settings.attributes.backgroundColor) {
    Object.assign(settings.attributes, {
      backgroundColor: {
        type: 'string'
      }
    });
  }

  if (!settings.attributes.textColor) {
    Object.assign(settings.attributes, {
      textColor: {
        type: 'string'
      }
    });
  }

  if (hasGradientSupport(settings) && !settings.attributes.gradient) {
    Object.assign(settings.attributes, {
      gradient: {
        type: 'string'
      }
    });
  }

  return settings;
}
/**
 * Override props assigned to save component to inject colors classnames.
 *
 * @param  {Object} props      Additional props applied to save element
 * @param  {Object} blockType  Block type
 * @param  {Object} attributes Block attributes
 * @return {Object}            Filtered props applied to save element
 */


function color_addSaveProps(props, blockType, attributes) {
  var _style$color, _style$color2, _style$color3, _style$color4, _style$elements, _style$elements$link;

  if (!hasColorSupport(blockType) || color_shouldSkipSerialization(blockType)) {
    return props;
  }

  const hasGradient = hasGradientSupport(blockType); // I'd have prefered to avoid the "style" attribute usage here

  const {
    backgroundColor,
    textColor,
    gradient,
    style
  } = attributes;
  const backgroundClass = getColorClassName('background-color', backgroundColor);

  const gradientClass = __experimentalGetGradientClass(gradient);

  const textClass = getColorClassName('color', textColor);
  const newClassName = classnames_default()(props.className, textClass, gradientClass, {
    // Don't apply the background class if there's a custom gradient
    [backgroundClass]: (!hasGradient || !(style !== null && style !== void 0 && (_style$color = style.color) !== null && _style$color !== void 0 && _style$color.gradient)) && !!backgroundClass,
    'has-text-color': textColor || (style === null || style === void 0 ? void 0 : (_style$color2 = style.color) === null || _style$color2 === void 0 ? void 0 : _style$color2.text),
    'has-background': backgroundColor || (style === null || style === void 0 ? void 0 : (_style$color3 = style.color) === null || _style$color3 === void 0 ? void 0 : _style$color3.background) || hasGradient && (gradient || (style === null || style === void 0 ? void 0 : (_style$color4 = style.color) === null || _style$color4 === void 0 ? void 0 : _style$color4.gradient)),
    'has-link-color': style === null || style === void 0 ? void 0 : (_style$elements = style.elements) === null || _style$elements === void 0 ? void 0 : (_style$elements$link = _style$elements.link) === null || _style$elements$link === void 0 ? void 0 : _style$elements$link.color
  });
  props.className = newClassName ? newClassName : undefined;
  return props;
}
/**
 * Filters registered block settings to extand the block edit wrapper
 * to apply the desired styles and classnames properly.
 *
 * @param  {Object} settings Original block settings
 * @return {Object}          Filtered block settings
 */

function color_addEditProps(settings) {
  if (!hasColorSupport(settings) || color_shouldSkipSerialization(settings)) {
    return settings;
  }

  const existingGetEditWrapperProps = settings.getEditWrapperProps;

  settings.getEditWrapperProps = attributes => {
    let props = {};

    if (existingGetEditWrapperProps) {
      props = existingGetEditWrapperProps(attributes);
    }

    return color_addSaveProps(props, settings, attributes);
  };

  return settings;
}

const getLinkColorFromAttributeValue = (colors, value) => {
  const attributeParsed = /var:preset\|color\|(.+)/.exec(value);

  if (attributeParsed && attributeParsed[1]) {
    return getColorObjectByAttributeValues(colors, attributeParsed[1]).color;
  }

  return value;
};

function immutableSet(object, path, value) {
  return Object(external_lodash_["setWith"])(object ? Object(external_lodash_["clone"])(object) : {}, path, value, external_lodash_["clone"]);
}
/**
 * Inspector control panel containing the color related configuration
 *
 * @param {Object} props
 *
 * @return {WPElement} Color edit element.
 */


function ColorEdit(props) {
  var _style$color6, _style$color7, _style$color8, _style$elements2, _style$elements2$link, _style$elements2$link2, _style$elements3, _style$elements3$link, _style$elements3$link2;

  const {
    name: blockName,
    attributes
  } = props;
  const solids = useSetting('color.palette') || color_EMPTY_ARRAY;
  const gradients = useSetting('color.gradients') || color_EMPTY_ARRAY;
  const areCustomSolidsEnabled = useSetting('color.custom');
  const areCustomGradientsEnabled = useSetting('color.customGradient');
  const isLinkEnabled = useSetting('color.link'); // Shouldn't be needed but right now the ColorGradientsPanel
  // can trigger both onChangeColor and onChangeBackground
  // synchronously causing our two callbacks to override changes
  // from each other.

  const localAttributes = Object(external_wp_element_["useRef"])(attributes);
  Object(external_wp_element_["useEffect"])(() => {
    localAttributes.current = attributes;
  }, [attributes]);

  if (!hasColorSupport(blockName) || external_wp_element_["Platform"].OS !== 'web') {
    return null;
  }

  const hasLinkColor = hasLinkColorSupport(blockName) && isLinkEnabled && (solids.length > 0 || areCustomSolidsEnabled);
  const hasTextColor = hasTextColorSupport(blockName) && (solids.length > 0 || areCustomSolidsEnabled);
  const hasBackgroundColor = hasBackgroundColorSupport(blockName) && (solids.length > 0 || areCustomSolidsEnabled);
  const hasGradientColor = hasGradientSupport(blockName) && (gradients.length > 0 || areCustomGradientsEnabled);

  if (!hasLinkColor && !hasTextColor && !hasBackgroundColor && !hasGradientColor) {
    return null;
  }

  const {
    style,
    textColor,
    backgroundColor,
    gradient
  } = attributes;
  let gradientValue;

  if (hasGradientColor && gradient) {
    gradientValue = getGradientValueBySlug(gradients, gradient);
  } else if (hasGradientColor) {
    var _style$color5;

    gradientValue = style === null || style === void 0 ? void 0 : (_style$color5 = style.color) === null || _style$color5 === void 0 ? void 0 : _style$color5.gradient;
  }

  const onChangeColor = name => value => {
    var _localAttributes$curr, _localAttributes$curr2;

    const colorObject = getColorObjectByColorValue(solids, value);
    const attributeName = name + 'Color';
    const newStyle = { ...localAttributes.current.style,
      color: { ...((_localAttributes$curr = localAttributes.current) === null || _localAttributes$curr === void 0 ? void 0 : (_localAttributes$curr2 = _localAttributes$curr.style) === null || _localAttributes$curr2 === void 0 ? void 0 : _localAttributes$curr2.color),
        [name]: colorObject !== null && colorObject !== void 0 && colorObject.slug ? undefined : value
      }
    };
    const newNamedColor = colorObject !== null && colorObject !== void 0 && colorObject.slug ? colorObject.slug : undefined;
    const newAttributes = {
      style: cleanEmptyObject(newStyle),
      [attributeName]: newNamedColor
    };
    props.setAttributes(newAttributes);
    localAttributes.current = { ...localAttributes.current,
      ...newAttributes
    };
  };

  const onChangeGradient = value => {
    const slug = getGradientSlugByValue(gradients, value);
    let newAttributes;

    if (slug) {
      var _localAttributes$curr3, _localAttributes$curr4, _localAttributes$curr5;

      const newStyle = { ...((_localAttributes$curr3 = localAttributes.current) === null || _localAttributes$curr3 === void 0 ? void 0 : _localAttributes$curr3.style),
        color: { ...((_localAttributes$curr4 = localAttributes.current) === null || _localAttributes$curr4 === void 0 ? void 0 : (_localAttributes$curr5 = _localAttributes$curr4.style) === null || _localAttributes$curr5 === void 0 ? void 0 : _localAttributes$curr5.color),
          gradient: undefined
        }
      };
      newAttributes = {
        style: cleanEmptyObject(newStyle),
        gradient: slug
      };
    } else {
      var _localAttributes$curr6, _localAttributes$curr7, _localAttributes$curr8;

      const newStyle = { ...((_localAttributes$curr6 = localAttributes.current) === null || _localAttributes$curr6 === void 0 ? void 0 : _localAttributes$curr6.style),
        color: { ...((_localAttributes$curr7 = localAttributes.current) === null || _localAttributes$curr7 === void 0 ? void 0 : (_localAttributes$curr8 = _localAttributes$curr7.style) === null || _localAttributes$curr8 === void 0 ? void 0 : _localAttributes$curr8.color),
          gradient: value
        }
      };
      newAttributes = {
        style: cleanEmptyObject(newStyle),
        gradient: undefined
      };
    }

    props.setAttributes(newAttributes);
    localAttributes.current = { ...localAttributes.current,
      ...newAttributes
    };
  };

  const onChangeLinkColor = value => {
    const colorObject = getColorObjectByColorValue(solids, value);
    const newLinkColorValue = colorObject !== null && colorObject !== void 0 && colorObject.slug ? `var:preset|color|${colorObject.slug}` : value;
    const newStyle = immutableSet(style, ['elements', 'link', 'color', 'text'], newLinkColorValue);
    props.setAttributes({
      style: newStyle
    });
  };

  return Object(external_wp_element_["createElement"])(ColorPanel, {
    enableContrastChecking: // Turn on contrast checker for web only since it's not supported on mobile yet.
    external_wp_element_["Platform"].OS === 'web' && !gradient && !(style !== null && style !== void 0 && (_style$color6 = style.color) !== null && _style$color6 !== void 0 && _style$color6.gradient),
    clientId: props.clientId,
    settings: [...(hasTextColor ? [{
      label: Object(external_wp_i18n_["__"])('Text color'),
      onColorChange: onChangeColor('text'),
      colorValue: getColorObjectByAttributeValues(solids, textColor, style === null || style === void 0 ? void 0 : (_style$color7 = style.color) === null || _style$color7 === void 0 ? void 0 : _style$color7.text).color
    }] : []), ...(hasBackgroundColor || hasGradientColor ? [{
      label: Object(external_wp_i18n_["__"])('Background color'),
      onColorChange: hasBackgroundColor ? onChangeColor('background') : undefined,
      colorValue: getColorObjectByAttributeValues(solids, backgroundColor, style === null || style === void 0 ? void 0 : (_style$color8 = style.color) === null || _style$color8 === void 0 ? void 0 : _style$color8.background).color,
      gradientValue,
      onGradientChange: hasGradientColor ? onChangeGradient : undefined
    }] : []), ...(hasLinkColor ? [{
      label: Object(external_wp_i18n_["__"])('Link Color'),
      onColorChange: onChangeLinkColor,
      colorValue: getLinkColorFromAttributeValue(solids, style === null || style === void 0 ? void 0 : (_style$elements2 = style.elements) === null || _style$elements2 === void 0 ? void 0 : (_style$elements2$link = _style$elements2.link) === null || _style$elements2$link === void 0 ? void 0 : (_style$elements2$link2 = _style$elements2$link.color) === null || _style$elements2$link2 === void 0 ? void 0 : _style$elements2$link2.text),
      clearable: !!(style !== null && style !== void 0 && (_style$elements3 = style.elements) !== null && _style$elements3 !== void 0 && (_style$elements3$link = _style$elements3.link) !== null && _style$elements3$link !== void 0 && (_style$elements3$link2 = _style$elements3$link.color) !== null && _style$elements3$link2 !== void 0 && _style$elements3$link2.text)
    }] : [])]
  });
}
/**
 * This adds inline styles for color palette colors.
 * Ideally, this is not needed and themes should load their palettes on the editor.
 *
 * @param  {Function} BlockListBlock Original component
 * @return {Function}                Wrapped component
 */

const withColorPaletteStyles = Object(external_wp_compose_["createHigherOrderComponent"])(BlockListBlock => props => {
  var _getColorObjectByAttr, _getColorObjectByAttr2, _props$wrapperProps;

  const {
    name,
    attributes
  } = props;
  const {
    backgroundColor,
    textColor
  } = attributes;
  const colors = useSetting('color.palette') || color_EMPTY_ARRAY;

  if (!hasColorSupport(name) || color_shouldSkipSerialization(name)) {
    return Object(external_wp_element_["createElement"])(BlockListBlock, props);
  }

  const extraStyles = {
    color: textColor ? (_getColorObjectByAttr = getColorObjectByAttributeValues(colors, textColor)) === null || _getColorObjectByAttr === void 0 ? void 0 : _getColorObjectByAttr.color : undefined,
    backgroundColor: backgroundColor ? (_getColorObjectByAttr2 = getColorObjectByAttributeValues(colors, backgroundColor)) === null || _getColorObjectByAttr2 === void 0 ? void 0 : _getColorObjectByAttr2.color : undefined
  };
  let wrapperProps = props.wrapperProps;
  wrapperProps = { ...props.wrapperProps,
    style: { ...extraStyles,
      ...((_props$wrapperProps = props.wrapperProps) === null || _props$wrapperProps === void 0 ? void 0 : _props$wrapperProps.style)
    }
  };
  return Object(external_wp_element_["createElement"])(BlockListBlock, Object(esm_extends["a" /* default */])({}, props, {
    wrapperProps: wrapperProps
  }));
});
Object(external_wp_hooks_["addFilter"])('blocks.registerBlockType', 'core/color/addAttribute', color_addAttributes);
Object(external_wp_hooks_["addFilter"])('blocks.getSaveContent.extraProps', 'core/color/addSaveProps', color_addSaveProps);
Object(external_wp_hooks_["addFilter"])('blocks.registerBlockType', 'core/color/addEditProps', color_addEditProps);
Object(external_wp_hooks_["addFilter"])('editor.BlockListBlock', 'core/color/with-color-palette-styles', withColorPaletteStyles);

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/format-underline.js


/**
 * WordPress dependencies
 */

const formatUnderline = Object(external_wp_element_["createElement"])(external_wp_primitives_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_primitives_["Path"], {
  d: "M7 18v1h10v-1H7zm5-2c1.5 0 2.6-.4 3.4-1.2.8-.8 1.1-2 1.1-3.5V5H15v5.8c0 1.2-.2 2.1-.6 2.8-.4.7-1.2 1-2.4 1s-2-.3-2.4-1c-.4-.7-.6-1.6-.6-2.8V5H7.5v6.2c0 1.5.4 2.7 1.1 3.5.8.9 1.9 1.3 3.4 1.3z"
}));
/* harmony default export */ var format_underline = (formatUnderline);

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/format-strikethrough.js
var format_strikethrough = __webpack_require__("Crq9");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/text-decoration-control/index.js


/**
 * WordPress dependencies
 */



const TEXT_DECORATIONS = [{
  name: Object(external_wp_i18n_["__"])('Underline'),
  value: 'underline',
  icon: format_underline
}, {
  name: Object(external_wp_i18n_["__"])('Strikethrough'),
  value: 'line-through',
  icon: format_strikethrough["a" /* default */]
}];
/**
 * Control to facilitate text decoration selections.
 *
 * @param  {Object}   props                 Component props.
 * @param  {string}   props.value           Currently selected text decoration.
 * @param  {Function} props.onChange        Handles change in text decoration selection.
 * @return {WPElement}                      Text decoration control.
 */

function TextDecorationControl({
  value,
  onChange
}) {
  return Object(external_wp_element_["createElement"])("fieldset", {
    className: "block-editor-text-decoration-control"
  }, Object(external_wp_element_["createElement"])("legend", null, Object(external_wp_i18n_["__"])('Decoration')), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-text-decoration-control__buttons"
  }, TEXT_DECORATIONS.map(textDecoration => {
    return Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
      key: textDecoration.value,
      icon: textDecoration.icon,
      isSmall: true,
      isPressed: textDecoration.value === value,
      onClick: () => onChange(textDecoration.value === value ? undefined : textDecoration.value),
      "aria-label": textDecoration.name
    });
  })));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/text-decoration.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




/**
 * Key within block settings' supports array indicating support for text
 * decorations e.g. settings found in `block.json`.
 */

const TEXT_DECORATION_SUPPORT_KEY = 'typography.__experimentalTextDecoration';
/**
 * Inspector control panel containing the text decoration options.
 *
 * @param  {Object} props Block properties.
 * @return {WPElement}    Text decoration edit element.
 */

function TextDecorationEdit(props) {
  var _style$typography;

  const {
    attributes: {
      style
    },
    setAttributes
  } = props;
  const isDisabled = useIsTextDecorationDisabled(props);

  if (isDisabled) {
    return null;
  }

  function onChange(newDecoration) {
    setAttributes({
      style: cleanEmptyObject({ ...style,
        typography: { ...(style === null || style === void 0 ? void 0 : style.typography),
          textDecoration: newDecoration
        }
      })
    });
  }

  return Object(external_wp_element_["createElement"])(TextDecorationControl, {
    value: style === null || style === void 0 ? void 0 : (_style$typography = style.typography) === null || _style$typography === void 0 ? void 0 : _style$typography.textDecoration,
    onChange: onChange
  });
}
/**
 * Checks if text-decoration settings have been disabled.
 *
 * @param  {string} name Name of the block.
 * @return {boolean}     Whether or not the setting is disabled.
 */

function useIsTextDecorationDisabled({
  name: blockName
} = {}) {
  const notSupported = !Object(external_wp_blocks_["hasBlockSupport"])(blockName, TEXT_DECORATION_SUPPORT_KEY);
  const hasTextDecoration = useSetting('typography.customTextDecorations');
  return notSupported || !hasTextDecoration;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/format-uppercase.js


/**
 * WordPress dependencies
 */

const formatUppercase = Object(external_wp_element_["createElement"])(external_wp_primitives_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_primitives_["Path"], {
  d: "M6.1 6.8L2.1 18h1.6l1.1-3h4.3l1.1 3h1.6l-4-11.2H6.1zm-.8 6.8L7 8.9l1.7 4.7H5.3zm15.1-.7c-.4-.5-.9-.8-1.6-1 .4-.2.7-.5.8-.9.2-.4.3-.9.3-1.4 0-.9-.3-1.6-.8-2-.6-.5-1.3-.7-2.4-.7h-3.5V18h4.2c1.1 0 2-.3 2.6-.8.6-.6 1-1.4 1-2.4-.1-.8-.3-1.4-.6-1.9zm-5.7-4.7h1.8c.6 0 1.1.1 1.4.4.3.2.5.7.5 1.3 0 .6-.2 1.1-.5 1.3-.3.2-.8.4-1.4.4h-1.8V8.2zm4 8c-.4.3-.9.5-1.5.5h-2.6v-3.8h2.6c1.4 0 2 .6 2 1.9.1.6-.1 1-.5 1.4z"
}));
/* harmony default export */ var format_uppercase = (formatUppercase);

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/format-lowercase.js


/**
 * WordPress dependencies
 */

const formatLowercase = Object(external_wp_element_["createElement"])(external_wp_primitives_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_primitives_["Path"], {
  d: "M11 16.8c-.1-.1-.2-.3-.3-.5v-2.6c0-.9-.1-1.7-.3-2.2-.2-.5-.5-.9-.9-1.2-.4-.2-.9-.3-1.6-.3-.5 0-1 .1-1.5.2s-.9.3-1.2.6l.2 1.2c.4-.3.7-.4 1.1-.5.3-.1.7-.2 1-.2.6 0 1 .1 1.3.4.3.2.4.7.4 1.4-1.2 0-2.3.2-3.3.7s-1.4 1.1-1.4 2.1c0 .7.2 1.2.7 1.6.4.4 1 .6 1.8.6.9 0 1.7-.4 2.4-1.2.1.3.2.5.4.7.1.2.3.3.6.4.3.1.6.1 1.1.1h.1l.2-1.2h-.1c-.4.1-.6 0-.7-.1zM9.2 16c-.2.3-.5.6-.9.8-.3.1-.7.2-1.1.2-.4 0-.7-.1-.9-.3-.2-.2-.3-.5-.3-.9 0-.6.2-1 .7-1.3.5-.3 1.3-.4 2.5-.5v2zm10.6-3.9c-.3-.6-.7-1.1-1.2-1.5-.6-.4-1.2-.6-1.9-.6-.5 0-.9.1-1.4.3-.4.2-.8.5-1.1.8V6h-1.4v12h1.3l.2-1c.2.4.6.6 1 .8.4.2.9.3 1.4.3.7 0 1.2-.2 1.8-.5.5-.4 1-.9 1.3-1.5.3-.6.5-1.3.5-2.1-.1-.6-.2-1.3-.5-1.9zm-1.7 4c-.4.5-.9.8-1.6.8s-1.2-.2-1.7-.7c-.4-.5-.7-1.2-.7-2.1 0-.9.2-1.6.7-2.1.4-.5 1-.7 1.7-.7s1.2.3 1.6.8c.4.5.6 1.2.6 2s-.2 1.4-.6 2z"
}));
/* harmony default export */ var format_lowercase = (formatLowercase);

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/format-capitalize.js


/**
 * WordPress dependencies
 */

const formatCapitalize = Object(external_wp_element_["createElement"])(external_wp_primitives_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_primitives_["Path"], {
  d: "M7.1 6.8L3.1 18h1.6l1.1-3h4.3l1.1 3h1.6l-4-11.2H7.1zm-.8 6.8L8 8.9l1.7 4.7H6.3zm14.5-1.5c-.3-.6-.7-1.1-1.2-1.5-.6-.4-1.2-.6-1.9-.6-.5 0-.9.1-1.4.3-.4.2-.8.5-1.1.8V6h-1.4v12h1.3l.2-1c.2.4.6.6 1 .8.4.2.9.3 1.4.3.7 0 1.2-.2 1.8-.5.5-.4 1-.9 1.3-1.5.3-.6.5-1.3.5-2.1-.1-.6-.2-1.3-.5-1.9zm-1.7 4c-.4.5-.9.8-1.6.8s-1.2-.2-1.7-.7c-.4-.5-.7-1.2-.7-2.1 0-.9.2-1.6.7-2.1.4-.5 1-.7 1.7-.7s1.2.3 1.6.8c.4.5.6 1.2.6 2 .1.8-.2 1.4-.6 2z"
}));
/* harmony default export */ var format_capitalize = (formatCapitalize);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/text-transform-control/index.js


/**
 * WordPress dependencies
 */



const TEXT_TRANSFORMS = [{
  name: Object(external_wp_i18n_["__"])('Uppercase'),
  value: 'uppercase',
  icon: format_uppercase
}, {
  name: Object(external_wp_i18n_["__"])('Lowercase'),
  value: 'lowercase',
  icon: format_lowercase
}, {
  name: Object(external_wp_i18n_["__"])('Capitalize'),
  value: 'capitalize',
  icon: format_capitalize
}];
/**
 * Control to facilitate text transform selections.
 *
 * @param  {Object}   props                Component props.
 * @param  {string}   props.value          Currently selected text transform.
 * @param  {Function} props.onChange       Handles change in text transform selection.
 * @return {WPElement}                     Text transform control.
 */

function TextTransformControl({
  value,
  onChange
}) {
  return Object(external_wp_element_["createElement"])("fieldset", {
    className: "block-editor-text-transform-control"
  }, Object(external_wp_element_["createElement"])("legend", null, Object(external_wp_i18n_["__"])('Letter case')), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-text-transform-control__buttons"
  }, TEXT_TRANSFORMS.map(textTransform => {
    return Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
      key: textTransform.value,
      icon: textTransform.icon,
      isSmall: true,
      isPressed: value === textTransform.value,
      "aria-label": textTransform.name,
      onClick: () => onChange(value === textTransform.value ? undefined : textTransform.value)
    });
  })));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/text-transform.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




/**
 * Key within block settings' supports array indicating support for text
 * transforms e.g. settings found in `block.json`.
 */

const TEXT_TRANSFORM_SUPPORT_KEY = 'typography.__experimentalTextTransform';
/**
 * Inspector control panel containing the text transform options.
 *
 * @param  {Object} props Block properties.
 * @return {WPElement}    Text transform edit element.
 */

function TextTransformEdit(props) {
  var _style$typography;

  const {
    attributes: {
      style
    },
    setAttributes
  } = props;
  const isDisabled = useIsTextTransformDisabled(props);

  if (isDisabled) {
    return null;
  }

  function onChange(newTransform) {
    setAttributes({
      style: cleanEmptyObject({ ...style,
        typography: { ...(style === null || style === void 0 ? void 0 : style.typography),
          textTransform: newTransform
        }
      })
    });
  }

  return Object(external_wp_element_["createElement"])(TextTransformControl, {
    value: style === null || style === void 0 ? void 0 : (_style$typography = style.typography) === null || _style$typography === void 0 ? void 0 : _style$typography.textTransform,
    onChange: onChange
  });
}
/**
 * Checks if text-transform settings have been disabled.
 *
 * @param  {string} name Name of the block.
 * @return {boolean}     Whether or not the setting is disabled.
 */

function useIsTextTransformDisabled({
  name: blockName
} = {}) {
  const notSupported = !Object(external_wp_blocks_["hasBlockSupport"])(blockName, TEXT_TRANSFORM_SUPPORT_KEY);
  const hasTextTransforms = useSetting('typography.customTextTransforms');
  return notSupported || !hasTextTransforms;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/text-decoration-and-transform/index.js


/**
 * Internal dependencies
 */


/**
 * Handles grouping related text decoration and text transform edit components
 * so they can be laid out in a more flexible manner within the Typography
 * InspectorControls panel.
 *
 * @param  {Object}   props Block props to be passed on to individual controls.
 * @return {WPElement}      Component containing text decoration or transform controls.
 */

function TextDecorationAndTransformEdit(props) {
  const decorationAvailable = !useIsTextDecorationDisabled(props);
  const transformAvailable = !useIsTextTransformDisabled(props);

  if (!decorationAvailable && !transformAvailable) {
    return null;
  }

  return Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-text-decoration-and-transform"
  }, decorationAvailable && Object(external_wp_element_["createElement"])(TextDecorationEdit, props), transformAvailable && Object(external_wp_element_["createElement"])(TextTransformEdit, props));
}

// EXTERNAL MODULE: external ["wp","keycodes"]
var external_wp_keycodes_ = __webpack_require__("RxS6");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/line-height-control/utils.js
const BASE_DEFAULT_VALUE = 1.5;
const STEP = 0.1;
/**
 * There are varying value types within LineHeightControl:
 *
 * {undefined} Initial value. No changes from the user.
 * {string} Input value. Value consumed/outputted by the input. Empty would be ''.
 * {number} Block attribute type. Input value needs to be converted for attribute setting.
 *
 * Note: If the value is undefined, the input requires it to be an empty string ('')
 * in order to be considered "controlled" by props (rather than internal state).
 */

const RESET_VALUE = '';
/**
 * Determines if the lineHeight attribute has been properly defined.
 *
 * @param {any} lineHeight The value to check.
 *
 * @return {boolean} Whether the lineHeight attribute is valid.
 */

function isLineHeightDefined(lineHeight) {
  return lineHeight !== undefined && lineHeight !== RESET_VALUE;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/line-height-control/index.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


function LineHeightControl({
  value: lineHeight,
  onChange
}) {
  const isDefined = isLineHeightDefined(lineHeight);

  const handleOnKeyDown = event => {
    const {
      keyCode
    } = event;

    if (keyCode === external_wp_keycodes_["ZERO"] && !isDefined) {
      /**
       * Prevents the onChange callback from firing, which prevents
       * the logic from assuming the change was triggered from
       * an input arrow CLICK.
       */
      event.preventDefault();
      onChange('0');
    }
  };

  const handleOnChange = nextValue => {
    // Set the next value without modification if lineHeight has been defined
    if (isDefined) {
      onChange(nextValue);
      return;
    } // Otherwise...

    /**
     * The following logic handles the initial up/down arrow CLICK of the
     * input element. This is so that the next values (from an undefined value state)
     * are more better suited for line-height rendering.
     */


    let adjustedNextValue = nextValue;

    switch (nextValue) {
      case `${STEP}`:
        // Increment by step value
        adjustedNextValue = BASE_DEFAULT_VALUE + STEP;
        break;

      case '0':
        // Decrement by step value
        adjustedNextValue = BASE_DEFAULT_VALUE - STEP;
        break;
    }

    onChange(adjustedNextValue);
  };

  const value = isDefined ? lineHeight : RESET_VALUE;
  return Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-line-height-control"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["TextControl"], {
    autoComplete: "off",
    onKeyDown: handleOnKeyDown,
    onChange: handleOnChange,
    label: Object(external_wp_i18n_["__"])('Line height'),
    placeholder: BASE_DEFAULT_VALUE,
    step: STEP,
    type: "number",
    value: value,
    min: 0
  }));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/line-height.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




const LINE_HEIGHT_SUPPORT_KEY = 'typography.lineHeight';
/**
 * Inspector control panel containing the line height related configuration
 *
 * @param {Object} props
 *
 * @return {WPElement} Line height edit element.
 */

function LineHeightEdit(props) {
  var _style$typography;

  const {
    attributes: {
      style
    }
  } = props;
  const isDisabled = useIsLineHeightDisabled(props);

  if (isDisabled) {
    return null;
  }

  const onChange = newLineHeightValue => {
    const newStyle = { ...style,
      typography: { ...(style === null || style === void 0 ? void 0 : style.typography),
        lineHeight: newLineHeightValue
      }
    };
    props.setAttributes({
      style: cleanEmptyObject(newStyle)
    });
  };

  return Object(external_wp_element_["createElement"])(LineHeightControl, {
    value: style === null || style === void 0 ? void 0 : (_style$typography = style.typography) === null || _style$typography === void 0 ? void 0 : _style$typography.lineHeight,
    onChange: onChange
  });
}
/**
 * Custom hook that checks if line-height settings have been disabled.
 *
 * @param {string} name The name of the block.
 * @return {boolean} Whether setting is disabled.
 */

function useIsLineHeightDisabled({
  name: blockName
} = {}) {
  const isDisabled = !useSetting('typography.customLineHeight');
  return !Object(external_wp_blocks_["hasBlockSupport"])(blockName, LINE_HEIGHT_SUPPORT_KEY) || isDisabled;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/font-appearance-control/index.js


/**
 * WordPress dependencies
 */



const FONT_STYLES = [{
  name: Object(external_wp_i18n_["__"])('Regular'),
  value: 'normal'
}, {
  name: Object(external_wp_i18n_["__"])('Italic'),
  value: 'italic'
}];
const FONT_WEIGHTS = [{
  name: Object(external_wp_i18n_["__"])('Thin'),
  value: '100'
}, {
  name: Object(external_wp_i18n_["__"])('Extra Light'),
  value: '200'
}, {
  name: Object(external_wp_i18n_["__"])('Light'),
  value: '300'
}, {
  name: Object(external_wp_i18n_["__"])('Regular'),
  value: '400'
}, {
  name: Object(external_wp_i18n_["__"])('Medium'),
  value: '500'
}, {
  name: Object(external_wp_i18n_["__"])('Semi Bold'),
  value: '600'
}, {
  name: Object(external_wp_i18n_["__"])('Bold'),
  value: '700'
}, {
  name: Object(external_wp_i18n_["__"])('Extra Bold'),
  value: '800'
}, {
  name: Object(external_wp_i18n_["__"])('Black'),
  value: '900'
}];
/**
 * Control to display unified font style and weight options.
 *
 * @param  {Object}   props Component props.
 * @return {WPElement}      Font appearance control.
 */

function FontAppearanceControl(props) {
  const {
    onChange,
    hasFontStyles = true,
    hasFontWeights = true,
    value: {
      fontStyle,
      fontWeight
    }
  } = props;
  const hasStylesOrWeights = hasFontStyles || hasFontWeights;
  const defaultOption = {
    key: 'default',
    name: Object(external_wp_i18n_["__"])('Default'),
    style: {
      fontStyle: undefined,
      fontWeight: undefined
    }
  }; // Combines both font style and weight options into a single dropdown.

  const combineOptions = () => {
    const combinedOptions = [defaultOption];
    FONT_STYLES.forEach(({
      name: styleName,
      value: styleValue
    }) => {
      FONT_WEIGHTS.forEach(({
        name: weightName,
        value: weightValue
      }) => {
        const optionName = styleValue === 'normal' ? weightName : Object(external_wp_i18n_["sprintf"])(
        /* translators: 1: Font weight name. 2: Font style name. */
        Object(external_wp_i18n_["__"])('%1$s %2$s'), weightName, styleName);
        combinedOptions.push({
          key: `${styleValue}-${weightValue}`,
          name: optionName,
          style: {
            fontStyle: styleValue,
            fontWeight: weightValue
          }
        });
      });
    });
    return combinedOptions;
  }; // Generates select options for font styles only.


  const styleOptions = () => {
    const combinedOptions = [defaultOption];
    FONT_STYLES.forEach(({
      name,
      value
    }) => {
      combinedOptions.push({
        key: value,
        name,
        style: {
          fontStyle: value,
          fontWeight: undefined
        }
      });
    });
    return combinedOptions;
  }; // Generates select options for font weights only.


  const weightOptions = () => {
    const combinedOptions = [defaultOption];
    FONT_WEIGHTS.forEach(({
      name,
      value
    }) => {
      combinedOptions.push({
        key: value,
        name,
        style: {
          fontStyle: undefined,
          fontWeight: value
        }
      });
    });
    return combinedOptions;
  }; // Map font styles and weights to select options.


  const selectOptions = Object(external_wp_element_["useMemo"])(() => {
    if (hasFontStyles && hasFontWeights) {
      return combineOptions();
    }

    return hasFontStyles ? styleOptions() : weightOptions();
  }, [props.options]); // Find current selection by comparing font style & weight against options.

  const currentSelection = selectOptions.find(option => option.style.fontStyle === fontStyle && option.style.fontWeight === fontWeight); // Adjusts field label in case either styles or weights are disabled.

  const getLabel = () => {
    if (!hasFontStyles) {
      return Object(external_wp_i18n_["__"])('Font weight');
    }

    if (!hasFontWeights) {
      return Object(external_wp_i18n_["__"])('Font style');
    }

    return Object(external_wp_i18n_["__"])('Appearance');
  };

  return Object(external_wp_element_["createElement"])("fieldset", {
    className: "components-font-appearance-control"
  }, hasStylesOrWeights && Object(external_wp_element_["createElement"])(external_wp_components_["CustomSelectControl"], {
    className: "components-font-appearance-control__select",
    label: getLabel(),
    options: selectOptions,
    value: currentSelection,
    onChange: ({
      selectedItem
    }) => onChange(selectedItem.style)
  }));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/font-appearance.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




/**
 * Key within block settings' support array indicating support for font style.
 */

const FONT_STYLE_SUPPORT_KEY = 'typography.__experimentalFontStyle';
/**
 * Key within block settings' support array indicating support for font weight.
 */

const FONT_WEIGHT_SUPPORT_KEY = 'typography.__experimentalFontWeight';
/**
 * Inspector control panel containing the font appearance options.
 *
 * @param  {Object} props Block properties.
 * @return {WPElement}    Font appearance edit element.
 */

function FontAppearanceEdit(props) {
  var _style$typography, _style$typography2;

  const {
    attributes: {
      style
    },
    setAttributes
  } = props;
  const hasFontStyles = !useIsFontStyleDisabled(props);
  const hasFontWeights = !useIsFontWeightDisabled(props);

  if (!hasFontStyles && !hasFontWeights) {
    return null;
  }

  const onChange = newStyles => {
    setAttributes({
      style: cleanEmptyObject({ ...style,
        typography: { ...(style === null || style === void 0 ? void 0 : style.typography),
          fontStyle: newStyles.fontStyle,
          fontWeight: newStyles.fontWeight
        }
      })
    });
  };

  const fontStyle = style === null || style === void 0 ? void 0 : (_style$typography = style.typography) === null || _style$typography === void 0 ? void 0 : _style$typography.fontStyle;
  const fontWeight = style === null || style === void 0 ? void 0 : (_style$typography2 = style.typography) === null || _style$typography2 === void 0 ? void 0 : _style$typography2.fontWeight;
  return Object(external_wp_element_["createElement"])(FontAppearanceControl, {
    onChange: onChange,
    hasFontStyles: hasFontStyles,
    hasFontWeights: hasFontWeights,
    value: {
      fontStyle,
      fontWeight
    }
  });
}
/**
 * Checks if font style support has been disabled either by not opting in for
 * support or by failing to provide preset styles.
 *
 * @param  {Object} props      Block properties.
 * @param  {string} props.name Name for the block type.
 * @return {boolean}           Whether font style support has been disabled.
 */

function useIsFontStyleDisabled({
  name: blockName
} = {}) {
  const styleSupport = Object(external_wp_blocks_["hasBlockSupport"])(blockName, FONT_STYLE_SUPPORT_KEY);
  const hasFontStyles = useSetting('typography.customFontStyle');
  return !styleSupport || !hasFontStyles;
}
/**
 * Checks if font weight support has been disabled either by not opting in for
 * support or by failing to provide preset weights.
 *
 * @param  {Object} props      Block properties.
 * @param  {string} props.name Name for the block type.
 * @return {boolean}           Whether font weight support has been disabled.
 */

function useIsFontWeightDisabled({
  name: blockName
} = {}) {
  const weightSupport = Object(external_wp_blocks_["hasBlockSupport"])(blockName, FONT_WEIGHT_SUPPORT_KEY);
  const hasFontWeights = useSetting('typography.customFontWeight');
  return !weightSupport || !hasFontWeights;
}
/**
 * Checks if font appearance support has been disabled.
 *
 * @param  {Object} props      Block properties.
 * @return {boolean}           Whether font appearance support has been disabled.
 */

function useIsFontAppearanceDisabled(props) {
  const stylesDisabled = useIsFontStyleDisabled(props);
  const weightsDisabled = useIsFontWeightDisabled(props);
  return stylesDisabled && weightsDisabled;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/font-family/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


function FontFamilyControl({
  value = '',
  onChange,
  fontFamilies,
  ...props
}) {
  const blockLevelFontFamilies = useSetting('typography.fontFamilies');

  if (!fontFamilies) {
    fontFamilies = blockLevelFontFamilies;
  }

  if (Object(external_lodash_["isEmpty"])(fontFamilies)) {
    return null;
  }

  const options = [{
    value: '',
    label: Object(external_wp_i18n_["__"])('Default')
  }, ...fontFamilies.map(({
    fontFamily,
    name
  }) => {
    return {
      value: fontFamily,
      label: name || fontFamily
    };
  })];
  return Object(external_wp_element_["createElement"])(external_wp_components_["SelectControl"], Object(esm_extends["a" /* default */])({
    label: Object(external_wp_i18n_["__"])('Font family'),
    options: options,
    value: value,
    onChange: onChange,
    labelPosition: "top"
  }, props));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/font-family.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




const FONT_FAMILY_SUPPORT_KEY = 'typography.__experimentalFontFamily';

const getFontFamilyFromAttributeValue = (fontFamilies, value) => {
  const attributeParsed = /var:preset\|font-family\|(.+)/.exec(value);

  if (attributeParsed && attributeParsed[1]) {
    const fontFamilyObject = Object(external_lodash_["find"])(fontFamilies, ({
      slug
    }) => {
      return slug === attributeParsed[1];
    });

    if (fontFamilyObject) {
      return fontFamilyObject.fontFamily;
    }
  }

  return value;
};

function FontFamilyEdit({
  name,
  setAttributes,
  attributes: {
    style = {}
  }
}) {
  var _style$typography;

  const fontFamilies = useSetting('typography.fontFamilies');
  const isDisable = useIsFontFamilyDisabled({
    name
  });

  if (isDisable) {
    return null;
  }

  const value = getFontFamilyFromAttributeValue(fontFamilies, (_style$typography = style.typography) === null || _style$typography === void 0 ? void 0 : _style$typography.fontFamily);

  function onChange(newValue) {
    const predefinedFontFamily = Object(external_lodash_["find"])(fontFamilies, ({
      fontFamily
    }) => fontFamily === newValue);
    setAttributes({
      style: cleanEmptyObject({ ...style,
        typography: { ...(style.typography || {}),
          fontFamily: predefinedFontFamily ? `var:preset|font-family|${predefinedFontFamily.slug}` : newValue || undefined
        }
      })
    });
  }

  return Object(external_wp_element_["createElement"])(FontFamilyControl, {
    className: "block-editor-hooks-font-family-control",
    fontFamilies: fontFamilies,
    value: value,
    onChange: onChange
  });
}
/**
 * Custom hook that checks if font-family functionality is disabled.
 *
 * @param {string} name The name of the block.
 * @return {boolean} Whether setting is disabled.
 */

function useIsFontFamilyDisabled({
  name
}) {
  const fontFamilies = useSetting('typography.fontFamilies');
  return !fontFamilies || fontFamilies.length === 0 || !Object(external_wp_blocks_["hasBlockSupport"])(name, FONT_FAMILY_SUPPORT_KEY);
}

// EXTERNAL MODULE: external ["wp","tokenList"]
var external_wp_tokenList_ = __webpack_require__("BLeD");
var external_wp_tokenList_default = /*#__PURE__*/__webpack_require__.n(external_wp_tokenList_);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/font-sizes/utils.js
/**
 * External dependencies
 */

/**
 *  Returns the font size object based on an array of named font sizes and the namedFontSize and customFontSize values.
 * 	If namedFontSize is undefined or not found in fontSizes an object with just the size value based on customFontSize is returned.
 *
 * @param {Array}   fontSizes               Array of font size objects containing at least the "name" and "size" values as properties.
 * @param {?string} fontSizeAttribute       Content of the font size attribute (slug).
 * @param {?number} customFontSizeAttribute Contents of the custom font size attribute (value).
 *
 * @return {?Object} If fontSizeAttribute is set and an equal slug is found in fontSizes it returns the font size object for that slug.
 * 					 Otherwise, an object with just the size value based on customFontSize is returned.
 */

const getFontSize = (fontSizes, fontSizeAttribute, customFontSizeAttribute) => {
  if (fontSizeAttribute) {
    const fontSizeObject = Object(external_lodash_["find"])(fontSizes, {
      slug: fontSizeAttribute
    });

    if (fontSizeObject) {
      return fontSizeObject;
    }
  }

  return {
    size: customFontSizeAttribute
  };
};
/**
 * Returns the corresponding font size object for a given value.
 *
 * @param {Array} fontSizes Array of font size objects.
 * @param {number} value Font size value.
 *
 * @return {Object} Font size object.
 */

function getFontSizeObjectByValue(fontSizes, value) {
  const fontSizeObject = Object(external_lodash_["find"])(fontSizes, {
    size: value
  });

  if (fontSizeObject) {
    return fontSizeObject;
  }

  return {
    size: value
  };
}
/**
 * Returns a class based on fontSizeName.
 *
 * @param {string} fontSizeSlug    Slug of the fontSize.
 *
 * @return {string} String with the class corresponding to the fontSize passed.
 *                  The class is generated by appending 'has-' followed by fontSizeSlug in kebabCase and ending with '-font-size'.
 */

function getFontSizeClass(fontSizeSlug) {
  if (!fontSizeSlug) {
    return;
  }

  return `has-${Object(external_lodash_["kebabCase"])(fontSizeSlug)}-font-size`;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/font-sizes/font-size-picker.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



function FontSizePicker(props) {
  const fontSizes = useSetting('typography.fontSizes');
  const disableCustomFontSizes = !useSetting('typography.customFontSize');
  return Object(external_wp_element_["createElement"])(external_wp_components_["FontSizePicker"], Object(esm_extends["a" /* default */])({}, props, {
    fontSizes: fontSizes,
    disableCustomFontSizes: disableCustomFontSizes
  }));
}

/* harmony default export */ var font_size_picker = (FontSizePicker);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/font-size.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




const FONT_SIZE_SUPPORT_KEY = 'typography.fontSize';
/**
 * Filters registered block settings, extending attributes to include
 * `fontSize` and `fontWeight` attributes.
 *
 * @param  {Object} settings Original block settings
 * @return {Object}          Filtered block settings
 */

function font_size_addAttributes(settings) {
  if (!Object(external_wp_blocks_["hasBlockSupport"])(settings, FONT_SIZE_SUPPORT_KEY)) {
    return settings;
  } // Allow blocks to specify a default value if needed.


  if (!settings.attributes.fontSize) {
    Object.assign(settings.attributes, {
      fontSize: {
        type: 'string'
      }
    });
  }

  return settings;
}
/**
 * Override props assigned to save component to inject font size.
 *
 * @param  {Object} props      Additional props applied to save element
 * @param  {Object} blockType  Block type
 * @param  {Object} attributes Block attributes
 * @return {Object}            Filtered props applied to save element
 */


function font_size_addSaveProps(props, blockType, attributes) {
  if (!Object(external_wp_blocks_["hasBlockSupport"])(blockType, FONT_SIZE_SUPPORT_KEY)) {
    return props;
  }

  if (Object(external_wp_blocks_["hasBlockSupport"])(blockType, 'typography.__experimentalSkipSerialization')) {
    return props;
  } // Use TokenList to dedupe classes.


  const classes = new external_wp_tokenList_default.a(props.className);
  classes.add(getFontSizeClass(attributes.fontSize));
  const newClassName = classes.value;
  props.className = newClassName ? newClassName : undefined;
  return props;
}
/**
 * Filters registered block settings to expand the block edit wrapper
 * by applying the desired styles and classnames.
 *
 * @param  {Object} settings Original block settings
 * @return {Object}          Filtered block settings
 */


function font_size_addEditProps(settings) {
  if (!Object(external_wp_blocks_["hasBlockSupport"])(settings, FONT_SIZE_SUPPORT_KEY)) {
    return settings;
  }

  const existingGetEditWrapperProps = settings.getEditWrapperProps;

  settings.getEditWrapperProps = attributes => {
    let props = {};

    if (existingGetEditWrapperProps) {
      props = existingGetEditWrapperProps(attributes);
    }

    return font_size_addSaveProps(props, settings, attributes);
  };

  return settings;
}
/**
 * Inspector control panel containing the font size related configuration
 *
 * @param {Object} props
 *
 * @return {WPElement} Font size edit element.
 */


function FontSizeEdit(props) {
  var _style$typography, _style$typography2;

  const {
    attributes: {
      fontSize,
      style
    },
    setAttributes
  } = props;
  const isDisabled = useIsFontSizeDisabled(props);
  const fontSizes = useSetting('typography.fontSizes');

  const onChange = value => {
    const fontSizeSlug = getFontSizeObjectByValue(fontSizes, value).slug;
    setAttributes({
      style: cleanEmptyObject({ ...style,
        typography: { ...(style === null || style === void 0 ? void 0 : style.typography),
          fontSize: fontSizeSlug ? undefined : value
        }
      }),
      fontSize: fontSizeSlug
    });
  };

  if (isDisabled) {
    return null;
  }

  const fontSizeObject = getFontSize(fontSizes, fontSize, style === null || style === void 0 ? void 0 : (_style$typography = style.typography) === null || _style$typography === void 0 ? void 0 : _style$typography.fontSize);
  const fontSizeValue = (fontSizeObject === null || fontSizeObject === void 0 ? void 0 : fontSizeObject.size) || (style === null || style === void 0 ? void 0 : (_style$typography2 = style.typography) === null || _style$typography2 === void 0 ? void 0 : _style$typography2.fontSize) || fontSize;
  return Object(external_wp_element_["createElement"])(font_size_picker, {
    onChange: onChange,
    value: fontSizeValue
  });
}
/**
 * Custom hook that checks if font-size settings have been disabled.
 *
 * @param {string} name The name of the block.
 * @return {boolean} Whether setting is disabled.
 */

function useIsFontSizeDisabled({
  name: blockName
} = {}) {
  const fontSizes = useSetting('typography.fontSizes');
  const hasFontSizes = !!(fontSizes !== null && fontSizes !== void 0 && fontSizes.length);
  return !Object(external_wp_blocks_["hasBlockSupport"])(blockName, FONT_SIZE_SUPPORT_KEY) || !hasFontSizes;
}
/**
 * Add inline styles for font sizes.
 * Ideally, this is not needed and themes load the font-size classes on the
 * editor.
 *
 * @param  {Function} BlockListBlock Original component
 * @return {Function}                Wrapped component
 */

const withFontSizeInlineStyles = Object(external_wp_compose_["createHigherOrderComponent"])(BlockListBlock => props => {
  var _style$typography3, _style$typography4;

  const fontSizes = useSetting('typography.fontSizes');
  const {
    name: blockName,
    attributes: {
      fontSize,
      style
    },
    wrapperProps
  } = props; // Only add inline styles if the block supports font sizes,
  // doesn't skip serialization of font sizes,
  // doesn't already have an inline font size,
  // and does have a class to extract the font size from.

  if (!Object(external_wp_blocks_["hasBlockSupport"])(blockName, FONT_SIZE_SUPPORT_KEY) || Object(external_wp_blocks_["hasBlockSupport"])(blockName, 'typography.__experimentalSkipSerialization') || !fontSize || style !== null && style !== void 0 && (_style$typography3 = style.typography) !== null && _style$typography3 !== void 0 && _style$typography3.fontSize) {
    return Object(external_wp_element_["createElement"])(BlockListBlock, props);
  }

  const fontSizeValue = getFontSize(fontSizes, fontSize, style === null || style === void 0 ? void 0 : (_style$typography4 = style.typography) === null || _style$typography4 === void 0 ? void 0 : _style$typography4.fontSize).size;
  const newProps = { ...props,
    wrapperProps: { ...wrapperProps,
      style: {
        fontSize: fontSizeValue,
        ...(wrapperProps === null || wrapperProps === void 0 ? void 0 : wrapperProps.style)
      }
    }
  };
  return Object(external_wp_element_["createElement"])(BlockListBlock, newProps);
}, 'withFontSizeInlineStyles');
Object(external_wp_hooks_["addFilter"])('blocks.registerBlockType', 'core/font/addAttribute', font_size_addAttributes);
Object(external_wp_hooks_["addFilter"])('blocks.getSaveContent.extraProps', 'core/font/addSaveProps', font_size_addSaveProps);
Object(external_wp_hooks_["addFilter"])('blocks.registerBlockType', 'core/font/addEditProps', font_size_addEditProps);
Object(external_wp_hooks_["addFilter"])('editor.BlockListBlock', 'core/font-size/with-font-size-inline-styles', withFontSizeInlineStyles);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/typography.js


/**
 * WordPress dependencies
 */

/**
 * External dependencies
 */




/**
 * Internal dependencies
 */









const TYPOGRAPHY_SUPPORT_KEY = 'typography';
const TYPOGRAPHY_SUPPORT_KEYS = [LINE_HEIGHT_SUPPORT_KEY, FONT_SIZE_SUPPORT_KEY, FONT_STYLE_SUPPORT_KEY, FONT_WEIGHT_SUPPORT_KEY, FONT_FAMILY_SUPPORT_KEY, TEXT_DECORATION_SUPPORT_KEY, TEXT_TRANSFORM_SUPPORT_KEY];
function TypographyPanel(props) {
  const isDisabled = useIsTypographyDisabled(props);
  const isSupported = hasTypographySupport(props.name);
  if (isDisabled || !isSupported) return null;
  return Object(external_wp_element_["createElement"])(inspector_controls, null, Object(external_wp_element_["createElement"])(external_wp_components_["PanelBody"], {
    title: Object(external_wp_i18n_["__"])('Typography')
  }, Object(external_wp_element_["createElement"])(external_wp_components_["__unstableComponentSystemProvider"], {
    __unstableNextInclude: ['WPComponentsFontSizePicker']
  }, Object(external_wp_element_["createElement"])(FontFamilyEdit, props), Object(external_wp_element_["createElement"])(FontSizeEdit, props), Object(external_wp_element_["createElement"])(FontAppearanceEdit, props), Object(external_wp_element_["createElement"])(LineHeightEdit, props), Object(external_wp_element_["createElement"])(TextDecorationAndTransformEdit, props))));
}

const hasTypographySupport = blockName => {
  return external_wp_element_["Platform"].OS === 'web' && TYPOGRAPHY_SUPPORT_KEYS.some(key => Object(external_wp_blocks_["hasBlockSupport"])(blockName, key));
};

function useIsTypographyDisabled(props = {}) {
  const configs = [useIsFontAppearanceDisabled(props), useIsFontSizeDisabled(props), useIsLineHeightDisabled(props), useIsFontFamilyDisabled(props), useIsTextDecorationDisabled(props), useIsTextTransformDisabled(props)];
  return configs.filter(Boolean).length === configs.length;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/margin.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




/**
 * Determines if there is margin support.
 *
 * @param  {string|Object} blockType Block name or Block Type object.
 * @return {boolean}                 Whether there is support.
 */

function hasMarginSupport(blockType) {
  const support = Object(external_wp_blocks_["getBlockSupport"])(blockType, SPACING_SUPPORT_KEY);
  return !!(true === support || support !== null && support !== void 0 && support.margin);
}
/**
 * Custom hook that checks if margin settings have been disabled.
 *
 * @param  {string} name The name of the block.
 * @return {boolean}     Whether margin setting is disabled.
 */

function useIsMarginDisabled({
  name: blockName
} = {}) {
  const isDisabled = !useSetting('spacing.customMargin');
  return !hasMarginSupport(blockName) || isDisabled;
}
/**
 * Inspector control panel containing the margin related configuration
 *
 * @param  {Object} props Block props.
 * @return {WPElement}    Margin edit element.
 */

function MarginEdit(props) {
  var _style$spacing;

  const {
    name: blockName,
    attributes: {
      style
    },
    setAttributes
  } = props;
  const units = Object(external_wp_components_["__experimentalUseCustomUnits"])({
    availableUnits: useSetting('spacing.units') || ['%', 'px', 'em', 'rem', 'vw']
  });
  const sides = useCustomSides(blockName, 'margin');

  if (useIsMarginDisabled(props)) {
    return null;
  }

  const onChange = next => {
    const newStyle = { ...style,
      spacing: { ...(style === null || style === void 0 ? void 0 : style.spacing),
        margin: next
      }
    };
    setAttributes({
      style: cleanEmptyObject(newStyle)
    });
  };

  const onChangeShowVisualizer = next => {
    const newStyle = { ...style,
      visualizers: {
        margin: next
      }
    };
    setAttributes({
      style: cleanEmptyObject(newStyle)
    });
  };

  return external_wp_element_["Platform"].select({
    web: Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalBoxControl"], {
      values: style === null || style === void 0 ? void 0 : (_style$spacing = style.spacing) === null || _style$spacing === void 0 ? void 0 : _style$spacing.margin,
      onChange: onChange,
      onChangeShowVisualizer: onChangeShowVisualizer,
      label: Object(external_wp_i18n_["__"])('Margin'),
      sides: sides,
      units: units
    })),
    native: null
  });
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/padding.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




/**
 * Determines if there is padding support.
 *
 * @param  {string|Object} blockType Block name or Block Type object.
 * @return {boolean}                 Whether there is support.
 */

function hasPaddingSupport(blockType) {
  const support = Object(external_wp_blocks_["getBlockSupport"])(blockType, SPACING_SUPPORT_KEY);
  return !!(true === support || support !== null && support !== void 0 && support.padding);
}
/**
 * Custom hook that checks if padding settings have been disabled.
 *
 * @param  {string} name The name of the block.
 * @return {boolean}                 Whether padding setting is disabled.
 */

function useIsPaddingDisabled({
  name: blockName
} = {}) {
  const isDisabled = !useSetting('spacing.customPadding');
  return !hasPaddingSupport(blockName) || isDisabled;
}
/**
 * Inspector control panel containing the padding related configuration
 *
 * @param {Object} props
 *
 * @return {WPElement} Padding edit element.
 */

function PaddingEdit(props) {
  var _style$spacing;

  const {
    name: blockName,
    attributes: {
      style
    },
    setAttributes
  } = props;
  const units = Object(external_wp_components_["__experimentalUseCustomUnits"])({
    availableUnits: useSetting('spacing.units') || ['%', 'px', 'em', 'rem', 'vw']
  });
  const sides = useCustomSides(blockName, 'padding');

  if (useIsPaddingDisabled(props)) {
    return null;
  }

  const onChange = next => {
    const newStyle = { ...style,
      spacing: { ...(style === null || style === void 0 ? void 0 : style.spacing),
        padding: next
      }
    };
    setAttributes({
      style: cleanEmptyObject(newStyle)
    });
  };

  const onChangeShowVisualizer = next => {
    const newStyle = { ...style,
      visualizers: {
        padding: next
      }
    };
    setAttributes({
      style: cleanEmptyObject(newStyle)
    });
  };

  return external_wp_element_["Platform"].select({
    web: Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalBoxControl"], {
      values: style === null || style === void 0 ? void 0 : (_style$spacing = style.spacing) === null || _style$spacing === void 0 ? void 0 : _style$spacing.padding,
      onChange: onChange,
      onChangeShowVisualizer: onChangeShowVisualizer,
      label: Object(external_wp_i18n_["__"])('Padding'),
      sides: sides,
      units: units
    })),
    native: null
  });
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/spacing.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




const SPACING_SUPPORT_KEY = 'spacing';
/**
 * Inspector controls for spacing support.
 *
 * @param  {Object} props Block props.
 * @return {WPElement}    Inspector controls for spacing support features.
 */

function SpacingPanel(props) {
  const isDisabled = useIsSpacingDisabled(props);
  const isSupported = hasSpacingSupport(props.name);

  if (isDisabled || !isSupported) {
    return null;
  }

  return Object(external_wp_element_["createElement"])(inspector_controls, {
    key: "spacing"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["PanelBody"], {
    title: Object(external_wp_i18n_["__"])('Spacing')
  }, Object(external_wp_element_["createElement"])(PaddingEdit, props), Object(external_wp_element_["createElement"])(MarginEdit, props)));
}
/**
 * Determine whether there is block support for padding or margins.
 *
 * @param {string} blockName Block name.
 * @return {boolean}         Whether there is support.
 */

function hasSpacingSupport(blockName) {
  if (external_wp_element_["Platform"].OS !== 'web') {
    return false;
  }

  return hasPaddingSupport(blockName) || hasMarginSupport(blockName);
}
/**
 * Determines whether spacing support has been disabled.
 *
 * @param  {Object} props Block properties.
 * @return {boolean}      If spacing support is completely disabled.
 */

const useIsSpacingDisabled = (props = {}) => {
  const paddingDisabled = useIsPaddingDisabled(props);
  const marginDisabled = useIsMarginDisabled(props);
  return paddingDisabled && marginDisabled;
};
/**
 * Custom hook to retrieve which padding/margin is supported
 * e.g. top, right, bottom or left.
 *
 * Sides are opted into by default. It is only if a specific side is set to
 * false that it is omitted.
 *
 * @param  {string} blockName Block name.
 * @param  {string} feature   The feature custom sides relate to e.g. padding or margins.
 * @return {Object}           Sides supporting custom margin.
 */


function useCustomSides(blockName, feature) {
  const support = Object(external_wp_blocks_["getBlockSupport"])(blockName, SPACING_SUPPORT_KEY); // Skip when setting is boolean as theme isn't setting arbitrary sides.

  if (typeof support[feature] === 'boolean') {
    return;
  }

  return support[feature];
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/style.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */






const styleSupportKeys = [...TYPOGRAPHY_SUPPORT_KEYS, BORDER_SUPPORT_KEY, COLOR_SUPPORT_KEY, SPACING_SUPPORT_KEY];

const hasStyleSupport = blockType => styleSupportKeys.some(key => Object(external_wp_blocks_["hasBlockSupport"])(blockType, key));

const VARIABLE_REFERENCE_PREFIX = 'var:';
const VARIABLE_PATH_SEPARATOR_TOKEN_ATTRIBUTE = '|';
const VARIABLE_PATH_SEPARATOR_TOKEN_STYLE = '--';

function compileStyleValue(uncompiledValue) {
  if (Object(external_lodash_["startsWith"])(uncompiledValue, VARIABLE_REFERENCE_PREFIX)) {
    const variable = uncompiledValue.slice(VARIABLE_REFERENCE_PREFIX.length).split(VARIABLE_PATH_SEPARATOR_TOKEN_ATTRIBUTE).join(VARIABLE_PATH_SEPARATOR_TOKEN_STYLE);
    return `var(--wp--${variable})`;
  }

  return uncompiledValue;
}
/**
 * Returns the inline styles to add depending on the style object
 *
 * @param  {Object} styles Styles configuration
 * @return {Object}        Flattened CSS variables declaration
 */


function getInlineStyles(styles = {}) {
  const output = {};
  Object.keys(external_wp_blocks_["__EXPERIMENTAL_STYLE_PROPERTY"]).forEach(propKey => {
    const path = external_wp_blocks_["__EXPERIMENTAL_STYLE_PROPERTY"][propKey].value;
    const subPaths = external_wp_blocks_["__EXPERIMENTAL_STYLE_PROPERTY"][propKey].properties; // Ignore styles on elements because they are handled on the server.

    if (Object(external_lodash_["has"])(styles, path) && 'elements' !== Object(external_lodash_["first"])(path)) {
      if (!!subPaths) {
        subPaths.forEach(suffix => {
          output[propKey + Object(external_lodash_["capitalize"])(suffix)] = compileStyleValue(Object(external_lodash_["get"])(styles, [...path, suffix]));
        });
      } else {
        output[propKey] = compileStyleValue(Object(external_lodash_["get"])(styles, path));
      }
    }
  });
  return output;
}

function compileElementsStyles(selector, elements = {}) {
  return Object(external_lodash_["map"])(elements, (styles, element) => {
    const elementStyles = getInlineStyles(styles);

    if (!Object(external_lodash_["isEmpty"])(elementStyles)) {
      return [`.${selector} ${external_wp_blocks_["__EXPERIMENTAL_ELEMENTS"][element]}{`, ...Object(external_lodash_["map"])(elementStyles, (value, property) => `\t${Object(external_lodash_["kebabCase"])(property)}: ${value}${element === 'link' ? '!important' : ''};`), '}'].join('\n');
    }

    return '';
  }).join('\n');
}
/**
 * Filters registered block settings, extending attributes to include `style` attribute.
 *
 * @param  {Object} settings Original block settings
 * @return {Object}          Filtered block settings
 */


function style_addAttribute(settings) {
  if (!hasStyleSupport(settings)) {
    return settings;
  } // allow blocks to specify their own attribute definition with default values if needed.


  if (!settings.attributes.style) {
    Object.assign(settings.attributes, {
      style: {
        type: 'object'
      }
    });
  }

  return settings;
}

const skipSerializationPaths = {
  [`${BORDER_SUPPORT_KEY}.__experimentalSkipSerialization`]: ['border'],
  [`${COLOR_SUPPORT_KEY}.__experimentalSkipSerialization`]: [COLOR_SUPPORT_KEY],
  [`${TYPOGRAPHY_SUPPORT_KEY}.__experimentalSkipSerialization`]: [TYPOGRAPHY_SUPPORT_KEY]
};
/**
 * Override props assigned to save component to inject the CSS variables definition.
 *
 * @param  {Object} props      Additional props applied to save element
 * @param  {Object} blockType  Block type
 * @param  {Object} attributes Block attributes
 * @return {Object}            Filtered props applied to save element
 */

function style_addSaveProps(props, blockType, attributes) {
  if (!hasStyleSupport(blockType)) {
    return props;
  }

  let {
    style
  } = attributes;
  Object(external_lodash_["forEach"])(skipSerializationPaths, (path, indicator) => {
    if (Object(external_wp_blocks_["getBlockSupport"])(blockType, indicator)) {
      style = Object(external_lodash_["omit"])(style, path);
    }
  });
  props.style = { ...getInlineStyles(style),
    ...props.style
  };
  return props;
}
/**
 * Filters registered block settings to extend the block edit wrapper
 * to apply the desired styles and classnames properly.
 *
 * @param  {Object} settings Original block settings
 * @return {Object}          Filtered block settings
 */

function style_addEditProps(settings) {
  if (!hasStyleSupport(settings)) {
    return settings;
  }

  const existingGetEditWrapperProps = settings.getEditWrapperProps;

  settings.getEditWrapperProps = attributes => {
    let props = {};

    if (existingGetEditWrapperProps) {
      props = existingGetEditWrapperProps(attributes);
    }

    return style_addSaveProps(props, settings, attributes);
  };

  return settings;
}
/**
 * Override the default edit UI to include new inspector controls for
 * all the custom styles configs.
 *
 * @param  {Function} BlockEdit Original component
 * @return {Function}           Wrapped component
 */

const withBlockControls = Object(external_wp_compose_["createHigherOrderComponent"])(BlockEdit => props => {
  const shouldDisplayControls = useDisplayBlockControls();
  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, shouldDisplayControls && Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(TypographyPanel, props), Object(external_wp_element_["createElement"])(BorderPanel, props), Object(external_wp_element_["createElement"])(ColorEdit, props), Object(external_wp_element_["createElement"])(SpacingPanel, props)), Object(external_wp_element_["createElement"])(BlockEdit, props));
}, 'withToolbarControls');
/**
 * Override the default block element to include duotone styles.
 *
 * @param  {Function} BlockListBlock Original component
 * @return {Function}                Wrapped component
 */

const withElementsStyles = Object(external_wp_compose_["createHigherOrderComponent"])(BlockListBlock => props => {
  var _props$attributes$sty, _props$attributes$sty2;

  const elements = (_props$attributes$sty = props.attributes.style) === null || _props$attributes$sty === void 0 ? void 0 : _props$attributes$sty.elements;
  const blockElementsContainerIdentifier = `wp-elements-${Object(external_wp_compose_["useInstanceId"])(BlockListBlock)}`;
  const styles = compileElementsStyles(blockElementsContainerIdentifier, (_props$attributes$sty2 = props.attributes.style) === null || _props$attributes$sty2 === void 0 ? void 0 : _props$attributes$sty2.elements);
  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, elements && Object(external_wp_element_["createElement"])("style", {
    dangerouslySetInnerHTML: {
      __html: styles
    }
  }), Object(external_wp_element_["createElement"])(BlockListBlock, Object(esm_extends["a" /* default */])({}, props, {
    className: elements ? classnames_default()(props.className, blockElementsContainerIdentifier) : props.className
  })));
});
Object(external_wp_hooks_["addFilter"])('blocks.registerBlockType', 'core/style/addAttribute', style_addAttribute);
Object(external_wp_hooks_["addFilter"])('blocks.getSaveContent.extraProps', 'core/style/addSaveProps', style_addSaveProps);
Object(external_wp_hooks_["addFilter"])('blocks.registerBlockType', 'core/style/addEditProps', style_addEditProps);
Object(external_wp_hooks_["addFilter"])('editor.BlockEdit', 'core/style/with-block-controls', withBlockControls);
Object(external_wp_hooks_["addFilter"])('editor.BlockListBlock', 'core/editor/with-elements-styles', withElementsStyles);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/duotone-control/duotone-picker-popover.js


/**
 * WordPress dependencies
 */



function DuotonePickerPopover({
  value,
  onChange,
  onToggle,
  duotonePalette,
  colorPalette,
  disableCustomColors,
  disableCustomDuotone
}) {
  return Object(external_wp_element_["createElement"])(external_wp_components_["Popover"], {
    className: "block-editor-duotone-control__popover",
    headerTitle: Object(external_wp_i18n_["__"])('Duotone'),
    onFocusOutside: onToggle
  }, Object(external_wp_element_["createElement"])(external_wp_components_["MenuGroup"], {
    label: Object(external_wp_i18n_["__"])('Duotone')
  }, Object(external_wp_element_["createElement"])(external_wp_components_["DuotonePicker"], {
    colorPalette: colorPalette,
    duotonePalette: duotonePalette,
    disableCustomColors: disableCustomColors,
    disableCustomDuotone: disableCustomDuotone,
    value: value,
    onChange: onChange
  })));
}

/* harmony default export */ var duotone_picker_popover = (DuotonePickerPopover);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/duotone-control/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



function DuotoneControl({
  colorPalette,
  duotonePalette,
  disableCustomColors,
  disableCustomDuotone,
  value,
  onChange
}) {
  const [isOpen, setIsOpen] = Object(external_wp_element_["useState"])(false);

  const onToggle = () => {
    setIsOpen(prev => !prev);
  };

  const openOnArrowDown = event => {
    if (!isOpen && event.keyCode === external_wp_keycodes_["DOWN"]) {
      event.preventDefault();
      event.stopPropagation();
      onToggle();
    }
  };

  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarButton"], {
    showTooltip: true,
    onClick: onToggle,
    "aria-haspopup": "true",
    "aria-expanded": isOpen,
    onKeyDown: openOnArrowDown,
    label: Object(external_wp_i18n_["__"])('Apply duotone filter'),
    icon: Object(external_wp_element_["createElement"])(external_wp_components_["DuotoneSwatch"], {
      values: value
    })
  }), isOpen && Object(external_wp_element_["createElement"])(duotone_picker_popover, {
    value: value,
    onChange: onChange,
    onToggle: onToggle,
    duotonePalette: duotonePalette,
    colorPalette: colorPalette,
    disableCustomColors: disableCustomColors,
    disableCustomDuotone: disableCustomDuotone
  }));
}

/* harmony default export */ var duotone_control = (DuotoneControl);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/head.js


/**
 * WordPress dependencies
 */

const head_context = Object(external_wp_element_["createContext"])();
function Head({
  children
}) {
  const [element, setElement] = Object(external_wp_element_["useState"])();
  return Object(external_wp_element_["createElement"])(head_context.Provider, {
    value: element
  }, Object(external_wp_element_["createElement"])("div", {
    ref: setElement
  }), children);
}
Head.context = head_context;

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/duotone.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */



const duotone_EMPTY_ARRAY = [];
/**
 * Convert a list of colors to an object of R, G, and B values.
 *
 * @param {string[]} colors Array of RBG color strings.
 *
 * @return {Object} R, G, and B values.
 */

function getValuesFromColors(colors = []) {
  const values = {
    r: [],
    g: [],
    b: []
  };
  colors.forEach(color => {
    // Access values directly to skip extra rounding that tinycolor.toRgb() does.
    const tcolor = tinycolor_default()(color);
    values.r.push(tcolor._r / 255);
    values.g.push(tcolor._g / 255);
    values.b.push(tcolor._b / 255);
  });
  return values;
}
/**
 * Values for the SVG `feComponentTransfer`.
 *
 * @typedef Values {Object}
 * @property {number[]} r Red values.
 * @property {number[]} g Green values.
 * @property {number[]} b Blue values.
 */

/**
 * SVG and stylesheet needed for rendering the duotone filter.
 *
 * @param  {Object} props          Duotone props.
 * @param  {string} props.selector Selector to apply the filter to.
 * @param  {string} props.id       Unique id for this duotone filter.
 * @param  {Values} props.values   R, G, and B values to filter with.
 * @return {WPElement}             Duotone element.
 */

function DuotoneFilter({
  selector,
  id,
  values
}) {
  const stylesheet = `
${selector} {
	filter: url( #${id} );
}
`;
  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(external_wp_components_["SVG"], {
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    viewBox: "0 0 0 0",
    width: "0",
    height: "0",
    focusable: "false",
    role: "none",
    style: {
      visibility: 'hidden',
      position: 'absolute',
      left: '-9999px',
      overflow: 'hidden'
    }
  }, Object(external_wp_element_["createElement"])("defs", null, Object(external_wp_element_["createElement"])("filter", {
    id: id
  }, Object(external_wp_element_["createElement"])("feColorMatrix", {
    type: "matrix" // Use perceptual brightness to convert to grayscale.
    // prettier-ignore
    ,
    values: ".299 .587 .114 0 0 .299 .587 .114 0 0 .299 .587 .114 0 0 0 0 0 1 0"
  }), Object(external_wp_element_["createElement"])("feComponentTransfer", {
    // Use sRGB instead of linearRGB to be consistent with how CSS gradients work.
    colorInterpolationFilters: "sRGB"
  }, Object(external_wp_element_["createElement"])("feFuncR", {
    type: "table",
    tableValues: values.r.join(' ')
  }), Object(external_wp_element_["createElement"])("feFuncG", {
    type: "table",
    tableValues: values.g.join(' ')
  }), Object(external_wp_element_["createElement"])("feFuncB", {
    type: "table",
    tableValues: values.b.join(' ')
  }))))), Object(external_wp_element_["createElement"])("style", {
    dangerouslySetInnerHTML: {
      __html: stylesheet
    }
  }));
}

function DuotonePanel({
  attributes,
  setAttributes
}) {
  var _style$color;

  const style = attributes === null || attributes === void 0 ? void 0 : attributes.style;
  const duotone = style === null || style === void 0 ? void 0 : (_style$color = style.color) === null || _style$color === void 0 ? void 0 : _style$color.duotone;
  const duotonePalette = useSetting('color.duotone') || duotone_EMPTY_ARRAY;
  const colorPalette = useSetting('color.palette') || duotone_EMPTY_ARRAY;
  const disableCustomColors = !useSetting('color.custom');
  const disableCustomDuotone = !useSetting('color.customDuotone') || (colorPalette === null || colorPalette === void 0 ? void 0 : colorPalette.length) === 0 && disableCustomColors;

  if ((duotonePalette === null || duotonePalette === void 0 ? void 0 : duotonePalette.length) === 0 && disableCustomDuotone) {
    return null;
  }

  return Object(external_wp_element_["createElement"])(block_controls, {
    group: "block"
  }, Object(external_wp_element_["createElement"])(duotone_control, {
    duotonePalette: duotonePalette,
    colorPalette: colorPalette,
    disableCustomDuotone: disableCustomDuotone,
    disableCustomColors: disableCustomColors,
    value: duotone,
    onChange: newDuotone => {
      const newStyle = { ...style,
        color: { ...(style === null || style === void 0 ? void 0 : style.color),
          duotone: newDuotone
        }
      };
      setAttributes({
        style: newStyle
      });
    }
  }));
}
/**
 * Filters registered block settings, extending attributes to include
 * the `duotone` attribute.
 *
 * @param  {Object} settings Original block settings
 * @return {Object}          Filtered block settings
 */


function addDuotoneAttributes(settings) {
  if (!Object(external_wp_blocks_["hasBlockSupport"])(settings, 'color.__experimentalDuotone')) {
    return settings;
  } // Allow blocks to specify their own attribute definition with default
  // values if needed.


  if (!settings.attributes.style) {
    Object.assign(settings.attributes, {
      style: {
        type: 'object'
      }
    });
  }

  return settings;
}
/**
 * Override the default edit UI to include toolbar controls for duotone if the
 * block supports duotone.
 *
 * @param  {Function} BlockEdit Original component
 * @return {Function}           Wrapped component
 */


const withDuotoneControls = Object(external_wp_compose_["createHigherOrderComponent"])(BlockEdit => props => {
  const hasDuotoneSupport = Object(external_wp_blocks_["hasBlockSupport"])(props.name, 'color.__experimentalDuotone');
  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(BlockEdit, props), hasDuotoneSupport && Object(external_wp_element_["createElement"])(DuotonePanel, props));
}, 'withDuotoneControls');
/**
 * Override the default block element to include duotone styles.
 *
 * @param  {Function} BlockListBlock Original component
 * @return {Function}                Wrapped component
 */

const withDuotoneStyles = Object(external_wp_compose_["createHigherOrderComponent"])(BlockListBlock => props => {
  var _props$attributes, _props$attributes$sty, _props$attributes$sty2;

  const duotoneSupport = Object(external_wp_blocks_["getBlockSupport"])(props.name, 'color.__experimentalDuotone');
  const values = props === null || props === void 0 ? void 0 : (_props$attributes = props.attributes) === null || _props$attributes === void 0 ? void 0 : (_props$attributes$sty = _props$attributes.style) === null || _props$attributes$sty === void 0 ? void 0 : (_props$attributes$sty2 = _props$attributes$sty.color) === null || _props$attributes$sty2 === void 0 ? void 0 : _props$attributes$sty2.duotone;

  if (!duotoneSupport || !values) {
    return Object(external_wp_element_["createElement"])(BlockListBlock, props);
  }

  const id = `wp-duotone-filter-${Object(external_wp_compose_["useInstanceId"])(BlockListBlock)}`;
  const selectors = duotoneSupport.split(',');
  const selectorsScoped = selectors.map(selector => `.${id} ${selector.trim()}`);
  const selectorsGroup = selectorsScoped.join(', ');
  const className = classnames_default()(props === null || props === void 0 ? void 0 : props.className, id);
  const element = Object(external_wp_element_["useContext"])(Head.context);
  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, element && Object(external_wp_element_["createPortal"])(Object(external_wp_element_["createElement"])(DuotoneFilter, {
    selector: selectorsGroup,
    id: id,
    values: getValuesFromColors(values)
  }), element), Object(external_wp_element_["createElement"])(BlockListBlock, Object(esm_extends["a" /* default */])({}, props, {
    className: className
  })));
}, 'withDuotoneStyles');
Object(external_wp_hooks_["addFilter"])('blocks.registerBlockType', 'core/editor/duotone/add-attributes', addDuotoneAttributes);
Object(external_wp_hooks_["addFilter"])('editor.BlockEdit', 'core/editor/duotone/with-editor-controls', withDuotoneControls);
Object(external_wp_hooks_["addFilter"])('editor.BlockListBlock', 'core/editor/duotone/with-styles', withDuotoneStyles);

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/icon/index.js
var build_module_icon = __webpack_require__("iClF");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/layout.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */









/**
 * Internal dependencies
 */







function LayoutPanel({
  setAttributes,
  attributes
}) {
  const {
    layout = {}
  } = attributes;
  const {
    wideSize,
    contentSize,
    inherit = false
  } = layout;
  const defaultLayout = useSetting('layout');
  const themeSupportsLayout = Object(external_wp_data_["useSelect"])(select => {
    const {
      getSettings
    } = select(store);
    return getSettings().supportsLayout;
  }, []);
  const units = Object(external_wp_components_["__experimentalUseCustomUnits"])({
    availableUnits: useSetting('spacing.units') || ['%', 'px', 'em', 'rem', 'vw']
  });

  if (!themeSupportsLayout) {
    return null;
  }

  return Object(external_wp_element_["createElement"])(inspector_controls, null, Object(external_wp_element_["createElement"])(external_wp_components_["PanelBody"], {
    title: Object(external_wp_i18n_["__"])('Layout')
  }, !!defaultLayout && Object(external_wp_element_["createElement"])(external_wp_components_["ToggleControl"], {
    label: Object(external_wp_i18n_["__"])('Inherit default layout'),
    checked: !!inherit,
    onChange: () => setAttributes({
      layout: {
        inherit: !inherit
      }
    })
  }), !inherit && Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-hooks__layout-controls"
  }, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-hooks__layout-controls-unit"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalUnitControl"], {
    label: Object(external_wp_i18n_["__"])('Content'),
    labelPosition: "top",
    __unstableInputWidth: "80px",
    value: contentSize || wideSize || '',
    onChange: nextWidth => {
      nextWidth = 0 > parseFloat(nextWidth) ? '0' : nextWidth;
      setAttributes({
        layout: { ...layout,
          contentSize: nextWidth
        }
      });
    },
    units: units
  }), Object(external_wp_element_["createElement"])(build_module_icon["a" /* default */], {
    icon: position_center
  })), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-hooks__layout-controls-unit"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalUnitControl"], {
    label: Object(external_wp_i18n_["__"])('Wide'),
    labelPosition: "top",
    __unstableInputWidth: "80px",
    value: wideSize || contentSize || '',
    onChange: nextWidth => {
      nextWidth = 0 > parseFloat(nextWidth) ? '0' : nextWidth;
      setAttributes({
        layout: { ...layout,
          wideSize: nextWidth
        }
      });
    },
    units: units
  }), Object(external_wp_element_["createElement"])(build_module_icon["a" /* default */], {
    icon: stretch_wide
  }))), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-hooks__layout-controls-reset"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    isSecondary: true,
    isSmall: true,
    disabled: !contentSize && !wideSize,
    onClick: () => setAttributes({
      layout: {
        contentSize: undefined,
        wideSize: undefined,
        inherit: false
      }
    })
  }, Object(external_wp_i18n_["__"])('Reset')))), Object(external_wp_element_["createElement"])("p", {
    className: "block-editor-hooks__layout-controls-helptext"
  }, Object(external_wp_i18n_["__"])('Customize the width for all elements that are assigned to the center or wide columns.'))));
}
/**
 * Filters registered block settings, extending attributes to include `layout`.
 *
 * @param  {Object} settings Original block settings
 * @return {Object}          Filtered block settings
 */


function layout_addAttribute(settings) {
  if (Object(external_lodash_["has"])(settings.attributes, ['layout', 'type'])) {
    return settings;
  }

  if (Object(external_wp_blocks_["hasBlockSupport"])(settings, '__experimentalLayout')) {
    settings.attributes = { ...settings.attributes,
      layout: {
        type: 'object'
      }
    };
  }

  return settings;
}
/**
 * Override the default edit UI to include layout controls
 *
 * @param  {Function} BlockEdit Original component
 * @return {Function}           Wrapped component
 */

const withInspectorControls = Object(external_wp_compose_["createHigherOrderComponent"])(BlockEdit => props => {
  const {
    name: blockName
  } = props;
  const supportLayout = Object(external_wp_blocks_["hasBlockSupport"])(blockName, '__experimentalLayout');
  return [supportLayout && Object(external_wp_element_["createElement"])(LayoutPanel, Object(esm_extends["a" /* default */])({
    key: "layout"
  }, props)), Object(external_wp_element_["createElement"])(BlockEdit, Object(esm_extends["a" /* default */])({
    key: "edit"
  }, props))];
}, 'withInspectorControls');
/**
 * Override the default block element to add the layout styles.
 *
 * @param  {Function} BlockListBlock Original component
 * @return {Function}                Wrapped component
 */

const withLayoutStyles = Object(external_wp_compose_["createHigherOrderComponent"])(BlockListBlock => props => {
  const {
    name,
    attributes
  } = props;
  const supportLayout = Object(external_wp_blocks_["hasBlockSupport"])(name, '__experimentalLayout');
  const id = Object(external_wp_compose_["useInstanceId"])(BlockListBlock);
  const defaultLayout = useSetting('layout') || {};

  if (!supportLayout) {
    return Object(external_wp_element_["createElement"])(BlockListBlock, props);
  }

  const {
    layout = {}
  } = attributes;
  const usedLayout = !!layout && layout.inherit ? defaultLayout : layout;
  const className = classnames_default()(props === null || props === void 0 ? void 0 : props.className, `wp-container-${id}`);
  const element = Object(external_wp_element_["useContext"])(Head.context);
  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, element && Object(external_wp_element_["createPortal"])(Object(external_wp_element_["createElement"])(LayoutStyle, {
    selector: `.wp-container-${id}`,
    layout: usedLayout
  }), element), Object(external_wp_element_["createElement"])(BlockListBlock, Object(esm_extends["a" /* default */])({}, props, {
    className: className
  })));
});
Object(external_wp_hooks_["addFilter"])('blocks.registerBlockType', 'core/layout/addAttribute', layout_addAttribute);
Object(external_wp_hooks_["addFilter"])('editor.BlockListBlock', 'core/editor/layout/with-layout-styles', withLayoutStyles);
Object(external_wp_hooks_["addFilter"])('editor.BlockEdit', 'core/editor/layout/with-inspector-controls', withInspectorControls);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/use-border-props.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */



 // This utility is intended to assist where the serialization of the border
// block support is being skipped for a block but the border related CSS classes
// & styles still need to be generated so they can be applied to inner elements.

const use_border_props_EMPTY_ARRAY = [];
/**
 * Provides the CSS class names and inline styles for a block's border support
 * attributes.
 *
 * @param  {Object} attributes             Block attributes.
 * @param  {string} attributes.borderColor Selected named border color.
 * @param  {Object} attributes.style       Block's styles attribute.
 *
 * @return {Object} Border block support derived CSS classes & styles.
 */

function getBorderClassesAndStyles({
  borderColor,
  style
}) {
  var _style$border;

  const borderStyles = (style === null || style === void 0 ? void 0 : style.border) || {};
  const borderClass = getColorClassName('border-color', borderColor);
  const className = classnames_default()({
    [borderClass]: !!borderClass,
    'has-border-color': borderColor || (style === null || style === void 0 ? void 0 : (_style$border = style.border) === null || _style$border === void 0 ? void 0 : _style$border.color)
  });
  return {
    className: className || undefined,
    style: getInlineStyles({
      border: borderStyles
    })
  };
}
/**
 * Derives the border related props for a block from its border block support
 * attributes.
 *
 * Inline styles are forced for named colors to ensure these selections are
 * reflected when themes do not load their color stylesheets in the editor.
 *
 * @param  {Object} attributes Block attributes.
 * @return {Object}            ClassName & style props from border block support.
 */

function useBorderProps(attributes) {
  const colors = useSetting('color.palette') || use_border_props_EMPTY_ARRAY;
  const borderProps = getBorderClassesAndStyles(attributes); // Force inline style to apply border color when themes do not load their
  // color stylesheets in the editor.

  if (attributes.borderColor) {
    const borderColorObject = getColorObjectByAttributeValues(colors, attributes.borderColor);
    borderProps.style.borderColor = borderColorObject.color;
  }

  return borderProps;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/use-color-props.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




 // The code in this file has largely been lifted from the color block support
// hook.
//
// This utility is intended to assist where the serialization of the colors
// block support is being skipped for a block but the color related CSS classes
// & styles still need to be generated so they can be applied to inner elements.

const use_color_props_EMPTY_ARRAY = [];
/**
 * Provides the CSS class names and inline styles for a block's color support
 * attributes.
 *
 * @param  {Object} attributes Block attributes.
 * @return {Object}            Color block support derived CSS classes & styles.
 */

function getColorClassesAndStyles(attributes) {
  var _style$color, _style$color2, _style$color3, _style$color4, _style$elements, _style$elements$link;

  const {
    backgroundColor,
    textColor,
    gradient,
    style
  } = attributes; // Collect color CSS classes.

  const backgroundClass = getColorClassName('background-color', backgroundColor);
  const textClass = getColorClassName('color', textColor);

  const gradientClass = __experimentalGetGradientClass(gradient);

  const hasGradient = gradientClass || (style === null || style === void 0 ? void 0 : (_style$color = style.color) === null || _style$color === void 0 ? void 0 : _style$color.gradient); // Determine color CSS class name list.

  const className = classnames_default()(textClass, gradientClass, {
    // Don't apply the background class if there's a gradient.
    [backgroundClass]: !hasGradient && !!backgroundClass,
    'has-text-color': textColor || (style === null || style === void 0 ? void 0 : (_style$color2 = style.color) === null || _style$color2 === void 0 ? void 0 : _style$color2.text),
    'has-background': backgroundColor || (style === null || style === void 0 ? void 0 : (_style$color3 = style.color) === null || _style$color3 === void 0 ? void 0 : _style$color3.background) || gradient || (style === null || style === void 0 ? void 0 : (_style$color4 = style.color) === null || _style$color4 === void 0 ? void 0 : _style$color4.gradient),
    'has-link-color': style === null || style === void 0 ? void 0 : (_style$elements = style.elements) === null || _style$elements === void 0 ? void 0 : (_style$elements$link = _style$elements.link) === null || _style$elements$link === void 0 ? void 0 : _style$elements$link.color
  }); // Collect inline styles for colors.

  const colorStyles = (style === null || style === void 0 ? void 0 : style.color) || {};
  const styleProp = getInlineStyles({
    color: colorStyles
  });
  return {
    className: className || undefined,
    style: styleProp
  };
}
/**
 * Determines the color related props for a block derived from its color block
 * support attributes.
 *
 * Inline styles are forced for named colors to ensure these selections are
 * reflected when themes do not load their color stylesheets in the editor.
 *
 * @param  {Object} attributes Block attributes.
 * @return {Object}            ClassName & style props from colors block support.
 */

function useColorProps(attributes) {
  const {
    backgroundColor,
    textColor,
    gradient
  } = attributes;
  const colors = useSetting('color.palette') || use_color_props_EMPTY_ARRAY;
  const gradients = useSetting('color.gradients') || use_color_props_EMPTY_ARRAY;
  const colorProps = getColorClassesAndStyles(attributes); // Force inline styles to apply colors when themes do not load their color
  // stylesheets in the editor.

  if (backgroundColor) {
    const backgroundColorObject = getColorObjectByAttributeValues(colors, backgroundColor);
    colorProps.style.backgroundColor = backgroundColorObject.color;
  }

  if (gradient) {
    colorProps.style.background = getGradientValueBySlug(gradients, gradient);
  }

  if (textColor) {
    const textColorObject = getColorObjectByAttributeValues(colors, textColor);
    colorProps.style.color = textColorObject.color;
  }

  return colorProps;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/hooks/index.js
/**
 * Internal dependencies
 */














// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/colors/with-colors.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



const DEFAULT_COLORS = [];
/**
 * Higher order component factory for injecting the `colorsArray` argument as
 * the colors prop in the `withCustomColors` HOC.
 *
 * @param {Array} colorsArray An array of color objects.
 *
 * @return {Function} The higher order component.
 */

const withCustomColorPalette = colorsArray => Object(external_wp_compose_["createHigherOrderComponent"])(WrappedComponent => props => Object(external_wp_element_["createElement"])(WrappedComponent, Object(esm_extends["a" /* default */])({}, props, {
  colors: colorsArray
})), 'withCustomColorPalette');
/**
 * Higher order component factory for injecting the editor colors as the
 * `colors` prop in the `withColors` HOC.
 *
 * @return {Function} The higher order component.
 */


const withEditorColorPalette = () => Object(external_wp_compose_["createHigherOrderComponent"])(WrappedComponent => props => {
  const colors = useSetting('color.palette') || DEFAULT_COLORS;
  return Object(external_wp_element_["createElement"])(WrappedComponent, Object(esm_extends["a" /* default */])({}, props, {
    colors: colors
  }));
}, 'withEditorColorPalette');
/**
 * Helper function used with `createHigherOrderComponent` to create
 * higher order components for managing color logic.
 *
 * @param {Array}    colorTypes       An array of color types (e.g. 'backgroundColor, borderColor).
 * @param {Function} withColorPalette A HOC for injecting the 'colors' prop into the WrappedComponent.
 *
 * @return {WPComponent} The component that can be used as a HOC.
 */


function createColorHOC(colorTypes, withColorPalette) {
  const colorMap = Object(external_lodash_["reduce"])(colorTypes, (colorObject, colorType) => {
    return { ...colorObject,
      ...(Object(external_lodash_["isString"])(colorType) ? {
        [colorType]: Object(external_lodash_["kebabCase"])(colorType)
      } : colorType)
    };
  }, {});
  return Object(external_wp_compose_["compose"])([withColorPalette, WrappedComponent => {
    return class extends external_wp_element_["Component"] {
      constructor(props) {
        super(props);
        this.setters = this.createSetters();
        this.colorUtils = {
          getMostReadableColor: this.getMostReadableColor.bind(this)
        };
        this.state = {};
      }

      getMostReadableColor(colorValue) {
        const {
          colors
        } = this.props;
        return getMostReadableColor(colors, colorValue);
      }

      createSetters() {
        return Object(external_lodash_["reduce"])(colorMap, (settersAccumulator, colorContext, colorAttributeName) => {
          const upperFirstColorAttributeName = Object(external_lodash_["upperFirst"])(colorAttributeName);
          const customColorAttributeName = `custom${upperFirstColorAttributeName}`;
          settersAccumulator[`set${upperFirstColorAttributeName}`] = this.createSetColor(colorAttributeName, customColorAttributeName);
          return settersAccumulator;
        }, {});
      }

      createSetColor(colorAttributeName, customColorAttributeName) {
        return colorValue => {
          const colorObject = getColorObjectByColorValue(this.props.colors, colorValue);
          this.props.setAttributes({
            [colorAttributeName]: colorObject && colorObject.slug ? colorObject.slug : undefined,
            [customColorAttributeName]: colorObject && colorObject.slug ? undefined : colorValue
          });
        };
      }

      static getDerivedStateFromProps({
        attributes,
        colors
      }, previousState) {
        return Object(external_lodash_["reduce"])(colorMap, (newState, colorContext, colorAttributeName) => {
          const colorObject = getColorObjectByAttributeValues(colors, attributes[colorAttributeName], attributes[`custom${Object(external_lodash_["upperFirst"])(colorAttributeName)}`]);
          const previousColorObject = previousState[colorAttributeName];
          const previousColor = previousColorObject === null || previousColorObject === void 0 ? void 0 : previousColorObject.color;
          /**
           * The "and previousColorObject" condition checks that a previous color object was already computed.
           * At the start previousColorObject and colorValue are both equal to undefined
           * bus as previousColorObject does not exist we should compute the object.
           */

          if (previousColor === colorObject.color && previousColorObject) {
            newState[colorAttributeName] = previousColorObject;
          } else {
            newState[colorAttributeName] = { ...colorObject,
              class: getColorClassName(colorContext, colorObject.slug)
            };
          }

          return newState;
        }, {});
      }

      render() {
        return Object(external_wp_element_["createElement"])(WrappedComponent, Object(esm_extends["a" /* default */])({}, this.props, {
          colors: undefined
        }, this.state, this.setters, {
          colorUtils: this.colorUtils
        }));
      }

    };
  }]);
}
/**
 * A higher-order component factory for creating a 'withCustomColors' HOC, which handles color logic
 * for class generation color value, retrieval and color attribute setting.
 *
 * Use this higher-order component to work with a custom set of colors.
 *
 * @example
 *
 * ```jsx
 * const CUSTOM_COLORS = [ { name: 'Red', slug: 'red', color: '#ff0000' }, { name: 'Blue', slug: 'blue', color: '#0000ff' } ];
 * const withCustomColors = createCustomColorsHOC( CUSTOM_COLORS );
 * // ...
 * export default compose(
 *     withCustomColors( 'backgroundColor', 'borderColor' ),
 *     MyColorfulComponent,
 * );
 * ```
 *
 * @param {Array} colorsArray The array of color objects (name, slug, color, etc... ).
 *
 * @return {Function} Higher-order component.
 */


function createCustomColorsHOC(colorsArray) {
  return (...colorTypes) => {
    const withColorPalette = withCustomColorPalette(colorsArray);
    return Object(external_wp_compose_["createHigherOrderComponent"])(createColorHOC(colorTypes, withColorPalette), 'withCustomColors');
  };
}
/**
 * A higher-order component, which handles color logic for class generation color value, retrieval and color attribute setting.
 *
 * For use with the default editor/theme color palette.
 *
 * @example
 *
 * ```jsx
 * export default compose(
 *     withColors( 'backgroundColor', { textColor: 'color' } ),
 *     MyColorfulComponent,
 * );
 * ```
 *
 * @param {...(Object|string)} colorTypes The arguments can be strings or objects. If the argument is an object,
 *                                        it should contain the color attribute name as key and the color context as value.
 *                                        If the argument is a string the value should be the color attribute name,
 *                                        the color context is computed by applying a kebab case transform to the value.
 *                                        Color context represents the context/place where the color is going to be used.
 *                                        The class name of the color is generated using 'has' followed by the color name
 *                                        and ending with the color context all in kebab case e.g: has-green-background-color.
 *
 * @return {Function} Higher-order component.
 */

function withColors(...colorTypes) {
  const withColorPalette = withEditorColorPalette();
  return Object(external_wp_compose_["createHigherOrderComponent"])(createColorHOC(colorTypes, withColorPalette), 'withColors');
}

// EXTERNAL MODULE: ./node_modules/memize/index.js
var memize = __webpack_require__("4eJC");
var memize_default = /*#__PURE__*/__webpack_require__.n(memize);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/panel-color-settings/index.js



/**
 * Internal dependencies
 */


const PanelColorSettings = ({
  colorSettings,
  ...props
}) => {
  const settings = colorSettings.map(({
    value,
    onChange,
    ...otherSettings
  }) => ({ ...otherSettings,
    colorValue: value,
    onColorChange: onChange
  }));
  return Object(external_wp_element_["createElement"])(panel_color_gradient_settings, Object(esm_extends["a" /* default */])({
    settings: settings,
    gradients: [],
    disableCustomGradients: true
  }, props));
};

/* harmony default export */ var panel_color_settings = (PanelColorSettings);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/colors/color-panel.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




const resolveContrastCheckerColor = (color, colorSettings, detectedColor) => {
  if (typeof color === 'function') {
    return color(colorSettings);
  } else if (color === true) {
    return detectedColor;
  }

  return color;
};

function color_panel_ColorPanel({
  title,
  colorSettings,
  colorPanelProps,
  contrastCheckers,
  detectedBackgroundColor,
  detectedColor,
  panelChildren,
  initialOpen
}) {
  return Object(external_wp_element_["createElement"])(panel_color_settings, Object(esm_extends["a" /* default */])({
    title: title,
    initialOpen: initialOpen,
    colorSettings: Object.values(colorSettings)
  }, colorPanelProps), contrastCheckers && (Array.isArray(contrastCheckers) ? contrastCheckers.map(({
    backgroundColor,
    textColor,
    ...rest
  }) => {
    backgroundColor = resolveContrastCheckerColor(backgroundColor, colorSettings, detectedBackgroundColor);
    textColor = resolveContrastCheckerColor(textColor, colorSettings, detectedColor);
    return Object(external_wp_element_["createElement"])(contrast_checker, Object(esm_extends["a" /* default */])({
      key: `${backgroundColor}-${textColor}`,
      backgroundColor: backgroundColor,
      textColor: textColor
    }, rest));
  }) : Object(external_lodash_["map"])(colorSettings, ({
    value
  }) => {
    let {
      backgroundColor,
      textColor
    } = contrastCheckers;
    backgroundColor = resolveContrastCheckerColor(backgroundColor || value, colorSettings, detectedBackgroundColor);
    textColor = resolveContrastCheckerColor(textColor || value, colorSettings, detectedColor);
    return Object(external_wp_element_["createElement"])(contrast_checker, Object(esm_extends["a" /* default */])({}, contrastCheckers, {
      key: `${backgroundColor}-${textColor}`,
      backgroundColor: backgroundColor,
      textColor: textColor
    }));
  })), typeof panelChildren === 'function' ? panelChildren(colorSettings) : panelChildren);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/colors/use-colors.js


/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */







function use_colors_getComputedStyle(node) {
  return node.ownerDocument.defaultView.getComputedStyle(node);
}

const use_colors_DEFAULT_COLORS = [];
const COMMON_COLOR_LABELS = {
  textColor: Object(external_wp_i18n_["__"])('Text color'),
  backgroundColor: Object(external_wp_i18n_["__"])('Background color')
};

const InspectorControlsColorPanel = props => Object(external_wp_element_["createElement"])(inspector_controls, null, Object(external_wp_element_["createElement"])(color_panel_ColorPanel, props));

function __experimentalUseColors(colorConfigs, {
  panelTitle = Object(external_wp_i18n_["__"])('Color'),
  colorPanelProps,
  contrastCheckers,
  panelChildren,
  colorDetector: {
    targetRef,
    backgroundColorTargetRef = targetRef,
    textColorTargetRef = targetRef
  } = {}
} = {
  panelTitle: Object(external_wp_i18n_["__"])('Color')
}, deps = []) {
  const {
    clientId
  } = useBlockEditContext();
  const settingsColors = useSetting('color.palette') || use_colors_DEFAULT_COLORS;
  const {
    attributes
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getBlockAttributes
    } = select(store);
    return {
      attributes: getBlockAttributes(clientId)
    };
  }, [clientId]);
  const {
    updateBlockAttributes
  } = Object(external_wp_data_["useDispatch"])(store);
  const setAttributes = Object(external_wp_element_["useCallback"])(newAttributes => updateBlockAttributes(clientId, newAttributes), [updateBlockAttributes, clientId]);
  const createComponent = Object(external_wp_element_["useMemo"])(() => memize_default()((name, property, className, color, colorValue, customColor) => ({
    children,
    className: componentClassName = '',
    style: componentStyle = {}
  }) => {
    let colorStyle = {};

    if (color) {
      colorStyle = {
        [property]: colorValue
      };
    } else if (customColor) {
      colorStyle = {
        [property]: customColor
      };
    }

    const extraProps = {
      className: classnames_default()(componentClassName, {
        [`has-${Object(external_lodash_["kebabCase"])(color)}-${Object(external_lodash_["kebabCase"])(property)}`]: color,
        [className || `has-${Object(external_lodash_["kebabCase"])(name)}`]: color || customColor
      }),
      style: { ...colorStyle,
        ...componentStyle
      }
    };

    if (Object(external_lodash_["isFunction"])(children)) {
      return children(extraProps);
    }

    return (// Clone children, setting the style property from the color configuration,
      // if not already set explicitly through props.
      external_wp_element_["Children"].map(children, child => {
        return Object(external_wp_element_["cloneElement"])(child, {
          className: classnames_default()(child.props.className, extraProps.className),
          style: { ...extraProps.style,
            ...(child.props.style || {})
          }
        });
      })
    );
  }, {
    maxSize: colorConfigs.length
  }), [colorConfigs.length]);
  const createSetColor = Object(external_wp_element_["useMemo"])(() => memize_default()((name, colors) => newColor => {
    const color = colors.find(_color => _color.color === newColor);
    setAttributes({
      [color ? Object(external_lodash_["camelCase"])(`custom ${name}`) : name]: undefined
    });
    setAttributes({
      [color ? name : Object(external_lodash_["camelCase"])(`custom ${name}`)]: color ? color.slug : newColor
    });
  }, {
    maxSize: colorConfigs.length
  }), [setAttributes, colorConfigs.length]);
  const [detectedBackgroundColor, setDetectedBackgroundColor] = Object(external_wp_element_["useState"])();
  const [detectedColor, setDetectedColor] = Object(external_wp_element_["useState"])();
  Object(external_wp_element_["useEffect"])(() => {
    if (!contrastCheckers) {
      return undefined;
    }

    let needsBackgroundColor = false;
    let needsColor = false;

    for (const {
      backgroundColor,
      textColor
    } of Object(external_lodash_["castArray"])(contrastCheckers)) {
      if (!needsBackgroundColor) {
        needsBackgroundColor = backgroundColor === true;
      }

      if (!needsColor) {
        needsColor = textColor === true;
      }

      if (needsBackgroundColor && needsColor) {
        break;
      }
    }

    if (needsColor) {
      setDetectedColor(use_colors_getComputedStyle(textColorTargetRef.current).color);
    }

    if (needsBackgroundColor) {
      let backgroundColorNode = backgroundColorTargetRef.current;
      let backgroundColor = use_colors_getComputedStyle(backgroundColorNode).backgroundColor;

      while (backgroundColor === 'rgba(0, 0, 0, 0)' && backgroundColorNode.parentNode && backgroundColorNode.parentNode.nodeType === backgroundColorNode.parentNode.ELEMENT_NODE) {
        backgroundColorNode = backgroundColorNode.parentNode;
        backgroundColor = use_colors_getComputedStyle(backgroundColorNode).backgroundColor;
      }

      setDetectedBackgroundColor(backgroundColor);
    }
  }, [colorConfigs.reduce((acc, colorConfig) => `${acc} | ${attributes[colorConfig.name]} | ${attributes[Object(external_lodash_["camelCase"])(`custom ${colorConfig.name}`)]}`, ''), ...deps]);
  return Object(external_wp_element_["useMemo"])(() => {
    const colorSettings = {};
    const components = colorConfigs.reduce((acc, colorConfig) => {
      if (typeof colorConfig === 'string') {
        colorConfig = {
          name: colorConfig
        };
      }

      const {
        name,
        // E.g. 'backgroundColor'.
        property = name,
        // E.g. 'backgroundColor'.
        className,
        panelLabel = colorConfig.label || COMMON_COLOR_LABELS[name] || Object(external_lodash_["startCase"])(name),
        // E.g. 'Background color'.
        componentName = Object(external_lodash_["startCase"])(name).replace(/\s/g, ''),
        // E.g. 'BackgroundColor'.
        color = colorConfig.color,
        colors = settingsColors
      } = { ...colorConfig,
        color: attributes[colorConfig.name]
      };
      const customColor = attributes[Object(external_lodash_["camelCase"])(`custom ${name}`)]; // We memoize the non-primitives to avoid unnecessary updates
      // when they are used as props for other components.

      const _color = customColor ? undefined : colors.find(__color => __color.slug === color);

      acc[componentName] = createComponent(name, property, className, color, _color && _color.color, customColor);
      acc[componentName].displayName = componentName;
      acc[componentName].color = customColor ? customColor : _color && _color.color;
      acc[componentName].slug = color;
      acc[componentName].setColor = createSetColor(name, colors);
      colorSettings[componentName] = {
        value: _color ? _color.color : attributes[Object(external_lodash_["camelCase"])(`custom ${name}`)],
        onChange: acc[componentName].setColor,
        label: panelLabel,
        colors
      }; // These settings will be spread over the `colors` in
      // `colorPanelProps`, so we need to unset the key here,
      // if not set to an actual value, to avoid overwriting
      // an actual value in `colorPanelProps`.

      if (!colors) {
        delete colorSettings[componentName].colors;
      }

      return acc;
    }, {});
    const wrappedColorPanelProps = {
      title: panelTitle,
      initialOpen: false,
      colorSettings,
      colorPanelProps,
      contrastCheckers,
      detectedBackgroundColor,
      detectedColor,
      panelChildren
    };
    return { ...components,
      ColorPanel: Object(external_wp_element_["createElement"])(color_panel_ColorPanel, wrappedColorPanelProps),
      InspectorControlsColorPanel: Object(external_wp_element_["createElement"])(InspectorControlsColorPanel, wrappedColorPanelProps)
    };
  }, [attributes, setAttributes, detectedColor, detectedBackgroundColor, ...deps]);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/colors/index.js




// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/gradients/index.js


// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/font-sizes/with-font-sizes.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



const DEFAULT_FONT_SIZES = [];
/**
 * Higher-order component, which handles font size logic for class generation,
 * font size value retrieval, and font size change handling.
 *
 * @param {...(Object|string)} fontSizeNames The arguments should all be strings.
 *                                           Each string contains the font size
 *                                           attribute name e.g: 'fontSize'.
 *
 * @return {Function} Higher-order component.
 */

/* harmony default export */ var with_font_sizes = ((...fontSizeNames) => {
  /*
   * Computes an object whose key is the font size attribute name as passed in the array,
   * and the value is the custom font size attribute name.
   * Custom font size is automatically compted by appending custom followed by the font size attribute name in with the first letter capitalized.
   */
  const fontSizeAttributeNames = Object(external_lodash_["reduce"])(fontSizeNames, (fontSizeAttributeNamesAccumulator, fontSizeAttributeName) => {
    fontSizeAttributeNamesAccumulator[fontSizeAttributeName] = `custom${Object(external_lodash_["upperFirst"])(fontSizeAttributeName)}`;
    return fontSizeAttributeNamesAccumulator;
  }, {});
  return Object(external_wp_compose_["createHigherOrderComponent"])(Object(external_wp_compose_["compose"])([Object(external_wp_compose_["createHigherOrderComponent"])(WrappedComponent => props => {
    const fontSizes = useSetting('typography.fontSizes') || DEFAULT_FONT_SIZES;
    return Object(external_wp_element_["createElement"])(WrappedComponent, Object(esm_extends["a" /* default */])({}, props, {
      fontSizes: fontSizes
    }));
  }, 'withFontSizes'), WrappedComponent => {
    return class extends external_wp_element_["Component"] {
      constructor(props) {
        super(props);
        this.setters = this.createSetters();
        this.state = {};
      }

      createSetters() {
        return Object(external_lodash_["reduce"])(fontSizeAttributeNames, (settersAccumulator, customFontSizeAttributeName, fontSizeAttributeName) => {
          const upperFirstFontSizeAttributeName = Object(external_lodash_["upperFirst"])(fontSizeAttributeName);
          settersAccumulator[`set${upperFirstFontSizeAttributeName}`] = this.createSetFontSize(fontSizeAttributeName, customFontSizeAttributeName);
          return settersAccumulator;
        }, {});
      }

      createSetFontSize(fontSizeAttributeName, customFontSizeAttributeName) {
        return fontSizeValue => {
          const fontSizeObject = Object(external_lodash_["find"])(this.props.fontSizes, {
            size: Number(fontSizeValue)
          });
          this.props.setAttributes({
            [fontSizeAttributeName]: fontSizeObject && fontSizeObject.slug ? fontSizeObject.slug : undefined,
            [customFontSizeAttributeName]: fontSizeObject && fontSizeObject.slug ? undefined : fontSizeValue
          });
        };
      }

      static getDerivedStateFromProps({
        attributes,
        fontSizes
      }, previousState) {
        const didAttributesChange = (customFontSizeAttributeName, fontSizeAttributeName) => {
          if (previousState[fontSizeAttributeName]) {
            // if new font size is name compare with the previous slug
            if (attributes[fontSizeAttributeName]) {
              return attributes[fontSizeAttributeName] !== previousState[fontSizeAttributeName].slug;
            } // if font size is not named, update when the font size value changes.


            return previousState[fontSizeAttributeName].size !== attributes[customFontSizeAttributeName];
          } // in this case we need to build the font size object


          return true;
        };

        if (!Object(external_lodash_["some"])(fontSizeAttributeNames, didAttributesChange)) {
          return null;
        }

        const newState = Object(external_lodash_["reduce"])(Object(external_lodash_["pickBy"])(fontSizeAttributeNames, didAttributesChange), (newStateAccumulator, customFontSizeAttributeName, fontSizeAttributeName) => {
          const fontSizeAttributeValue = attributes[fontSizeAttributeName];
          const fontSizeObject = getFontSize(fontSizes, fontSizeAttributeValue, attributes[customFontSizeAttributeName]);
          newStateAccumulator[fontSizeAttributeName] = { ...fontSizeObject,
            class: getFontSizeClass(fontSizeAttributeValue)
          };
          return newStateAccumulator;
        }, {});
        return { ...previousState,
          ...newState
        };
      }

      render() {
        return Object(external_wp_element_["createElement"])(WrappedComponent, Object(esm_extends["a" /* default */])({}, this.props, {
          fontSizes: undefined
        }, this.state, this.setters));
      }

    };
  }]), 'withFontSizes');
});

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/font-sizes/index.js




// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/align-left.js
var align_left = __webpack_require__("fPbg");

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/align-center.js
var align_center = __webpack_require__("plpT");

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/align-right.js
var align_right = __webpack_require__("ziDm");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/alignment-control/ui.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




const DEFAULT_ALIGNMENT_CONTROLS = [{
  icon: align_left["a" /* default */],
  title: Object(external_wp_i18n_["__"])('Align text left'),
  align: 'left'
}, {
  icon: align_center["a" /* default */],
  title: Object(external_wp_i18n_["__"])('Align text center'),
  align: 'center'
}, {
  icon: align_right["a" /* default */],
  title: Object(external_wp_i18n_["__"])('Align text right'),
  align: 'right'
}];
const alignment_control_ui_POPOVER_PROPS = {
  position: 'bottom right',
  isAlternate: true
};

function AlignmentUI({
  value,
  onChange,
  alignmentControls = DEFAULT_ALIGNMENT_CONTROLS,
  label = Object(external_wp_i18n_["__"])('Align'),
  describedBy = Object(external_wp_i18n_["__"])('Change text alignment'),
  isCollapsed = true,
  isToolbar
}) {
  function applyOrUnset(align) {
    return () => onChange(value === align ? undefined : align);
  }

  const activeAlignment = Object(external_lodash_["find"])(alignmentControls, control => control.align === value);

  function setIcon() {
    if (activeAlignment) return activeAlignment.icon;
    return Object(external_wp_i18n_["isRTL"])() ? align_right["a" /* default */] : align_left["a" /* default */];
  }

  const UIComponent = isToolbar ? external_wp_components_["ToolbarGroup"] : external_wp_components_["ToolbarDropdownMenu"];
  const extraProps = isToolbar ? {
    isCollapsed
  } : {};
  return Object(external_wp_element_["createElement"])(UIComponent, Object(esm_extends["a" /* default */])({
    icon: setIcon(),
    label: label,
    toggleProps: {
      describedBy
    },
    popoverProps: alignment_control_ui_POPOVER_PROPS,
    controls: alignmentControls.map(control => {
      const {
        align
      } = control;
      const isActive = value === align;
      return { ...control,
        isActive,
        role: isCollapsed ? 'menuitemradio' : undefined,
        onClick: applyOrUnset(align)
      };
    })
  }, extraProps));
}

/* harmony default export */ var alignment_control_ui = (AlignmentUI);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/alignment-control/index.js



/**
 * Internal dependencies
 */

function AlignmentControl(props) {
  return Object(external_wp_element_["createElement"])(alignment_control_ui, Object(esm_extends["a" /* default */])({}, props, {
    isToolbar: false
  }));
}
function AlignmentToolbar(props) {
  return Object(external_wp_element_["createElement"])(alignment_control_ui, Object(esm_extends["a" /* default */])({}, props, {
    isToolbar: true
  }));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/search-items.js
/**
 * External dependencies
 */
 // Default search helpers

const defaultGetName = item => item.name || '';

const defaultGetTitle = item => item.title;

const defaultGetDescription = item => item.description || '';

const defaultGetKeywords = item => item.keywords || [];

const defaultGetCategory = item => item.category;

const defaultGetCollection = () => null;
/**
 * Sanitizes the search input string.
 *
 * @param {string} input The search input to normalize.
 *
 * @return {string} The normalized search input.
 */


function normalizeSearchInput(input = '') {
  // Disregard diacritics.
  //  Input: "média"
  input = Object(external_lodash_["deburr"])(input); // Accommodate leading slash, matching autocomplete expectations.
  //  Input: "/media"

  input = input.replace(/^\//, ''); // Lowercase.
  //  Input: "MEDIA"

  input = input.toLowerCase();
  return input;
}
/**
 * Converts the search term into a list of normalized terms.
 *
 * @param {string} input The search term to normalize.
 *
 * @return {string[]} The normalized list of search terms.
 */


const getNormalizedSearchTerms = (input = '') => {
  // Extract words.
  return Object(external_lodash_["words"])(normalizeSearchInput(input));
};

const removeMatchingTerms = (unmatchedTerms, unprocessedTerms) => {
  return Object(external_lodash_["differenceWith"])(unmatchedTerms, getNormalizedSearchTerms(unprocessedTerms), (unmatchedTerm, unprocessedTerm) => unprocessedTerm.includes(unmatchedTerm));
};

const searchBlockItems = (items, categories, collections, searchInput) => {
  const normalizedSearchTerms = getNormalizedSearchTerms(searchInput);

  if (normalizedSearchTerms.length === 0) {
    return items;
  }

  const config = {
    getCategory: item => {
      var _find;

      return (_find = Object(external_lodash_["find"])(categories, {
        slug: item.category
      })) === null || _find === void 0 ? void 0 : _find.title;
    },
    getCollection: item => {
      var _collections$item$nam;

      return (_collections$item$nam = collections[item.name.split('/')[0]]) === null || _collections$item$nam === void 0 ? void 0 : _collections$item$nam.title;
    }
  };
  return searchItems(items, searchInput, config);
};
/**
 * Filters an item list given a search term.
 *
 * @param {Array}  items       Item list
 * @param {string} searchInput Search input.
 * @param {Object} config      Search Config.
 * @return {Array}             Filtered item list.
 */

const searchItems = (items = [], searchInput = '', config = {}) => {
  const normalizedSearchTerms = getNormalizedSearchTerms(searchInput);

  if (normalizedSearchTerms.length === 0) {
    return items;
  }

  const rankedItems = items.map(item => {
    return [item, getItemSearchRank(item, searchInput, config)];
  }).filter(([, rank]) => rank > 0);
  rankedItems.sort(([, rank1], [, rank2]) => rank2 - rank1);
  return rankedItems.map(([item]) => item);
};
/**
 * Get the search rank for a given item and a specific search term.
 * The better the match, the higher the rank.
 * If the rank equals 0, it should be excluded from the results.
 *
 * @param {Object} item       Item to filter.
 * @param {string} searchTerm Search term.
 * @param {Object} config     Search Config.
 * @return {number}           Search Rank.
 */

function getItemSearchRank(item, searchTerm, config = {}) {
  const {
    getName = defaultGetName,
    getTitle = defaultGetTitle,
    getDescription = defaultGetDescription,
    getKeywords = defaultGetKeywords,
    getCategory = defaultGetCategory,
    getCollection = defaultGetCollection
  } = config;
  const name = getName(item);
  const title = getTitle(item);
  const description = getDescription(item);
  const keywords = getKeywords(item);
  const category = getCategory(item);
  const collection = getCollection(item);
  const normalizedSearchInput = normalizeSearchInput(searchTerm);
  const normalizedTitle = normalizeSearchInput(title);
  let rank = 0; // Prefers exact matches
  // Then prefers if the beginning of the title matches the search term
  // name, keywords, categories, collection, variations match come later.

  if (normalizedSearchInput === normalizedTitle) {
    rank += 30;
  } else if (normalizedTitle.startsWith(normalizedSearchInput)) {
    rank += 20;
  } else {
    const terms = [name, title, description, ...keywords, category, collection].join(' ');
    const normalizedSearchTerms = Object(external_lodash_["words"])(normalizedSearchInput);
    const unmatchedTerms = removeMatchingTerms(normalizedSearchTerms, terms);

    if (unmatchedTerms.length === 0) {
      rank += 10;
    }
  } // Give a better rank to "core" namespaced items.


  if (rank !== 0 && name.startsWith('core/')) {
    rank++;
  }

  return rank;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-block-types-state.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Retrieves the block types inserter state.
 *
 * @param {string=}  rootClientId        Insertion's root client ID.
 * @param {Function} onInsert            function called when inserter a list of blocks.
 * @return {Array} Returns the block types state. (block types, categories, collections, onSelect handler)
 */

const useBlockTypesState = (rootClientId, onInsert) => {
  const {
    categories,
    collections,
    items
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getInserterItems
    } = select(store);
    const {
      getCategories,
      getCollections
    } = select(external_wp_blocks_["store"]);
    return {
      categories: getCategories(),
      collections: getCollections(),
      items: getInserterItems(rootClientId)
    };
  }, [rootClientId]);
  const onSelectItem = Object(external_wp_element_["useCallback"])(({
    name,
    initialAttributes,
    innerBlocks
  }, shouldFocusBlock) => {
    const insertedBlock = Object(external_wp_blocks_["createBlock"])(name, initialAttributes, Object(external_wp_blocks_["createBlocksFromInnerBlocksTemplate"])(innerBlocks));
    onInsert(insertedBlock, undefined, shouldFocusBlock);
  }, [onInsert]);
  return [items, categories, collections, onSelectItem];
};

/* harmony default export */ var use_block_types_state = (useBlockTypesState);

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/block-default.js
var block_default = __webpack_require__("//Lo");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-icon/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



function BlockIcon({
  icon,
  showColors = false,
  className
}) {
  var _icon;

  if (((_icon = icon) === null || _icon === void 0 ? void 0 : _icon.src) === 'block-default') {
    icon = {
      src: block_default["a" /* default */]
    };
  }

  const renderedIcon = Object(external_wp_element_["createElement"])(external_wp_components_["Icon"], {
    icon: icon && icon.src ? icon.src : icon
  });
  const style = showColors ? {
    backgroundColor: icon && icon.background,
    color: icon && icon.foreground
  } : {};
  return Object(external_wp_element_["createElement"])("span", {
    style: style,
    className: classnames_default()('block-editor-block-icon', className, {
      'has-colors': showColors
    })
  }, renderedIcon);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/autocompleters/block.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





const SHOWN_BLOCK_TYPES = 9;
/** @typedef {import('@wordpress/components').WPCompleter} WPCompleter */

/**
 * Creates a blocks repeater for replacing the current block with a selected block type.
 *
 * @return {WPCompleter} A blocks completer.
 */

function createBlockCompleter() {
  return {
    name: 'blocks',
    className: 'block-editor-autocompleters__block',
    triggerPrefix: '/',

    useItems(filterValue) {
      const {
        rootClientId,
        selectedBlockName
      } = Object(external_wp_data_["useSelect"])(select => {
        const {
          getSelectedBlockClientId,
          getBlockName,
          getBlockInsertionPoint
        } = select(store);
        const selectedBlockClientId = getSelectedBlockClientId();
        return {
          selectedBlockName: selectedBlockClientId ? getBlockName(selectedBlockClientId) : null,
          rootClientId: getBlockInsertionPoint().rootClientId
        };
      }, []);
      const [items, categories, collections] = use_block_types_state(rootClientId, external_lodash_["noop"]);
      const filteredItems = Object(external_wp_element_["useMemo"])(() => {
        const initialFilteredItems = !!filterValue.trim() ? searchBlockItems(items, categories, collections, filterValue) : Object(external_lodash_["orderBy"])(items, ['frecency'], ['desc']);
        return initialFilteredItems.filter(item => item.name !== selectedBlockName).slice(0, SHOWN_BLOCK_TYPES);
      }, [filterValue, selectedBlockName, items, categories, collections]);
      const options = Object(external_wp_element_["useMemo"])(() => filteredItems.map(blockItem => {
        const {
          title,
          icon,
          isDisabled
        } = blockItem;
        return {
          key: `block-${blockItem.id}`,
          value: blockItem,
          label: Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(BlockIcon, {
            key: "icon",
            icon: icon,
            showColors: true
          }), title),
          isDisabled
        };
      }), [filteredItems]);
      return [options];
    },

    allowContext(before, after) {
      return !(/\S/.test(before) || /\S/.test(after));
    },

    getOptionCompletion(inserterItem) {
      const {
        name,
        initialAttributes,
        innerBlocks
      } = inserterItem;
      return {
        action: 'replace',
        value: Object(external_wp_blocks_["createBlock"])(name, initialAttributes, Object(external_wp_blocks_["createBlocksFromInnerBlocksTemplate"])(innerBlocks))
      };
    }

  };
}
/**
 * Creates a blocks repeater for replacing the current block with a selected block type.
 *
 * @return {WPCompleter} A blocks completer.
 */


/* harmony default export */ var autocompleters_block = (createBlockCompleter());

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/autocomplete/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



/**
 * Shared reference to an empty array for cases where it is important to avoid
 * returning a new array reference on every invocation.
 *
 * @type {Array}
 */

const autocomplete_EMPTY_ARRAY = [];

function useCompleters({
  completers = autocomplete_EMPTY_ARRAY
}) {
  const {
    name
  } = useBlockEditContext();
  return Object(external_wp_element_["useMemo"])(() => {
    let filteredCompleters = completers;

    if (name === Object(external_wp_blocks_["getDefaultBlockName"])()) {
      filteredCompleters = filteredCompleters.concat([autocompleters_block]);
    }

    if (Object(external_wp_hooks_["hasFilter"])('editor.Autocomplete.completers')) {
      // Provide copies so filters may directly modify them.
      if (filteredCompleters === completers) {
        filteredCompleters = filteredCompleters.map(external_lodash_["clone"]);
      }

      filteredCompleters = Object(external_wp_hooks_["applyFilters"])('editor.Autocomplete.completers', filteredCompleters, name);
    }

    return filteredCompleters;
  }, [completers, name]);
}

function useBlockEditorAutocompleteProps(props) {
  return Object(external_wp_components_["__unstableUseAutocompleteProps"])({ ...props,
    completers: useCompleters(props)
  });
}
/**
 * Wrap the default Autocomplete component with one that supports a filter hook
 * for customizing its list of autocompleters.
 *
 * @type {import('react').FC}
 */

function BlockEditorAutocomplete(props) {
  return Object(external_wp_element_["createElement"])(external_wp_components_["Autocomplete"], Object(esm_extends["a" /* default */])({}, props, {
    completers: useCompleters(props)
  }));
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/autocomplete/README.md
 */


/* harmony default export */ var autocomplete = (BlockEditorAutocomplete);

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/fullscreen.js


/**
 * WordPress dependencies
 */

const fullscreen = Object(external_wp_element_["createElement"])(external_wp_primitives_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_primitives_["Path"], {
  d: "M4.2 9h1.5V5.8H9V4.2H4.2V9zm14 9.2H15v1.5h4.8V15h-1.5v3.2zM15 4.2v1.5h3.2V9h1.5V4.2H15zM5.8 15H4.2v4.8H9v-1.5H5.8V15z"
}));
/* harmony default export */ var library_fullscreen = (fullscreen);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-full-height-alignment-control/index.js


/**
 * WordPress dependencies
 */




function BlockFullHeightAlignmentControl({
  isActive,
  label = Object(external_wp_i18n_["__"])('Toggle full height'),
  onToggle,
  isDisabled
}) {
  return Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarButton"], {
    isActive: isActive,
    icon: library_fullscreen,
    label: label,
    onClick: () => onToggle(!isActive),
    disabled: isDisabled
  });
}

/* harmony default export */ var block_full_height_alignment_control = (BlockFullHeightAlignmentControl);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-alignment-matrix-control/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





function BlockAlignmentMatrixControl(props) {
  const {
    label = Object(external_wp_i18n_["__"])('Change matrix alignment'),
    onChange = external_lodash_["noop"],
    value = 'center',
    isDisabled
  } = props;
  const icon = Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalAlignmentMatrixControl"].Icon, {
    value: value
  });
  const className = 'block-editor-block-alignment-matrix-control';
  const popoverClassName = `${className}__popover`;
  const isAlternate = true;
  return Object(external_wp_element_["createElement"])(external_wp_components_["Dropdown"], {
    position: "bottom right",
    className: className,
    popoverProps: {
      className: popoverClassName,
      isAlternate
    },
    renderToggle: ({
      onToggle,
      isOpen
    }) => {
      const openOnArrowDown = event => {
        if (!isOpen && event.keyCode === external_wp_keycodes_["DOWN"]) {
          event.preventDefault();
          event.stopPropagation();
          onToggle();
        }
      };

      return Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarButton"], {
        onClick: onToggle,
        "aria-haspopup": "true",
        "aria-expanded": isOpen,
        onKeyDown: openOnArrowDown,
        label: label,
        icon: icon,
        showTooltip: true,
        disabled: isDisabled
      });
    },
    renderContent: () => Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalAlignmentMatrixControl"], {
      hasFocusBorder: false,
      onChange: onChange,
      value: value
    })
  });
}

/* harmony default export */ var block_alignment_matrix_control = (BlockAlignmentMatrixControl);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/use-block-display-information/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/** @typedef {import('@wordpress/blocks').WPIcon} WPIcon */

/**
 * Contains basic block's information for display reasons.
 *
 * @typedef {Object} WPBlockDisplayInformation
 *
 * @property {string} title Human-readable block type label.
 * @property {WPIcon} icon Block type icon.
 * @property {string} description A detailed block type description.
 */

/**
 * Hook used to try to find a matching block variation and return
 * the appropriate information for display reasons. In order to
 * to try to find a match we need to things:
 * 1. Block's client id to extract it's current attributes.
 * 2. A block variation should have set `isActive` prop to a proper function.
 *
 * If for any reason a block variaton match cannot be found,
 * the returned information come from the Block Type.
 * If no blockType is found with the provided clientId, returns null.
 *
 * @param {string} clientId Block's client id.
 * @return {?WPBlockDisplayInformation} Block's display information, or `null` when the block or its type not found.
 */

function useBlockDisplayInformation(clientId) {
  return Object(external_wp_data_["useSelect"])(select => {
    if (!clientId) return null;
    const {
      getBlockName,
      getBlockAttributes
    } = select(store);
    const {
      getBlockType,
      getActiveBlockVariation
    } = select(external_wp_blocks_["store"]);
    const blockName = getBlockName(clientId);
    const blockType = getBlockType(blockName);
    if (!blockType) return null;
    const attributes = getBlockAttributes(clientId);
    const match = getActiveBlockVariation(blockName, attributes);
    const blockTypeInfo = {
      title: blockType.title,
      icon: blockType.icon,
      description: blockType.description,
      anchor: attributes === null || attributes === void 0 ? void 0 : attributes.anchor
    };
    if (!match) return blockTypeInfo;
    return {
      title: match.title || blockType.title,
      icon: match.icon || blockType.icon,
      description: match.description || blockType.description
    };
  }, [clientId]);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-title/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/**
 * Renders the block's configured title as a string, or empty if the title
 * cannot be determined.
 *
 * @example
 *
 * ```jsx
 * <BlockTitle clientId="afd1cb17-2c08-4e7a-91be-007ba7ddc3a1" />
 * ```
 *
 * @param {Object} props
 * @param {string} props.clientId Client ID of block.
 *
 * @return {?string} Block title.
 */

function BlockTitle({
  clientId
}) {
  const {
    attributes,
    name,
    reusableBlockTitle
  } = Object(external_wp_data_["useSelect"])(select => {
    if (!clientId) {
      return {};
    }

    const {
      getBlockName,
      getBlockAttributes,
      __experimentalGetReusableBlockTitle
    } = select(store);
    const blockName = getBlockName(clientId);

    if (!blockName) {
      return {};
    }

    const isReusable = Object(external_wp_blocks_["isReusableBlock"])(Object(external_wp_blocks_["getBlockType"])(blockName));
    return {
      attributes: getBlockAttributes(clientId),
      name: blockName,
      reusableBlockTitle: isReusable && __experimentalGetReusableBlockTitle(getBlockAttributes(clientId).ref)
    };
  }, [clientId]);
  const blockInformation = useBlockDisplayInformation(clientId);
  if (!name || !blockInformation) return null;
  const blockType = Object(external_wp_blocks_["getBlockType"])(name);
  const label = reusableBlockTitle || Object(external_wp_blocks_["__experimentalGetBlockLabel"])(blockType, attributes); // Label will fallback to the title if no label is defined for the current
  // label context. If the label is defined we prioritize it over possible
  // possible block variation title match.

  if (label !== blockType.title) {
    return Object(external_lodash_["truncate"])(label, {
      length: 35
    });
  }

  return blockInformation.title;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-breadcrumb/index.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/**
 * Block breadcrumb component, displaying the hierarchy of the current block selection as a breadcrumb.
 *
 * @param  {Object}   props               Component props.
 * @param  {string}   props.rootLabelText Translated label for the root element of the breadcrumb trail.
 * @return {WPElement}                    Block Breadcrumb.
 */

function BlockBreadcrumb({
  rootLabelText
}) {
  const {
    selectBlock,
    clearSelectedBlock
  } = Object(external_wp_data_["useDispatch"])(store);
  const {
    clientId,
    parents,
    hasSelection
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getSelectionStart,
      getSelectedBlockClientId,
      getBlockParents
    } = select(store);
    const selectedBlockClientId = getSelectedBlockClientId();
    return {
      parents: getBlockParents(selectedBlockClientId),
      clientId: selectedBlockClientId,
      hasSelection: !!getSelectionStart().clientId
    };
  }, []);

  const rootLabel = rootLabelText || Object(external_wp_i18n_["__"])('Document');
  /*
   * Disable reason: The `list` ARIA role is redundant but
   * Safari+VoiceOver won't announce the list otherwise.
   */

  /* eslint-disable jsx-a11y/no-redundant-roles */


  return Object(external_wp_element_["createElement"])("ul", {
    className: "block-editor-block-breadcrumb",
    role: "list",
    "aria-label": Object(external_wp_i18n_["__"])('Block breadcrumb')
  }, Object(external_wp_element_["createElement"])("li", {
    className: !hasSelection ? 'block-editor-block-breadcrumb__current' : undefined,
    "aria-current": !hasSelection ? 'true' : undefined
  }, hasSelection && Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    className: "block-editor-block-breadcrumb__button",
    isTertiary: true,
    onClick: clearSelectedBlock
  }, rootLabel), !hasSelection && rootLabel), parents.map(parentClientId => Object(external_wp_element_["createElement"])("li", {
    key: parentClientId
  }, Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    className: "block-editor-block-breadcrumb__button",
    isTertiary: true,
    onClick: () => selectBlock(parentClientId)
  }, Object(external_wp_element_["createElement"])(BlockTitle, {
    clientId: parentClientId
  })))), !!clientId && Object(external_wp_element_["createElement"])("li", {
    className: "block-editor-block-breadcrumb__current",
    "aria-current": "true"
  }, Object(external_wp_element_["createElement"])(BlockTitle, {
    clientId: clientId
  })))
  /* eslint-enable jsx-a11y/no-redundant-roles */
  ;
}

/* harmony default export */ var block_breadcrumb = (BlockBreadcrumb);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-context/index.js


/**
 * WordPress dependencies
 */

/** @typedef {import('react').ReactNode} ReactNode */

/**
 * @typedef BlockContextProviderProps
 *
 * @property {Record<string,*>} value    Context value to merge with current
 *                                       value.
 * @property {ReactNode}        children Component children.
 */

/** @type {import('react').Context<Record<string,*>>} */

const block_context_Context = Object(external_wp_element_["createContext"])({});
/**
 * Component which merges passed value with current consumed block context.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-context/README.md
 *
 * @param {BlockContextProviderProps} props
 */

function BlockContextProvider({
  value,
  children
}) {
  const context = Object(external_wp_element_["useContext"])(block_context_Context);
  const nextValue = Object(external_wp_element_["useMemo"])(() => ({ ...context,
    ...value
  }), [context, value]);
  return Object(external_wp_element_["createElement"])(block_context_Context.Provider, {
    value: nextValue,
    children: children
  });
}
/* harmony default export */ var block_context = (block_context_Context);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/color-style-selector/index.js


/**
 * WordPress dependencies
 */




const ColorSelectorSVGIcon = () => Object(external_wp_element_["createElement"])(external_wp_components_["SVG"], {
  xmlns: "https://www.w3.org/2000/svg",
  viewBox: "0 0 20 20"
}, Object(external_wp_element_["createElement"])(external_wp_components_["Path"], {
  d: "M7.434 5l3.18 9.16H8.538l-.692-2.184H4.628l-.705 2.184H2L5.18 5h2.254zm-1.13 1.904h-.115l-1.148 3.593H7.44L6.304 6.904zM14.348 7.006c1.853 0 2.9.876 2.9 2.374v4.78h-1.79v-.914h-.114c-.362.64-1.123 1.022-2.031 1.022-1.346 0-2.292-.826-2.292-2.108 0-1.27.972-2.006 2.71-2.107l1.696-.102V9.38c0-.584-.42-.914-1.18-.914-.667 0-1.112.228-1.264.647h-1.701c.12-1.295 1.307-2.107 3.066-2.107zm1.079 4.1l-1.416.09c-.793.056-1.18.342-1.18.844 0 .52.45.837 1.091.837.857 0 1.505-.545 1.505-1.256v-.515z"
}));
/**
 * Color Selector Icon component.
 *
 * @param {Object} props           Component properties.
 * @param {Object} props.style     Style object.
 * @param {string} props.className Class name for component.
 *
 * @return {*} React Icon component.
 */


const ColorSelectorIcon = ({
  style,
  className
}) => {
  return Object(external_wp_element_["createElement"])("div", {
    className: "block-library-colors-selector__icon-container"
  }, Object(external_wp_element_["createElement"])("div", {
    className: `${className} block-library-colors-selector__state-selection`,
    style: style
  }, Object(external_wp_element_["createElement"])(ColorSelectorSVGIcon, null)));
};
/**
 * Renders the Colors Selector Toolbar with the icon button.
 *
 * @param {Object} props                 Component properties.
 * @param {Object} props.TextColor       Text color component that wraps icon.
 * @param {Object} props.BackgroundColor Background color component that wraps icon.
 *
 * @return {*} React toggle button component.
 */


const renderToggleComponent = ({
  TextColor,
  BackgroundColor
}) => ({
  onToggle,
  isOpen
}) => {
  const openOnArrowDown = event => {
    if (!isOpen && event.keyCode === external_wp_keycodes_["DOWN"]) {
      event.preventDefault();
      event.stopPropagation();
      onToggle();
    }
  };

  return Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarGroup"], null, Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarButton"], {
    className: "components-toolbar__control block-library-colors-selector__toggle",
    label: Object(external_wp_i18n_["__"])('Open Colors Selector'),
    onClick: onToggle,
    onKeyDown: openOnArrowDown,
    icon: Object(external_wp_element_["createElement"])(BackgroundColor, null, Object(external_wp_element_["createElement"])(TextColor, null, Object(external_wp_element_["createElement"])(ColorSelectorIcon, null)))
  }));
};

const BlockColorsStyleSelector = ({
  children,
  ...other
}) => Object(external_wp_element_["createElement"])(external_wp_components_["Dropdown"], {
  position: "bottom right",
  className: "block-library-colors-selector",
  contentClassName: "block-library-colors-selector__popover",
  renderToggle: renderToggleComponent(other),
  renderContent: () => children
});

/* harmony default export */ var color_style_selector = (BlockColorsStyleSelector);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-edit/edit.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/**
 * Default value used for blocks which do not define their own context needs,
 * used to guarantee that a block's `context` prop will always be an object. It
 * is assigned as a constant since it is always expected to be an empty object,
 * and in order to avoid unnecessary React reconciliations of a changing object.
 *
 * @type {{}}
 */

const DEFAULT_BLOCK_CONTEXT = {};
const edit_Edit = props => {
  const {
    attributes = {},
    name
  } = props;
  const blockType = Object(external_wp_blocks_["getBlockType"])(name);
  const blockContext = Object(external_wp_element_["useContext"])(block_context); // Assign context values using the block type's declared context needs.

  const context = Object(external_wp_element_["useMemo"])(() => {
    return blockType && blockType.usesContext ? Object(external_lodash_["pick"])(blockContext, blockType.usesContext) : DEFAULT_BLOCK_CONTEXT;
  }, [blockType, blockContext]);

  if (!blockType) {
    return null;
  } // `edit` and `save` are functions or components describing the markup
  // with which a block is displayed. If `blockType` is valid, assign
  // them preferentially as the render value for the block.


  const Component = blockType.edit || blockType.save;

  if (blockType.apiVersion > 1 || Object(external_wp_blocks_["hasBlockSupport"])(blockType, 'lightBlockWrapper', false)) {
    return Object(external_wp_element_["createElement"])(Component, Object(esm_extends["a" /* default */])({}, props, {
      context: context
    }));
  } // Generate a class name for the block's editable form


  const generatedClassName = Object(external_wp_blocks_["hasBlockSupport"])(blockType, 'className', true) ? Object(external_wp_blocks_["getBlockDefaultClassName"])(name) : null;
  const className = classnames_default()(generatedClassName, attributes.className);
  return Object(external_wp_element_["createElement"])(Component, Object(esm_extends["a" /* default */])({}, props, {
    context: context,
    className: className
  }));
};
/* harmony default export */ var edit = (Object(external_wp_components_["withFilters"])('editor.BlockEdit')(edit_Edit));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-edit/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




function block_edit_BlockEdit(props) {
  const {
    name,
    isSelected,
    clientId
  } = props;
  const context = {
    name,
    isSelected,
    clientId
  };
  return Object(external_wp_element_["createElement"])(context_Provider // It is important to return the same object if props haven't
  // changed to avoid  unnecessary rerenders.
  // See https://reactjs.org/docs/context.html#caveats.
  , {
    value: Object(external_wp_element_["useMemo"])(() => context, Object.values(context))
  }, Object(external_wp_element_["createElement"])(edit, props));
}

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/list-view.js
var list_view = __webpack_require__("OzlF");

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/more-vertical.js
var more_vertical = __webpack_require__("VKE3");

// EXTERNAL MODULE: ./node_modules/react-spring/web.cjs.js
var web_cjs = __webpack_require__("ZO3Q");

// EXTERNAL MODULE: external ["wp","dom"]
var external_wp_dom_ = __webpack_require__("1CF3");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/use-moving-animation/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Simple reducer used to increment a counter.
 *
 * @param {number} state  Previous counter value.
 * @return {number} New state value.
 */

const counterReducer = state => state + 1;

const getAbsolutePosition = element => {
  return {
    top: element.offsetTop,
    left: element.offsetLeft
  };
};
/**
 * Hook used to compute the styles required to move a div into a new position.
 *
 * The way this animation works is the following:
 *  - It first renders the element as if there was no animation.
 *  - It takes a snapshot of the position of the block to use it
 *    as a destination point for the animation.
 *  - It restores the element to the previous position using a CSS transform
 *  - It uses the "resetAnimation" flag to reset the animation
 *    from the beginning in order to animate to the new destination point.
 *
 * @param {Object}  $1                          Options
 * @param {boolean} $1.isSelected               Whether it's the current block or not.
 * @param {boolean} $1.adjustScrolling          Adjust the scroll position to the current block.
 * @param {boolean} $1.enableAnimation          Enable/Disable animation.
 * @param {*}       $1.triggerAnimationOnChange Variable used to trigger the animation if it changes.
 */


function useMovingAnimation({
  isSelected,
  adjustScrolling,
  enableAnimation,
  triggerAnimationOnChange
}) {
  const ref = Object(external_wp_element_["useRef"])();
  const prefersReducedMotion = Object(external_wp_compose_["useReducedMotion"])() || !enableAnimation;
  const [triggeredAnimation, triggerAnimation] = Object(external_wp_element_["useReducer"])(counterReducer, 0);
  const [finishedAnimation, endAnimation] = Object(external_wp_element_["useReducer"])(counterReducer, 0);
  const [transform, setTransform] = Object(external_wp_element_["useState"])({
    x: 0,
    y: 0
  });
  const previous = Object(external_wp_element_["useMemo"])(() => ref.current ? getAbsolutePosition(ref.current) : null, [triggerAnimationOnChange]); // Calculate the previous position of the block relative to the viewport and
  // return a function to maintain that position by scrolling.

  const preserveScrollPosition = Object(external_wp_element_["useMemo"])(() => {
    if (!adjustScrolling || !ref.current) {
      return () => {};
    }

    const scrollContainer = Object(external_wp_dom_["getScrollContainer"])(ref.current);

    if (!scrollContainer) {
      return () => {};
    }

    const prevRect = ref.current.getBoundingClientRect();
    return () => {
      const blockRect = ref.current.getBoundingClientRect();
      const diff = blockRect.top - prevRect.top;

      if (diff) {
        scrollContainer.scrollTop += diff;
      }
    };
  }, [triggerAnimationOnChange, adjustScrolling]);
  Object(external_wp_element_["useLayoutEffect"])(() => {
    if (triggeredAnimation) {
      endAnimation();
    }
  }, [triggeredAnimation]);
  Object(external_wp_element_["useLayoutEffect"])(() => {
    if (!previous) {
      return;
    }

    if (prefersReducedMotion) {
      // if the animation is disabled and the scroll needs to be adjusted,
      // just move directly to the final scroll position.
      preserveScrollPosition();
      return;
    }

    ref.current.style.transform = '';
    const destination = getAbsolutePosition(ref.current);
    triggerAnimation();
    setTransform({
      x: Math.round(previous.left - destination.left),
      y: Math.round(previous.top - destination.top)
    });
  }, [triggerAnimationOnChange]); // Only called when either the x or y value changes.

  function onFrameChange({
    x,
    y
  }) {
    if (!ref.current) {
      return;
    }

    const isMoving = x === 0 && y === 0;
    ref.current.style.transformOrigin = isMoving ? '' : 'center';
    ref.current.style.transform = isMoving ? '' : `translate3d(${x}px,${y}px,0)`;
    ref.current.style.zIndex = !isSelected || isMoving ? '' : '1';
    preserveScrollPosition();
  } // Called for every frame computed by useSpring.


  function onFrame({
    x,
    y
  }) {
    x = Math.round(x);
    y = Math.round(y);

    if (x !== onFrame.x || y !== onFrame.y) {
      onFrameChange({
        x,
        y
      });
      onFrame.x = x;
      onFrame.y = y;
    }
  }

  onFrame.x = 0;
  onFrame.y = 0;
  Object(web_cjs["useSpring"])({
    from: {
      x: transform.x,
      y: transform.y
    },
    to: {
      x: 0,
      y: 0
    },
    reset: triggeredAnimation !== finishedAnimation,
    config: {
      mass: 5,
      tension: 2000,
      friction: 200
    },
    immediate: prefersReducedMotion,
    onFrame
  });
  return ref;
}

/* harmony default export */ var use_moving_animation = (useMovingAnimation);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-navigation/leaf.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


const AnimatedTreeGridRow = Object(web_cjs["animated"])(external_wp_components_["__experimentalTreeGridRow"]);
function BlockNavigationLeaf({
  isSelected,
  position,
  level,
  rowCount,
  children,
  className,
  path,
  ...props
}) {
  const ref = use_moving_animation({
    isSelected,
    adjustScrolling: false,
    enableAnimation: true,
    triggerAnimationOnChange: path.join('_')
  });
  return Object(external_wp_element_["createElement"])(AnimatedTreeGridRow, Object(esm_extends["a" /* default */])({
    ref: ref,
    className: classnames_default()('block-editor-block-navigation-leaf', className),
    level: level,
    positionInSet: position,
    setSize: rowCount
  }, props), children);
}

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/chevron-right.js
var chevron_right = __webpack_require__("1iEr");

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/chevron-left.js
var chevron_left = __webpack_require__("2gm7");

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/chevron-up.js
var chevron_up = __webpack_require__("XgzB");

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/chevron-down.js
var chevron_down = __webpack_require__("NWDH");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-mover/mover-description.js
/**
 * WordPress dependencies
 */

/**
 * Return a label for the block movement controls depending on block position.
 *
 * @param {number}  selectedCount Number of blocks selected.
 * @param {string}  type          Block type - in the case of a single block, should
 *                                 define its 'type'. I.e. 'Text', 'Heading', 'Image' etc.
 * @param {number}  firstIndex    The index (position - 1) of the first block selected.
 * @param {boolean} isFirst       This is the first block.
 * @param {boolean} isLast        This is the last block.
 * @param {number}  dir           Direction of movement (> 0 is considered to be going
 *                                 down, < 0 is up).
 * @param {string}  orientation   The orientation of the block movers, vertical or
 * 								   horizontal.
 *
 * @return {string} Label for the block movement controls.
 */

function getBlockMoverDescription(selectedCount, type, firstIndex, isFirst, isLast, dir, orientation) {
  const position = firstIndex + 1;

  const getMovementDirection = moveDirection => {
    if (moveDirection === 'up') {
      if (orientation === 'horizontal') {
        return Object(external_wp_i18n_["isRTL"])() ? 'right' : 'left';
      }

      return 'up';
    } else if (moveDirection === 'down') {
      if (orientation === 'horizontal') {
        return Object(external_wp_i18n_["isRTL"])() ? 'left' : 'right';
      }

      return 'down';
    }

    return null;
  };

  if (selectedCount > 1) {
    return getMultiBlockMoverDescription(selectedCount, firstIndex, isFirst, isLast, dir);
  }

  if (isFirst && isLast) {
    return Object(external_wp_i18n_["sprintf"])( // translators: %s: Type of block (i.e. Text, Image etc)
    Object(external_wp_i18n_["__"])('Block %s is the only block, and cannot be moved'), type);
  }

  if (dir > 0 && !isLast) {
    // moving down
    const movementDirection = getMovementDirection('down');

    if (movementDirection === 'down') {
      return Object(external_wp_i18n_["sprintf"])( // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      Object(external_wp_i18n_["__"])('Move %1$s block from position %2$d down to position %3$d'), type, position, position + 1);
    }

    if (movementDirection === 'left') {
      return Object(external_wp_i18n_["sprintf"])( // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      Object(external_wp_i18n_["__"])('Move %1$s block from position %2$d left to position %3$d'), type, position, position + 1);
    }

    if (movementDirection === 'right') {
      return Object(external_wp_i18n_["sprintf"])( // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      Object(external_wp_i18n_["__"])('Move %1$s block from position %2$d right to position %3$d'), type, position, position + 1);
    }
  }

  if (dir > 0 && isLast) {
    // moving down, and is the last item
    const movementDirection = getMovementDirection('down');

    if (movementDirection === 'down') {
      return Object(external_wp_i18n_["sprintf"])( // translators: 1: Type of block (i.e. Text, Image etc)
      Object(external_wp_i18n_["__"])('Block %1$s is at the end of the content and can’t be moved down'), type);
    }

    if (movementDirection === 'left') {
      return Object(external_wp_i18n_["sprintf"])( // translators: 1: Type of block (i.e. Text, Image etc)
      Object(external_wp_i18n_["__"])('Block %1$s is at the end of the content and can’t be moved left'), type);
    }

    if (movementDirection === 'right') {
      return Object(external_wp_i18n_["sprintf"])( // translators: 1: Type of block (i.e. Text, Image etc)
      Object(external_wp_i18n_["__"])('Block %1$s is at the end of the content and can’t be moved right'), type);
    }
  }

  if (dir < 0 && !isFirst) {
    // moving up
    const movementDirection = getMovementDirection('up');

    if (movementDirection === 'up') {
      return Object(external_wp_i18n_["sprintf"])( // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      Object(external_wp_i18n_["__"])('Move %1$s block from position %2$d up to position %3$d'), type, position, position - 1);
    }

    if (movementDirection === 'left') {
      return Object(external_wp_i18n_["sprintf"])( // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      Object(external_wp_i18n_["__"])('Move %1$s block from position %2$d left to position %3$d'), type, position, position - 1);
    }

    if (movementDirection === 'right') {
      return Object(external_wp_i18n_["sprintf"])( // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      Object(external_wp_i18n_["__"])('Move %1$s block from position %2$d right to position %3$d'), type, position, position - 1);
    }
  }

  if (dir < 0 && isFirst) {
    // moving up, and is the first item
    const movementDirection = getMovementDirection('up');

    if (movementDirection === 'up') {
      return Object(external_wp_i18n_["sprintf"])( // translators: 1: Type of block (i.e. Text, Image etc)
      Object(external_wp_i18n_["__"])('Block %1$s is at the beginning of the content and can’t be moved up'), type);
    }

    if (movementDirection === 'left') {
      return Object(external_wp_i18n_["sprintf"])( // translators: 1: Type of block (i.e. Text, Image etc)
      Object(external_wp_i18n_["__"])('Block %1$s is at the beginning of the content and can’t be moved left'), type);
    }

    if (movementDirection === 'right') {
      return Object(external_wp_i18n_["sprintf"])( // translators: 1: Type of block (i.e. Text, Image etc)
      Object(external_wp_i18n_["__"])('Block %1$s is at the beginning of the content and can’t be moved right'), type);
    }
  }
}
/**
 * Return a label for the block movement controls depending on block position.
 *
 * @param {number}  selectedCount Number of blocks selected.
 * @param {number}  firstIndex    The index (position - 1) of the first block selected.
 * @param {boolean} isFirst       This is the first block.
 * @param {boolean} isLast        This is the last block.
 * @param {number}  dir           Direction of movement (> 0 is considered to be going
 *                                 down, < 0 is up).
 *
 * @return {string} Label for the block movement controls.
 */

function getMultiBlockMoverDescription(selectedCount, firstIndex, isFirst, isLast, dir) {
  const position = firstIndex + 1;

  if (dir < 0 && isFirst) {
    return Object(external_wp_i18n_["__"])('Blocks cannot be moved up as they are already at the top');
  }

  if (dir > 0 && isLast) {
    return Object(external_wp_i18n_["__"])('Blocks cannot be moved down as they are already at the bottom');
  }

  if (dir < 0 && !isFirst) {
    return Object(external_wp_i18n_["sprintf"])( // translators: 1: Number of selected blocks, 2: Position of selected blocks
    Object(external_wp_i18n_["_n"])('Move %1$d block from position %2$d up by one place', 'Move %1$d blocks from position %2$d up by one place', selectedCount), selectedCount, position);
  }

  if (dir > 0 && !isLast) {
    return Object(external_wp_i18n_["sprintf"])( // translators: 1: Number of selected blocks, 2: Position of selected blocks
    Object(external_wp_i18n_["_n"])('Move %1$d block from position %2$d down by one place', 'Move %1$d blocks from position %2$d down by one place', selectedCount), selectedCount, position);
  }
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-mover/button.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */





const getArrowIcon = (direction, orientation) => {
  if (direction === 'up') {
    if (orientation === 'horizontal') {
      return Object(external_wp_i18n_["isRTL"])() ? chevron_right["a" /* default */] : chevron_left["a" /* default */];
    }

    return chevron_up["a" /* default */];
  } else if (direction === 'down') {
    if (orientation === 'horizontal') {
      return Object(external_wp_i18n_["isRTL"])() ? chevron_left["a" /* default */] : chevron_right["a" /* default */];
    }

    return chevron_down["a" /* default */];
  }

  return null;
};

const getMovementDirectionLabel = (moveDirection, orientation) => {
  if (moveDirection === 'up') {
    if (orientation === 'horizontal') {
      return Object(external_wp_i18n_["isRTL"])() ? Object(external_wp_i18n_["__"])('Move right') : Object(external_wp_i18n_["__"])('Move left');
    }

    return Object(external_wp_i18n_["__"])('Move up');
  } else if (moveDirection === 'down') {
    if (orientation === 'horizontal') {
      return Object(external_wp_i18n_["isRTL"])() ? Object(external_wp_i18n_["__"])('Move left') : Object(external_wp_i18n_["__"])('Move right');
    }

    return Object(external_wp_i18n_["__"])('Move down');
  }

  return null;
};

const BlockMoverButton = Object(external_wp_element_["forwardRef"])(({
  clientIds,
  direction,
  orientation: moverOrientation,
  ...props
}, ref) => {
  const instanceId = Object(external_wp_compose_["useInstanceId"])(BlockMoverButton);
  const blocksCount = Object(external_lodash_["castArray"])(clientIds).length;
  const {
    blockType,
    isDisabled,
    rootClientId,
    isFirst,
    isLast,
    firstIndex,
    orientation = 'vertical'
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getBlockIndex,
      getBlockRootClientId,
      getBlockOrder,
      getBlock,
      getBlockListSettings
    } = select(store);
    const normalizedClientIds = Object(external_lodash_["castArray"])(clientIds);
    const firstClientId = Object(external_lodash_["first"])(normalizedClientIds);
    const blockRootClientId = getBlockRootClientId(firstClientId);
    const firstBlockIndex = getBlockIndex(firstClientId, blockRootClientId);
    const lastBlockIndex = getBlockIndex(Object(external_lodash_["last"])(normalizedClientIds), blockRootClientId);
    const blockOrder = getBlockOrder(blockRootClientId);
    const block = getBlock(firstClientId);
    const isFirstBlock = firstBlockIndex === 0;
    const isLastBlock = lastBlockIndex === blockOrder.length - 1;
    const {
      orientation: blockListOrientation
    } = getBlockListSettings(blockRootClientId) || {};
    return {
      blockType: block ? Object(external_wp_blocks_["getBlockType"])(block.name) : null,
      isDisabled: direction === 'up' ? isFirstBlock : isLastBlock,
      rootClientId: blockRootClientId,
      firstIndex: firstBlockIndex,
      isFirst: isFirstBlock,
      isLast: isLastBlock,
      orientation: moverOrientation || blockListOrientation
    };
  }, [clientIds, direction]);
  const {
    moveBlocksDown,
    moveBlocksUp
  } = Object(external_wp_data_["useDispatch"])(store);
  const moverFunction = direction === 'up' ? moveBlocksUp : moveBlocksDown;

  const onClick = event => {
    moverFunction(clientIds, rootClientId);

    if (props.onClick) {
      props.onClick(event);
    }
  };

  const descriptionId = `block-editor-block-mover-button__description-${instanceId}`;
  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(external_wp_components_["Button"], Object(esm_extends["a" /* default */])({
    ref: ref,
    className: classnames_default()('block-editor-block-mover-button', `is-${direction}-button`),
    icon: getArrowIcon(direction, orientation),
    label: getMovementDirectionLabel(direction, orientation),
    "aria-describedby": descriptionId
  }, props, {
    onClick: isDisabled ? null : onClick,
    "aria-disabled": isDisabled
  })), Object(external_wp_element_["createElement"])("span", {
    id: descriptionId,
    className: "block-editor-block-mover-button__description"
  }, getBlockMoverDescription(blocksCount, blockType && blockType.title, firstIndex, isFirst, isLast, direction === 'up' ? -1 : 1, orientation)));
});
const BlockMoverUpButton = Object(external_wp_element_["forwardRef"])((props, ref) => {
  return Object(external_wp_element_["createElement"])(BlockMoverButton, Object(esm_extends["a" /* default */])({
    direction: "up",
    ref: ref
  }, props));
});
const BlockMoverDownButton = Object(external_wp_element_["forwardRef"])((props, ref) => {
  return Object(external_wp_element_["createElement"])(BlockMoverButton, Object(esm_extends["a" /* default */])({
    direction: "down",
    ref: ref
  }, props));
});

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-navigation/context.js
/**
 * WordPress dependencies
 */

const BlockNavigationContext = Object(external_wp_element_["createContext"])({
  __experimentalFeatures: false,
  __experimentalPersistentListViewFeatures: false
});
const useBlockNavigationContext = () => Object(external_wp_element_["useContext"])(BlockNavigationContext);

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/more-horizontal.js


/**
 * WordPress dependencies
 */

const moreHorizontal = Object(external_wp_element_["createElement"])(external_wp_primitives_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_primitives_["Path"], {
  d: "M11 13h2v-2h-2v2zm-6 0h2v-2H5v2zm12-2v2h2v-2h-2z"
}));
/* harmony default export */ var more_horizontal = (moreHorizontal);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/warning/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






function Warning({
  className,
  actions,
  children,
  secondaryActions
}) {
  return Object(external_wp_element_["createElement"])("div", {
    className: classnames_default()(className, 'block-editor-warning')
  }, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-warning__contents"
  }, Object(external_wp_element_["createElement"])("p", {
    className: "block-editor-warning__message"
  }, children), (external_wp_element_["Children"].count(actions) > 0 || secondaryActions) && Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-warning__actions"
  }, external_wp_element_["Children"].count(actions) > 0 && external_wp_element_["Children"].map(actions, (action, i) => Object(external_wp_element_["createElement"])("span", {
    key: i,
    className: "block-editor-warning__action"
  }, action)), secondaryActions && Object(external_wp_element_["createElement"])(external_wp_components_["DropdownMenu"], {
    className: "block-editor-warning__secondary",
    icon: more_horizontal,
    label: Object(external_wp_i18n_["__"])('More options'),
    popoverProps: {
      position: 'bottom left',
      className: 'block-editor-warning__dropdown'
    },
    noIcons: true
  }, () => Object(external_wp_element_["createElement"])(external_wp_components_["MenuGroup"], null, secondaryActions.map((item, pos) => Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
    onClick: item.onClick,
    key: pos
  }, item.title)))))));
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/warning/README.md
 */


/* harmony default export */ var warning = (Warning);

// EXTERNAL MODULE: ./node_modules/diff/lib/diff/character.js
var diff_character = __webpack_require__("iA5R");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-compare/block-view.js


/**
 * WordPress dependencies
 */



function BlockView({
  title,
  rawContent,
  renderedContent,
  action,
  actionText,
  className
}) {
  return Object(external_wp_element_["createElement"])("div", {
    className: className
  }, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-compare__content"
  }, Object(external_wp_element_["createElement"])("h2", {
    className: "block-editor-block-compare__heading"
  }, title), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-compare__html"
  }, rawContent), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-compare__preview edit-post-visual-editor"
  }, Object(external_wp_element_["createElement"])(external_wp_element_["RawHTML"], null, Object(external_wp_dom_["safeHTML"])(renderedContent)))), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-compare__action"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    isSecondary: true,
    tabIndex: "0",
    onClick: action
  }, actionText)));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-compare/index.js


/**
 * External dependencies
 */

 // diff doesn't tree-shake correctly, so we import from the individual
// module here, to avoid including too much of the library


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function BlockCompare({
  block,
  onKeep,
  onConvert,
  convertor,
  convertButtonText
}) {
  function getDifference(originalContent, newContent) {
    const difference = Object(diff_character["diffChars"])(originalContent, newContent);
    return difference.map((item, pos) => {
      const classes = classnames_default()({
        'block-editor-block-compare__added': item.added,
        'block-editor-block-compare__removed': item.removed
      });
      return Object(external_wp_element_["createElement"])("span", {
        key: pos,
        className: classes
      }, item.value);
    });
  }

  function getConvertedContent(convertedBlock) {
    // The convertor may return an array of items or a single item
    const newBlocks = Object(external_lodash_["castArray"])(convertedBlock); // Get converted block details

    const newContent = newBlocks.map(item => Object(external_wp_blocks_["getSaveContent"])(item.name, item.attributes, item.innerBlocks));
    return newContent.join('');
  }

  const converted = getConvertedContent(convertor(block));
  const difference = getDifference(block.originalContent, converted);
  return Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-compare__wrapper"
  }, Object(external_wp_element_["createElement"])(BlockView, {
    title: Object(external_wp_i18n_["__"])('Current'),
    className: "block-editor-block-compare__current",
    action: onKeep,
    actionText: Object(external_wp_i18n_["__"])('Convert to HTML'),
    rawContent: block.originalContent,
    renderedContent: block.originalContent
  }), Object(external_wp_element_["createElement"])(BlockView, {
    title: Object(external_wp_i18n_["__"])('After Conversion'),
    className: "block-editor-block-compare__converted",
    action: onConvert,
    actionText: convertButtonText,
    rawContent: difference,
    renderedContent: converted
  }));
}

/* harmony default export */ var block_compare = (BlockCompare);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/block-invalid-warning.js


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




function BlockInvalidWarning({
  convertToHTML,
  convertToBlocks,
  convertToClassic,
  attemptBlockRecovery,
  block
}) {
  const hasHTMLBlock = !!Object(external_wp_blocks_["getBlockType"])('core/html');
  const [compare, setCompare] = Object(external_wp_element_["useState"])(false);
  const onCompare = Object(external_wp_element_["useCallback"])(() => setCompare(true), []);
  const onCompareClose = Object(external_wp_element_["useCallback"])(() => setCompare(false), []); // We memo the array here to prevent the children components from being updated unexpectedly

  const hiddenActions = Object(external_wp_element_["useMemo"])(() => [{
    // translators: Button to fix block content
    title: Object(external_wp_i18n_["_x"])('Resolve', 'imperative verb'),
    onClick: onCompare
  }, hasHTMLBlock && {
    title: Object(external_wp_i18n_["__"])('Convert to HTML'),
    onClick: convertToHTML
  }, {
    title: Object(external_wp_i18n_["__"])('Convert to Classic Block'),
    onClick: convertToClassic
  }].filter(Boolean), [onCompare, convertToHTML, convertToClassic]);
  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(warning, {
    actions: [Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
      key: "recover",
      onClick: attemptBlockRecovery,
      isPrimary: true
    }, Object(external_wp_i18n_["__"])('Attempt Block Recovery'))],
    secondaryActions: hiddenActions
  }, Object(external_wp_i18n_["__"])('This block contains unexpected or invalid content.')), compare && Object(external_wp_element_["createElement"])(external_wp_components_["Modal"], {
    title: // translators: Dialog title to fix block content
    Object(external_wp_i18n_["__"])('Resolve Block'),
    onRequestClose: onCompareClose,
    className: "block-editor-block-compare"
  }, Object(external_wp_element_["createElement"])(block_compare, {
    block: block,
    onKeep: convertToHTML,
    onConvert: convertToBlocks,
    convertor: blockToBlocks,
    convertButtonText: Object(external_wp_i18n_["__"])('Convert to Blocks')
  })));
}

const blockToClassic = block => Object(external_wp_blocks_["createBlock"])('core/freeform', {
  content: block.originalContent
});

const blockToHTML = block => Object(external_wp_blocks_["createBlock"])('core/html', {
  content: block.originalContent
});

const blockToBlocks = block => Object(external_wp_blocks_["rawHandler"])({
  HTML: block.originalContent
});

const recoverBlock = ({
  name,
  attributes,
  innerBlocks
}) => Object(external_wp_blocks_["createBlock"])(name, attributes, innerBlocks);

/* harmony default export */ var block_invalid_warning = (Object(external_wp_compose_["compose"])([Object(external_wp_data_["withSelect"])((select, {
  clientId
}) => ({
  block: select(store).getBlock(clientId)
})), Object(external_wp_data_["withDispatch"])((dispatch, {
  block
}) => {
  const {
    replaceBlock
  } = dispatch(store);
  return {
    convertToClassic() {
      replaceBlock(block.clientId, blockToClassic(block));
    },

    convertToHTML() {
      replaceBlock(block.clientId, blockToHTML(block));
    },

    convertToBlocks() {
      replaceBlock(block.clientId, blockToBlocks(block));
    },

    attemptBlockRecovery() {
      replaceBlock(block.clientId, recoverBlock(block));
    }

  };
})])(BlockInvalidWarning));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/block-crash-warning.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


const block_crash_warning_warning = Object(external_wp_element_["createElement"])(warning, {
  className: "block-editor-block-list__block-crash-warning"
}, Object(external_wp_i18n_["__"])('This block has encountered an error and cannot be previewed.'));
/* harmony default export */ var block_crash_warning = (() => block_crash_warning_warning);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/block-crash-boundary.js
/**
 * WordPress dependencies
 */


class block_crash_boundary_BlockCrashBoundary extends external_wp_element_["Component"] {
  constructor() {
    super(...arguments);
    this.state = {
      hasError: false
    };
  }

  componentDidCatch() {
    this.setState({
      hasError: true
    });
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }

    return this.props.children;
  }

}

/* harmony default export */ var block_crash_boundary = (block_crash_boundary_BlockCrashBoundary);

// EXTERNAL MODULE: ./node_modules/react-autosize-textarea/lib/index.js
var lib = __webpack_require__("O6Fj");
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/block-html.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



function BlockHTML({
  clientId
}) {
  const [html, setHtml] = Object(external_wp_element_["useState"])('');
  const block = Object(external_wp_data_["useSelect"])(select => select(store).getBlock(clientId), [clientId]);
  const {
    updateBlock
  } = Object(external_wp_data_["useDispatch"])(store);

  const onChange = () => {
    const blockType = Object(external_wp_blocks_["getBlockType"])(block.name);
    const attributes = Object(external_wp_blocks_["getBlockAttributes"])(blockType, html, block.attributes); // If html is empty  we reset the block to the default HTML and mark it as valid to avoid triggering an error

    const content = html ? html : Object(external_wp_blocks_["getSaveContent"])(blockType, attributes);
    const isValid = html ? Object(external_wp_blocks_["isValidBlockContent"])(blockType, attributes, content) : true;
    updateBlock(clientId, {
      attributes,
      originalContent: content,
      isValid
    }); // Ensure the state is updated if we reset so it displays the default content

    if (!html) {
      setHtml({
        content
      });
    }
  };

  Object(external_wp_element_["useEffect"])(() => {
    setHtml(Object(external_wp_blocks_["getBlockContent"])(block));
  }, [block]);
  return Object(external_wp_element_["createElement"])(lib_default.a, {
    className: "block-editor-block-list__block-html-textarea",
    value: html,
    onBlur: onChange,
    onChange: event => setHtml(event.target.value)
  });
}

/* harmony default export */ var block_html = (BlockHTML);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/dom.js
const BLOCK_SELECTOR = '.block-editor-block-list__block';
/**
 * Returns true if two elements are contained within the same block.
 *
 * @param {Element} a First element.
 * @param {Element} b Second element.
 *
 * @return {boolean} Whether elements are in the same block.
 */

function isInSameBlock(a, b) {
  return a.closest(BLOCK_SELECTOR) === b.closest(BLOCK_SELECTOR);
}
/**
 * Returns true if an element is considered part of the block and not its
 * children.
 *
 * @param {Element} blockElement Block container element.
 * @param {Element} element      Element.
 *
 * @return {boolean} Whether element is in the block Element but not its
 *                   children.
 */

function isInsideRootBlock(blockElement, element) {
  const parentBlock = element.closest(BLOCK_SELECTOR);
  return parentBlock === blockElement;
}
/**
 * Finds the block client ID given any DOM node inside the block.
 *
 * @param {Node?} node DOM node.
 *
 * @return {string|undefined} Client ID or undefined if the node is not part of
 *                            a block.
 */

function getBlockClientId(node) {
  while (node && node.nodeType !== node.ELEMENT_NODE) {
    node = node.parentNode;
  }

  if (!node) {
    return;
  }

  const elementNode =
  /** @type {Element} */
  node;
  const blockNode = elementNode.closest(BLOCK_SELECTOR);

  if (!blockNode) {
    return;
  }

  return blockNode.id.slice('block-'.length);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-focus-first-element.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



/** @typedef {import('@wordpress/element').RefObject} RefObject */

/**
 * Returns the initial position if the block needs to be focussed, `undefined`
 * otherwise. The initial position is either 0 (start) or -1 (end).
 *
 * @param {string} clientId Block client ID.
 *
 * @return {number} The initial position, either 0 (start) or -1 (end).
 */

function useInitialPosition(clientId) {
  return Object(external_wp_data_["useSelect"])(select => {
    const {
      getSelectedBlocksInitialCaretPosition,
      isMultiSelecting,
      isNavigationMode,
      isBlockSelected
    } = select(store);

    if (!isBlockSelected(clientId)) {
      return;
    }

    if (isMultiSelecting() || isNavigationMode()) {
      return;
    } // If there's no initial position, return 0 to focus the start.


    return getSelectedBlocksInitialCaretPosition();
  }, [clientId]);
}
/**
 * Transitions focus to the block or inner tabbable when the block becomes
 * selected and an initial position is set.
 *
 * @param {string} clientId Block client ID.
 *
 * @return {RefObject} React ref with the block element.
 */


function useFocusFirstElement(clientId) {
  const ref = Object(external_wp_element_["useRef"])();
  const initialPosition = useInitialPosition(clientId);
  Object(external_wp_element_["useEffect"])(() => {
    if (initialPosition === undefined || initialPosition === null) {
      return;
    }

    if (!ref.current) {
      return;
    }

    const {
      ownerDocument
    } = ref.current; // Do not focus the block if it already contains the active element.

    if (ref.current.contains(ownerDocument.activeElement)) {
      return;
    } // Find all tabbables within node.


    const textInputs = external_wp_dom_["focus"].tabbable.find(ref.current).filter(node => Object(external_wp_dom_["isTextField"])(node)); // If reversed (e.g. merge via backspace), use the last in the set of
    // tabbables.

    const isReverse = -1 === initialPosition;
    const target = (isReverse ? external_lodash_["last"] : external_lodash_["first"])(textInputs) || ref.current;

    if ( // Don't focus inner block or block appenders.
    !isInsideRootBlock(ref.current, target) || target.closest('.block-list-appender')) {
      ref.current.focus();
      return;
    }

    Object(external_wp_dom_["placeCaretAtHorizontalEdge"])(target, isReverse);
  }, [initialPosition]);
  return ref;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-is-hovered.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function listener(event) {
  if (event.defaultPrevented) {
    return;
  }

  const action = event.type === 'mouseover' ? 'add' : 'remove';
  event.preventDefault();
  event.currentTarget.classList[action]('is-hovered');
}
/**
 * Adds `is-hovered` class when the block is hovered and in navigation or
 * outline mode.
 */


function useIsHovered() {
  const isEnabled = Object(external_wp_data_["useSelect"])(select => {
    const {
      isNavigationMode,
      getSettings
    } = select(store);
    return isNavigationMode() || getSettings().outlineMode;
  }, []);
  return Object(external_wp_compose_["useRefEffect"])(node => {
    if (isEnabled) {
      node.addEventListener('mouseout', listener);
      node.addEventListener('mouseover', listener);
      return () => {
        node.removeEventListener('mouseout', listener);
        node.removeEventListener('mouseover', listener); // Remove class in case it lingers.

        node.classList.remove('is-hovered');
      };
    }
  }, [isEnabled]);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-class-names.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Returns the class names used for the different states of the block.
 *
 * @param {string} clientId The block client ID.
 *
 * @return {string} The class names.
 */

function useBlockClassNames(clientId) {
  return Object(external_wp_data_["useSelect"])(select => {
    const {
      isBlockBeingDragged,
      isBlockHighlighted,
      isBlockSelected,
      isBlockMultiSelected,
      getBlockName,
      getSettings,
      hasSelectedInnerBlock,
      isTyping,
      __experimentalGetActiveBlockIdByBlockNames: getActiveBlockIdByBlockNames
    } = select(store);
    const {
      __experimentalSpotlightEntityBlocks: spotlightEntityBlocks,
      outlineMode
    } = getSettings();
    const isDragging = isBlockBeingDragged(clientId);
    const isSelected = isBlockSelected(clientId);
    const name = getBlockName(clientId);
    const checkDeep = true; // "ancestor" is the more appropriate label due to "deep" check

    const isAncestorOfSelectedBlock = hasSelectedInnerBlock(clientId, checkDeep);
    const activeEntityBlockId = getActiveBlockIdByBlockNames(spotlightEntityBlocks);
    return classnames_default()({
      'is-selected': isSelected,
      'is-highlighted': isBlockHighlighted(clientId),
      'is-multi-selected': isBlockMultiSelected(clientId),
      'is-reusable': Object(external_wp_blocks_["isReusableBlock"])(Object(external_wp_blocks_["getBlockType"])(name)),
      'is-dragging': isDragging,
      'has-child-selected': isAncestorOfSelectedBlock,
      'has-active-entity': activeEntityBlockId,
      // Determine if there is an active entity area to spotlight.
      'is-active-entity': activeEntityBlockId === clientId,
      'remove-outline': isSelected && outlineMode && isTyping()
    });
  }, [clientId]);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-default-class-name.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Returns the default class name if the block is a light block and it supports
 * `className`.
 *
 * @param {string} clientId The block client ID.
 *
 * @return {string} The class name, e.g. `wp-block-paragraph`.
 */

function useBlockDefaultClassName(clientId) {
  return Object(external_wp_data_["useSelect"])(select => {
    const name = select(store).getBlockName(clientId);
    const blockType = Object(external_wp_blocks_["getBlockType"])(name);
    const hasLightBlockWrapper = blockType.apiVersion > 1 || Object(external_wp_blocks_["hasBlockSupport"])(blockType, 'lightBlockWrapper', false);

    if (!hasLightBlockWrapper) {
      return;
    }

    return Object(external_wp_blocks_["getBlockDefaultClassName"])(name);
  }, [clientId]);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-custom-class-name.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Returns the custom class name if the block is a light block.
 *
 * @param {string} clientId The block client ID.
 *
 * @return {string} The custom class name.
 */

function useBlockCustomClassName(clientId) {
  // It's good for this to be a separate selector because it will be executed
  // on every attribute change, while the other selectors are not re-evaluated
  // as much.
  return Object(external_wp_data_["useSelect"])(select => {
    const {
      getBlockName,
      getBlockAttributes
    } = select(store);
    const {
      className
    } = getBlockAttributes(clientId);

    if (!className) {
      return;
    }

    const blockType = Object(external_wp_blocks_["getBlockType"])(getBlockName(clientId));
    const hasLightBlockWrapper = blockType.apiVersion > 1 || Object(external_wp_blocks_["hasBlockSupport"])(blockType, 'lightBlockWrapper', false);

    if (!hasLightBlockWrapper) {
      return;
    }

    return className;
  }, [clientId]);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-moving-mode-class-names.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Returns the class names used for block moving mode.
 *
 * @param {string} clientId The block client ID to insert above.
 *
 * @return {string} The class names.
 */

function useBlockMovingModeClassNames(clientId) {
  return Object(external_wp_data_["useSelect"])(select => {
    const {
      hasBlockMovingClientId,
      canInsertBlockType,
      getBlockName,
      getBlockRootClientId,
      isBlockSelected
    } = select(store); // The classes are only relevant for the selected block. Avoid
    // re-rendering all blocks!

    if (!isBlockSelected(clientId)) {
      return;
    }

    const movingClientId = hasBlockMovingClientId();

    if (!movingClientId) {
      return;
    }

    return classnames_default()('is-block-moving-mode', {
      'can-insert-moving-block': canInsertBlockType(getBlockName(movingClientId), getBlockRootClientId(clientId))
    });
  }, [clientId]);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-focus-handler.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/**
 * Selects the block if it receives focus.
 *
 * @param {string} clientId Block client ID.
 */

function useFocusHandler(clientId) {
  const {
    isBlockSelected
  } = Object(external_wp_data_["useSelect"])(store);
  const {
    selectBlock,
    selectionChange
  } = Object(external_wp_data_["useDispatch"])(store);
  return Object(external_wp_compose_["useRefEffect"])(node => {
    /**
     * Marks the block as selected when focused and not already
     * selected. This specifically handles the case where block does not
     * set focus on its own (via `setFocus`), typically if there is no
     * focusable input in the block.
     *
     * @param {FocusEvent} event Focus event.
     */
    function onFocus(event) {
      // Check synchronously because a non-selected block might be
      // getting data through `useSelect` asynchronously.
      if (isBlockSelected(clientId)) {
        // Potentially change selection away from rich text.
        if (!event.target.isContentEditable) {
          selectionChange(clientId);
        }

        return;
      } // If an inner block is focussed, that block is resposible for
      // setting the selected block.


      if (!isInsideRootBlock(node, event.target)) {
        return;
      }

      selectBlock(clientId);
    }

    node.addEventListener('focusin', onFocus);
    return () => {
      node.removeEventListener('focusin', onFocus);
    };
  }, [isBlockSelected, selectBlock]);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-selected-block-event-handlers.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/**
 * Adds block behaviour:
 *   - Removes the block on BACKSPACE.
 *   - Inserts a default block on ENTER.
 *   - Disables dragging of block contents.
 *
 * @param {string} clientId Block client ID.
 */

function useEventHandlers(clientId) {
  const isSelected = Object(external_wp_data_["useSelect"])(select => select(store).isBlockSelected(clientId), [clientId]);
  const {
    getBlockRootClientId,
    getBlockIndex
  } = Object(external_wp_data_["useSelect"])(store);
  const {
    insertDefaultBlock,
    removeBlock
  } = Object(external_wp_data_["useDispatch"])(store);
  return Object(external_wp_compose_["useRefEffect"])(node => {
    if (!isSelected) {
      return;
    }
    /**
     * Interprets keydown event intent to remove or insert after block if
     * key event occurs on wrapper node. This can occur when the block has
     * no text fields of its own, particularly after initial insertion, to
     * allow for easy deletion and continuous writing flow to add additional
     * content.
     *
     * @param {KeyboardEvent} event Keydown event.
     */


    function onKeyDown(event) {
      const {
        keyCode,
        target
      } = event;

      if (keyCode !== external_wp_keycodes_["ENTER"] && keyCode !== external_wp_keycodes_["BACKSPACE"] && keyCode !== external_wp_keycodes_["DELETE"]) {
        return;
      }

      if (target !== node || Object(external_wp_dom_["isTextField"])(target)) {
        return;
      }

      event.preventDefault();

      if (keyCode === external_wp_keycodes_["ENTER"]) {
        insertDefaultBlock({}, getBlockRootClientId(clientId), getBlockIndex(clientId) + 1);
      } else {
        removeBlock(clientId);
      }
    }
    /**
     * Prevents default dragging behavior within a block. To do: we must
     * handle this in the future and clean up the drag target.
     *
     * @param {DragEvent} event Drag event.
     */


    function onDragStart(event) {
      event.preventDefault();
    }

    node.addEventListener('keydown', onKeyDown);
    node.addEventListener('dragstart', onDragStart);
    return () => {
      node.removeEventListener('keydown', onKeyDown);
      node.removeEventListener('dragstart', onDragStart);
    };
  }, [clientId, isSelected, getBlockRootClientId, getBlockIndex, insertDefaultBlock, removeBlock]);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-nav-mode-exit.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Allows navigation mode to be exited by clicking in the selected block.
 *
 * @param {string} clientId Block client ID.
 */

function useNavModeExit(clientId) {
  const {
    isNavigationMode,
    isBlockSelected
  } = Object(external_wp_data_["useSelect"])(store);
  const {
    setNavigationMode,
    selectBlock
  } = Object(external_wp_data_["useDispatch"])(store);
  return Object(external_wp_compose_["useRefEffect"])(node => {
    function onMouseDown(event) {
      // Don't select a block if it's already handled by a child
      // block.
      if (isNavigationMode() && !event.defaultPrevented) {
        // Prevent focus from moving to the block.
        event.preventDefault(); // When clicking on a selected block, exit navigation mode.

        if (isBlockSelected(clientId)) {
          setNavigationMode(false);
        } else {
          selectBlock(clientId);
        }
      }
    }

    node.addEventListener('mousedown', onMouseDown);
    return () => {
      node.addEventListener('mousedown', onMouseDown);
    };
  }, [clientId, isNavigationMode, isBlockSelected, setNavigationMode]);
}

// EXTERNAL MODULE: ./node_modules/dom-scroll-into-view/lib/index.js
var dom_scroll_into_view_lib = __webpack_require__("9Do8");
var dom_scroll_into_view_lib_default = /*#__PURE__*/__webpack_require__.n(dom_scroll_into_view_lib);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-scroll-into-view.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


function useScrollIntoView(clientId) {
  const ref = Object(external_wp_element_["useRef"])();
  const isSelectionEnd = Object(external_wp_data_["useSelect"])(select => {
    const {
      isBlockSelected,
      getBlockSelectionEnd
    } = select(store);
    return isBlockSelected(clientId) || getBlockSelectionEnd() === clientId;
  }, [clientId]); // Note that we can't use `useRefEffect` here, since an element change does
  // not mean we can scroll. `isSelectionEnd` should be the sole dependency,
  // while with `useRefEffect`, the element is a dependency as well.

  Object(external_wp_element_["useEffect"])(() => {
    if (!isSelectionEnd) {
      return;
    }

    const extentNode = ref.current;

    if (!extentNode) {
      return;
    } // If the block is focused, the browser will already have scrolled into
    // view if necessary.


    if (extentNode.contains(extentNode.ownerDocument.activeElement)) {
      return;
    }

    const scrollContainer = Object(external_wp_dom_["getScrollContainer"])(extentNode) || extentNode.ownerDocument.defaultView; // If there's no scroll container, it follows that there's no scrollbar
    // and thus there's no need to try to scroll into view.

    if (!scrollContainer) {
      return;
    }

    dom_scroll_into_view_lib_default()(extentNode, scrollContainer, {
      onlyScrollIfNeeded: true
    });
  }, [isSelectionEnd]);
  return ref;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-multi-selection.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function toggleRichText(container, toggle) {
  Array.from(container.closest('.is-root-container').querySelectorAll('.rich-text')).forEach(node => {
    if (toggle) {
      node.setAttribute('contenteditable', true);
    } else {
      node.removeAttribute('contenteditable');
    }
  });
}
/**
 * Sets a multi-selection based on the native selection across blocks.
 *
 * @param {string} clientId Block client ID.
 */


function useMultiSelection(clientId) {
  const {
    startMultiSelect,
    stopMultiSelect,
    multiSelect,
    selectBlock
  } = Object(external_wp_data_["useDispatch"])(store);
  const {
    isSelectionEnabled,
    isBlockSelected,
    getBlockParents,
    getBlockSelectionStart,
    hasMultiSelection
  } = Object(external_wp_data_["useSelect"])(store);
  return Object(external_wp_compose_["useRefEffect"])(node => {
    const {
      ownerDocument
    } = node;
    const {
      defaultView
    } = ownerDocument;
    let anchorElement;
    let rafId;

    function onSelectionChange({
      isSelectionEnd
    }) {
      const selection = defaultView.getSelection(); // If no selection is found, end multi selection and enable all rich
      // text areas.

      if (!selection.rangeCount || selection.isCollapsed) {
        toggleRichText(node, true);
        return;
      }

      const endClientId = getBlockClientId(selection.focusNode);
      const isSingularSelection = clientId === endClientId;

      if (isSingularSelection) {
        selectBlock(clientId); // If the selection is complete (on mouse up), and no
        // multiple blocks have been selected, set focus back to the
        // anchor element. if the anchor element contains the
        // selection. Additionally, rich text elements that were
        // previously disabled can now be enabled again.

        if (isSelectionEnd) {
          toggleRichText(node, true);

          if (selection.rangeCount) {
            const {
              commonAncestorContainer
            } = selection.getRangeAt(0);

            if (anchorElement.contains(commonAncestorContainer)) {
              anchorElement.focus();
            }
          }
        }
      } else {
        const startPath = [...getBlockParents(clientId), clientId];
        const endPath = [...getBlockParents(endClientId), endClientId];
        const depth = Math.min(startPath.length, endPath.length) - 1;
        multiSelect(startPath[depth], endPath[depth]);
      }
    }

    function onSelectionEnd() {
      ownerDocument.removeEventListener('selectionchange', onSelectionChange); // Equivalent to attaching the listener once.

      defaultView.removeEventListener('mouseup', onSelectionEnd); // The browser selection won't have updated yet at this point,
      // so wait until the next animation frame to get the browser
      // selection.

      rafId = defaultView.requestAnimationFrame(() => {
        onSelectionChange({
          isSelectionEnd: true
        });
        stopMultiSelect();
      });
    }

    function onMouseLeave({
      buttons
    }) {
      // The primary button must be pressed to initiate selection.
      // See https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
      if (buttons !== 1) {
        return;
      }

      if (!isSelectionEnabled() || !isBlockSelected(clientId)) {
        return;
      }

      anchorElement = ownerDocument.activeElement;
      startMultiSelect(); // `onSelectionStart` is called after `mousedown` and
      // `mouseleave` (from a block). The selection ends when
      // `mouseup` happens anywhere in the window.

      ownerDocument.addEventListener('selectionchange', onSelectionChange);
      defaultView.addEventListener('mouseup', onSelectionEnd); // Removing the contenteditable attributes within the block
      // editor is essential for selection to work across editable
      // areas. The edible hosts are removed, allowing selection to be
      // extended outside the DOM element. `startMultiSelect` sets a
      // flag in the store so the rich text components are updated,
      // but the rerender may happen very slowly, especially in Safari
      // for the blocks that are asynchonously rendered. To ensure the
      // browser instantly removes the selection boundaries, we remove
      // the contenteditable attributes manually.

      toggleRichText(node, false);
    }

    function onMouseDown(event) {
      // The main button.
      // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
      if (!isSelectionEnabled() || event.button !== 0) {
        return;
      }

      if (event.shiftKey) {
        const blockSelectionStart = getBlockSelectionStart();

        if (blockSelectionStart !== clientId) {
          toggleRichText(node, false);
          multiSelect(blockSelectionStart, clientId);
          event.preventDefault();
        }
      } else if (hasMultiSelection()) {
        // Allow user to escape out of a multi-selection to a
        // singular selection of a block via click. This is handled
        // here since focus handling excludes blocks when there is
        // multiselection, as focus can be incurred by starting a
        // multiselection (focus moved to first block's multi-
        // controls).
        selectBlock(clientId);
      }
    }

    node.addEventListener('mousedown', onMouseDown);
    node.addEventListener('mouseleave', onMouseLeave);
    return () => {
      node.removeEventListener('mousedown', onMouseDown);
      node.removeEventListener('mouseleave', onMouseLeave);
      ownerDocument.removeEventListener('selectionchange', onSelectionChange);
      defaultView.removeEventListener('mouseup', onSelectionEnd);
      defaultView.cancelAnimationFrame(rafId);
    };
  }, [clientId, startMultiSelect, stopMultiSelect, multiSelect, selectBlock, isSelectionEnabled, isBlockSelected, getBlockParents]);
}

// EXTERNAL MODULE: external ["wp","htmlEntities"]
var external_wp_htmlEntities_ = __webpack_require__("rmEH");

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/plus.js
var plus = __webpack_require__("Q4Sy");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/tips.js


/**
 * WordPress dependencies
 */



const globalTips = [Object(external_wp_element_["createInterpolateElement"])(Object(external_wp_i18n_["__"])('While writing, you can press <kbd>/</kbd> to quickly insert new blocks.'), {
  kbd: Object(external_wp_element_["createElement"])("kbd", null)
}), Object(external_wp_element_["createInterpolateElement"])(Object(external_wp_i18n_["__"])('Indent a list by pressing <kbd>space</kbd> at the beginning of a line.'), {
  kbd: Object(external_wp_element_["createElement"])("kbd", null)
}), Object(external_wp_element_["createInterpolateElement"])(Object(external_wp_i18n_["__"])('Outdent a list by pressing <kbd>backspace</kbd> at the beginning of a line.'), {
  kbd: Object(external_wp_element_["createElement"])("kbd", null)
}), Object(external_wp_i18n_["__"])('Drag files into the editor to automatically insert media blocks.'), Object(external_wp_i18n_["__"])("Change a block's type by pressing the block icon on the toolbar.")];

function Tips() {
  const [randomIndex] = Object(external_wp_element_["useState"])( // Disable Reason: I'm not generating an HTML id.
  // eslint-disable-next-line no-restricted-syntax
  Math.floor(Math.random() * globalTips.length));
  return Object(external_wp_element_["createElement"])(external_wp_components_["Tip"], null, globalTips[randomIndex]);
}

/* harmony default export */ var tips = (Tips);

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/close-small.js
var close_small = __webpack_require__("bWcr");

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/search.js
var search = __webpack_require__("cGtP");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/search-form.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */







function InserterSearchForm({
  className,
  onChange,
  value,
  label,
  placeholder
}) {
  const instanceId = Object(external_wp_compose_["useInstanceId"])(InserterSearchForm);
  const searchInput = Object(external_wp_element_["useRef"])();
  return Object(external_wp_element_["createElement"])("div", {
    className: classnames_default()('block-editor-inserter__search', className)
  }, Object(external_wp_element_["createElement"])(external_wp_components_["VisuallyHidden"], {
    as: "label",
    htmlFor: `block-editor-inserter__search-${instanceId}`
  }, label || placeholder), Object(external_wp_element_["createElement"])("input", {
    ref: searchInput,
    className: "block-editor-inserter__search-input",
    id: `block-editor-inserter__search-${instanceId}`,
    type: "search",
    placeholder: placeholder,
    onChange: event => onChange(event.target.value),
    autoComplete: "off",
    value: value || ''
  }), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-inserter__search-icon"
  }, !!value && Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    icon: close_small["a" /* default */],
    label: Object(external_wp_i18n_["__"])('Reset search'),
    onClick: () => {
      onChange('');
      searchInput.current.focus();
    }
  }), !value && Object(external_wp_element_["createElement"])(build_module_icon["a" /* default */], {
    icon: search["a" /* default */]
  })));
}

/* harmony default export */ var search_form = (InserterSearchForm);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-card/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



function BlockCard({
  title,
  icon,
  description,
  blockType
}) {
  if (blockType) {
    external_wp_deprecated_default()('`blockType` property in `BlockCard component`', {
      since: '5.7',
      alternative: '`title, icon and description` properties'
    });
    ({
      title,
      icon,
      description
    } = blockType);
  }

  return Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-card"
  }, Object(external_wp_element_["createElement"])(BlockIcon, {
    icon: icon,
    showColors: true
  }), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-card__content"
  }, Object(external_wp_element_["createElement"])("h2", {
    className: "block-editor-block-card__title"
  }, title), Object(external_wp_element_["createElement"])("span", {
    className: "block-editor-block-card__description"
  }, description)));
}

/* harmony default export */ var block_card = (BlockCard);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/provider/with-registry-provider.js



/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



const withRegistryProvider = Object(external_wp_compose_["createHigherOrderComponent"])(WrappedComponent => {
  return Object(external_wp_data_["withRegistry"])(({
    useSubRegistry = true,
    registry,
    ...props
  }) => {
    if (!useSubRegistry) {
      return Object(external_wp_element_["createElement"])(WrappedComponent, Object(esm_extends["a" /* default */])({
        registry: registry
      }, props));
    }

    const [subRegistry, setSubRegistry] = Object(external_wp_element_["useState"])(null);
    Object(external_wp_element_["useEffect"])(() => {
      const newRegistry = Object(external_wp_data_["createRegistry"])({}, registry);
      newRegistry.registerStore(STORE_NAME, storeConfig);
      setSubRegistry(newRegistry);
    }, [registry]);

    if (!subRegistry) {
      return null;
    }

    return Object(external_wp_element_["createElement"])(external_wp_data_["RegistryProvider"], {
      value: subRegistry
    }, Object(external_wp_element_["createElement"])(WrappedComponent, Object(esm_extends["a" /* default */])({
      registry: subRegistry
    }, props)));
  });
}, 'withRegistryProvider');
/* harmony default export */ var with_registry_provider = (withRegistryProvider);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/provider/use-block-sync.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/**
 * A function to call when the block value has been updated in the block-editor
 * store.
 *
 * @callback onBlockUpdate
 * @param {Object[]} blocks  The updated blocks.
 * @param {Object}   options The updated block options, such as selectionStart
 *                           and selectionEnd.
 */

/**
 * useBlockSync is a side effect which handles bidirectional sync between the
 * block-editor store and a controlling data source which provides blocks. This
 * is most commonly used by the BlockEditorProvider to synchronize the contents
 * of the block-editor store with the root entity, like a post.
 *
 * Another example would be the template part block, which provides blocks from
 * a separate entity data source than a root entity. This hook syncs edits to
 * the template part in the block editor back to the entity and vice-versa.
 *
 * Here are some of its basic functions:
 * - Initalizes the block-editor store for the given clientID to the blocks
 *   given via props.
 * - Adds incoming changes (like undo) to the block-editor store.
 * - Adds outgoing changes (like editing content) to the controlling entity,
 *   determining if a change should be considered persistent or not.
 * - Handles edge cases and race conditions which occur in those operations.
 * - Ignores changes which happen to other entities (like nested inner block
 *   controllers.
 * - Passes selection state from the block-editor store to the controlling entity.
 *
 * @param {Object} props Props for the block sync hook
 * @param {string} props.clientId The client ID of the inner block controller.
 *                                If none is passed, then it is assumed to be a
 *                                root controller rather than an inner block
 *                                controller.
 * @param {Object[]} props.value  The control value for the blocks. This value
 *                                is used to initalize the block-editor store
 *                                and for resetting the blocks to incoming
 *                                changes like undo.
 * @param {Object} props.selection The selection state responsible to restore the selection on undo/redo.
 * @param {onBlockUpdate} props.onChange Function to call when a persistent
 *                                change has been made in the block-editor blocks
 *                                for the given clientId. For example, after
 *                                this function is called, an entity is marked
 *                                dirty because it has changes to save.
 * @param {onBlockUpdate} props.onInput Function to call when a non-persistent
 *                                change has been made in the block-editor blocks
 *                                for the given clientId. When this is called,
 *                                controlling sources do not become dirty.
 */

function useBlockSync({
  clientId = null,
  value: controlledBlocks,
  selection: controlledSelection,
  onChange = external_lodash_["noop"],
  onInput = external_lodash_["noop"]
}) {
  const registry = Object(external_wp_data_["useRegistry"])();
  const {
    resetBlocks,
    resetSelection,
    replaceInnerBlocks,
    setHasControlledInnerBlocks,
    __unstableMarkNextChangeAsNotPersistent
  } = registry.dispatch(store);
  const {
    getBlockName,
    getBlocks
  } = registry.select(store);
  const pendingChanges = Object(external_wp_element_["useRef"])({
    incoming: null,
    outgoing: []
  });
  const subscribed = Object(external_wp_element_["useRef"])(false);

  const setControlledBlocks = () => {
    if (!controlledBlocks) {
      return;
    } // We don't need to persist this change because we only replace
    // controlled inner blocks when the change was caused by an entity,
    // and so it would already be persisted.


    __unstableMarkNextChangeAsNotPersistent();

    if (clientId) {
      setHasControlledInnerBlocks(clientId, true);

      __unstableMarkNextChangeAsNotPersistent();

      const storeBlocks = controlledBlocks.map(block => Object(external_wp_blocks_["cloneBlock"])(block));

      if (subscribed.current) {
        pendingChanges.current.incoming = storeBlocks;
      }

      replaceInnerBlocks(clientId, storeBlocks);
    } else {
      if (subscribed.current) {
        pendingChanges.current.incoming = controlledBlocks;
      }

      resetBlocks(controlledBlocks);
    }
  }; // Add a subscription to the block-editor registry to detect when changes
  // have been made. This lets us inform the data source of changes. This
  // is an effect so that the subscriber can run synchronously without
  // waiting for React renders for changes.


  const onInputRef = Object(external_wp_element_["useRef"])(onInput);
  const onChangeRef = Object(external_wp_element_["useRef"])(onChange);
  Object(external_wp_element_["useEffect"])(() => {
    onInputRef.current = onInput;
    onChangeRef.current = onChange;
  }, [onInput, onChange]); // Determine if blocks need to be reset when they change.

  Object(external_wp_element_["useEffect"])(() => {
    if (pendingChanges.current.outgoing.includes(controlledBlocks)) {
      // Skip block reset if the value matches expected outbound sync
      // triggered by this component by a preceding change detection.
      // Only skip if the value matches expectation, since a reset should
      // still occur if the value is modified (not equal by reference),
      // to allow that the consumer may apply modifications to reflect
      // back on the editor.
      if (Object(external_lodash_["last"])(pendingChanges.current.outgoing) === controlledBlocks) {
        pendingChanges.current.outgoing = [];
      }
    } else if (getBlocks(clientId) !== controlledBlocks) {
      // Reset changing value in all other cases than the sync described
      // above. Since this can be reached in an update following an out-
      // bound sync, unset the outbound value to avoid considering it in
      // subsequent renders.
      pendingChanges.current.outgoing = [];
      setControlledBlocks();

      if (controlledSelection) {
        resetSelection(controlledSelection.selectionStart, controlledSelection.selectionEnd, controlledSelection.initialPosition);
      }
    }
  }, [controlledBlocks, clientId]);
  Object(external_wp_element_["useEffect"])(() => {
    const {
      getSelectionStart,
      getSelectionEnd,
      getSelectedBlocksInitialCaretPosition,
      isLastBlockChangePersistent,
      __unstableIsLastBlockChangeIgnored
    } = registry.select(store);
    let blocks = getBlocks(clientId);
    let isPersistent = isLastBlockChangePersistent();
    let previousAreBlocksDifferent = false;
    subscribed.current = true;
    const unsubscribe = registry.subscribe(() => {
      // Sometimes, when changing block lists, lingering subscriptions
      // might trigger before they are cleaned up. If the block for which
      // the subscription runs is no longer in the store, this would clear
      // its parent entity's block list. To avoid this, we bail out if
      // the subscription is triggering for a block (`clientId !== null`)
      // and its block name can't be found because it's not on the list.
      // (`getBlockName( clientId ) === null`).
      if (clientId !== null && getBlockName(clientId) === null) return;
      const newIsPersistent = isLastBlockChangePersistent();
      const newBlocks = getBlocks(clientId);
      const areBlocksDifferent = newBlocks !== blocks;
      blocks = newBlocks;

      if (areBlocksDifferent && (pendingChanges.current.incoming || __unstableIsLastBlockChangeIgnored())) {
        pendingChanges.current.incoming = null;
        isPersistent = newIsPersistent;
        return;
      } // Since we often dispatch an action to mark the previous action as
      // persistent, we need to make sure that the blocks changed on the
      // previous action before committing the change.


      const didPersistenceChange = previousAreBlocksDifferent && !areBlocksDifferent && newIsPersistent && !isPersistent;

      if (areBlocksDifferent || didPersistenceChange) {
        isPersistent = newIsPersistent; // We know that onChange/onInput will update controlledBlocks.
        // We need to be aware that it was caused by an outgoing change
        // so that we do not treat it as an incoming change later on,
        // which would cause a block reset.

        pendingChanges.current.outgoing.push(blocks); // Inform the controlling entity that changes have been made to
        // the block-editor store they should be aware about.

        const updateParent = isPersistent ? onChangeRef.current : onInputRef.current;
        updateParent(blocks, {
          selection: {
            selectionStart: getSelectionStart(),
            selectionEnd: getSelectionEnd(),
            initialPosition: getSelectedBlocksInitialCaretPosition()
          }
        });
      }

      previousAreBlocksDifferent = areBlocksDifferent;
    });
    return () => unsubscribe();
  }, [registry, clientId]);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/provider/index.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





/** @typedef {import('@wordpress/data').WPDataRegistry} WPDataRegistry */

function BlockEditorProvider(props) {
  const {
    children,
    settings
  } = props;
  const {
    updateSettings
  } = Object(external_wp_data_["useDispatch"])(store);
  Object(external_wp_element_["useEffect"])(() => {
    updateSettings(settings);
  }, [settings]); // Syncs the entity provider with changes in the block-editor store.

  useBlockSync(props);
  return Object(external_wp_element_["createElement"])(BlockRefsProvider, null, children);
}

/* harmony default export */ var provider = (with_registry_provider(BlockEditorProvider));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-preview/live.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


function LiveBlockPreview({
  onClick
}) {
  return Object(external_wp_element_["createElement"])("div", {
    tabIndex: 0,
    role: "button",
    onClick: onClick,
    onKeyPress: onClick
  }, Object(external_wp_element_["createElement"])(external_wp_components_["Disabled"], null, Object(external_wp_element_["createElement"])(BlockList, null)));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-preview/auto.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

 // This is used to avoid rendering the block list if the sizes change.

let MemoizedBlockList;

function AutoBlockPreview({
  viewportWidth,
  __experimentalPadding
}) {
  const [containerResizeListener, {
    width: containerWidth
  }] = Object(external_wp_compose_["useResizeObserver"])();
  const [containtResizeListener, {
    height: contentHeight
  }] = Object(external_wp_compose_["useResizeObserver"])(); // Initialize on render instead of module top level, to avoid circular dependency issues.

  MemoizedBlockList = MemoizedBlockList || Object(external_wp_compose_["pure"])(BlockList);
  const scale = (containerWidth - 2 * __experimentalPadding) / viewportWidth;
  return Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-preview__container editor-styles-wrapper",
    "aria-hidden": true,
    style: {
      height: contentHeight * scale + 2 * __experimentalPadding
    }
  }, containerResizeListener, Object(external_wp_element_["createElement"])(external_wp_components_["Disabled"], {
    style: {
      transform: `scale(${scale})`,
      width: viewportWidth,
      left: __experimentalPadding,
      right: __experimentalPadding,
      top: __experimentalPadding
    },
    className: "block-editor-block-preview__content"
  }, containtResizeListener, Object(external_wp_element_["createElement"])(MemoizedBlockList, null)));
}

/* harmony default export */ var auto = (AutoBlockPreview);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-preview/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */





function BlockPreview({
  blocks,
  __experimentalPadding = 0,
  viewportWidth = 1200,
  __experimentalLive = false,
  __experimentalOnClick
}) {
  const originalSettings = Object(external_wp_data_["useSelect"])(select => select(store).getSettings(), []);
  const settings = Object(external_wp_element_["useMemo"])(() => {
    const _settings = { ...originalSettings
    };
    _settings.__experimentalBlockPatterns = [];
    return _settings;
  }, [originalSettings]);
  const renderedBlocks = Object(external_wp_element_["useMemo"])(() => Object(external_lodash_["castArray"])(blocks), [blocks]);

  if (!blocks || blocks.length === 0) {
    return null;
  }

  return Object(external_wp_element_["createElement"])(provider, {
    value: renderedBlocks,
    settings: settings
  }, __experimentalLive ? Object(external_wp_element_["createElement"])(LiveBlockPreview, {
    onClick: __experimentalOnClick
  }) : Object(external_wp_element_["createElement"])(auto, {
    viewportWidth: viewportWidth,
    __experimentalPadding: __experimentalPadding
  }));
}
/**
 * BlockPreview renders a preview of a block or array of blocks.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-preview/README.md
 *
 * @param {Object} preview options for how the preview should be shown
 * @param {Array|Object} preview.blocks A block instance (object) or an array of blocks to be previewed.
 * @param {number} preview.viewportWidth Width of the preview container in pixels. Controls at what size the blocks will be rendered inside the preview. Default: 700.
 *
 * @return {WPComponent} The component to be rendered.
 */

/* harmony default export */ var block_preview = (Object(external_wp_element_["memo"])(BlockPreview));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/preview-panel.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function InserterPreviewPanel({
  item
}) {
  var _hoveredItemBlockType, _hoveredItemBlockType2;

  const {
    name,
    title,
    icon,
    description,
    initialAttributes
  } = item;
  const hoveredItemBlockType = Object(external_wp_blocks_["getBlockType"])(name);
  const isReusable = Object(external_wp_blocks_["isReusableBlock"])(item);
  return Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-inserter__preview-container"
  }, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-inserter__preview"
  }, isReusable || hoveredItemBlockType.example ? Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-inserter__preview-content"
  }, Object(external_wp_element_["createElement"])(block_preview, {
    __experimentalPadding: 16,
    viewportWidth: (_hoveredItemBlockType = (_hoveredItemBlockType2 = hoveredItemBlockType.example) === null || _hoveredItemBlockType2 === void 0 ? void 0 : _hoveredItemBlockType2.viewportWidth) !== null && _hoveredItemBlockType !== void 0 ? _hoveredItemBlockType : 500,
    blocks: hoveredItemBlockType.example ? Object(external_wp_blocks_["getBlockFromExample"])(item.name, {
      attributes: { ...hoveredItemBlockType.example.attributes,
        ...initialAttributes
      },
      innerBlocks: hoveredItemBlockType.example.innerBlocks
    }) : Object(external_wp_blocks_["createBlock"])(name, initialAttributes)
  })) : Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-inserter__preview-content-missing"
  }, Object(external_wp_i18n_["__"])('No Preview Available.'))), !isReusable && Object(external_wp_element_["createElement"])(block_card, {
    title: title,
    icon: icon,
    description: description
  }));
}

/* harmony default export */ var preview_panel = (InserterPreviewPanel);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/context.js
/**
 * WordPress dependencies
 */

const InserterListboxContext = Object(external_wp_element_["createContext"])();
/* harmony default export */ var inserter_listbox_context = (InserterListboxContext);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/item.js



/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function InserterListboxItem({
  isFirst,
  as: Component,
  children,
  ...props
}, ref) {
  const state = Object(external_wp_element_["useContext"])(inserter_listbox_context);
  return Object(external_wp_element_["createElement"])(external_wp_components_["__unstableCompositeItem"], Object(esm_extends["a" /* default */])({
    ref: ref,
    state: state,
    role: "option" // Use the CompositeItem `focusable` prop over Button's
    // isFocusable. The latter was shown to cause an issue
    // with tab order in the inserter list.
    ,
    focusable: true
  }, props), htmlProps => {
    const propsWithTabIndex = { ...htmlProps,
      tabIndex: isFirst ? 0 : htmlProps.tabIndex
    };

    if (Component) {
      return Object(external_wp_element_["createElement"])(Component, propsWithTabIndex, children);
    }

    if (typeof children === 'function') {
      return children(propsWithTabIndex);
    }

    return Object(external_wp_element_["createElement"])(external_wp_components_["Button"], propsWithTabIndex, children);
  });
}

/* harmony default export */ var inserter_listbox_item = (Object(external_wp_element_["forwardRef"])(InserterListboxItem));

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/drag-handle.js


/**
 * WordPress dependencies
 */

const dragHandle = Object(external_wp_element_["createElement"])(external_wp_primitives_["SVG"], {
  width: "18",
  height: "18",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 18 18"
}, Object(external_wp_element_["createElement"])(external_wp_primitives_["Path"], {
  d: "M5 4h2V2H5v2zm6-2v2h2V2h-2zm-6 8h2V8H5v2zm6 0h2V8h-2v2zm-6 6h2v-2H5v2zm6 0h2v-2h-2v2z"
}));
/* harmony default export */ var drag_handle = (dragHandle);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-draggable/draggable-chip.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


function BlockDraggableChip({
  count,
  icon
}) {
  return Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-draggable-chip-wrapper"
  }, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-draggable-chip"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["Flex"], {
    justify: "center",
    className: "block-editor-block-draggable-chip__content"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["FlexItem"], null, icon ? Object(external_wp_element_["createElement"])(BlockIcon, {
    icon: icon
  }) : Object(external_wp_i18n_["sprintf"])(
  /* translators: %d: Number of blocks. */
  Object(external_wp_i18n_["_n"])('%d block', '%d blocks', count), count)), Object(external_wp_element_["createElement"])(external_wp_components_["FlexItem"], null, Object(external_wp_element_["createElement"])(BlockIcon, {
    icon: drag_handle
  })))));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter-draggable-blocks/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



const InserterDraggableBlocks = ({
  isEnabled,
  blocks,
  icon,
  children
}) => {
  const transferData = {
    type: 'inserter',
    blocks
  };
  return Object(external_wp_element_["createElement"])(external_wp_components_["Draggable"], {
    __experimentalTransferDataType: "wp-blocks",
    transferData: transferData,
    __experimentalDragComponent: Object(external_wp_element_["createElement"])(BlockDraggableChip, {
      count: blocks.length,
      icon: icon
    })
  }, ({
    onDraggableStart,
    onDraggableEnd
  }) => {
    return children({
      draggable: isEnabled,
      onDragStart: isEnabled ? onDraggableStart : undefined,
      onDragEnd: isEnabled ? onDraggableEnd : undefined
    });
  });
};

/* harmony default export */ var inserter_draggable_blocks = (InserterDraggableBlocks);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter-list-item/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




/**
 * Return true if platform is MacOS.
 *
 * @param {Object} _window   window object by default; used for DI testing.
 *
 * @return {boolean} True if MacOS; false otherwise.
 */

function isAppleOS(_window = window) {
  const {
    platform
  } = _window.navigator;
  return platform.indexOf('Mac') !== -1 || ['iPad', 'iPhone'].includes(platform);
}

function InserterListItem({
  className,
  isFirst,
  item,
  onSelect,
  onHover,
  isDraggable,
  ...props
}) {
  const isDragging = Object(external_wp_element_["useRef"])(false);
  const itemIconStyle = item.icon ? {
    backgroundColor: item.icon.background,
    color: item.icon.foreground
  } : {};
  const blocks = Object(external_wp_element_["useMemo"])(() => {
    return [Object(external_wp_blocks_["createBlock"])(item.name, item.initialAttributes, Object(external_wp_blocks_["createBlocksFromInnerBlocksTemplate"])(item.innerBlocks))];
  }, [item.name, item.initialAttributes, item.initialAttributes]);
  return Object(external_wp_element_["createElement"])(inserter_draggable_blocks, {
    isEnabled: isDraggable && !item.disabled,
    blocks: blocks,
    icon: item.icon
  }, ({
    draggable,
    onDragStart,
    onDragEnd
  }) => Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-types-list__list-item",
    draggable: draggable,
    onDragStart: event => {
      isDragging.current = true;

      if (onDragStart) {
        onHover(null);
        onDragStart(event);
      }
    },
    onDragEnd: event => {
      isDragging.current = false;

      if (onDragEnd) {
        onDragEnd(event);
      }
    }
  }, Object(external_wp_element_["createElement"])(inserter_listbox_item, Object(esm_extends["a" /* default */])({
    isFirst: isFirst,
    className: classnames_default()('block-editor-block-types-list__item', className),
    disabled: item.isDisabled,
    onClick: event => {
      event.preventDefault();
      onSelect(item, isAppleOS() ? event.metaKey : event.ctrlKey);
      onHover(null);
    },
    onKeyDown: event => {
      const {
        keyCode
      } = event;

      if (keyCode === external_wp_keycodes_["ENTER"]) {
        event.preventDefault();
        onSelect(item, isAppleOS() ? event.metaKey : event.ctrlKey);
        onHover(null);
      }
    },
    onFocus: () => {
      if (isDragging.current) {
        return;
      }

      onHover(item);
    },
    onMouseEnter: () => {
      if (isDragging.current) {
        return;
      }

      onHover(item);
    },
    onMouseLeave: () => onHover(null),
    onBlur: () => onHover(null)
  }, props), Object(external_wp_element_["createElement"])("span", {
    className: "block-editor-block-types-list__item-icon",
    style: itemIconStyle
  }, Object(external_wp_element_["createElement"])(BlockIcon, {
    icon: item.icon,
    showColors: true
  })), Object(external_wp_element_["createElement"])("span", {
    className: "block-editor-block-types-list__item-title"
  }, item.title))));
}

/* harmony default export */ var inserter_list_item = (Object(external_wp_element_["memo"])(InserterListItem));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/group.js



/**
 * WordPress dependencies
 */




function InserterListboxGroup(props, ref) {
  const [shouldSpeak, setShouldSpeak] = Object(external_wp_element_["useState"])(false);
  Object(external_wp_element_["useEffect"])(() => {
    if (shouldSpeak) {
      Object(external_wp_a11y_["speak"])(Object(external_wp_i18n_["__"])('Use left and right arrow keys to move through blocks'));
    }
  }, [shouldSpeak]);
  return Object(external_wp_element_["createElement"])("div", Object(esm_extends["a" /* default */])({
    ref: ref,
    role: "listbox",
    "aria-orientation": "horizontal",
    onFocus: () => {
      setShouldSpeak(true);
    },
    onBlur: event => {
      const focusingOutsideGroup = !event.currentTarget.contains(event.relatedTarget);

      if (focusingOutsideGroup) {
        setShouldSpeak(false);
      }
    }
  }, props));
}

/* harmony default export */ var inserter_listbox_group = (Object(external_wp_element_["forwardRef"])(InserterListboxGroup));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/row.js



/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function InserterListboxRow(props, ref) {
  const state = Object(external_wp_element_["useContext"])(inserter_listbox_context);
  return Object(external_wp_element_["createElement"])(external_wp_components_["__unstableCompositeGroup"], Object(esm_extends["a" /* default */])({
    state: state,
    role: "presentation",
    ref: ref
  }, props));
}

/* harmony default export */ var inserter_listbox_row = (Object(external_wp_element_["forwardRef"])(InserterListboxRow));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-types-list/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




function chunk(array, size) {
  const chunks = [];

  for (let i = 0, j = array.length; i < j; i += size) {
    chunks.push(array.slice(i, i + size));
  }

  return chunks;
}

function BlockTypesList({
  items = [],
  onSelect,
  onHover = () => {},
  children,
  label,
  isDraggable = true
}) {
  return Object(external_wp_element_["createElement"])(inserter_listbox_group, {
    className: "block-editor-block-types-list",
    "aria-label": label
  }, chunk(items, 3).map((row, i) => Object(external_wp_element_["createElement"])(inserter_listbox_row, {
    key: i
  }, row.map((item, j) => Object(external_wp_element_["createElement"])(inserter_list_item, {
    key: item.id,
    item: item,
    className: Object(external_wp_blocks_["getBlockMenuDefaultClassName"])(item.id),
    onSelect: onSelect,
    onHover: onHover,
    isDraggable: isDraggable,
    isFirst: i === 0 && j === 0
  })))), children);
}

/* harmony default export */ var block_types_list = (BlockTypesList);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/panel.js


/**
 * WordPress dependencies
 */


function InserterPanel({
  title,
  icon,
  children
}) {
  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-inserter__panel-header"
  }, Object(external_wp_element_["createElement"])("h2", {
    className: "block-editor-inserter__panel-title"
  }, title), Object(external_wp_element_["createElement"])(external_wp_components_["Icon"], {
    icon: icon
  })), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-inserter__panel-content"
  }, children));
}

/* harmony default export */ var panel = (InserterPanel);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */






function InserterListbox({
  children
}) {
  const compositeState = Object(external_wp_components_["__unstableUseCompositeState"])({
    shift: true,
    wrap: 'horizontal'
  });
  return Object(external_wp_element_["createElement"])(inserter_listbox_context.Provider, {
    value: compositeState
  }, children);
}

/* harmony default export */ var inserter_listbox = (InserterListbox);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/block-types-tab.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */






const getBlockNamespace = item => item.name.split('/')[0];

const MAX_SUGGESTED_ITEMS = 6;
function BlockTypesTab({
  rootClientId,
  onInsert,
  onHover,
  showMostUsedBlocks
}) {
  const [items, categories, collections, onSelectItem] = use_block_types_state(rootClientId, onInsert);
  const suggestedItems = Object(external_wp_element_["useMemo"])(() => {
    return Object(external_lodash_["orderBy"])(items, ['frecency'], ['desc']).slice(0, MAX_SUGGESTED_ITEMS);
  }, [items]);
  const uncategorizedItems = Object(external_wp_element_["useMemo"])(() => {
    return items.filter(item => !item.category);
  }, [items]);
  const itemsPerCategory = Object(external_wp_element_["useMemo"])(() => {
    return Object(external_lodash_["flow"])(itemList => itemList.filter(item => item.category && item.category !== 'reusable'), itemList => Object(external_lodash_["groupBy"])(itemList, 'category'))(items);
  }, [items]);
  const itemsPerCollection = Object(external_wp_element_["useMemo"])(() => {
    // Create a new Object to avoid mutating collection.
    const result = { ...collections
    };
    Object.keys(collections).forEach(namespace => {
      result[namespace] = items.filter(item => getBlockNamespace(item) === namespace);

      if (result[namespace].length === 0) {
        delete result[namespace];
      }
    });
    return result;
  }, [items, collections]); // Hide block preview on unmount.

  Object(external_wp_element_["useEffect"])(() => () => onHover(null), []);
  return Object(external_wp_element_["createElement"])(inserter_listbox, null, Object(external_wp_element_["createElement"])("div", null, showMostUsedBlocks && !!suggestedItems.length && Object(external_wp_element_["createElement"])(panel, {
    title: Object(external_wp_i18n_["_x"])('Most used', 'blocks')
  }, Object(external_wp_element_["createElement"])(block_types_list, {
    items: suggestedItems,
    onSelect: onSelectItem,
    onHover: onHover,
    label: Object(external_wp_i18n_["_x"])('Most used', 'blocks')
  })), Object(external_lodash_["map"])(categories, category => {
    const categoryItems = itemsPerCategory[category.slug];

    if (!categoryItems || !categoryItems.length) {
      return null;
    }

    return Object(external_wp_element_["createElement"])(panel, {
      key: category.slug,
      title: category.title,
      icon: category.icon
    }, Object(external_wp_element_["createElement"])(block_types_list, {
      items: categoryItems,
      onSelect: onSelectItem,
      onHover: onHover,
      label: category.title
    }));
  }), uncategorizedItems.length > 0 && Object(external_wp_element_["createElement"])(panel, {
    className: "block-editor-inserter__uncategorized-blocks-panel",
    title: Object(external_wp_i18n_["__"])('Uncategorized')
  }, Object(external_wp_element_["createElement"])(block_types_list, {
    items: uncategorizedItems,
    onSelect: onSelectItem,
    onHover: onHover,
    label: Object(external_wp_i18n_["__"])('Uncategorized')
  })), Object(external_lodash_["map"])(collections, (collection, namespace) => {
    const collectionItems = itemsPerCollection[namespace];

    if (!collectionItems || !collectionItems.length) {
      return null;
    }

    return Object(external_wp_element_["createElement"])(panel, {
      key: namespace,
      title: collection.title,
      icon: collection.icon
    }, Object(external_wp_element_["createElement"])(block_types_list, {
      items: collectionItems,
      onSelect: onSelectItem,
      onHover: onHover,
      label: collection.title
    }));
  })));
}
/* harmony default export */ var block_types_tab = (BlockTypesTab);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/pattern-panel.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




function PatternInserterPanel({
  selectedCategory,
  patternCategories,
  onClickCategory,
  children
}) {
  const categoryOptions = () => {
    const options = [];
    patternCategories.map(patternCategory => {
      return options.push({
        value: patternCategory.name,
        label: patternCategory.label
      });
    });
    return options;
  };

  const onChangeSelect = selected => {
    onClickCategory(patternCategories.find(patternCategory => selected === patternCategory.name));
  };

  const getPanelHeaderClassName = () => {
    return classnames_default()('block-editor-inserter__panel-header', 'block-editor-inserter__panel-header-patterns');
  }; // In iOS-based mobile devices, the onBlur will fire when selecting an option
  // from a Select element. To prevent closing the useDialog on iOS devices, we
  // stop propagating the onBlur event if there is no relatedTarget, which means
  // that the user most likely did not click on an element within the editor canvas.


  const onBlur = event => {
    if (!(event !== null && event !== void 0 && event.relatedTarget)) {
      event.stopPropagation();
    }
  };

  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])("div", {
    className: getPanelHeaderClassName()
  }, Object(external_wp_element_["createElement"])(external_wp_components_["SelectControl"], {
    className: "block-editor-inserter__panel-dropdown",
    label: Object(external_wp_i18n_["__"])('Filter patterns'),
    hideLabelFromVision: true,
    value: selectedCategory.name,
    onChange: onChangeSelect,
    onBlur: onBlur,
    options: categoryOptions()
  })), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-inserter__panel-content"
  }, children));
}

/* harmony default export */ var pattern_panel = (PatternInserterPanel);

// EXTERNAL MODULE: external ["wp","notices"]
var external_wp_notices_ = __webpack_require__("onLe");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-patterns-state.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */


/**
 * Retrieves the block patterns inserter state.
 *
 * @param {Function} onInsert     function called when inserter a list of blocks.
 * @param {string=}  rootClientId Insertion's root client ID.
 *
 * @return {Array} Returns the patterns state. (patterns, categories, onSelect handler)
 */

const usePatternsState = (onInsert, rootClientId) => {
  const {
    patternCategories,
    patterns
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      __experimentalGetAllowedPatterns,
      getSettings
    } = select(store);
    return {
      patterns: __experimentalGetAllowedPatterns(rootClientId),
      patternCategories: getSettings().__experimentalBlockPatternCategories
    };
  }, [rootClientId]);
  const {
    createSuccessNotice
  } = Object(external_wp_data_["useDispatch"])(external_wp_notices_["store"]);
  const onClickPattern = Object(external_wp_element_["useCallback"])((pattern, blocks) => {
    onInsert(Object(external_lodash_["map"])(blocks, block => Object(external_wp_blocks_["cloneBlock"])(block)), pattern.name);
    createSuccessNotice(Object(external_wp_i18n_["sprintf"])(
    /* translators: %s: block pattern title. */
    Object(external_wp_i18n_["__"])('Block pattern "%s" inserted.'), pattern.title), {
      type: 'snackbar'
    });
  }, []);
  return [patterns, patternCategories, onClickPattern];
};

/* harmony default export */ var use_patterns_state = (usePatternsState);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-patterns-list/index.js



/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





function BlockPattern({
  isDraggable,
  pattern,
  onClick,
  composite
}) {
  const {
    name,
    viewportWidth
  } = pattern;
  const {
    blocks
  } = Object(external_wp_data_["useSelect"])(select => select(store).__experimentalGetParsedPattern(name), [name]);
  const instanceId = Object(external_wp_compose_["useInstanceId"])(BlockPattern);
  const descriptionId = `block-editor-block-patterns-list__item-description-${instanceId}`;
  return Object(external_wp_element_["createElement"])(inserter_draggable_blocks, {
    isEnabled: isDraggable,
    blocks: blocks
  }, ({
    draggable,
    onDragStart,
    onDragEnd
  }) => Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-patterns-list__list-item",
    "aria-label": pattern.title,
    "aria-describedby": pattern.description ? descriptionId : undefined,
    draggable: draggable,
    onDragStart: onDragStart,
    onDragEnd: onDragEnd
  }, Object(external_wp_element_["createElement"])(external_wp_components_["__unstableCompositeItem"], Object(esm_extends["a" /* default */])({
    role: "option",
    as: "div"
  }, composite, {
    className: "block-editor-block-patterns-list__item",
    onClick: () => onClick(pattern, blocks)
  }), Object(external_wp_element_["createElement"])(block_preview, {
    blocks: blocks,
    viewportWidth: viewportWidth
  }), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-patterns-list__item-title"
  }, pattern.title), !!pattern.description && Object(external_wp_element_["createElement"])(external_wp_components_["VisuallyHidden"], {
    id: descriptionId
  }, pattern.description))));
}

function BlockPatternPlaceholder() {
  return Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-patterns-list__item is-placeholder"
  });
}

function BlockPatternList({
  isDraggable,
  blockPatterns,
  shownPatterns,
  onClickPattern,
  orientation,
  label = Object(external_wp_i18n_["__"])('Block Patterns')
}) {
  const composite = Object(external_wp_components_["__unstableUseCompositeState"])({
    orientation
  });
  return Object(external_wp_element_["createElement"])(external_wp_components_["__unstableComposite"], Object(esm_extends["a" /* default */])({}, composite, {
    role: "listbox",
    className: "block-editor-block-patterns-list",
    "aria-label": label
  }), blockPatterns.map(pattern => {
    const isShown = shownPatterns.includes(pattern);
    return isShown ? Object(external_wp_element_["createElement"])(BlockPattern, {
      key: pattern.name,
      pattern: pattern,
      onClick: onClickPattern,
      isDraggable: isDraggable,
      composite: composite
    }) : Object(external_wp_element_["createElement"])(BlockPatternPlaceholder, {
      key: pattern.name
    });
  }));
}

/* harmony default export */ var block_patterns_list = (BlockPatternList);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-tab.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





function BlockPatternsCategory({
  rootClientId,
  onInsert,
  selectedCategory,
  onClickCategory
}) {
  const [allPatterns, allCategories, onClick] = use_patterns_state(onInsert, rootClientId); // Remove any empty categories

  const populatedCategories = Object(external_wp_element_["useMemo"])(() => allCategories.filter(category => allPatterns.some(pattern => {
    var _pattern$categories;

    return (_pattern$categories = pattern.categories) === null || _pattern$categories === void 0 ? void 0 : _pattern$categories.includes(category.name);
  })), [allPatterns, allCategories]);
  const patternCategory = selectedCategory ? selectedCategory : populatedCategories[0];
  Object(external_wp_element_["useEffect"])(() => {
    if (allPatterns.some(pattern => getPatternIndex(pattern) === Infinity) && !populatedCategories.find(category => category.name === 'uncategorized')) {
      populatedCategories.push({
        name: 'uncategorized',
        label: Object(external_wp_i18n_["_x"])('Uncategorized')
      });
    }
  }, [populatedCategories, allPatterns]);
  const getPatternIndex = Object(external_wp_element_["useCallback"])(pattern => {
    if (!pattern.categories || !pattern.categories.length) {
      return Infinity;
    }

    const indexedCategories = Object(external_lodash_["fromPairs"])(populatedCategories.map(({
      name
    }, index) => [name, index]));
    return Math.min(...pattern.categories.map(cat => indexedCategories[cat] !== undefined ? indexedCategories[cat] : Infinity));
  }, [populatedCategories]);
  const currentCategoryPatterns = Object(external_wp_element_["useMemo"])(() => allPatterns.filter(pattern => patternCategory.name === 'uncategorized' ? getPatternIndex(pattern) === Infinity : pattern.categories && pattern.categories.includes(patternCategory.name)), [allPatterns, patternCategory]); // Ordering the patterns is important for the async rendering.

  const orderedPatterns = Object(external_wp_element_["useMemo"])(() => {
    return currentCategoryPatterns.sort((a, b) => {
      return getPatternIndex(a) - getPatternIndex(b);
    });
  }, [currentCategoryPatterns, getPatternIndex]);
  const currentShownPatterns = Object(external_wp_compose_["useAsyncList"])(orderedPatterns);
  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, !!currentCategoryPatterns.length && Object(external_wp_element_["createElement"])(pattern_panel, {
    selectedCategory: patternCategory,
    patternCategories: populatedCategories,
    onClickCategory: onClickCategory
  }, Object(external_wp_element_["createElement"])(block_patterns_list, {
    shownPatterns: currentShownPatterns,
    blockPatterns: currentCategoryPatterns,
    onClickPattern: onClick,
    label: patternCategory.label,
    orientation: "vertical",
    isDraggable: true
  })));
}

function BlockPatternsTabs({
  rootClientId,
  onInsert,
  onClickCategory,
  selectedCategory
}) {
  return Object(external_wp_element_["createElement"])(BlockPatternsCategory, {
    rootClientId: rootClientId,
    selectedCategory: selectedCategory,
    onInsert: onInsert,
    onClickCategory: onClickCategory
  });
}

/* harmony default export */ var block_patterns_tab = (BlockPatternsTabs);

// EXTERNAL MODULE: external ["wp","url"]
var external_wp_url_ = __webpack_require__("Mmq9");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/no-results.js


/**
 * WordPress dependencies
 */



function InserterNoResults() {
  return Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-inserter__no-results"
  }, Object(external_wp_element_["createElement"])(build_module_icon["a" /* default */], {
    className: "block-editor-inserter__no-results-icon",
    icon: block_default["a" /* default */]
  }), Object(external_wp_element_["createElement"])("p", null, Object(external_wp_i18n_["__"])('No results found.')));
}

/* harmony default export */ var no_results = (InserterNoResults);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/reusable-blocks-tab.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */






function ReusableBlocksList({
  onHover,
  onInsert,
  rootClientId
}) {
  const [items,,, onSelectItem] = use_block_types_state(rootClientId, onInsert);
  const filteredItems = Object(external_wp_element_["useMemo"])(() => {
    return items.filter(({
      category
    }) => category === 'reusable');
  }, [items]);

  if (filteredItems.length === 0) {
    return Object(external_wp_element_["createElement"])(no_results, null);
  }

  return Object(external_wp_element_["createElement"])(panel, {
    title: Object(external_wp_i18n_["__"])('Reusable blocks')
  }, Object(external_wp_element_["createElement"])(block_types_list, {
    items: filteredItems,
    onSelect: onSelectItem,
    onHover: onHover,
    label: Object(external_wp_i18n_["__"])('Reusable blocks')
  }));
} // The unwrapped component is only exported for use by unit tests.

/**
 * List of reusable blocks shown in the "Reusable" tab of the inserter.
 *
 * @param {Object}   props                Component props.
 * @param {?string}  props.rootClientId   Client id of block to insert into.
 * @param {Function} props.onInsert       Callback to run when item is inserted.
 * @param {Function} props.onHover        Callback to run when item is hovered.
 *
 * @return {WPComponent} The component.
 */


function ReusableBlocksTab({
  rootClientId,
  onInsert,
  onHover
}) {
  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(ReusableBlocksList, {
    onHover: onHover,
    onInsert: onInsert,
    rootClientId: rootClientId
  }), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-inserter__manage-reusable-blocks-container"
  }, Object(external_wp_element_["createElement"])("a", {
    className: "block-editor-inserter__manage-reusable-blocks",
    href: Object(external_wp_url_["addQueryArgs"])('edit.php', {
      post_type: 'wp_block'
    })
  }, Object(external_wp_i18n_["__"])('Manage Reusable blocks'))));
}
/* harmony default export */ var reusable_blocks_tab = (ReusableBlocksTab);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter-menu-extension/index.js
/**
 * WordPress dependencies
 */

const {
  Fill: __unstableInserterMenuExtension,
  Slot: inserter_menu_extension_Slot
} = Object(external_wp_components_["createSlotFill"])('__unstableInserterMenuExtension');
__unstableInserterMenuExtension.Slot = inserter_menu_extension_Slot;
/* harmony default export */ var inserter_menu_extension = (__unstableInserterMenuExtension);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-insertion-point.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */


/**
 * @typedef WPInserterConfig
 *
 * @property {string=}   rootClientId        If set, insertion will be into the
 *                                           block with this ID.
 * @property {number=}   insertionIndex      If set, insertion will be into this
 *                                           explicit position.
 * @property {string=}   clientId            If set, insertion will be after the
 *                                           block with this ID.
 * @property {boolean=}  isAppender          Whether the inserter is an appender
 *                                           or not.
 * @property {Function=} onSelect            Called after insertion.
 */

/**
 * Returns the insertion point state given the inserter config.
 *
 * @param {WPInserterConfig} config Inserter Config.
 * @return {Array} Insertion Point State (rootClientID, onInsertBlocks and onToggle).
 */

function useInsertionPoint({
  rootClientId = '',
  insertionIndex,
  clientId,
  isAppender,
  onSelect,
  shouldFocusBlock = true
}) {
  const {
    getSelectedBlock
  } = Object(external_wp_data_["useSelect"])(store);
  const {
    destinationRootClientId,
    destinationIndex
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getSelectedBlockClientId,
      getBlockRootClientId,
      getBlockIndex,
      getBlockOrder
    } = select(store);
    const selectedBlockClientId = getSelectedBlockClientId();
    let _destinationRootClientId = rootClientId;

    let _destinationIndex;

    if (insertionIndex !== undefined) {
      // Insert into a specific index.
      _destinationIndex = insertionIndex;
    } else if (clientId) {
      // Insert after a specific client ID.
      _destinationIndex = getBlockIndex(clientId, _destinationRootClientId);
    } else if (!isAppender && selectedBlockClientId) {
      _destinationRootClientId = getBlockRootClientId(selectedBlockClientId);
      _destinationIndex = getBlockIndex(selectedBlockClientId, _destinationRootClientId) + 1;
    } else {
      // Insert at the end of the list.
      _destinationIndex = getBlockOrder(_destinationRootClientId).length;
    }

    return {
      destinationRootClientId: _destinationRootClientId,
      destinationIndex: _destinationIndex
    };
  }, [rootClientId, insertionIndex, clientId, isAppender]);
  const {
    replaceBlocks,
    insertBlocks,
    showInsertionPoint,
    hideInsertionPoint
  } = Object(external_wp_data_["useDispatch"])(store);
  const onInsertBlocks = Object(external_wp_element_["useCallback"])((blocks, meta, shouldForceFocusBlock = false) => {
    const selectedBlock = getSelectedBlock();

    if (!isAppender && selectedBlock && Object(external_wp_blocks_["isUnmodifiedDefaultBlock"])(selectedBlock)) {
      replaceBlocks(selectedBlock.clientId, blocks, null, shouldFocusBlock || shouldForceFocusBlock ? 0 : null, meta);
    } else {
      insertBlocks(blocks, destinationIndex, destinationRootClientId, true, shouldFocusBlock || shouldForceFocusBlock ? 0 : null, meta);
    }

    const message = Object(external_wp_i18n_["sprintf"])( // translators: %d: the name of the block that has been added
    Object(external_wp_i18n_["_n"])('%d block added.', '%d blocks added.', Object(external_lodash_["castArray"])(blocks).length), Object(external_lodash_["castArray"])(blocks).length);
    Object(external_wp_a11y_["speak"])(message);

    if (onSelect) {
      onSelect();
    }
  }, [isAppender, getSelectedBlock, replaceBlocks, insertBlocks, destinationRootClientId, destinationIndex, onSelect, shouldFocusBlock]);
  const onToggleInsertionPoint = Object(external_wp_element_["useCallback"])(show => {
    if (show) {
      showInsertionPoint(destinationRootClientId, destinationIndex);
    } else {
      hideInsertionPoint();
    }
  }, [showInsertionPoint, hideInsertionPoint, destinationRootClientId, destinationIndex]);
  return [destinationRootClientId, onInsertBlocks, onToggleInsertionPoint];
}

/* harmony default export */ var use_insertion_point = (useInsertionPoint);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/search-results.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */












function InserterSearchResults({
  filterValue,
  onSelect,
  onHover,
  rootClientId,
  clientId,
  isAppender,
  __experimentalInsertionIndex,
  maxBlockPatterns,
  maxBlockTypes,
  showBlockDirectory = false,
  isDraggable = true,
  shouldFocusBlock = true
}) {
  const debouncedSpeak = Object(external_wp_compose_["useDebounce"])(external_wp_a11y_["speak"], 500);
  const [destinationRootClientId, onInsertBlocks] = use_insertion_point({
    onSelect,
    rootClientId,
    clientId,
    isAppender,
    insertionIndex: __experimentalInsertionIndex,
    shouldFocusBlock
  });
  const [blockTypes, blockTypeCategories, blockTypeCollections, onSelectBlockType] = use_block_types_state(destinationRootClientId, onInsertBlocks);
  const [patterns,, onSelectBlockPattern] = use_patterns_state(onInsertBlocks, destinationRootClientId);
  const filteredBlockTypes = Object(external_wp_element_["useMemo"])(() => {
    const results = searchBlockItems(Object(external_lodash_["orderBy"])(blockTypes, ['frecency'], ['desc']), blockTypeCategories, blockTypeCollections, filterValue);
    return maxBlockTypes !== undefined ? results.slice(0, maxBlockTypes) : results;
  }, [filterValue, blockTypes, blockTypeCategories, blockTypeCollections, maxBlockTypes]);
  const filteredBlockPatterns = Object(external_wp_element_["useMemo"])(() => {
    const results = searchItems(patterns, filterValue);
    return maxBlockPatterns !== undefined ? results.slice(0, maxBlockPatterns) : results;
  }, [filterValue, patterns, maxBlockPatterns]); // Announce search results on change

  Object(external_wp_element_["useEffect"])(() => {
    if (!filterValue) {
      return;
    }

    const count = filteredBlockTypes.length + filteredBlockPatterns.length;
    const resultsFoundMessage = Object(external_wp_i18n_["sprintf"])(
    /* translators: %d: number of results. */
    Object(external_wp_i18n_["_n"])('%d result found.', '%d results found.', count), count);
    debouncedSpeak(resultsFoundMessage);
  }, [filterValue, debouncedSpeak]);
  const currentShownPatterns = Object(external_wp_compose_["useAsyncList"])(filteredBlockPatterns);
  const hasItems = !Object(external_lodash_["isEmpty"])(filteredBlockTypes) || !Object(external_lodash_["isEmpty"])(filteredBlockPatterns);
  return Object(external_wp_element_["createElement"])(inserter_listbox, null, !showBlockDirectory && !hasItems && Object(external_wp_element_["createElement"])(no_results, null), !!filteredBlockTypes.length && Object(external_wp_element_["createElement"])(panel, {
    title: Object(external_wp_element_["createElement"])(external_wp_components_["VisuallyHidden"], null, Object(external_wp_i18n_["__"])('Blocks'))
  }, Object(external_wp_element_["createElement"])(block_types_list, {
    items: filteredBlockTypes,
    onSelect: onSelectBlockType,
    onHover: onHover,
    label: Object(external_wp_i18n_["__"])('Blocks'),
    isDraggable: isDraggable
  })), !!filteredBlockTypes.length && !!filteredBlockPatterns.length && Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-inserter__quick-inserter-separator"
  }), !!filteredBlockPatterns.length && Object(external_wp_element_["createElement"])(panel, {
    title: Object(external_wp_element_["createElement"])(external_wp_components_["VisuallyHidden"], null, Object(external_wp_i18n_["__"])('Block Patterns'))
  }, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-inserter__quick-inserter-patterns"
  }, Object(external_wp_element_["createElement"])(block_patterns_list, {
    shownPatterns: currentShownPatterns,
    blockPatterns: filteredBlockPatterns,
    onClickPattern: onSelectBlockPattern,
    isDraggable: isDraggable
  }))), showBlockDirectory && Object(external_wp_element_["createElement"])(inserter_menu_extension.Slot, {
    fillProps: {
      onSelect: onSelectBlockType,
      onHover,
      filterValue,
      hasItems,
      rootClientId: destinationRootClientId
    }
  }, fills => {
    if (fills.length) {
      return fills;
    }

    if (!hasItems) {
      return Object(external_wp_element_["createElement"])(no_results, null);
    }

    return null;
  }));
}

/* harmony default export */ var search_results = (InserterSearchResults);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/tabs.js


/**
 * WordPress dependencies
 */



const tabs_blocksTab = {
  name: 'blocks',

  /* translators: Blocks tab title in the block inserter. */
  title: Object(external_wp_i18n_["__"])('Blocks')
};
const tabs_patternsTab = {
  name: 'patterns',

  /* translators: Patterns tab title in the block inserter. */
  title: Object(external_wp_i18n_["__"])('Patterns')
};
const tabs_reusableBlocksTab = {
  name: 'reusable',

  /* translators: Reusable blocks tab title in the block inserter. */
  title: Object(external_wp_i18n_["__"])('Reusable')
};

function InserterTabs({
  children,
  showPatterns = false,
  showReusableBlocks = false,
  onSelect
}) {
  const tabs = Object(external_wp_element_["useMemo"])(() => {
    const tempTabs = [tabs_blocksTab];

    if (showPatterns) {
      tempTabs.push(tabs_patternsTab);
    }

    if (showReusableBlocks) {
      tempTabs.push(tabs_reusableBlocksTab);
    }

    return tempTabs;
  }, [tabs_blocksTab, showPatterns, tabs_patternsTab, showReusableBlocks, tabs_reusableBlocksTab]);
  return Object(external_wp_element_["createElement"])(external_wp_components_["TabPanel"], {
    className: "block-editor-inserter__tabs",
    tabs: tabs,
    onSelect: onSelect
  }, children);
}

/* harmony default export */ var inserter_tabs = (InserterTabs);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/menu.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */












function InserterMenu({
  rootClientId,
  clientId,
  isAppender,
  __experimentalInsertionIndex,
  onSelect,
  showInserterHelpPanel,
  showMostUsedBlocks,
  shouldFocusBlock = true
}) {
  const [filterValue, setFilterValue] = Object(external_wp_element_["useState"])('');
  const [hoveredItem, setHoveredItem] = Object(external_wp_element_["useState"])(null);
  const [selectedPatternCategory, setSelectedPatternCategory] = Object(external_wp_element_["useState"])(null);
  const [destinationRootClientId, onInsertBlocks, onToggleInsertionPoint] = use_insertion_point({
    rootClientId,
    clientId,
    isAppender,
    insertionIndex: __experimentalInsertionIndex,
    shouldFocusBlock
  });
  const {
    showPatterns,
    hasReusableBlocks
  } = Object(external_wp_data_["useSelect"])(select => {
    var _getSettings$__experi;

    const {
      __experimentalGetAllowedPatterns,
      getSettings
    } = select(store);
    return {
      showPatterns: !!__experimentalGetAllowedPatterns(destinationRootClientId).length,
      hasReusableBlocks: !!((_getSettings$__experi = getSettings().__experimentalReusableBlocks) !== null && _getSettings$__experi !== void 0 && _getSettings$__experi.length)
    };
  }, [destinationRootClientId]);
  const onInsert = Object(external_wp_element_["useCallback"])((blocks, meta, shouldForceFocusBlock) => {
    onInsertBlocks(blocks, meta, shouldForceFocusBlock);
    onSelect();
  }, [onInsertBlocks, onSelect]);
  const onInsertPattern = Object(external_wp_element_["useCallback"])((blocks, patternName) => {
    onInsertBlocks(blocks, {
      patternName
    });
    onSelect();
  }, [onInsertBlocks, onSelect]);
  const onHover = Object(external_wp_element_["useCallback"])(item => {
    onToggleInsertionPoint(!!item);
    setHoveredItem(item);
  }, [onToggleInsertionPoint, setHoveredItem]);
  const onClickPatternCategory = Object(external_wp_element_["useCallback"])(patternCategory => {
    setSelectedPatternCategory(patternCategory);
  }, [setSelectedPatternCategory]);
  const blocksTab = Object(external_wp_element_["useMemo"])(() => Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-inserter__block-list"
  }, Object(external_wp_element_["createElement"])(block_types_tab, {
    rootClientId: destinationRootClientId,
    onInsert: onInsert,
    onHover: onHover,
    showMostUsedBlocks: showMostUsedBlocks
  })), showInserterHelpPanel && Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-inserter__tips"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["VisuallyHidden"], {
    as: "h2"
  }, Object(external_wp_i18n_["__"])('A tip for using the block editor')), Object(external_wp_element_["createElement"])(tips, null))), [destinationRootClientId, onInsert, onHover, filterValue, showMostUsedBlocks, showInserterHelpPanel]);
  const patternsTab = Object(external_wp_element_["useMemo"])(() => Object(external_wp_element_["createElement"])(block_patterns_tab, {
    rootClientId: destinationRootClientId,
    onInsert: onInsertPattern,
    onClickCategory: onClickPatternCategory,
    selectedCategory: selectedPatternCategory
  }), [destinationRootClientId, onInsertPattern, onClickPatternCategory, selectedPatternCategory]);
  const reusableBlocksTab = Object(external_wp_element_["useMemo"])(() => Object(external_wp_element_["createElement"])(reusable_blocks_tab, {
    rootClientId: destinationRootClientId,
    onInsert: onInsert,
    onHover: onHover
  }), [destinationRootClientId, onInsert, onHover]);
  const getCurrentTab = Object(external_wp_element_["useCallback"])(tab => {
    if (tab.name === 'blocks') {
      return blocksTab;
    } else if (tab.name === 'patterns') {
      return patternsTab;
    }

    return reusableBlocksTab;
  }, [blocksTab, patternsTab, reusableBlocksTab]);
  return Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-inserter__menu"
  }, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-inserter__main-area"
  }, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-inserter__content"
  }, Object(external_wp_element_["createElement"])(search_form, {
    onChange: value => {
      if (hoveredItem) setHoveredItem(null);
      setFilterValue(value);
    },
    value: filterValue,
    label: Object(external_wp_i18n_["__"])('Search for blocks and patterns'),
    placeholder: Object(external_wp_i18n_["__"])('Search')
  }), !!filterValue && Object(external_wp_element_["createElement"])(search_results, {
    filterValue: filterValue,
    onSelect: onSelect,
    onHover: onHover,
    rootClientId: rootClientId,
    clientId: clientId,
    isAppender: isAppender,
    __experimentalInsertionIndex: __experimentalInsertionIndex,
    showBlockDirectory: true,
    shouldFocusBlock: shouldFocusBlock
  }), !filterValue && (showPatterns || hasReusableBlocks) && Object(external_wp_element_["createElement"])(inserter_tabs, {
    showPatterns: showPatterns,
    showReusableBlocks: hasReusableBlocks
  }, getCurrentTab), !filterValue && !showPatterns && !hasReusableBlocks && blocksTab)), showInserterHelpPanel && hoveredItem && Object(external_wp_element_["createElement"])(preview_panel, {
    item: hoveredItem
  }));
}

/* harmony default export */ var menu = (InserterMenu);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/quick-inserter.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */







const SEARCH_THRESHOLD = 6;
const quick_inserter_SHOWN_BLOCK_TYPES = 6;
const SHOWN_BLOCK_PATTERNS = 2;
function QuickInserter({
  onSelect,
  rootClientId,
  clientId,
  isAppender
}) {
  const [filterValue, setFilterValue] = Object(external_wp_element_["useState"])('');
  const [destinationRootClientId, onInsertBlocks] = use_insertion_point({
    onSelect,
    rootClientId,
    clientId,
    isAppender
  });
  const [blockTypes] = use_block_types_state(destinationRootClientId, onInsertBlocks);
  const [patterns] = use_patterns_state(onInsertBlocks, destinationRootClientId);
  const showPatterns = patterns.length && !!filterValue;
  const showSearch = showPatterns && patterns.length > SEARCH_THRESHOLD || blockTypes.length > SEARCH_THRESHOLD;
  const {
    setInserterIsOpened,
    insertionIndex
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getSettings,
      getBlockIndex,
      getBlockCount
    } = select(store);
    const index = getBlockIndex(clientId, rootClientId);
    return {
      setInserterIsOpened: getSettings().__experimentalSetIsInserterOpened,
      insertionIndex: index === -1 ? getBlockCount() : index
    };
  }, [clientId, rootClientId]);
  Object(external_wp_element_["useEffect"])(() => {
    if (setInserterIsOpened) {
      setInserterIsOpened(false);
    }
  }, [setInserterIsOpened]); // When clicking Browse All select the appropriate block so as
  // the insertion point can work as expected

  const onBrowseAll = () => {
    setInserterIsOpened({
      rootClientId,
      insertionIndex
    });
  };

  return Object(external_wp_element_["createElement"])("div", {
    className: classnames_default()('block-editor-inserter__quick-inserter', {
      'has-search': showSearch,
      'has-expand': setInserterIsOpened
    })
  }, showSearch && Object(external_wp_element_["createElement"])(search_form, {
    value: filterValue,
    onChange: value => {
      setFilterValue(value);
    },
    label: Object(external_wp_i18n_["__"])('Search for blocks and patterns'),
    placeholder: Object(external_wp_i18n_["__"])('Search')
  }), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-inserter__quick-inserter-results"
  }, Object(external_wp_element_["createElement"])(search_results, {
    filterValue: filterValue,
    onSelect: onSelect,
    rootClientId: rootClientId,
    clientId: clientId,
    isAppender: isAppender,
    maxBlockPatterns: showPatterns ? SHOWN_BLOCK_PATTERNS : 0,
    maxBlockTypes: quick_inserter_SHOWN_BLOCK_TYPES,
    isDraggable: false
  })), setInserterIsOpened && Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    className: "block-editor-inserter__quick-inserter-expand",
    onClick: onBrowseAll,
    "aria-label": Object(external_wp_i18n_["__"])('Browse all. This will open the main inserter panel in the editor toolbar.')
  }, Object(external_wp_i18n_["__"])('Browse all')));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/index.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */









/**
 * Internal dependencies
 */





const defaultRenderToggle = ({
  onToggle,
  disabled,
  isOpen,
  blockTitle,
  hasSingleBlockType,
  toggleProps = {}
}) => {
  let label;

  if (hasSingleBlockType) {
    label = Object(external_wp_i18n_["sprintf"])( // translators: %s: the name of the block when there is only one
    Object(external_wp_i18n_["_x"])('Add %s', 'directly add the only allowed block'), blockTitle);
  } else {
    label = Object(external_wp_i18n_["_x"])('Add block', 'Generic label for block inserter button');
  }

  const {
    onClick,
    ...rest
  } = toggleProps; // Handle both onClick functions from the toggle and the parent component

  function handleClick(event) {
    if (onToggle) {
      onToggle(event);
    }

    if (onClick) {
      onClick(event);
    }
  }

  return Object(external_wp_element_["createElement"])(external_wp_components_["Button"], Object(esm_extends["a" /* default */])({
    icon: plus["a" /* default */],
    label: label,
    tooltipPosition: "bottom",
    onClick: handleClick,
    className: "block-editor-inserter__toggle",
    "aria-haspopup": !hasSingleBlockType ? 'true' : false,
    "aria-expanded": !hasSingleBlockType ? isOpen : false,
    disabled: disabled
  }, rest));
};

class inserter_Inserter extends external_wp_element_["Component"] {
  constructor() {
    super(...arguments);
    this.onToggle = this.onToggle.bind(this);
    this.renderToggle = this.renderToggle.bind(this);
    this.renderContent = this.renderContent.bind(this);
  }

  onToggle(isOpen) {
    const {
      onToggle
    } = this.props; // Surface toggle callback to parent component

    if (onToggle) {
      onToggle(isOpen);
    }
  }
  /**
   * Render callback to display Dropdown toggle element.
   *
   * @param {Object}   options
   * @param {Function} options.onToggle Callback to invoke when toggle is
   *                                    pressed.
   * @param {boolean}  options.isOpen   Whether dropdown is currently open.
   *
   * @return {WPElement} Dropdown toggle element.
   */


  renderToggle({
    onToggle,
    isOpen
  }) {
    const {
      disabled,
      blockTitle,
      hasSingleBlockType,
      toggleProps,
      hasItems,
      renderToggle = defaultRenderToggle
    } = this.props;
    return renderToggle({
      onToggle,
      isOpen,
      disabled: disabled || !hasItems,
      blockTitle,
      hasSingleBlockType,
      toggleProps
    });
  }
  /**
   * Render callback to display Dropdown content element.
   *
   * @param {Object}   options
   * @param {Function} options.onClose Callback to invoke when dropdown is
   *                                   closed.
   *
   * @return {WPElement} Dropdown content element.
   */


  renderContent({
    onClose
  }) {
    const {
      rootClientId,
      clientId,
      isAppender,
      showInserterHelpPanel,
      // This prop is experimental to give some time for the quick inserter to mature
      // Feel free to make them stable after a few releases.
      __experimentalIsQuick: isQuick
    } = this.props;

    if (isQuick) {
      return Object(external_wp_element_["createElement"])(QuickInserter, {
        onSelect: () => {
          onClose();
        },
        rootClientId: rootClientId,
        clientId: clientId,
        isAppender: isAppender
      });
    }

    return Object(external_wp_element_["createElement"])(menu, {
      onSelect: () => {
        onClose();
      },
      rootClientId: rootClientId,
      clientId: clientId,
      isAppender: isAppender,
      showInserterHelpPanel: showInserterHelpPanel
    });
  }

  render() {
    const {
      position,
      hasSingleBlockType,
      insertOnlyAllowedBlock,
      __experimentalIsQuick: isQuick,
      onSelectOrClose
    } = this.props;

    if (hasSingleBlockType) {
      return this.renderToggle({
        onToggle: insertOnlyAllowedBlock
      });
    }

    return Object(external_wp_element_["createElement"])(external_wp_components_["Dropdown"], {
      className: "block-editor-inserter",
      contentClassName: classnames_default()('block-editor-inserter__popover', {
        'is-quick': isQuick
      }),
      position: position,
      onToggle: this.onToggle,
      expandOnMobile: true,
      headerTitle: Object(external_wp_i18n_["__"])('Add a block'),
      renderToggle: this.renderToggle,
      renderContent: this.renderContent,
      onClose: onSelectOrClose
    });
  }

}

/* harmony default export */ var inserter = (Object(external_wp_compose_["compose"])([Object(external_wp_data_["withSelect"])((select, {
  clientId,
  rootClientId
}) => {
  const {
    getBlockRootClientId,
    hasInserterItems,
    __experimentalGetAllowedBlocks
  } = select(store);
  const {
    getBlockVariations
  } = select(external_wp_blocks_["store"]);
  rootClientId = rootClientId || getBlockRootClientId(clientId) || undefined;

  const allowedBlocks = __experimentalGetAllowedBlocks(rootClientId);

  const hasSingleBlockType = Object(external_lodash_["size"])(allowedBlocks) === 1 && Object(external_lodash_["size"])(getBlockVariations(allowedBlocks[0].name, 'inserter')) === 0;
  let allowedBlockType = false;

  if (hasSingleBlockType) {
    allowedBlockType = allowedBlocks[0];
  }

  return {
    hasItems: hasInserterItems(rootClientId),
    hasSingleBlockType,
    blockTitle: allowedBlockType ? allowedBlockType.title : '',
    allowedBlockType,
    rootClientId
  };
}), Object(external_wp_data_["withDispatch"])((dispatch, ownProps, {
  select
}) => {
  return {
    insertOnlyAllowedBlock() {
      const {
        rootClientId,
        clientId,
        isAppender,
        hasSingleBlockType,
        allowedBlockType,
        onSelectOrClose
      } = ownProps;

      if (!hasSingleBlockType) {
        return;
      }

      function getInsertionIndex() {
        const {
          getBlockIndex,
          getBlockSelectionEnd,
          getBlockOrder,
          getBlockRootClientId
        } = select(store); // If the clientId is defined, we insert at the position of the block.

        if (clientId) {
          return getBlockIndex(clientId, rootClientId);
        } // If there a selected block, we insert after the selected block.


        const end = getBlockSelectionEnd();

        if (!isAppender && end && getBlockRootClientId(end) === rootClientId) {
          return getBlockIndex(end, rootClientId) + 1;
        } // Otherwise, we insert at the end of the current rootClientId


        return getBlockOrder(rootClientId).length;
      }

      const {
        insertBlock
      } = dispatch(store);
      const blockToInsert = Object(external_wp_blocks_["createBlock"])(allowedBlockType.name);
      insertBlock(blockToInsert, getInsertionIndex(), rootClientId);

      if (onSelectOrClose) {
        onSelectOrClose();
      }

      const message = Object(external_wp_i18n_["sprintf"])( // translators: %s: the name of the block that has been added
      Object(external_wp_i18n_["__"])('%s block added'), allowedBlockType.title);
      Object(external_wp_a11y_["speak"])(message);
    }

  };
}), // The global inserter should always be visible, we are using ( ! isAppender && ! rootClientId && ! clientId ) as
// a way to detect the global Inserter.
Object(external_wp_compose_["ifCondition"])(({
  hasItems,
  isAppender,
  rootClientId,
  clientId
}) => hasItems || !isAppender && !rootClientId && !clientId)])(inserter_Inserter));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/default-block-appender/index.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



/**
 * Zero width non-breaking space, used as padding for the paragraph when it is
 * empty.
 */

const ZWNBSP = '\ufeff';
function DefaultBlockAppender({
  isLocked,
  isVisible,
  onAppend,
  showPrompt,
  placeholder,
  rootClientId
}) {
  if (isLocked || !isVisible) {
    return null;
  }

  const value = Object(external_wp_htmlEntities_["decodeEntities"])(placeholder) || Object(external_wp_i18n_["__"])('Type / to choose a block');

  return Object(external_wp_element_["createElement"])("div", {
    "data-root-client-id": rootClientId || '',
    className: "block-editor-default-block-appender"
  }, Object(external_wp_element_["createElement"])("p", {
    tabIndex: "0" // Only necessary for `useCanvasClickRedirect` to consider it
    // as a target. Ideally it should consider any tabbable target,
    // but the inserter is rendered in place while it should be
    // rendered in a popover, just like it does for an empty
    // paragraph block.
    ,
    contentEditable: true,
    suppressContentEditableWarning: true // We want this element to be styled as a paragraph by themes.
    // eslint-disable-next-line jsx-a11y/no-noninteractive-element-to-interactive-role
    ,
    role: "button",
    "aria-label": Object(external_wp_i18n_["__"])('Add block') // The wp-block className is important for editor styles.
    ,
    className: "wp-block block-editor-default-block-appender__content",
    onFocus: onAppend
  }, showPrompt ? value : ZWNBSP), Object(external_wp_element_["createElement"])(inserter, {
    rootClientId: rootClientId,
    position: "bottom right",
    isAppender: true,
    __experimentalIsQuick: true
  }));
}
/* harmony default export */ var default_block_appender = (Object(external_wp_compose_["compose"])(Object(external_wp_data_["withSelect"])((select, ownProps) => {
  const {
    getBlockCount,
    getBlockName,
    isBlockValid,
    getSettings,
    getTemplateLock
  } = select(store);
  const isEmpty = !getBlockCount(ownProps.rootClientId);
  const isLastBlockDefault = getBlockName(ownProps.lastBlockClientId) === Object(external_wp_blocks_["getDefaultBlockName"])();
  const isLastBlockValid = isBlockValid(ownProps.lastBlockClientId);
  const {
    bodyPlaceholder
  } = getSettings();
  return {
    isVisible: isEmpty || !isLastBlockDefault || !isLastBlockValid,
    showPrompt: isEmpty,
    isLocked: !!getTemplateLock(ownProps.rootClientId),
    placeholder: bodyPlaceholder
  };
}), Object(external_wp_data_["withDispatch"])((dispatch, ownProps) => {
  const {
    insertDefaultBlock,
    startTyping
  } = dispatch(store);
  return {
    onAppend() {
      const {
        rootClientId
      } = ownProps;
      insertDefaultBlock(undefined, rootClientId);
      startTyping();
    }

  };
}))(DefaultBlockAppender));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/button-block-appender/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */



function ButtonBlockAppender({
  rootClientId,
  className,
  onFocus,
  tabIndex
}, ref) {
  return Object(external_wp_element_["createElement"])(inserter, {
    position: "bottom center",
    rootClientId: rootClientId,
    __experimentalIsQuick: true,
    renderToggle: ({
      onToggle,
      disabled,
      isOpen,
      blockTitle,
      hasSingleBlockType
    }) => {
      let label;

      if (hasSingleBlockType) {
        label = Object(external_wp_i18n_["sprintf"])( // translators: %s: the name of the block when there is only one
        Object(external_wp_i18n_["_x"])('Add %s', 'directly add the only allowed block'), blockTitle);
      } else {
        label = Object(external_wp_i18n_["_x"])('Add block', 'Generic label for block inserter button');
      }

      const isToggleButton = !hasSingleBlockType;
      let inserterButton = Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
        ref: ref,
        onFocus: onFocus,
        tabIndex: tabIndex,
        className: classnames_default()(className, 'block-editor-button-block-appender'),
        onClick: onToggle,
        "aria-haspopup": isToggleButton ? 'true' : undefined,
        "aria-expanded": isToggleButton ? isOpen : undefined,
        disabled: disabled,
        label: label
      }, !hasSingleBlockType && Object(external_wp_element_["createElement"])(external_wp_components_["VisuallyHidden"], {
        as: "span"
      }, label), Object(external_wp_element_["createElement"])(build_module_icon["a" /* default */], {
        icon: plus["a" /* default */]
      }));

      if (isToggleButton || hasSingleBlockType) {
        inserterButton = Object(external_wp_element_["createElement"])(external_wp_components_["Tooltip"], {
          text: label
        }, inserterButton);
      }

      return inserterButton;
    },
    isAppender: true
  });
}
/**
 * Use `ButtonBlockAppender` instead.
 *
 * @deprecated
 */


const ButtonBlockerAppender = Object(external_wp_element_["forwardRef"])((props, ref) => {
  external_wp_deprecated_default()(`wp.blockEditor.ButtonBlockerAppender`, {
    alternative: 'wp.blockEditor.ButtonBlockAppender'
  });
  return ButtonBlockAppender(props, ref);
});
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/button-block-appender/README.md
 */

/* harmony default export */ var button_block_appender = (Object(external_wp_element_["forwardRef"])(ButtonBlockAppender));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list-appender/index.js


/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



 // A Context to store the map of the appender map.

const AppenderNodesContext = Object(external_wp_element_["createContext"])();

function stopPropagation(event) {
  event.stopPropagation();
}

function BlockListAppender({
  blockClientIds,
  rootClientId,
  canInsertDefaultBlock,
  isLocked,
  renderAppender: CustomAppender,
  className,
  selectedBlockClientId,
  tagName: TagName = 'div'
}) {
  if (isLocked || CustomAppender === false) {
    return null;
  }

  let appender;

  if (CustomAppender) {
    // Prefer custom render prop if provided.
    appender = Object(external_wp_element_["createElement"])(CustomAppender, null);
  } else {
    const isDocumentAppender = !rootClientId;
    const isParentSelected = selectedBlockClientId === rootClientId;
    const isAnotherDefaultAppenderAlreadyDisplayed = selectedBlockClientId && !blockClientIds.includes(selectedBlockClientId);

    if (!isDocumentAppender && !isParentSelected && (!selectedBlockClientId || isAnotherDefaultAppenderAlreadyDisplayed)) {
      return null;
    }

    if (canInsertDefaultBlock) {
      // Render the default block appender when renderAppender has not been
      // provided and the context supports use of the default appender.
      appender = Object(external_wp_element_["createElement"])(default_block_appender, {
        rootClientId: rootClientId,
        lastBlockClientId: Object(external_lodash_["last"])(blockClientIds)
      });
    } else {
      // Fallback in the case no renderAppender has been provided and the
      // default block can't be inserted.
      appender = Object(external_wp_element_["createElement"])(button_block_appender, {
        rootClientId: rootClientId,
        className: "block-list-appender__toggle"
      });
    }
  }

  return Object(external_wp_element_["createElement"])(TagName // A `tabIndex` is used on the wrapping `div` element in order to
  // force a focus event to occur when an appender `button` element
  // is clicked. In some browsers (Firefox, Safari), button clicks do
  // not emit a focus event, which could cause this event to propagate
  // unexpectedly. The `tabIndex` ensures that the interaction is
  // captured as a focus, without also adding an extra tab stop.
  //
  // See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
  , {
    tabIndex: -1 // Prevent the block from being selected when the appender is
    // clicked.
    ,
    onFocus: stopPropagation,
    className: classnames_default()('block-list-appender', className)
  }, appender);
}

/* harmony default export */ var block_list_appender = (Object(external_wp_data_["withSelect"])((select, {
  rootClientId
}) => {
  const {
    getBlockOrder,
    canInsertBlockType,
    getTemplateLock,
    getSelectedBlockClientId
  } = select(store);
  return {
    isLocked: !!getTemplateLock(rootClientId),
    blockClientIds: getBlockOrder(rootClientId),
    canInsertDefaultBlock: canInsertBlockType(Object(external_wp_blocks_["getDefaultBlockName"])(), rootClientId),
    selectedBlockClientId: getSelectedBlockClientId()
  };
})(BlockListAppender));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/use-on-block-drop/index.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/** @typedef {import('@wordpress/element').WPSyntheticEvent} WPSyntheticEvent */

/**
 * Retrieve the data for a block drop event.
 *
 * @param {WPSyntheticEvent} event The drop event.
 *
 * @return {Object} An object with block drag and drop data.
 */

function parseDropEvent(event) {
  let result = {
    srcRootClientId: null,
    srcClientIds: null,
    srcIndex: null,
    type: null,
    blocks: null
  };

  if (!event.dataTransfer) {
    return result;
  }

  try {
    result = Object.assign(result, JSON.parse(event.dataTransfer.getData('wp-blocks')));
  } catch (err) {
    return result;
  }

  return result;
}
/**
 * A function that returns an event handler function for block drop events.
 *
 * @param {string} targetRootClientId        The root client id where the block(s) will be inserted.
 * @param {number} targetBlockIndex          The index where the block(s) will be inserted.
 * @param {Function} getBlockIndex             A function that gets the index of a block.
 * @param {Function} getClientIdsOfDescendants A function that gets the client ids of descendant blocks.
 * @param {Function} moveBlocksToPosition      A function that moves blocks.
 * @param {Function} insertBlocks              A function that inserts blocks.
 * @param {Function} clearSelectedBlock        A function that clears block selection.
 * @return {Function} The event handler for a block drop event.
 */

function use_on_block_drop_onBlockDrop(targetRootClientId, targetBlockIndex, getBlockIndex, getClientIdsOfDescendants, moveBlocksToPosition, insertBlocks, clearSelectedBlock) {
  return event => {
    const {
      srcRootClientId: sourceRootClientId,
      srcClientIds: sourceClientIds,
      type: dropType,
      blocks
    } = parseDropEvent(event); // If the user is inserting a block

    if (dropType === 'inserter') {
      clearSelectedBlock();
      insertBlocks(blocks, targetBlockIndex, targetRootClientId, true, null);
    } // If the user is moving a block


    if (dropType === 'block') {
      const sourceBlockIndex = getBlockIndex(sourceClientIds[0], sourceRootClientId); // If the user is dropping to the same position, return early.

      if (sourceRootClientId === targetRootClientId && sourceBlockIndex === targetBlockIndex) {
        return;
      } // If the user is attempting to drop a block within its own
      // nested blocks, return early as this would create infinite
      // recursion.


      if (sourceClientIds.includes(targetRootClientId) || getClientIdsOfDescendants(sourceClientIds).some(id => id === targetRootClientId)) {
        return;
      }

      const isAtSameLevel = sourceRootClientId === targetRootClientId;
      const draggedBlockCount = sourceClientIds.length; // If the block is kept at the same level and moved downwards,
      // subtract to take into account that the blocks being dragged
      // were removed from the block list above the insertion point.

      const insertIndex = isAtSameLevel && sourceBlockIndex < targetBlockIndex ? targetBlockIndex - draggedBlockCount : targetBlockIndex;
      moveBlocksToPosition(sourceClientIds, sourceRootClientId, targetRootClientId, insertIndex);
    }
  };
}
/**
 * A function that returns an event handler function for block-related file drop events.
 *
 * @param {string}   targetRootClientId    The root client id where the block(s) will be inserted.
 * @param {number}   targetBlockIndex      The index where the block(s) will be inserted.
 * @param {boolean}  hasUploadPermissions  Whether the user has upload permissions.
 * @param {Function} updateBlockAttributes A function that updates a block's attributes.
 * @param {Function} canInsertBlockType    A function that returns checks whether a block type can be inserted.
 * @param {Function} insertBlocks          A function that inserts blocks.
 *
 * @return {Function} The event handler for a block-related file drop event.
 */

function onFilesDrop(targetRootClientId, targetBlockIndex, hasUploadPermissions, updateBlockAttributes, canInsertBlockType, insertBlocks) {
  return files => {
    if (!hasUploadPermissions) {
      return;
    }

    const transformation = Object(external_wp_blocks_["findTransform"])(Object(external_wp_blocks_["getBlockTransforms"])('from'), transform => transform.type === 'files' && canInsertBlockType(transform.blockName, targetRootClientId) && transform.isMatch(files));

    if (transformation) {
      const blocks = transformation.transform(files, updateBlockAttributes);
      insertBlocks(blocks, targetBlockIndex, targetRootClientId);
    }
  };
}
/**
 * A function that returns an event handler function for block-related HTML drop events.
 *
 * @param {string}   targetRootClientId The root client id where the block(s) will be inserted.
 * @param {number}   targetBlockIndex   The index where the block(s) will be inserted.
 * @param {Function} insertBlocks       A function that inserts blocks.
 *
 * @return {Function} The event handler for a block-related HTML drop event.
 */

function use_on_block_drop_onHTMLDrop(targetRootClientId, targetBlockIndex, insertBlocks) {
  return HTML => {
    const blocks = Object(external_wp_blocks_["pasteHandler"])({
      HTML,
      mode: 'BLOCKS'
    });

    if (blocks.length) {
      insertBlocks(blocks, targetBlockIndex, targetRootClientId);
    }
  };
}
/**
 * A React hook for handling block drop events.
 *
 * @param {string} targetRootClientId The root client id where the block(s) will be inserted.
 * @param {number} targetBlockIndex   The index where the block(s) will be inserted.
 *
 * @return {Object} An object that contains the event handlers `onDrop`, `onFilesDrop` and `onHTMLDrop`.
 */

function useOnBlockDrop(targetRootClientId, targetBlockIndex) {
  const hasUploadPermissions = Object(external_wp_data_["useSelect"])(select => select(store).getSettings().mediaUpload, []);
  const {
    canInsertBlockType,
    getBlockIndex,
    getClientIdsOfDescendants
  } = Object(external_wp_data_["useSelect"])(store);
  const {
    insertBlocks,
    moveBlocksToPosition,
    updateBlockAttributes,
    clearSelectedBlock
  } = Object(external_wp_data_["useDispatch"])(store);

  const _onDrop = use_on_block_drop_onBlockDrop(targetRootClientId, targetBlockIndex, getBlockIndex, getClientIdsOfDescendants, moveBlocksToPosition, insertBlocks, clearSelectedBlock);

  const _onFilesDrop = onFilesDrop(targetRootClientId, targetBlockIndex, hasUploadPermissions, updateBlockAttributes, canInsertBlockType, insertBlocks);

  const _onHTMLDrop = use_on_block_drop_onHTMLDrop(targetRootClientId, targetBlockIndex, insertBlocks);

  return event => {
    const files = Object(external_wp_dom_["getFilesFromDataTransfer"])(event.dataTransfer);
    const html = event.dataTransfer.getData('text/html');

    if (files.length) {
      _onFilesDrop(files);
    } else if (html) {
      _onHTMLDrop(html);
    } else {
      _onDrop(event);
    }
  };
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/math.js
/**
 * A string representing the name of an edge.
 *
 * @typedef {'top'|'right'|'bottom'|'left'} WPEdgeName
 */

/**
 * @typedef  {Object} WPPoint
 * @property {number} x The horizontal position.
 * @property {number} y The vertical position.
 */

/**
 * Given a point, a DOMRect and the name of an edge, returns the distance to
 * that edge of the rect.
 *
 * This function works for edges that are horizontal or vertical (e.g. not
 * rotated), the following terms are used so that the function works in both
 * orientations:
 *
 * - Forward, meaning the axis running horizontally when an edge is vertical
 *   and vertically when an edge is horizontal.
 * - Lateral, meaning the axis running vertically when an edge is vertical
 *   and horizontally when an edge is horizontal.
 *
 * @param {WPPoint}    point The point to measure distance from.
 * @param {DOMRect}    rect  A DOM Rect containing edge positions.
 * @param {WPEdgeName} edge  The edge to measure to.
 */
function getDistanceFromPointToEdge(point, rect, edge) {
  const isHorizontal = edge === 'top' || edge === 'bottom';
  const {
    x,
    y
  } = point;
  const pointLateralPosition = isHorizontal ? x : y;
  const pointForwardPosition = isHorizontal ? y : x;
  const edgeStart = isHorizontal ? rect.left : rect.top;
  const edgeEnd = isHorizontal ? rect.right : rect.bottom;
  const edgeForwardPosition = rect[edge]; // Measure the straight line distance to the edge of the rect, when the
  // point is adjacent to the edge.
  // Else, if the point is positioned diagonally to the edge of the rect,
  // measure diagonally to the nearest corner that the edge meets.

  let edgeLateralPosition;

  if (pointLateralPosition >= edgeStart && pointLateralPosition <= edgeEnd) {
    edgeLateralPosition = pointLateralPosition;
  } else if (pointLateralPosition < edgeEnd) {
    edgeLateralPosition = edgeStart;
  } else {
    edgeLateralPosition = edgeEnd;
  }

  return Math.sqrt((pointLateralPosition - edgeLateralPosition) ** 2 + (pointForwardPosition - edgeForwardPosition) ** 2);
}
/**
 * Given a point, a DOMRect and a list of allowed edges returns the name of and
 * distance to the nearest edge.
 *
 * @param {WPPoint}      point        The point to measure distance from.
 * @param {DOMRect}      rect         A DOM Rect containing edge positions.
 * @param {WPEdgeName[]} allowedEdges A list of the edges included in the
 *                                    calculation. Defaults to all edges.
 *
 * @return {[number, string]} An array where the first value is the distance
 *                              and a second is the edge name.
 */

function getDistanceToNearestEdge(point, rect, allowedEdges = ['top', 'bottom', 'left', 'right']) {
  let candidateDistance;
  let candidateEdge;
  allowedEdges.forEach(edge => {
    const distance = getDistanceFromPointToEdge(point, rect, edge);

    if (candidateDistance === undefined || distance < candidateDistance) {
      candidateDistance = distance;
      candidateEdge = edge;
    }
  });
  return [candidateDistance, candidateEdge];
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/use-block-drop-zone/index.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




/** @typedef {import('../../utils/math').WPPoint} WPPoint */

/**
 * The orientation of a block list.
 *
 * @typedef {'horizontal'|'vertical'|undefined} WPBlockListOrientation
 */

/**
 * Given a list of block DOM elements finds the index that a block should be dropped
 * at.
 *
 * @param {Element[]}              elements    Array of DOM elements that represent each block in a block list.
 * @param {WPPoint}                position    The position of the item being dragged.
 * @param {WPBlockListOrientation} orientation The orientation of a block list.
 *
 * @return {number|undefined} The block index that's closest to the drag position.
 */

function getNearestBlockIndex(elements, position, orientation) {
  const allowedEdges = orientation === 'horizontal' ? ['left', 'right'] : ['top', 'bottom'];
  const isRightToLeft = Object(external_wp_i18n_["isRTL"])();
  let candidateIndex;
  let candidateDistance;
  elements.forEach((element, index) => {
    const rect = element.getBoundingClientRect();
    const [distance, edge] = getDistanceToNearestEdge(position, rect, allowedEdges);

    if (candidateDistance === undefined || distance < candidateDistance) {
      // If the user is dropping to the trailing edge of the block
      // add 1 to the index to represent dragging after.
      // Take RTL languages into account where the left edge is
      // the trailing edge.
      const isTrailingEdge = edge === 'bottom' || !isRightToLeft && edge === 'right' || isRightToLeft && edge === 'left';
      const offset = isTrailingEdge ? 1 : 0; // Update the currently known best candidate.

      candidateDistance = distance;
      candidateIndex = index + offset;
    }
  });
  return candidateIndex;
}
/**
 * @typedef  {Object} WPBlockDropZoneConfig
 * @property {string} rootClientId The root client id for the block list.
 */

/**
 * A React hook that can be used to make a block list handle drag and drop.
 *
 * @param {WPBlockDropZoneConfig} dropZoneConfig configuration data for the drop zone.
 */

function useBlockDropZone({
  // An undefined value represents a top-level block. Default to an empty
  // string for this so that `targetRootClientId` can be easily compared to
  // values returned by the `getRootBlockClientId` selector, which also uses
  // an empty string to represent top-level blocks.
  rootClientId: targetRootClientId = ''
} = {}) {
  const [targetBlockIndex, setTargetBlockIndex] = Object(external_wp_element_["useState"])(null);
  const isLockedAll = Object(external_wp_data_["useSelect"])(select => {
    const {
      getTemplateLock
    } = select(store);
    return getTemplateLock(targetRootClientId) === 'all';
  }, [targetRootClientId]);
  const {
    getBlockListSettings
  } = Object(external_wp_data_["useSelect"])(store);
  const {
    showInsertionPoint,
    hideInsertionPoint
  } = Object(external_wp_data_["useDispatch"])(store);
  const onBlockDrop = useOnBlockDrop(targetRootClientId, targetBlockIndex);
  const throttled = Object(external_wp_compose_["useThrottle"])(Object(external_wp_element_["useCallback"])((event, currentTarget) => {
    var _getBlockListSettings;

    const blockElements = Array.from(currentTarget.children).filter( // Ensure the element is a block. It should have the `wp-block` class.
    element => element.classList.contains('wp-block'));
    const targetIndex = getNearestBlockIndex(blockElements, {
      x: event.clientX,
      y: event.clientY
    }, (_getBlockListSettings = getBlockListSettings(targetRootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation);
    setTargetBlockIndex(targetIndex === undefined ? 0 : targetIndex);

    if (targetIndex !== null) {
      showInsertionPoint(targetRootClientId, targetIndex);
    }
  }, []), 200);
  return Object(external_wp_compose_["__experimentalUseDropZone"])({
    isDisabled: isLockedAll,
    onDrop: onBlockDrop,

    onDragOver(event) {
      // `currentTarget` is only available while the event is being
      // handled, so get it now and pass it to the thottled function.
      // https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget
      throttled(event, event.currentTarget);
    },

    onDragLeave() {
      throttled.cancel();
      hideInsertionPoint();
      setTargetBlockIndex(null);
    },

    onDragEnd() {
      throttled.cancel();
      hideInsertionPoint();
      setTargetBlockIndex(null);
    }

  });
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-tools/use-popover-scroll.js
/**
 * WordPress dependencies
 */

/**
 * Allow scrolling "through" popovers over the canvas. This is only called for
 * as long as the pointer is over a popover. Do not use React events because it
 * will bubble through portals.
 *
 * @param {Object} scrollableRef
 */

function usePopoverScroll(scrollableRef) {
  return Object(external_wp_compose_["useRefEffect"])(node => {
    if (!scrollableRef) {
      return;
    }

    function onWheel(event) {
      const {
        deltaX,
        deltaY
      } = event;
      scrollableRef.current.scrollBy(deltaX, deltaY);
    }

    node.addEventListener('wheel', onWheel);
    return () => {
      node.removeEventListener('wheel', onWheel);
    };
  }, [scrollableRef]);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-tools/insertion-point.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */





const InsertionPointOpenRef = Object(external_wp_element_["createContext"])();

function InsertionPointPopover({
  __unstablePopoverSlot,
  __unstableContentRef
}) {
  const {
    selectBlock
  } = Object(external_wp_data_["useDispatch"])(store);
  const openRef = Object(external_wp_element_["useContext"])(InsertionPointOpenRef);
  const ref = Object(external_wp_element_["useRef"])();
  const {
    orientation,
    previousClientId,
    nextClientId,
    rootClientId,
    isInserterShown
  } = Object(external_wp_data_["useSelect"])(select => {
    var _getBlockListSettings;

    const {
      getBlockOrder,
      getBlockListSettings,
      getBlockInsertionPoint,
      isBlockBeingDragged,
      getPreviousBlockClientId,
      getNextBlockClientId
    } = select(store);
    const insertionPoint = getBlockInsertionPoint();
    const order = getBlockOrder(insertionPoint.rootClientId);

    if (!order.length) {
      return {};
    }

    let _previousClientId = order[insertionPoint.index - 1];
    let _nextClientId = order[insertionPoint.index];

    while (isBlockBeingDragged(_previousClientId)) {
      _previousClientId = getPreviousBlockClientId(_previousClientId);
    }

    while (isBlockBeingDragged(_nextClientId)) {
      _nextClientId = getNextBlockClientId(_nextClientId);
    }

    return {
      previousClientId: _previousClientId,
      nextClientId: _nextClientId,
      orientation: ((_getBlockListSettings = getBlockListSettings(insertionPoint.rootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation) || 'vertical',
      rootClientId: insertionPoint.rootClientId,
      isInserterShown: insertionPoint === null || insertionPoint === void 0 ? void 0 : insertionPoint.__unstableWithInserter
    };
  }, []);
  const previousElement = useBlockElement(previousClientId);
  const nextElement = useBlockElement(nextClientId);
  const style = Object(external_wp_element_["useMemo"])(() => {
    if (!previousElement && !nextElement) {
      return {};
    }

    const previousRect = previousElement ? previousElement.getBoundingClientRect() : null;
    const nextRect = nextElement ? nextElement.getBoundingClientRect() : null;

    if (orientation === 'vertical') {
      return {
        width: previousElement ? previousElement.offsetWidth : nextElement.offsetWidth,
        height: nextRect && previousRect ? nextRect.top - previousRect.bottom : 0
      };
    }

    let width = 0;

    if (previousRect && nextRect) {
      width = Object(external_wp_i18n_["isRTL"])() ? previousRect.left - nextRect.right : nextRect.left - previousRect.right;
    }

    return {
      width,
      height: previousElement ? previousElement.offsetHeight : nextElement.offsetHeight
    };
  }, [previousElement, nextElement]);
  const getAnchorRect = Object(external_wp_element_["useCallback"])(() => {
    if (!previousElement && !nextElement) {
      return {};
    }

    const {
      ownerDocument
    } = previousElement || nextElement;
    const previousRect = previousElement ? previousElement.getBoundingClientRect() : null;
    const nextRect = nextElement ? nextElement.getBoundingClientRect() : null;

    if (orientation === 'vertical') {
      if (Object(external_wp_i18n_["isRTL"])()) {
        return {
          top: previousRect ? previousRect.bottom : nextRect.top,
          left: previousRect ? previousRect.right : nextRect.right,
          right: previousRect ? previousRect.left : nextRect.left,
          bottom: nextRect ? nextRect.top : previousRect.bottom,
          ownerDocument
        };
      }

      return {
        top: previousRect ? previousRect.bottom : nextRect.top,
        left: previousRect ? previousRect.left : nextRect.left,
        right: previousRect ? previousRect.right : nextRect.right,
        bottom: nextRect ? nextRect.top : previousRect.bottom,
        ownerDocument
      };
    }

    if (Object(external_wp_i18n_["isRTL"])()) {
      return {
        top: previousRect ? previousRect.top : nextRect.top,
        left: previousRect ? previousRect.left : nextRect.right,
        right: nextRect ? nextRect.right : previousRect.left,
        bottom: previousRect ? previousRect.bottom : nextRect.bottom,
        ownerDocument
      };
    }

    return {
      top: previousRect ? previousRect.top : nextRect.top,
      left: previousRect ? previousRect.right : nextRect.left,
      right: nextRect ? nextRect.left : previousRect.right,
      bottom: previousRect ? previousRect.bottom : nextRect.bottom,
      ownerDocument
    };
  }, [previousElement, nextElement]);
  const popoverScrollRef = usePopoverScroll(__unstableContentRef);
  const className = classnames_default()('block-editor-block-list__insertion-point', 'is-' + orientation);

  function onClick(event) {
    if (event.target === ref.current && nextClientId) {
      selectBlock(nextClientId, -1);
    }
  }

  function onFocus(event) {
    // Only handle click on the wrapper specifically, and not an event
    // bubbled from the inserter itself.
    if (event.target !== ref.current) {
      openRef.current = true;
    }
  } // Only show the in-between inserter between blocks, so when there's a
  // previous and a next element.


  const showInsertionPointInserter = previousElement && nextElement && isInserterShown;
  /* eslint-disable jsx-a11y/no-static-element-interactions, jsx-a11y/click-events-have-key-events */
  // While ideally it would be enough to capture the
  // bubbling focus event from the Inserter, due to the
  // characteristics of click focusing of `button`s in
  // Firefox and Safari, it is not reliable.
  //
  // See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus

  return Object(external_wp_element_["createElement"])(external_wp_components_["Popover"], {
    ref: popoverScrollRef,
    noArrow: true,
    animate: false,
    getAnchorRect: getAnchorRect,
    focusOnMount: false,
    className: "block-editor-block-list__insertion-point-popover" // Render in the old slot if needed for backward compatibility,
    // otherwise render in place (not in the the default popover slot).
    ,
    __unstableSlotName: __unstablePopoverSlot || null
  }, Object(external_wp_element_["createElement"])("div", {
    ref: ref,
    tabIndex: -1,
    onClick: onClick,
    onFocus: onFocus,
    className: classnames_default()(className, {
      'is-with-inserter': showInsertionPointInserter
    }),
    style: style
  }, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-list__insertion-point-indicator"
  }), showInsertionPointInserter && Object(external_wp_element_["createElement"])("div", {
    className: classnames_default()('block-editor-block-list__insertion-point-inserter')
  }, Object(external_wp_element_["createElement"])(inserter, {
    position: "bottom center",
    clientId: nextClientId,
    rootClientId: rootClientId,
    __experimentalIsQuick: true,
    onToggle: isOpen => {
      openRef.current = isOpen;
    },
    onSelectOrClose: () => {
      openRef.current = false;
    }
  }))));
  /* eslint-enable jsx-a11y/no-static-element-interactions, jsx-a11y/click-events-have-key-events */
}

function InsertionPoint({
  children,
  __unstablePopoverSlot,
  __unstableContentRef
}) {
  const isVisible = Object(external_wp_data_["useSelect"])(select => {
    return select(store).isBlockInsertionPointVisible();
  }, []);
  return Object(external_wp_element_["createElement"])(InsertionPointOpenRef.Provider, {
    value: Object(external_wp_element_["useRef"])(false)
  }, isVisible && Object(external_wp_element_["createElement"])(InsertionPointPopover, {
    __unstablePopoverSlot: __unstablePopoverSlot,
    __unstableContentRef: __unstableContentRef
  }), children);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-in-between-inserter.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function useInBetweenInserter() {
  const openRef = Object(external_wp_element_["useContext"])(InsertionPointOpenRef);
  const hasReducedUI = Object(external_wp_data_["useSelect"])(select => select(store).getSettings().hasReducedUI, []);
  const {
    getBlockListSettings,
    getBlockRootClientId,
    getBlockIndex,
    isBlockInsertionPointVisible,
    isMultiSelecting,
    getSelectedBlockClientIds,
    getTemplateLock
  } = Object(external_wp_data_["useSelect"])(store);
  const {
    showInsertionPoint,
    hideInsertionPoint
  } = Object(external_wp_data_["useDispatch"])(store);
  return Object(external_wp_compose_["useRefEffect"])(node => {
    if (hasReducedUI) {
      return;
    }

    function onMouseMove(event) {
      var _getBlockListSettings;

      if (openRef.current) {
        return;
      }

      if (isMultiSelecting()) {
        return;
      }

      if (!event.target.classList.contains('block-editor-block-list__layout')) {
        if (isBlockInsertionPointVisible()) {
          hideInsertionPoint();
        }

        return;
      }

      let rootClientId;

      if (!event.target.classList.contains('is-root-container')) {
        const blockElement = !!event.target.getAttribute('data-block') ? event.target : event.target.closest('[data-block]');
        rootClientId = blockElement.getAttribute('data-block');
      } // Don't set the insertion point if the template is locked.


      if (getTemplateLock(rootClientId)) {
        return;
      }

      const orientation = ((_getBlockListSettings = getBlockListSettings(rootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation) || 'vertical';
      const rect = event.target.getBoundingClientRect();
      const offsetTop = event.clientY - rect.top;
      const offsetLeft = event.clientX - rect.left;
      const children = Array.from(event.target.children);
      let element = children.find(blockEl => {
        return blockEl.classList.contains('wp-block') && orientation === 'vertical' && blockEl.offsetTop > offsetTop || blockEl.classList.contains('wp-block') && orientation === 'horizontal' && blockEl.offsetLeft > offsetLeft;
      });

      if (!element) {
        return;
      } // The block may be in an alignment wrapper, so check the first direct
      // child if the element has no ID.


      if (!element.id) {
        element = element.firstElementChild;

        if (!element) {
          return;
        }
      }

      const clientId = element.id.slice('block-'.length);

      if (!clientId) {
        return;
      } // Don't show the inserter when hovering above (conflicts with
      // block toolbar) or inside selected block(s).


      if (getSelectedBlockClientIds().includes(clientId)) {
        return;
      }

      const elementRect = element.getBoundingClientRect();

      if (orientation === 'horizontal' && (event.clientY > elementRect.bottom || event.clientY < elementRect.top) || orientation === 'vertical' && (event.clientX > elementRect.right || event.clientX < elementRect.left)) {
        if (isBlockInsertionPointVisible()) {
          hideInsertionPoint();
        }

        return;
      }

      const index = getBlockIndex(clientId, rootClientId); // Don't show the in-between inserter before the first block in
      // the list (preserves the original behaviour).

      if (index === 0) {
        if (isBlockInsertionPointVisible()) {
          hideInsertionPoint();
        }

        return;
      }

      showInsertionPoint(rootClientId, index, {
        __unstableWithInserter: true
      });
    }

    node.addEventListener('mousemove', onMouseMove);
    return () => {
      node.removeEventListener('mousemove', onMouseMove);
    };
  }, [openRef, getBlockListSettings, getBlockRootClientId, getBlockIndex, isBlockInsertionPointVisible, isMultiSelecting, showInsertionPoint, hideInsertionPoint, getSelectedBlockClientIds]);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/pre-parse-patterns.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const pre_parse_patterns_requestIdleCallback = (() => {
  if (typeof window === 'undefined') {
    return callback => {
      setTimeout(() => callback(Date.now()), 0);
    };
  }

  return window.requestIdleCallback || window.requestAnimationFrame;
})();

const cancelIdleCallback = (() => {
  if (typeof window === 'undefined') {
    return clearTimeout;
  }

  return window.cancelIdleCallback || window.cancelAnimationFrame;
})();

function usePreParsePatterns() {
  const patterns = Object(external_wp_data_["useSelect"])(_select => _select(store).getSettings().__experimentalBlockPatterns, []);
  Object(external_wp_element_["useEffect"])(() => {
    if (!(patterns !== null && patterns !== void 0 && patterns.length)) {
      return;
    }

    let handle;
    let index = -1;

    const callback = () => {
      index++;

      if (index >= patterns.length) {
        return;
      }

      Object(external_wp_data_["select"])(store).__experimentalGetParsedPattern(patterns[index].name);

      handle = pre_parse_patterns_requestIdleCallback(callback);
    };

    handle = pre_parse_patterns_requestIdleCallback(callback);
    return () => cancelIdleCallback(handle);
  }, [patterns]);
  return null;
}

// EXTERNAL MODULE: external ["wp","keyboardShortcuts"]
var external_wp_keyboardShortcuts_ = __webpack_require__("hF7m");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-draggable/use-scroll-when-dragging.js
/**
 * WordPress dependencies
 */


const SCROLL_INACTIVE_DISTANCE_PX = 50;
const SCROLL_INTERVAL_MS = 25;
const PIXELS_PER_SECOND_PER_PERCENTAGE = 1000;
const VELOCITY_MULTIPLIER = PIXELS_PER_SECOND_PER_PERCENTAGE * (SCROLL_INTERVAL_MS / 1000);
/**
 * React hook that scrolls the scroll container when a block is being dragged.
 *
 * @return {Function[]} `startScrolling`, `scrollOnDragOver`, `stopScrolling`
 *                      functions to be called in `onDragStart`, `onDragOver`
 *                      and `onDragEnd` events respectively.
 */

function useScrollWhenDragging() {
  const dragStartY = Object(external_wp_element_["useRef"])(null);
  const velocityY = Object(external_wp_element_["useRef"])(null);
  const scrollParentY = Object(external_wp_element_["useRef"])(null);
  const scrollEditorInterval = Object(external_wp_element_["useRef"])(null); // Clear interval when unmounting.

  Object(external_wp_element_["useEffect"])(() => () => {
    if (scrollEditorInterval.current) {
      clearInterval(scrollEditorInterval.current);
      scrollEditorInterval.current = null;
    }
  }, []);
  const startScrolling = Object(external_wp_element_["useCallback"])(event => {
    dragStartY.current = event.clientY; // Find nearest parent(s) to scroll.

    scrollParentY.current = Object(external_wp_dom_["getScrollContainer"])(event.target);
    scrollEditorInterval.current = setInterval(() => {
      if (scrollParentY.current && velocityY.current) {
        const newTop = scrollParentY.current.scrollTop + velocityY.current; // Setting `behavior: 'smooth'` as a scroll property seems to hurt performance.
        // Better to use a small scroll interval.

        scrollParentY.current.scroll({
          top: newTop
        });
      }
    }, SCROLL_INTERVAL_MS);
  }, []);
  const scrollOnDragOver = Object(external_wp_element_["useCallback"])(event => {
    if (!scrollParentY.current) {
      return;
    }

    const scrollParentHeight = scrollParentY.current.offsetHeight;
    const offsetDragStartPosition = dragStartY.current - scrollParentY.current.offsetTop;
    const offsetDragPosition = event.clientY - scrollParentY.current.offsetTop;

    if (event.clientY > offsetDragStartPosition) {
      // User is dragging downwards.
      const moveableDistance = Math.max(scrollParentHeight - offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
      const dragDistance = Math.max(offsetDragPosition - offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
      const distancePercentage = dragDistance / moveableDistance;
      velocityY.current = VELOCITY_MULTIPLIER * distancePercentage;
    } else if (event.clientY < offsetDragStartPosition) {
      // User is dragging upwards.
      const moveableDistance = Math.max(offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
      const dragDistance = Math.max(offsetDragStartPosition - offsetDragPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
      const distancePercentage = dragDistance / moveableDistance;
      velocityY.current = -VELOCITY_MULTIPLIER * distancePercentage;
    } else {
      velocityY.current = 0;
    }
  }, []);

  const stopScrolling = () => {
    dragStartY.current = null;
    scrollParentY.current = null;

    if (scrollEditorInterval.current) {
      clearInterval(scrollEditorInterval.current);
      scrollEditorInterval.current = null;
    }
  };

  return [startScrolling, scrollOnDragOver, stopScrolling];
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-draggable/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





const BlockDraggable = ({
  children,
  clientIds,
  cloneClassname,
  onDragStart,
  onDragEnd,
  elementId
}) => {
  const {
    srcRootClientId,
    isDraggable,
    icon
  } = Object(external_wp_data_["useSelect"])(select => {
    var _getBlockType;

    const {
      getBlockRootClientId,
      getTemplateLock,
      getBlockName
    } = select(store);
    const rootClientId = getBlockRootClientId(clientIds[0]);
    const templateLock = rootClientId ? getTemplateLock(rootClientId) : null;
    const blockName = getBlockName(clientIds[0]);
    return {
      srcRootClientId: rootClientId,
      isDraggable: 'all' !== templateLock,
      icon: (_getBlockType = Object(external_wp_blocks_["getBlockType"])(blockName)) === null || _getBlockType === void 0 ? void 0 : _getBlockType.icon
    };
  }, [clientIds]);
  const isDragging = Object(external_wp_element_["useRef"])(false);
  const [startScrolling, scrollOnDragOver, stopScrolling] = useScrollWhenDragging();
  const {
    startDraggingBlocks,
    stopDraggingBlocks
  } = Object(external_wp_data_["useDispatch"])(store); // Stop dragging blocks if the block draggable is unmounted

  Object(external_wp_element_["useEffect"])(() => {
    return () => {
      if (isDragging.current) {
        stopDraggingBlocks();
      }
    };
  }, []);

  if (!isDraggable) {
    return children({
      isDraggable: false
    });
  }

  const transferData = {
    type: 'block',
    srcClientIds: clientIds,
    srcRootClientId
  };
  return Object(external_wp_element_["createElement"])(external_wp_components_["Draggable"], {
    cloneClassname: cloneClassname,
    elementId: elementId,
    __experimentalTransferDataType: "wp-blocks",
    transferData: transferData,
    onDragStart: event => {
      startDraggingBlocks(clientIds);
      isDragging.current = true;
      startScrolling(event);

      if (onDragStart) {
        onDragStart();
      }
    },
    onDragOver: scrollOnDragOver,
    onDragEnd: () => {
      stopDraggingBlocks();
      isDragging.current = false;
      stopScrolling();

      if (onDragEnd) {
        onDragEnd();
      }
    },
    __experimentalDragComponent: Object(external_wp_element_["createElement"])(BlockDraggableChip, {
      count: clientIds.length,
      icon: icon
    })
  }, ({
    onDraggableStart,
    onDraggableEnd
  }) => {
    return children({
      draggable: true,
      onDragStart: onDraggableStart,
      onDragEnd: onDraggableEnd
    });
  });
};

/* harmony default export */ var block_draggable = (BlockDraggable);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-tools/block-selection-button.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */










/**
 * Internal dependencies
 */






/**
 * Returns true if the user is using windows.
 *
 * @return {boolean} Whether the user is using Windows.
 */

function isWindows() {
  return window.navigator.platform.indexOf('Win') > -1;
}
/**
 * Block selection button component, displaying the label of the block. If the block
 * descends from a root block, a button is displayed enabling the user to select
 * the root block.
 *
 * @param {string} props          Component props.
 * @param {string} props.clientId Client ID of block.
 *
 * @return {WPComponent} The component to be rendered.
 */


function BlockSelectionButton({
  clientId,
  rootClientId,
  blockElement
}) {
  const blockInformation = useBlockDisplayInformation(clientId);
  const selected = Object(external_wp_data_["useSelect"])(select => {
    var _getBlockListSettings;

    const {
      __unstableGetBlockWithoutInnerBlocks,
      getBlockIndex,
      hasBlockMovingClientId,
      getBlockListSettings
    } = select(store);
    const index = getBlockIndex(clientId, rootClientId);

    const {
      name,
      attributes
    } = __unstableGetBlockWithoutInnerBlocks(clientId);

    const blockMovingMode = hasBlockMovingClientId();
    return {
      index,
      name,
      attributes,
      blockMovingMode,
      orientation: (_getBlockListSettings = getBlockListSettings(rootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation
    };
  }, [clientId, rootClientId]);
  const {
    index,
    name,
    attributes,
    blockMovingMode,
    orientation
  } = selected;
  const {
    setNavigationMode,
    removeBlock
  } = Object(external_wp_data_["useDispatch"])(store);
  const ref = Object(external_wp_element_["useRef"])(); // Focus the breadcrumb in navigation mode.

  Object(external_wp_element_["useEffect"])(() => {
    ref.current.focus(); // NVDA on windows suffers from a bug where focus changes are not announced properly
    // See WordPress/gutenberg#24121 and nvaccess/nvda#5825 for more details
    // To solve it we announce the focus change manually.

    if (isWindows()) {
      Object(external_wp_a11y_["speak"])(label);
    }
  }, []);
  const {
    hasBlockMovingClientId,
    getBlockIndex,
    getBlockRootClientId,
    getClientIdsOfDescendants,
    getSelectedBlockClientId,
    getMultiSelectedBlocksEndClientId,
    getPreviousBlockClientId,
    getNextBlockClientId
  } = Object(external_wp_data_["useSelect"])(store);
  const {
    selectBlock,
    clearSelectedBlock,
    setBlockMovingClientId,
    moveBlockToPosition
  } = Object(external_wp_data_["useDispatch"])(store);

  function onKeyDown(event) {
    const {
      keyCode
    } = event;
    const isUp = keyCode === external_wp_keycodes_["UP"];
    const isDown = keyCode === external_wp_keycodes_["DOWN"];
    const isLeft = keyCode === external_wp_keycodes_["LEFT"];
    const isRight = keyCode === external_wp_keycodes_["RIGHT"];
    const isTab = keyCode === external_wp_keycodes_["TAB"];
    const isEscape = keyCode === external_wp_keycodes_["ESCAPE"];
    const isEnter = keyCode === external_wp_keycodes_["ENTER"];
    const isSpace = keyCode === external_wp_keycodes_["SPACE"];
    const isShift = event.shiftKey;

    if (keyCode === external_wp_keycodes_["BACKSPACE"] || keyCode === external_wp_keycodes_["DELETE"]) {
      removeBlock(clientId);
      event.preventDefault();
      return;
    }

    const selectedBlockClientId = getSelectedBlockClientId();
    const selectionEndClientId = getMultiSelectedBlocksEndClientId();
    const selectionBeforeEndClientId = getPreviousBlockClientId(selectionEndClientId || selectedBlockClientId);
    const selectionAfterEndClientId = getNextBlockClientId(selectionEndClientId || selectedBlockClientId);
    const navigateUp = isTab && isShift || isUp;
    const navigateDown = isTab && !isShift || isDown; // Move out of current nesting level (no effect if at root level).

    const navigateOut = isLeft; // Move into next nesting level (no effect if the current block has no innerBlocks).

    const navigateIn = isRight;
    let focusedBlockUid;

    if (navigateUp) {
      focusedBlockUid = selectionBeforeEndClientId;
    } else if (navigateDown) {
      focusedBlockUid = selectionAfterEndClientId;
    } else if (navigateOut) {
      var _getBlockRootClientId;

      focusedBlockUid = (_getBlockRootClientId = getBlockRootClientId(selectedBlockClientId)) !== null && _getBlockRootClientId !== void 0 ? _getBlockRootClientId : selectedBlockClientId;
    } else if (navigateIn) {
      var _getClientIdsOfDescen;

      focusedBlockUid = (_getClientIdsOfDescen = getClientIdsOfDescendants([selectedBlockClientId])[0]) !== null && _getClientIdsOfDescen !== void 0 ? _getClientIdsOfDescen : selectedBlockClientId;
    }

    const startingBlockClientId = hasBlockMovingClientId();

    if (isEscape && startingBlockClientId) {
      setBlockMovingClientId(null);
    }

    if ((isEnter || isSpace) && startingBlockClientId) {
      const sourceRoot = getBlockRootClientId(startingBlockClientId);
      const destRoot = getBlockRootClientId(selectedBlockClientId);
      const sourceBlockIndex = getBlockIndex(startingBlockClientId, sourceRoot);
      let destinationBlockIndex = getBlockIndex(selectedBlockClientId, destRoot);

      if (sourceBlockIndex < destinationBlockIndex && sourceRoot === destRoot) {
        destinationBlockIndex -= 1;
      }

      moveBlockToPosition(startingBlockClientId, sourceRoot, destRoot, destinationBlockIndex);
      selectBlock(startingBlockClientId);
      setBlockMovingClientId(null);
    }

    if (navigateDown || navigateUp || navigateOut || navigateIn) {
      if (focusedBlockUid) {
        event.preventDefault();
        selectBlock(focusedBlockUid);
      } else if (isTab && selectedBlockClientId) {
        let nextTabbable;

        if (navigateDown) {
          nextTabbable = external_wp_dom_["focus"].tabbable.findNext(blockElement);

          if (!nextTabbable) {
            nextTabbable = blockElement.ownerDocument.defaultView.frameElement;
            nextTabbable = external_wp_dom_["focus"].tabbable.findNext(nextTabbable);
          }
        } else {
          nextTabbable = external_wp_dom_["focus"].tabbable.findPrevious(blockElement);
        }

        if (nextTabbable) {
          event.preventDefault();
          nextTabbable.focus();
          clearSelectedBlock();
        }
      }
    }
  }

  const blockType = Object(external_wp_blocks_["getBlockType"])(name);
  const label = Object(external_wp_blocks_["__experimentalGetAccessibleBlockLabel"])(blockType, attributes, index + 1, orientation);
  const classNames = classnames_default()('block-editor-block-list__block-selection-button', {
    'is-block-moving-mode': !!blockMovingMode
  });

  const dragHandleLabel = Object(external_wp_i18n_["__"])('Drag');

  return Object(external_wp_element_["createElement"])("div", {
    className: classNames
  }, Object(external_wp_element_["createElement"])(external_wp_components_["Flex"], {
    justify: "center",
    className: "block-editor-block-list__block-selection-button__content"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["FlexItem"], null, Object(external_wp_element_["createElement"])(BlockIcon, {
    icon: blockInformation === null || blockInformation === void 0 ? void 0 : blockInformation.icon,
    showColors: true
  })), Object(external_wp_element_["createElement"])(external_wp_components_["FlexItem"], null, Object(external_wp_element_["createElement"])(block_draggable, {
    clientIds: [clientId]
  }, draggableProps => Object(external_wp_element_["createElement"])(external_wp_components_["Button"], Object(esm_extends["a" /* default */])({
    icon: drag_handle,
    className: "block-selection-button_drag-handle",
    "aria-hidden": "true",
    label: dragHandleLabel // Should not be able to tab to drag handle as this
    // button can only be used with a pointer device.
    ,
    tabIndex: "-1"
  }, draggableProps)))), Object(external_wp_element_["createElement"])(external_wp_components_["FlexItem"], null, Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    ref: ref,
    onClick: () => setNavigationMode(false),
    onKeyDown: onKeyDown,
    label: label,
    className: "block-selection-button_select-button"
  }, Object(external_wp_element_["createElement"])(BlockTitle, {
    clientId: clientId
  })))));
}

/* harmony default export */ var block_selection_button = (BlockSelectionButton);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/navigable-toolbar/index.js



/**
 * WordPress dependencies
 */






function hasOnlyToolbarItem(elements) {
  const dataProp = 'toolbarItem';
  return !elements.some(element => !(dataProp in element.dataset));
}

function getAllToolbarItemsIn(container) {
  return Array.from(container.querySelectorAll('[data-toolbar-item]'));
}

function hasFocusWithin(container) {
  return container.contains(container.ownerDocument.activeElement);
}

function focusFirstTabbableIn(container) {
  const [firstTabbable] = external_wp_dom_["focus"].tabbable.find(container);

  if (firstTabbable) {
    firstTabbable.focus();
  }
}

function useIsAccessibleToolbar(ref) {
  /*
   * By default, we'll assume the starting accessible state of the Toolbar
   * is true, as it seems to be the most common case.
   *
   * Transitioning from an (initial) false to true state causes the
   * <Toolbar /> component to mount twice, which is causing undesired
   * side-effects. These side-effects appear to only affect certain
   * E2E tests.
   *
   * This was initial discovered in this pull-request:
   * https://github.com/WordPress/gutenberg/pull/23425
   */
  const initialAccessibleToolbarState = true; // By default, it's gonna render NavigableMenu. If all the tabbable elements
  // inside the toolbar are ToolbarItem components (or derived components like
  // ToolbarButton), then we can wrap them with the accessible Toolbar
  // component.

  const [isAccessibleToolbar, setIsAccessibleToolbar] = Object(external_wp_element_["useState"])(initialAccessibleToolbarState);
  const determineIsAccessibleToolbar = Object(external_wp_element_["useCallback"])(() => {
    const tabbables = external_wp_dom_["focus"].tabbable.find(ref.current);
    const onlyToolbarItem = hasOnlyToolbarItem(tabbables);

    if (!onlyToolbarItem) {
      external_wp_deprecated_default()('Using custom components as toolbar controls', {
        since: '5.6',
        alternative: 'ToolbarItem, ToolbarButton or ToolbarDropdownMenu components',
        link: 'https://developer.wordpress.org/block-editor/components/toolbar-button/#inside-blockcontrols'
      });
    }

    setIsAccessibleToolbar(onlyToolbarItem);
  }, []);
  Object(external_wp_element_["useLayoutEffect"])(() => {
    // Toolbar buttons may be rendered asynchronously, so we use
    // MutationObserver to check if the toolbar subtree has been modified
    const observer = new window.MutationObserver(determineIsAccessibleToolbar);
    observer.observe(ref.current, {
      childList: true,
      subtree: true
    });
    return () => observer.disconnect();
  }, [isAccessibleToolbar]);
  return isAccessibleToolbar;
}

function useToolbarFocus(ref, focusOnMount, isAccessibleToolbar, defaultIndex, onIndexChange) {
  // Make sure we don't use modified versions of this prop
  const [initialFocusOnMount] = Object(external_wp_element_["useState"])(focusOnMount);
  const [initialIndex] = Object(external_wp_element_["useState"])(defaultIndex);
  const focusToolbar = Object(external_wp_element_["useCallback"])(() => {
    focusFirstTabbableIn(ref.current);
  }, []); // Focus on toolbar when pressing alt+F10 when the toolbar is visible

  Object(external_wp_keyboardShortcuts_["useShortcut"])('core/block-editor/focus-toolbar', focusToolbar, {
    bindGlobal: true,
    eventName: 'keydown'
  });
  Object(external_wp_element_["useEffect"])(() => {
    if (initialFocusOnMount) {
      focusToolbar();
    }
  }, [isAccessibleToolbar, initialFocusOnMount, focusToolbar]);
  Object(external_wp_element_["useEffect"])(() => {
    // If initialIndex is passed, we focus on that toolbar item when the
    // toolbar gets mounted and initial focus is not forced.
    // We have to wait for the next browser paint because block controls aren't
    // rendered right away when the toolbar gets mounted.
    let raf = 0;

    if (initialIndex && !initialFocusOnMount) {
      raf = window.requestAnimationFrame(() => {
        const items = getAllToolbarItemsIn(ref.current);
        const index = initialIndex || 0;

        if (items[index] && hasFocusWithin(ref.current)) {
          items[index].focus();
        }
      });
    }

    return () => {
      window.cancelAnimationFrame(raf);
      if (!onIndexChange) return; // When the toolbar element is unmounted and onIndexChange is passed, we
      // pass the focused toolbar item index so it can be hydrated later.

      const items = getAllToolbarItemsIn(ref.current);
      const index = items.findIndex(item => item.tabIndex === 0);
      onIndexChange(index);
    };
  }, [initialIndex, initialFocusOnMount]);
}

function NavigableToolbar({
  children,
  focusOnMount,
  __experimentalInitialIndex: initialIndex,
  __experimentalOnIndexChange: onIndexChange,
  ...props
}) {
  const ref = Object(external_wp_element_["useRef"])();
  const isAccessibleToolbar = useIsAccessibleToolbar(ref);
  useToolbarFocus(ref, focusOnMount, isAccessibleToolbar, initialIndex, onIndexChange);

  if (isAccessibleToolbar) {
    return Object(external_wp_element_["createElement"])(external_wp_components_["Toolbar"], Object(esm_extends["a" /* default */])({
      label: props['aria-label'],
      ref: ref
    }, props), children);
  }

  return Object(external_wp_element_["createElement"])(external_wp_components_["NavigableMenu"], Object(esm_extends["a" /* default */])({
    orientation: "horizontal",
    role: "toolbar",
    ref: ref
  }, props), children);
}

/* harmony default export */ var navigable_toolbar = (NavigableToolbar);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-mover/index.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */





function BlockMover({
  isFirst,
  isLast,
  clientIds,
  isLocked,
  isHidden,
  rootClientId,
  orientation,
  hideDragHandle
}) {
  const [isFocused, setIsFocused] = Object(external_wp_element_["useState"])(false);

  const onFocus = () => setIsFocused(true);

  const onBlur = () => setIsFocused(false);

  if (isLocked || isFirst && isLast && !rootClientId) {
    return null;
  }

  const dragHandleLabel = Object(external_wp_i18n_["__"])('Drag'); // We emulate a disabled state because forcefully applying the `disabled`
  // attribute on the buttons while it has focus causes the screen to change
  // to an unfocused state (body as active element) without firing blur on,
  // the rendering parent, leaving it unable to react to focus out.


  return Object(external_wp_element_["createElement"])("div", {
    className: classnames_default()('block-editor-block-mover', {
      'is-visible': isFocused || !isHidden,
      'is-horizontal': orientation === 'horizontal'
    })
  }, !hideDragHandle && Object(external_wp_element_["createElement"])(block_draggable, {
    clientIds: clientIds,
    cloneClassname: "block-editor-block-mover__drag-clone"
  }, draggableProps => Object(external_wp_element_["createElement"])(external_wp_components_["Button"], Object(esm_extends["a" /* default */])({
    icon: drag_handle,
    className: "block-editor-block-mover__drag-handle",
    "aria-hidden": "true",
    label: dragHandleLabel // Should not be able to tab to drag handle as this
    // button can only be used with a pointer device.
    ,
    tabIndex: "-1"
  }, draggableProps))), Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarGroup"], {
    className: "block-editor-block-mover__move-button-container"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarItem"], {
    onFocus: onFocus,
    onBlur: onBlur
  }, itemProps => Object(external_wp_element_["createElement"])(BlockMoverUpButton, Object(esm_extends["a" /* default */])({
    clientIds: clientIds
  }, itemProps))), Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarItem"], {
    onFocus: onFocus,
    onBlur: onBlur
  }, itemProps => Object(external_wp_element_["createElement"])(BlockMoverDownButton, Object(esm_extends["a" /* default */])({
    clientIds: clientIds
  }, itemProps)))));
}

/* harmony default export */ var block_mover = (Object(external_wp_data_["withSelect"])((select, {
  clientIds
}) => {
  var _getBlockListSettings;

  const {
    getBlock,
    getBlockIndex,
    getBlockListSettings,
    getTemplateLock,
    getBlockOrder,
    getBlockRootClientId
  } = select(store);
  const normalizedClientIds = Object(external_lodash_["castArray"])(clientIds);
  const firstClientId = Object(external_lodash_["first"])(normalizedClientIds);
  const block = getBlock(firstClientId);
  const rootClientId = getBlockRootClientId(Object(external_lodash_["first"])(normalizedClientIds));
  const firstIndex = getBlockIndex(firstClientId, rootClientId);
  const lastIndex = getBlockIndex(Object(external_lodash_["last"])(normalizedClientIds), rootClientId);
  const blockOrder = getBlockOrder(rootClientId);
  const isFirst = firstIndex === 0;
  const isLast = lastIndex === blockOrder.length - 1;
  return {
    blockType: block ? Object(external_wp_blocks_["getBlockType"])(block.name) : null,
    isLocked: getTemplateLock(rootClientId) === 'all',
    rootClientId,
    firstIndex,
    isFirst,
    isLast,
    orientation: (_getBlockListSettings = getBlockListSettings(rootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation
  };
})(BlockMover));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-toolbar/utils.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


const {
  clearTimeout: utils_clearTimeout,
  setTimeout: utils_setTimeout
} = window;
const DEBOUNCE_TIMEOUT = 200;
/**
 * Hook that creates a showMover state, as well as debounced show/hide callbacks.
 *
 * @param {Object}   props                       Component props.
 * @param {Object}   props.ref                   Element reference.
 * @param {boolean}  props.isFocused             Whether the component has current focus.
 * @param {number}   [props.debounceTimeout=250] Debounce timeout in milliseconds.
 * @param {Function} [props.onChange=noop]       Callback function.
 */

function useDebouncedShowMovers({
  ref,
  isFocused,
  debounceTimeout = DEBOUNCE_TIMEOUT,
  onChange = external_lodash_["noop"]
}) {
  const [showMovers, setShowMovers] = Object(external_wp_element_["useState"])(false);
  const timeoutRef = Object(external_wp_element_["useRef"])();

  const handleOnChange = nextIsFocused => {
    if (ref !== null && ref !== void 0 && ref.current) {
      setShowMovers(nextIsFocused);
    }

    onChange(nextIsFocused);
  };

  const getIsHovered = () => {
    return (ref === null || ref === void 0 ? void 0 : ref.current) && ref.current.matches(':hover');
  };

  const shouldHideMovers = () => {
    const isHovered = getIsHovered();
    return !isFocused && !isHovered;
  };

  const clearTimeoutRef = () => {
    const timeout = timeoutRef.current;

    if (timeout && utils_clearTimeout) {
      utils_clearTimeout(timeout);
    }
  };

  const debouncedShowMovers = event => {
    if (event) {
      event.stopPropagation();
    }

    clearTimeoutRef();

    if (!showMovers) {
      handleOnChange(true);
    }
  };

  const debouncedHideMovers = event => {
    if (event) {
      event.stopPropagation();
    }

    clearTimeoutRef();
    timeoutRef.current = utils_setTimeout(() => {
      if (shouldHideMovers()) {
        handleOnChange(false);
      }
    }, debounceTimeout);
  };

  Object(external_wp_element_["useEffect"])(() => () => clearTimeoutRef(), []);
  return {
    showMovers,
    debouncedShowMovers,
    debouncedHideMovers
  };
}
/**
 * Hook that provides a showMovers state and gesture events for DOM elements
 * that interact with the showMovers state.
 *
 * @param {Object}   props                       Component props.
 * @param {Object}   props.ref                   Element reference.
 * @param {number}   [props.debounceTimeout=250] Debounce timeout in milliseconds.
 * @param {Function} [props.onChange=noop]       Callback function.
 */

function useShowMoversGestures({
  ref,
  debounceTimeout = DEBOUNCE_TIMEOUT,
  onChange = external_lodash_["noop"]
}) {
  const [isFocused, setIsFocused] = Object(external_wp_element_["useState"])(false);
  const {
    showMovers,
    debouncedShowMovers,
    debouncedHideMovers
  } = useDebouncedShowMovers({
    ref,
    debounceTimeout,
    isFocused,
    onChange
  });
  const registerRef = Object(external_wp_element_["useRef"])(false);

  const isFocusedWithin = () => {
    return (ref === null || ref === void 0 ? void 0 : ref.current) && ref.current.contains(ref.current.ownerDocument.activeElement);
  };

  Object(external_wp_element_["useEffect"])(() => {
    const node = ref.current;

    const handleOnFocus = () => {
      if (isFocusedWithin()) {
        setIsFocused(true);
        debouncedShowMovers();
      }
    };

    const handleOnBlur = () => {
      if (!isFocusedWithin()) {
        setIsFocused(false);
        debouncedHideMovers();
      }
    };
    /**
     * Events are added via DOM events (vs. React synthetic events),
     * as the child React components swallow mouse events.
     */


    if (node && !registerRef.current) {
      node.addEventListener('focus', handleOnFocus, true);
      node.addEventListener('blur', handleOnBlur, true);
      registerRef.current = true;
    }

    return () => {
      if (node) {
        node.removeEventListener('focus', handleOnFocus);
        node.removeEventListener('blur', handleOnBlur);
      }
    };
  }, [ref, registerRef, setIsFocused, debouncedShowMovers, debouncedHideMovers]);
  return {
    showMovers,
    gestures: {
      onMouseMove: debouncedShowMovers,
      onMouseLeave: debouncedHideMovers
    }
  };
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-parent-selector/index.js



/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */





/**
 * Block parent selector component, displaying the hierarchy of the
 * current block selection as a single icon to "go up" a level.
 *
 * @return {WPComponent} Parent block selector.
 */

function BlockParentSelector() {
  const {
    selectBlock,
    toggleBlockHighlight
  } = Object(external_wp_data_["useDispatch"])(store);
  const {
    firstParentClientId,
    shouldHide,
    hasReducedUI
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getBlockName,
      getBlockParents,
      getSelectedBlockClientId,
      getSettings
    } = select(store);
    const {
      hasBlockSupport
    } = select(external_wp_blocks_["store"]);
    const selectedBlockClientId = getSelectedBlockClientId();
    const parents = getBlockParents(selectedBlockClientId);
    const _firstParentClientId = parents[parents.length - 1];
    const parentBlockName = getBlockName(_firstParentClientId);

    const _parentBlockType = Object(external_wp_blocks_["getBlockType"])(parentBlockName);

    const settings = getSettings();
    return {
      firstParentClientId: _firstParentClientId,
      shouldHide: !hasBlockSupport(_parentBlockType, '__experimentalParentSelector', true),
      hasReducedUI: settings.hasReducedUI
    };
  }, []);
  const blockInformation = useBlockDisplayInformation(firstParentClientId); // Allows highlighting the parent block outline when focusing or hovering
  // the parent block selector within the child.

  const nodeRef = Object(external_wp_element_["useRef"])();
  const {
    gestures: showMoversGestures
  } = useShowMoversGestures({
    ref: nodeRef,

    onChange(isFocused) {
      if (isFocused && hasReducedUI) {
        return;
      }

      toggleBlockHighlight(firstParentClientId, isFocused);
    }

  });

  if (shouldHide || firstParentClientId === undefined) {
    return null;
  }

  return Object(external_wp_element_["createElement"])("div", Object(esm_extends["a" /* default */])({
    className: "block-editor-block-parent-selector",
    key: firstParentClientId,
    ref: nodeRef
  }, showMoversGestures), Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarButton"], {
    className: "block-editor-block-parent-selector__button",
    onClick: () => selectBlock(firstParentClientId),
    label: Object(external_wp_i18n_["sprintf"])(
    /* translators: %s: Name of the block's parent. */
    Object(external_wp_i18n_["__"])('Select %s'), blockInformation.title),
    showTooltip: true,
    icon: Object(external_wp_element_["createElement"])(BlockIcon, {
      icon: blockInformation.icon
    })
  }));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/stack.js


/**
 * WordPress dependencies
 */

const stack_stack = Object(external_wp_element_["createElement"])(external_wp_primitives_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_primitives_["Path"], {
  d: "M20.2 8v11c0 .7-.6 1.2-1.2 1.2H6v1.5h13c1.5 0 2.7-1.2 2.7-2.8V8zM18 16.4V4.6c0-.9-.7-1.6-1.6-1.6H4.6C3.7 3 3 3.7 3 4.6v11.8c0 .9.7 1.6 1.6 1.6h11.8c.9 0 1.6-.7 1.6-1.6zm-13.5 0V4.6c0-.1.1-.1.1-.1h11.8c.1 0 .1.1.1.1v11.8c0 .1-.1.1-.1.1H4.6l-.1-.1z"
}));
/* harmony default export */ var library_stack = (stack_stack);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/preview-block-popover.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function PreviewBlockPopover({
  blocks
}) {
  return Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-switcher__popover__preview__parent"
  }, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-switcher__popover__preview__container"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["Popover"], {
    className: "block-editor-block-switcher__preview__popover",
    position: "bottom right",
    focusOnMount: false
  }, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-switcher__preview"
  }, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-switcher__preview-title"
  }, Object(external_wp_i18n_["__"])('Preview')), Object(external_wp_element_["createElement"])(block_preview, {
    viewportWidth: 500,
    blocks: blocks
  })))));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/block-transformations-menu.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




const BlockTransformationsMenu = ({
  className,
  possibleBlockTransformations,
  onSelect,
  blocks
}) => {
  const [hoveredTransformItemName, setHoveredTransformItemName] = Object(external_wp_element_["useState"])();
  return Object(external_wp_element_["createElement"])(external_wp_components_["MenuGroup"], {
    label: Object(external_wp_i18n_["__"])('Transform to'),
    className: className
  }, hoveredTransformItemName && Object(external_wp_element_["createElement"])(PreviewBlockPopover, {
    blocks: Object(external_wp_blocks_["switchToBlockType"])(blocks, hoveredTransformItemName)
  }), possibleBlockTransformations.map(item => {
    const {
      name,
      icon,
      title,
      isDisabled
    } = item;
    return Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
      key: name,
      className: Object(external_wp_blocks_["getBlockMenuDefaultClassName"])(name),
      onClick: event => {
        event.preventDefault();
        onSelect(name);
      },
      disabled: isDisabled,
      onMouseLeave: () => setHoveredTransformItemName(null),
      onMouseEnter: () => setHoveredTransformItemName(name)
    }, Object(external_wp_element_["createElement"])(BlockIcon, {
      icon: icon,
      showColors: true
    }), title);
  }));
};

/* harmony default export */ var block_transformations_menu = (BlockTransformationsMenu);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-styles/utils.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Returns the active style from the given className.
 *
 * @param {Array} styles Block style variations.
 * @param {string} className  Class name
 *
 * @return {Object?} The active style.
 */

function getActiveStyle(styles, className) {
  for (const style of new external_wp_tokenList_default.a(className).values()) {
    if (style.indexOf('is-style-') === -1) {
      continue;
    }

    const potentialStyleName = style.substring(9);
    const activeStyle = Object(external_lodash_["find"])(styles, {
      name: potentialStyleName
    });

    if (activeStyle) {
      return activeStyle;
    }
  }

  return Object(external_lodash_["find"])(styles, 'isDefault');
}
/**
 * Replaces the active style in the block's className.
 *
 * @param {string}  className   Class name.
 * @param {Object?} activeStyle The replaced style.
 * @param {Object}  newStyle    The replacing style.
 *
 * @return {string} The updated className.
 */

function replaceActiveStyle(className, activeStyle, newStyle) {
  const list = new external_wp_tokenList_default.a(className);

  if (activeStyle) {
    list.remove('is-style-' + activeStyle.name);
  }

  list.add('is-style-' + newStyle.name);
  return list.value;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-styles/index.js


/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




const EMPTY_OBJECT = {};

function useGenericPreviewBlock(block, type) {
  return Object(external_wp_element_["useMemo"])(() => {
    const example = type === null || type === void 0 ? void 0 : type.example;
    const blockName = type === null || type === void 0 ? void 0 : type.name;

    if (example && blockName) {
      return Object(external_wp_blocks_["getBlockFromExample"])(blockName, {
        attributes: example.attributes,
        innerBlocks: example.innerBlocks
      });
    }

    if (block) {
      return Object(external_wp_blocks_["cloneBlock"])(block);
    }
  }, [type !== null && type !== void 0 && type.example ? block === null || block === void 0 ? void 0 : block.name : block, type]);
}

function BlockStyles({
  clientId,
  onSwitch = external_lodash_["noop"],
  onHoverClassName = external_lodash_["noop"],
  itemRole
}) {
  const selector = select => {
    const {
      getBlock
    } = select(store);
    const block = getBlock(clientId);

    if (!block) {
      return EMPTY_OBJECT;
    }

    const blockType = Object(external_wp_blocks_["getBlockType"])(block.name);
    const {
      getBlockStyles
    } = select(external_wp_blocks_["store"]);
    return {
      block,
      type: blockType,
      styles: getBlockStyles(block.name),
      className: block.attributes.className || ''
    };
  };

  const {
    styles,
    block,
    type,
    className
  } = Object(external_wp_data_["useSelect"])(selector, [clientId]);
  const {
    updateBlockAttributes
  } = Object(external_wp_data_["useDispatch"])(store);
  const genericPreviewBlock = useGenericPreviewBlock(block, type);

  if (!styles || styles.length === 0) {
    return null;
  }

  const renderedStyles = Object(external_lodash_["find"])(styles, 'isDefault') ? styles : [{
    name: 'default',
    label: Object(external_wp_i18n_["_x"])('Default', 'block style'),
    isDefault: true
  }, ...styles];
  const activeStyle = getActiveStyle(renderedStyles, className);
  return Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-styles"
  }, renderedStyles.map(style => {
    const styleClassName = replaceActiveStyle(className, activeStyle, style);
    return Object(external_wp_element_["createElement"])(BlockStyleItem, {
      genericPreviewBlock: genericPreviewBlock,
      className: className,
      isActive: activeStyle === style,
      key: style.name,
      onSelect: () => {
        updateBlockAttributes(clientId, {
          className: styleClassName
        });
        onHoverClassName(null);
        onSwitch();
      },
      onBlur: () => onHoverClassName(null),
      onHover: () => onHoverClassName(styleClassName),
      style: style,
      styleClassName: styleClassName,
      itemRole: itemRole
    });
  }));
}

function BlockStyleItem({
  genericPreviewBlock,
  style,
  isActive,
  onBlur,
  onHover,
  onSelect,
  styleClassName,
  itemRole
}) {
  const previewBlocks = Object(external_wp_element_["useMemo"])(() => {
    return { ...genericPreviewBlock,
      attributes: { ...genericPreviewBlock.attributes,
        className: styleClassName
      }
    };
  }, [genericPreviewBlock, styleClassName]);
  return Object(external_wp_element_["createElement"])("div", {
    key: style.name,
    className: classnames_default()('block-editor-block-styles__item', {
      'is-active': isActive
    }),
    onClick: () => onSelect(),
    onKeyDown: event => {
      if (external_wp_keycodes_["ENTER"] === event.keyCode || external_wp_keycodes_["SPACE"] === event.keyCode) {
        event.preventDefault();
        onSelect();
      }
    },
    onMouseEnter: onHover,
    onMouseLeave: onBlur,
    role: itemRole || 'button',
    tabIndex: "0",
    "aria-label": style.label || style.name
  }, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-styles__item-preview"
  }, Object(external_wp_element_["createElement"])(block_preview, {
    viewportWidth: 500,
    blocks: previewBlocks
  })), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-styles__item-label"
  }, style.label || style.name));
}

/* harmony default export */ var block_styles = (BlockStyles);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/block-styles-menu.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



function BlockStylesMenu({
  hoveredBlock,
  onSwitch
}) {
  const {
    name,
    clientId
  } = hoveredBlock;
  const [hoveredClassName, setHoveredClassName] = Object(external_wp_element_["useState"])();
  const blockType = Object(external_wp_data_["useSelect"])(select => select(external_wp_blocks_["store"]).getBlockType(name), [name]);
  return Object(external_wp_element_["createElement"])(external_wp_components_["MenuGroup"], {
    label: Object(external_wp_i18n_["__"])('Styles'),
    className: "block-editor-block-switcher__styles__menugroup"
  }, hoveredClassName && Object(external_wp_element_["createElement"])(PreviewBlockPopover, {
    blocks: blockType.example ? Object(external_wp_blocks_["getBlockFromExample"])(blockType.name, {
      attributes: { ...blockType.example.attributes,
        className: hoveredClassName
      },
      innerBlocks: blockType.example.innerBlocks
    }) : Object(external_wp_blocks_["cloneBlock"])(hoveredBlock, {
      className: hoveredClassName
    })
  }), Object(external_wp_element_["createElement"])(block_styles, {
    clientId: clientId,
    onSwitch: onSwitch,
    onHoverClassName: setHoveredClassName,
    itemRole: "menuitem"
  }));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/utils.js
/**
 * WordPress dependencies
 */

/**
 * Try to find a matching block by a block's name in a provided
 * block. We recurse through InnerBlocks and return the reference
 * of the matched block (it could be an InnerBlock).
 * If no match is found return nothing.
 *
 * @param {WPBlock} block The block to try to find a match.
 * @param {string} selectedBlockName The block's name to use for matching condition.
 * @param {Set} consumedBlocks A set holding the previously matched/consumed blocks.
 *
 * @return {WPBlock?} The matched block if found or nothing(`undefined`).
 */

const getMatchingBlockByName = (block, selectedBlockName, consumedBlocks = new Set()) => {
  const {
    clientId,
    name,
    innerBlocks = []
  } = block; // Check if block has been consumed already.

  if (consumedBlocks.has(clientId)) return;
  if (name === selectedBlockName) return block; // Try to find a matching block from InnerBlocks recursively.

  for (const innerBlock of innerBlocks) {
    const match = getMatchingBlockByName(innerBlock, selectedBlockName, consumedBlocks);
    if (match) return match;
  }
};
/**
 * Find and return the block attributes to retain through
 * the transformation, based on Block Type's `role:content`
 * attributes. If no `role:content` attributes exist,
 * return selected block's attributes.
 *
 * @param {string} name Block type's namespaced name.
 * @param {Object} attributes Selected block's attributes.
 * @return {Object} The block's attributes to retain.
 */

const getRetainedBlockAttributes = (name, attributes) => {
  const contentAttributes = Object(external_wp_blocks_["__experimentalGetBlockAttributesNamesByRole"])(name, 'content');
  if (!(contentAttributes !== null && contentAttributes !== void 0 && contentAttributes.length)) return attributes;
  return contentAttributes.reduce((_accumulator, attribute) => {
    if (attributes[attribute]) _accumulator[attribute] = attributes[attribute];
    return _accumulator;
  }, {});
};

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/use-transformed-patterns.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Mutate the matched block's attributes by getting
 * which block type's attributes to retain and prioritize
 * them in the merging of the attributes.
 *
 * @param {WPBlock} match The matched block.
 * @param {WPBlock} selectedBlock The selected block.
 * @return {void}
 */

const transformMatchingBlock = (match, selectedBlock) => {
  // Get the block attributes to retain through the transformation.
  const retainedBlockAttributes = getRetainedBlockAttributes(selectedBlock.name, selectedBlock.attributes);
  match.attributes = { ...match.attributes,
    ...retainedBlockAttributes
  };
};
/**
 * By providing the selected blocks and pattern's blocks
 * find the matching blocks, transform them and return them.
 * If not all selected blocks are matched, return nothing.
 *
 * @param {WPBlock[]} selectedBlocks The selected blocks.
 * @param {WPBlock[]} patternBlocks The pattern's blocks.
 * @return {WPBlock[]|void} The transformed pattern's blocks or undefined if not all selected blocks have been matched.
 */

const getPatternTransformedBlocks = (selectedBlocks, patternBlocks) => {
  // Clone Pattern's blocks to produce new clientIds and be able to mutate the matches.
  const _patternBlocks = patternBlocks.map(block => Object(external_wp_blocks_["cloneBlock"])(block));
  /**
   * Keep track of the consumed pattern blocks.
   * This is needed because we loop the selected blocks
   * and for example we may have selected two paragraphs and
   * the pattern's blocks could have more `paragraphs`.
   */


  const consumedBlocks = new Set();

  for (const selectedBlock of selectedBlocks) {
    let isMatch = false;

    for (const patternBlock of _patternBlocks) {
      const match = getMatchingBlockByName(patternBlock, selectedBlock.name, consumedBlocks);
      if (!match) continue;
      isMatch = true;
      consumedBlocks.add(match.clientId); // We update (mutate) the matching pattern block.

      transformMatchingBlock(match, selectedBlock); // No need to loop through other pattern's blocks.

      break;
    } // Bail eary if a selected block has not been matched.


    if (!isMatch) return;
  }

  return _patternBlocks;
};
/**
 * @typedef {WPBlockPattern & {transformedBlocks: WPBlock[]}} TransformedBlockPattern
 */

/**
 * Custom hook that accepts patterns from state and the selected
 * blocks and tries to match these with the pattern's blocks.
 * If all selected blocks are matched with a Pattern's block,
 * we transform them by retaining block's attributes with `role:content`.
 * The transformed pattern's blocks are set to a new pattern
 * property `transformedBlocks`.
 *
 * @param {WPBlockPattern[]} patterns Patterns from state.
 * @param {WPBlock[]} selectedBlocks The currently selected blocks.
 * @return {TransformedBlockPattern[]} Returns the eligible matched patterns with all the selected blocks.
 */
// TODO tests

const useTransformedPatterns = (patterns, selectedBlocks) => {
  return Object(external_wp_element_["useMemo"])(() => patterns.reduce((accumulator, _pattern) => {
    const transformedBlocks = getPatternTransformedBlocks(selectedBlocks, _pattern.blocks);

    if (transformedBlocks) {
      accumulator.push({ ..._pattern,
        transformedBlocks
      });
    }

    return accumulator;
  }, []), [patterns, selectedBlocks]);
};

/* harmony default export */ var use_transformed_patterns = (useTransformedPatterns);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/pattern-transformations-menu.js



/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




function PatternTransformationsMenu({
  blocks,
  patterns: statePatterns,
  onSelect
}) {
  const [showTransforms, setShowTransforms] = Object(external_wp_element_["useState"])(false);
  const patterns = use_transformed_patterns(statePatterns, blocks);
  if (!patterns.length) return null;
  return Object(external_wp_element_["createElement"])(external_wp_components_["MenuGroup"], {
    className: "block-editor-block-switcher__pattern__transforms__menugroup"
  }, showTransforms && Object(external_wp_element_["createElement"])(PreviewPatternsPopover, {
    patterns: patterns,
    onSelect: onSelect
  }), Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
    onClick: event => {
      event.preventDefault();
      setShowTransforms(!showTransforms);
    },
    icon: chevron_right["a" /* default */]
  }, Object(external_wp_i18n_["__"])('Patterns')));
}

function PreviewPatternsPopover({
  patterns,
  onSelect
}) {
  return Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-switcher__popover__preview__parent"
  }, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-switcher__popover__preview__container"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["Popover"], {
    className: "block-editor-block-switcher__preview__popover",
    position: "bottom right"
  }, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-switcher__preview"
  }, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-switcher__preview-title"
  }, Object(external_wp_i18n_["__"])('Preview')), Object(external_wp_element_["createElement"])(BlockPatternsList, {
    patterns: patterns,
    onSelect: onSelect
  })))));
}

function BlockPatternsList({
  patterns,
  onSelect
}) {
  const composite = Object(external_wp_components_["__unstableUseCompositeState"])();
  return Object(external_wp_element_["createElement"])(external_wp_components_["__unstableComposite"], Object(esm_extends["a" /* default */])({}, composite, {
    role: "listbox",
    className: "block-editor-block-switcher__preview-patterns-container",
    "aria-label": Object(external_wp_i18n_["__"])('Patterns list')
  }), patterns.map(pattern => Object(external_wp_element_["createElement"])(pattern_transformations_menu_BlockPattern, {
    key: pattern.name,
    pattern: pattern,
    onSelect: onSelect,
    composite: composite
  })));
}

function pattern_transformations_menu_BlockPattern({
  pattern,
  onSelect,
  composite
}) {
  // TODO check pattern/preview width...
  const baseClassName = 'block-editor-block-switcher__preview-patterns-container';
  const descriptionId = Object(external_wp_compose_["useInstanceId"])(pattern_transformations_menu_BlockPattern, `${baseClassName}-list__item-description`);
  return Object(external_wp_element_["createElement"])("div", {
    className: `${baseClassName}-list__list-item`,
    "aria-label": pattern.title,
    "aria-describedby": pattern.description ? descriptionId : undefined
  }, Object(external_wp_element_["createElement"])(external_wp_components_["__unstableCompositeItem"], Object(esm_extends["a" /* default */])({
    role: "option",
    as: "div"
  }, composite, {
    className: `${baseClassName}-list__item`,
    onClick: () => onSelect(pattern.transformedBlocks)
  }), Object(external_wp_element_["createElement"])(block_preview, {
    blocks: pattern.transformedBlocks,
    viewportWidth: pattern.viewportWidth || 500
  }), Object(external_wp_element_["createElement"])("div", {
    className: `${baseClassName}-list__item-title`
  }, pattern.title)), !!pattern.description && Object(external_wp_element_["createElement"])(external_wp_components_["VisuallyHidden"], {
    id: descriptionId
  }, pattern.description));
}

/* harmony default export */ var pattern_transformations_menu = (PatternTransformationsMenu);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */








const BlockSwitcherDropdownMenu = ({
  clientIds,
  blocks
}) => {
  const {
    replaceBlocks
  } = Object(external_wp_data_["useDispatch"])(store);
  const blockInformation = useBlockDisplayInformation(blocks[0].clientId);
  const {
    possibleBlockTransformations,
    hasBlockStyles,
    icon,
    blockTitle,
    patterns
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getBlockRootClientId,
      getBlockTransformItems,
      __experimentalGetPatternTransformItems
    } = select(store);
    const {
      getBlockStyles,
      getBlockType
    } = select(external_wp_blocks_["store"]);
    const rootClientId = getBlockRootClientId(Object(external_lodash_["castArray"])(clientIds)[0]);
    const [{
      name: firstBlockName
    }] = blocks;

    const _isSingleBlockSelected = blocks.length === 1;

    const styles = _isSingleBlockSelected && getBlockStyles(firstBlockName);

    let _icon;

    if (_isSingleBlockSelected) {
      _icon = blockInformation === null || blockInformation === void 0 ? void 0 : blockInformation.icon; // Take into account active block variations.
    } else {
      var _getBlockType;

      const isSelectionOfSameType = Object(external_lodash_["uniq"])(blocks.map(({
        name
      }) => name)).length === 1; // When selection consists of blocks of multiple types, display an
      // appropriate icon to communicate the non-uniformity.

      _icon = isSelectionOfSameType ? (_getBlockType = getBlockType(firstBlockName)) === null || _getBlockType === void 0 ? void 0 : _getBlockType.icon : library_stack;
    }

    return {
      possibleBlockTransformations: getBlockTransformItems(blocks, rootClientId),
      hasBlockStyles: !!(styles !== null && styles !== void 0 && styles.length),
      icon: _icon,
      blockTitle: getBlockType(firstBlockName).title,
      patterns: __experimentalGetPatternTransformItems(blocks, rootClientId)
    };
  }, [clientIds, blocks, blockInformation === null || blockInformation === void 0 ? void 0 : blockInformation.icon]);
  const isReusable = blocks.length === 1 && Object(external_wp_blocks_["isReusableBlock"])(blocks[0]);
  const isTemplate = blocks.length === 1 && Object(external_wp_blocks_["isTemplatePart"])(blocks[0]); // Simple block tranformation based on the `Block Transforms` API.

  const onBlockTransform = name => replaceBlocks(clientIds, Object(external_wp_blocks_["switchToBlockType"])(blocks, name)); // Pattern transformation through the `Patterns` API.


  const onPatternTransform = transformedBlocks => replaceBlocks(clientIds, transformedBlocks);

  const hasPossibleBlockTransformations = !!possibleBlockTransformations.length;
  const hasPatternTransformation = !!(patterns !== null && patterns !== void 0 && patterns.length);

  if (!hasBlockStyles && !hasPossibleBlockTransformations) {
    return Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarGroup"], null, Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarButton"], {
      disabled: true,
      className: "block-editor-block-switcher__no-switcher-icon",
      title: blockTitle,
      icon: Object(external_wp_element_["createElement"])(BlockIcon, {
        icon: icon,
        showColors: true
      })
    }));
  }

  const blockSwitcherLabel = blockTitle;
  const blockSwitcherDescription = 1 === blocks.length ? Object(external_wp_i18n_["sprintf"])(
  /* translators: %s: block title. */
  Object(external_wp_i18n_["__"])('%s: Change block type or style'), blockTitle) : Object(external_wp_i18n_["sprintf"])(
  /* translators: %d: number of blocks. */
  Object(external_wp_i18n_["_n"])('Change type of %d block', 'Change type of %d blocks', blocks.length), blocks.length);
  const showDropDown = hasBlockStyles || hasPossibleBlockTransformations || hasPatternTransformation;
  return Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarGroup"], null, Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarItem"], null, toggleProps => Object(external_wp_element_["createElement"])(external_wp_components_["DropdownMenu"], {
    className: "block-editor-block-switcher",
    label: blockSwitcherLabel,
    popoverProps: {
      position: 'bottom right',
      isAlternate: true,
      className: 'block-editor-block-switcher__popover'
    },
    icon: Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(BlockIcon, {
      icon: icon,
      className: "block-editor-block-switcher__toggle",
      showColors: true
    }), (isReusable || isTemplate) && Object(external_wp_element_["createElement"])("span", {
      className: "block-editor-block-switcher__toggle-text"
    }, Object(external_wp_element_["createElement"])(BlockTitle, {
      clientId: clientIds
    }))),
    toggleProps: {
      describedBy: blockSwitcherDescription,
      ...toggleProps
    },
    menuProps: {
      orientation: 'both'
    }
  }, ({
    onClose
  }) => showDropDown && Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-switcher__container"
  }, hasPatternTransformation && Object(external_wp_element_["createElement"])(pattern_transformations_menu, {
    blocks: blocks,
    patterns: patterns,
    onSelect: transformedBlocks => {
      onPatternTransform(transformedBlocks);
      onClose();
    }
  }), hasPossibleBlockTransformations && Object(external_wp_element_["createElement"])(block_transformations_menu, {
    className: "block-editor-block-switcher__transforms__menugroup",
    possibleBlockTransformations: possibleBlockTransformations,
    blocks: blocks,
    onSelect: name => {
      onBlockTransform(name);
      onClose();
    }
  }), hasBlockStyles && Object(external_wp_element_["createElement"])(BlockStylesMenu, {
    hoveredBlock: blocks[0],
    onSwitch: onClose
  })))));
};
const BlockSwitcher = ({
  clientIds
}) => {
  const blocks = Object(external_wp_data_["useSelect"])(select => select(store).getBlocksByClientId(clientIds), [clientIds]);

  if (!blocks.length || blocks.some(block => !block)) {
    return null;
  }

  return Object(external_wp_element_["createElement"])(BlockSwitcherDropdownMenu, {
    clientIds: clientIds,
    blocks: blocks
  });
};
/* harmony default export */ var block_switcher = (BlockSwitcher);

// EXTERNAL MODULE: external ["wp","blob"]
var external_wp_blob_ = __webpack_require__("xTGt");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/get-paste-event-data.js
/**
 * WordPress dependencies
 */


function getPasteEventData({
  clipboardData
}) {
  let plainText = '';
  let html = ''; // IE11 only supports `Text` as an argument for `getData` and will
  // otherwise throw an invalid argument error, so we try the standard
  // arguments first, then fallback to `Text` if they fail.

  try {
    plainText = clipboardData.getData('text/plain');
    html = clipboardData.getData('text/html');
  } catch (error1) {
    try {
      html = clipboardData.getData('Text');
    } catch (error2) {
      // Some browsers like UC Browser paste plain text by default and
      // don't support clipboardData at all, so allow default
      // behaviour.
      return;
    }
  }

  const files = Object(external_wp_dom_["getFilesFromDataTransfer"])(clipboardData).filter(({
    type
  }) => /^image\/(?:jpe?g|png|gif)$/.test(type)); // Only process files if no HTML is present.
  // A pasted file may have the URL as plain text.

  if (files.length && !html) {
    html = files.map(file => `<img src="${Object(external_wp_blob_["createBlobURL"])(file)}">`).join('');
    plainText = '';
  }

  return {
    html,
    plainText
  };
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/copy-handler/index.js


/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */



function useNotifyCopy() {
  const {
    getBlockName
  } = Object(external_wp_data_["useSelect"])(store);
  const {
    getBlockType
  } = Object(external_wp_data_["useSelect"])(external_wp_blocks_["store"]);
  const {
    createSuccessNotice
  } = Object(external_wp_data_["useDispatch"])(external_wp_notices_["store"]);
  return Object(external_wp_element_["useCallback"])((eventType, selectedBlockClientIds) => {
    let notice = '';

    if (selectedBlockClientIds.length === 1) {
      const clientId = selectedBlockClientIds[0];
      const {
        title
      } = getBlockType(getBlockName(clientId));
      notice = eventType === 'copy' ? Object(external_wp_i18n_["sprintf"])( // Translators: Name of the block being copied, e.g. "Paragraph".
      Object(external_wp_i18n_["__"])('Copied "%s" to clipboard.'), title) : Object(external_wp_i18n_["sprintf"])( // Translators: Name of the block being cut, e.g. "Paragraph".
      Object(external_wp_i18n_["__"])('Moved "%s" to clipboard.'), title);
    } else {
      notice = eventType === 'copy' ? Object(external_wp_i18n_["sprintf"])( // Translators: %d: Number of blocks being copied.
      Object(external_wp_i18n_["_n"])('Copied %d block to clipboard.', 'Copied %d blocks to clipboard.', selectedBlockClientIds.length), selectedBlockClientIds.length) : Object(external_wp_i18n_["sprintf"])( // Translators: %d: Number of blocks being cut.
      Object(external_wp_i18n_["_n"])('Moved %d block to clipboard.', 'Moved %d blocks to clipboard.', selectedBlockClientIds.length), selectedBlockClientIds.length);
    }

    createSuccessNotice(notice, {
      type: 'snackbar'
    });
  }, []);
}
function useClipboardHandler() {
  const {
    getBlocksByClientId,
    getSelectedBlockClientIds,
    hasMultiSelection,
    getSettings
  } = Object(external_wp_data_["useSelect"])(store);
  const {
    flashBlock,
    removeBlocks,
    replaceBlocks
  } = Object(external_wp_data_["useDispatch"])(store);
  const notifyCopy = useNotifyCopy();
  return Object(external_wp_compose_["useRefEffect"])(node => {
    function handler(event) {
      const selectedBlockClientIds = getSelectedBlockClientIds();

      if (selectedBlockClientIds.length === 0) {
        return;
      } // Always handle multiple selected blocks.


      if (!hasMultiSelection()) {
        const {
          target
        } = event;
        const {
          ownerDocument
        } = target; // If copying, only consider actual text selection as selection.
        // Otherwise, any focus on an input field is considered.

        const hasSelection = event.type === 'copy' || event.type === 'cut' ? Object(external_wp_dom_["documentHasUncollapsedSelection"])(ownerDocument) : Object(external_wp_dom_["documentHasSelection"])(ownerDocument); // Let native copy behaviour take over in input fields.

        if (hasSelection) {
          return;
        }
      }

      if (!node.contains(event.target.ownerDocument.activeElement)) {
        return;
      }

      event.preventDefault();

      if (event.type === 'copy' || event.type === 'cut') {
        if (selectedBlockClientIds.length === 1) {
          flashBlock(selectedBlockClientIds[0]);
        }

        notifyCopy(event.type, selectedBlockClientIds);
        const blocks = getBlocksByClientId(selectedBlockClientIds);
        const serialized = Object(external_wp_blocks_["serialize"])(blocks);
        event.clipboardData.setData('text/plain', serialized);
        event.clipboardData.setData('text/html', serialized);
      }

      if (event.type === 'cut') {
        removeBlocks(selectedBlockClientIds);
      } else if (event.type === 'paste') {
        const {
          __experimentalCanUserUseUnfilteredHTML: canUserUseUnfilteredHTML
        } = getSettings();
        const {
          plainText,
          html
        } = getPasteEventData(event);
        const blocks = Object(external_wp_blocks_["pasteHandler"])({
          HTML: html,
          plainText,
          mode: 'BLOCKS',
          canUserUseUnfilteredHTML
        });
        replaceBlocks(selectedBlockClientIds, blocks, blocks.length - 1, -1);
      }
    }

    node.ownerDocument.addEventListener('copy', handler);
    node.ownerDocument.addEventListener('cut', handler);
    node.ownerDocument.addEventListener('paste', handler);
    return () => {
      node.ownerDocument.removeEventListener('copy', handler);
      node.ownerDocument.removeEventListener('cut', handler);
      node.ownerDocument.removeEventListener('paste', handler);
    };
  }, []);
}

function CopyHandler({
  children
}) {
  return Object(external_wp_element_["createElement"])("div", {
    ref: useClipboardHandler()
  }, children);
}

/* harmony default export */ var copy_handler = (CopyHandler);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-actions/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function BlockActions({
  clientIds,
  children,
  __experimentalUpdateSelection: updateSelection
}) {
  const {
    canInsertBlockType,
    getBlockRootClientId,
    getBlocksByClientId,
    getTemplateLock
  } = Object(external_wp_data_["useSelect"])(select => select(store), []);
  const {
    getDefaultBlockName,
    getGroupingBlockName
  } = Object(external_wp_data_["useSelect"])(select => select(external_wp_blocks_["store"]), []);
  const blocks = getBlocksByClientId(clientIds);
  const rootClientId = getBlockRootClientId(clientIds[0]);
  const canDuplicate = Object(external_lodash_["every"])(blocks, block => {
    return !!block && Object(external_wp_blocks_["hasBlockSupport"])(block.name, 'multiple', true) && canInsertBlockType(block.name, rootClientId);
  });
  const canInsertDefaultBlock = canInsertBlockType(getDefaultBlockName(), rootClientId);
  const {
    removeBlocks,
    replaceBlocks,
    duplicateBlocks,
    insertAfterBlock,
    insertBeforeBlock,
    flashBlock,
    setBlockMovingClientId,
    setNavigationMode,
    selectBlock
  } = Object(external_wp_data_["useDispatch"])(store);
  const notifyCopy = useNotifyCopy();
  return children({
    canDuplicate,
    canInsertDefaultBlock,
    isLocked: !!getTemplateLock(rootClientId),
    rootClientId,
    blocks,

    onDuplicate() {
      return duplicateBlocks(clientIds, updateSelection);
    },

    onRemove() {
      return removeBlocks(clientIds, updateSelection);
    },

    onInsertBefore() {
      insertBeforeBlock(Object(external_lodash_["first"])(Object(external_lodash_["castArray"])(clientIds)));
    },

    onInsertAfter() {
      insertAfterBlock(Object(external_lodash_["last"])(Object(external_lodash_["castArray"])(clientIds)));
    },

    onMoveTo() {
      setNavigationMode(true);
      selectBlock(clientIds[0]);
      setBlockMovingClientId(clientIds[0]);
    },

    onGroup() {
      if (!blocks.length) {
        return;
      }

      const groupingBlockName = getGroupingBlockName(); // Activate the `transform` on `core/group` which does the conversion

      const newBlocks = Object(external_wp_blocks_["switchToBlockType"])(blocks, groupingBlockName);

      if (!newBlocks) {
        return;
      }

      replaceBlocks(clientIds, newBlocks);
    },

    onUngroup() {
      if (!blocks.length) {
        return;
      }

      const innerBlocks = blocks[0].innerBlocks;

      if (!innerBlocks.length) {
        return;
      }

      replaceBlocks(clientIds, innerBlocks);
    },

    onCopy() {
      const selectedBlockClientIds = blocks.map(({
        clientId
      }) => clientId);

      if (blocks.length === 1) {
        flashBlock(selectedBlockClientIds[0]);
      }

      notifyCopy('copy', selectedBlockClientIds);
    }

  });
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-mode-toggle.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */


function BlockModeToggle({
  blockType,
  mode,
  onToggleMode,
  small = false,
  isCodeEditingEnabled = true
}) {
  if (!Object(external_wp_blocks_["hasBlockSupport"])(blockType, 'html', true) || !isCodeEditingEnabled) {
    return null;
  }

  const label = mode === 'visual' ? Object(external_wp_i18n_["__"])('Edit as HTML') : Object(external_wp_i18n_["__"])('Edit visually');
  return Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
    onClick: onToggleMode
  }, !small && label);
}
/* harmony default export */ var block_mode_toggle = (Object(external_wp_compose_["compose"])([Object(external_wp_data_["withSelect"])((select, {
  clientId
}) => {
  const {
    getBlock,
    getBlockMode,
    getSettings
  } = select(store);
  const block = getBlock(clientId);
  const isCodeEditingEnabled = getSettings().codeEditingEnabled;
  return {
    mode: getBlockMode(clientId),
    blockType: block ? Object(external_wp_blocks_["getBlockType"])(block.name) : null,
    isCodeEditingEnabled
  };
}), Object(external_wp_data_["withDispatch"])((dispatch, {
  onToggle = external_lodash_["noop"],
  clientId
}) => ({
  onToggleMode() {
    dispatch(store).toggleBlockMode(clientId);
    onToggle();
  }

}))])(BlockModeToggle));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-convert-button.js


/**
 * WordPress dependencies
 */


function BlockConvertButton({
  shouldRender,
  onClick,
  small
}) {
  if (!shouldRender) {
    return null;
  }

  const label = Object(external_wp_i18n_["__"])('Convert to Blocks');

  return Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
    onClick: onClick
  }, !small && label);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-html-convert-button.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/* harmony default export */ var block_html_convert_button = (Object(external_wp_compose_["compose"])(Object(external_wp_data_["withSelect"])((select, {
  clientId
}) => {
  const block = select(store).getBlock(clientId);
  return {
    block,
    shouldRender: block && block.name === 'core/html'
  };
}), Object(external_wp_data_["withDispatch"])((dispatch, {
  block
}) => ({
  onClick: () => dispatch(store).replaceBlocks(block.clientId, Object(external_wp_blocks_["rawHandler"])({
    HTML: Object(external_wp_blocks_["getBlockContent"])(block)
  }))
})))(BlockConvertButton));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-settings-menu-first-item.js
/**
 * WordPress dependencies
 */

const {
  Fill: __unstableBlockSettingsMenuFirstItem,
  Slot: block_settings_menu_first_item_Slot
} = Object(external_wp_components_["createSlotFill"])('__unstableBlockSettingsMenuFirstItem');
__unstableBlockSettingsMenuFirstItem.Slot = block_settings_menu_first_item_Slot;
/* harmony default export */ var block_settings_menu_first_item = (__unstableBlockSettingsMenuFirstItem);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/convert-to-group-buttons/use-convert-to-group-button-props.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Contains the properties `ConvertToGroupButton` component needs.
 *
 * @typedef {Object} ConvertToGroupButtonProps
 * @property {string[]} clientIds  An array of the selected client ids.
 * @property {boolean} isGroupable Indicates if the selected blocks can be grouped.
 * @property {boolean} isUngroupable Indicates if the selected blocks can be ungrouped.
 * @property {WPBlock[]} blocksSelection An array of the selected blocks.
 * @property {string} groupingBlockName The name of block used for handling grouping interactions.
 */

/**
 * Returns the properties `ConvertToGroupButton` component needs to work properly.
 * It is used in `BlockSettingsMenuControls` to know if `ConvertToGroupButton`
 * should be rendered, to avoid ending up with an empty MenuGroup.
 *
 * @return {ConvertToGroupButtonProps} Returns the properties needed by `ConvertToGroupButton`.
 */

function useConvertToGroupButtonProps() {
  const {
    clientIds,
    isGroupable,
    isUngroupable,
    blocksSelection,
    groupingBlockName
  } = Object(external_wp_data_["useSelect"])(select => {
    var _blocksSelection$;

    const {
      getBlockRootClientId,
      getBlocksByClientId,
      canInsertBlockType,
      getSelectedBlockClientIds
    } = select(store);
    const {
      getGroupingBlockName
    } = select(external_wp_blocks_["store"]);

    const _clientIds = getSelectedBlockClientIds();

    const _groupingBlockName = getGroupingBlockName();

    const rootClientId = !!(_clientIds !== null && _clientIds !== void 0 && _clientIds.length) ? getBlockRootClientId(_clientIds[0]) : undefined;
    const groupingBlockAvailable = canInsertBlockType(_groupingBlockName, rootClientId);

    const _blocksSelection = getBlocksByClientId(_clientIds);

    const isSingleGroupingBlock = _blocksSelection.length === 1 && ((_blocksSelection$ = _blocksSelection[0]) === null || _blocksSelection$ === void 0 ? void 0 : _blocksSelection$.name) === _groupingBlockName; // Do we have
    // 1. Grouping block available to be inserted?
    // 2. One or more blocks selected
    // (we allow single Blocks to become groups unless
    // they are a soltiary group block themselves)

    const _isGroupable = groupingBlockAvailable && _blocksSelection.length && !isSingleGroupingBlock; // Do we have a single Group Block selected and does that group have inner blocks?


    const _isUngroupable = isSingleGroupingBlock && !!_blocksSelection[0].innerBlocks.length;

    return {
      clientIds: _clientIds,
      isGroupable: _isGroupable,
      isUngroupable: _isUngroupable,
      blocksSelection: _blocksSelection,
      groupingBlockName: _groupingBlockName
    };
  }, []);
  return {
    clientIds,
    isGroupable,
    isUngroupable,
    blocksSelection,
    groupingBlockName
  };
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/convert-to-group-buttons/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




function ConvertToGroupButton({
  clientIds,
  isGroupable,
  isUngroupable,
  blocksSelection,
  groupingBlockName,
  onClose = () => {}
}) {
  const {
    replaceBlocks
  } = Object(external_wp_data_["useDispatch"])(store);

  const onConvertToGroup = () => {
    // Activate the `transform` on the Grouping Block which does the conversion
    const newBlocks = Object(external_wp_blocks_["switchToBlockType"])(blocksSelection, groupingBlockName);

    if (newBlocks) {
      replaceBlocks(clientIds, newBlocks);
    }
  };

  const onConvertFromGroup = () => {
    const innerBlocks = blocksSelection[0].innerBlocks;

    if (!innerBlocks.length) {
      return;
    }

    replaceBlocks(clientIds, innerBlocks);
  };

  if (!isGroupable && !isUngroupable) {
    return null;
  }

  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, isGroupable && Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
    onClick: () => {
      onConvertToGroup();
      onClose();
    }
  }, Object(external_wp_i18n_["_x"])('Group', 'verb')), isUngroupable && Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
    onClick: () => {
      onConvertFromGroup();
      onClose();
    }
  }, Object(external_wp_i18n_["_x"])('Ungroup', 'Ungrouping blocks from within a Group block back into individual blocks within the Editor ')));
}



// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu-controls/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



const {
  Fill: block_settings_menu_controls_Fill,
  Slot: block_settings_menu_controls_Slot
} = Object(external_wp_components_["createSlotFill"])('BlockSettingsMenuControls');

const BlockSettingsMenuControlsSlot = ({
  fillProps,
  clientIds = null
}) => {
  const selectedBlocks = Object(external_wp_data_["useSelect"])(select => {
    const {
      getBlocksByClientId,
      getSelectedBlockClientIds
    } = select(store);
    const ids = clientIds !== null ? clientIds : getSelectedBlockClientIds();
    return Object(external_lodash_["map"])(Object(external_lodash_["compact"])(getBlocksByClientId(ids)), block => block.name);
  }, [clientIds]); // Check if current selection of blocks is Groupable or Ungroupable
  // and pass this props down to ConvertToGroupButton.

  const convertToGroupButtonProps = useConvertToGroupButtonProps();
  const {
    isGroupable,
    isUngroupable
  } = convertToGroupButtonProps;
  const showConvertToGroupButton = isGroupable || isUngroupable;
  return Object(external_wp_element_["createElement"])(block_settings_menu_controls_Slot, {
    fillProps: { ...fillProps,
      selectedBlocks
    }
  }, fills => {
    if ((fills === null || fills === void 0 ? void 0 : fills.length) > 0 || showConvertToGroupButton) {
      return Object(external_wp_element_["createElement"])(external_wp_components_["MenuGroup"], null, fills, Object(external_wp_element_["createElement"])(ConvertToGroupButton, Object(esm_extends["a" /* default */])({}, convertToGroupButtonProps, {
        onClose: fillProps === null || fillProps === void 0 ? void 0 : fillProps.onClose
      })));
    }
  });
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-settings-menu-controls/README.md
 *
 * @param {Object} props  Fill props.
 * @return {WPElement} Element.
 */


function BlockSettingsMenuControls({ ...props
}) {
  return Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalStyleProvider"], {
    document: document
  }, Object(external_wp_element_["createElement"])(block_settings_menu_controls_Fill, props));
}

BlockSettingsMenuControls.Slot = BlockSettingsMenuControlsSlot;
/* harmony default export */ var block_settings_menu_controls = (BlockSettingsMenuControls);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-settings-dropdown.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */









/**
 * Internal dependencies
 */






const block_settings_dropdown_POPOVER_PROPS = {
  className: 'block-editor-block-settings-menu__popover',
  position: 'bottom right',
  isAlternate: true
};

function CopyMenuItem({
  blocks,
  onCopy
}) {
  const ref = Object(external_wp_compose_["useCopyToClipboard"])(() => Object(external_wp_blocks_["serialize"])(blocks), onCopy);
  return Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
    ref: ref
  }, Object(external_wp_i18n_["__"])('Copy'));
}

function BlockSettingsDropdown({
  clientIds,
  __experimentalSelectBlock,
  children,
  ...props
}) {
  const blockClientIds = Object(external_lodash_["castArray"])(clientIds);
  const count = blockClientIds.length;
  const firstBlockClientId = blockClientIds[0];
  const shortcuts = Object(external_wp_data_["useSelect"])(select => {
    const {
      getShortcutRepresentation
    } = select(external_wp_keyboardShortcuts_["store"]);
    return {
      duplicate: getShortcutRepresentation('core/block-editor/duplicate'),
      remove: getShortcutRepresentation('core/block-editor/remove'),
      insertAfter: getShortcutRepresentation('core/block-editor/insert-after'),
      insertBefore: getShortcutRepresentation('core/block-editor/insert-before')
    };
  }, []);
  const updateSelection = Object(external_wp_element_["useCallback"])(__experimentalSelectBlock ? async clientIdsPromise => {
    const ids = await clientIdsPromise;

    if (ids && ids[0]) {
      __experimentalSelectBlock(ids[0]);
    }
  } : external_lodash_["noop"], [__experimentalSelectBlock]);
  const removeBlockLabel = count === 1 ? Object(external_wp_i18n_["__"])('Remove block') : Object(external_wp_i18n_["__"])('Remove blocks');
  return Object(external_wp_element_["createElement"])(BlockActions, {
    clientIds: clientIds,
    __experimentalUpdateSelection: !__experimentalSelectBlock
  }, ({
    canDuplicate,
    canInsertDefaultBlock,
    isLocked,
    onDuplicate,
    onInsertAfter,
    onInsertBefore,
    onRemove,
    onCopy,
    onMoveTo,
    blocks
  }) => Object(external_wp_element_["createElement"])(external_wp_components_["DropdownMenu"], Object(esm_extends["a" /* default */])({
    icon: more_vertical["a" /* default */],
    label: Object(external_wp_i18n_["__"])('Options'),
    className: "block-editor-block-settings-menu",
    popoverProps: block_settings_dropdown_POPOVER_PROPS,
    noIcons: true
  }, props), ({
    onClose
  }) => Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(external_wp_components_["MenuGroup"], null, Object(external_wp_element_["createElement"])(block_settings_menu_first_item.Slot, {
    fillProps: {
      onClose
    }
  }), count === 1 && Object(external_wp_element_["createElement"])(block_html_convert_button, {
    clientId: firstBlockClientId
  }), Object(external_wp_element_["createElement"])(CopyMenuItem, {
    blocks: blocks,
    onCopy: onCopy
  }), canDuplicate && Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
    onClick: Object(external_lodash_["flow"])(onClose, onDuplicate, updateSelection),
    shortcut: shortcuts.duplicate
  }, Object(external_wp_i18n_["__"])('Duplicate')), canInsertDefaultBlock && Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
    onClick: Object(external_lodash_["flow"])(onClose, onInsertBefore),
    shortcut: shortcuts.insertBefore
  }, Object(external_wp_i18n_["__"])('Insert before')), Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
    onClick: Object(external_lodash_["flow"])(onClose, onInsertAfter),
    shortcut: shortcuts.insertAfter
  }, Object(external_wp_i18n_["__"])('Insert after'))), !isLocked && Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
    onClick: Object(external_lodash_["flow"])(onClose, onMoveTo)
  }, Object(external_wp_i18n_["__"])('Move to')), count === 1 && Object(external_wp_element_["createElement"])(block_mode_toggle, {
    clientId: firstBlockClientId,
    onToggle: onClose
  })), Object(external_wp_element_["createElement"])(block_settings_menu_controls.Slot, {
    fillProps: {
      onClose
    },
    clientIds: clientIds
  }), typeof children === 'function' ? children({
    onClose
  }) : external_wp_element_["Children"].map(child => Object(external_wp_element_["cloneElement"])(child, {
    onClose
  })), Object(external_wp_element_["createElement"])(external_wp_components_["MenuGroup"], null, !isLocked && Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
    onClick: Object(external_lodash_["flow"])(onClose, onRemove, updateSelection),
    shortcut: shortcuts.remove
  }, removeBlockLabel)))));
}
/* harmony default export */ var block_settings_dropdown = (BlockSettingsDropdown);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/index.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


function BlockSettingsMenu({
  clientIds,
  ...props
}) {
  return Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarGroup"], null, Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarItem"], null, toggleProps => Object(external_wp_element_["createElement"])(block_settings_dropdown, Object(esm_extends["a" /* default */])({
    clientIds: clientIds,
    toggleProps: toggleProps
  }, props))));
}
/* harmony default export */ var block_settings_menu = (BlockSettingsMenu);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-toolbar/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */








function BlockToolbar({
  hideDragHandle
}) {
  const {
    blockClientIds,
    blockClientId,
    blockType,
    hasFixedToolbar,
    hasReducedUI,
    isValid,
    isVisual
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getBlockName,
      getBlockMode,
      getSelectedBlockClientIds,
      isBlockValid,
      getBlockRootClientId,
      getSettings
    } = select(store);
    const selectedBlockClientIds = getSelectedBlockClientIds();
    const selectedBlockClientId = selectedBlockClientIds[0];
    const blockRootClientId = getBlockRootClientId(selectedBlockClientId);
    const settings = getSettings();
    return {
      blockClientIds: selectedBlockClientIds,
      blockClientId: selectedBlockClientId,
      blockType: selectedBlockClientId && Object(external_wp_blocks_["getBlockType"])(getBlockName(selectedBlockClientId)),
      hasFixedToolbar: settings.hasFixedToolbar,
      hasReducedUI: settings.hasReducedUI,
      rootClientId: blockRootClientId,
      isValid: selectedBlockClientIds.every(id => isBlockValid(id)),
      isVisual: selectedBlockClientIds.every(id => getBlockMode(id) === 'visual')
    };
  }, []); // Handles highlighting the current block outline on hover or focus of the
  // block type toolbar area.

  const {
    toggleBlockHighlight
  } = Object(external_wp_data_["useDispatch"])(store);
  const nodeRef = Object(external_wp_element_["useRef"])();
  const {
    showMovers,
    gestures: showMoversGestures
  } = useShowMoversGestures({
    ref: nodeRef,

    onChange(isFocused) {
      if (isFocused && hasReducedUI) {
        return;
      }

      toggleBlockHighlight(blockClientId, isFocused);
    }

  }); // Account for the cases where the block toolbar is rendered within the
  // header area and not contextually to the block.

  const displayHeaderToolbar = Object(external_wp_compose_["useViewportMatch"])('medium', '<') || hasFixedToolbar;

  if (blockType) {
    if (!Object(external_wp_blocks_["hasBlockSupport"])(blockType, '__experimentalToolbar', true)) {
      return null;
    }
  }

  const shouldShowMovers = displayHeaderToolbar || showMovers;

  if (blockClientIds.length === 0) {
    return null;
  }

  const shouldShowVisualToolbar = isValid && isVisual;
  const isMultiToolbar = blockClientIds.length > 1;
  const classes = classnames_default()('block-editor-block-toolbar', shouldShowMovers && 'is-showing-movers');
  return Object(external_wp_element_["createElement"])("div", {
    className: classes
  }, !isMultiToolbar && !displayHeaderToolbar && Object(external_wp_element_["createElement"])(BlockParentSelector, {
    clientIds: blockClientIds
  }), Object(external_wp_element_["createElement"])("div", Object(esm_extends["a" /* default */])({
    ref: nodeRef
  }, showMoversGestures), (shouldShowVisualToolbar || isMultiToolbar) && Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarGroup"], {
    className: "block-editor-block-toolbar__block-controls"
  }, Object(external_wp_element_["createElement"])(block_switcher, {
    clientIds: blockClientIds
  }), Object(external_wp_element_["createElement"])(block_mover, {
    clientIds: blockClientIds,
    hideDragHandle: hideDragHandle || hasReducedUI
  }))), shouldShowVisualToolbar && Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(block_controls.Slot, {
    group: "block",
    className: "block-editor-block-toolbar__slot"
  }), Object(external_wp_element_["createElement"])(block_controls.Slot, {
    className: "block-editor-block-toolbar__slot"
  }), Object(external_wp_element_["createElement"])(block_controls.Slot, {
    group: "inline",
    className: "block-editor-block-toolbar__slot"
  }), Object(external_wp_element_["createElement"])(block_controls.Slot, {
    group: "other",
    className: "block-editor-block-toolbar__slot"
  })), Object(external_wp_element_["createElement"])(block_settings_menu, {
    clientIds: blockClientIds
  }));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-tools/block-contextual-toolbar.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





function BlockContextualToolbar({
  focusOnMount,
  isFixed,
  ...props
}) {
  const {
    blockType,
    hasParents,
    showParentSelector
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getBlockName,
      getBlockParents,
      getSelectedBlockClientIds
    } = select(store);
    const {
      getBlockType
    } = select(external_wp_blocks_["store"]);
    const selectedBlockClientIds = getSelectedBlockClientIds();
    const selectedBlockClientId = selectedBlockClientIds[0];
    const parents = getBlockParents(selectedBlockClientId);
    const firstParentClientId = parents[parents.length - 1];
    const parentBlockName = getBlockName(firstParentClientId);
    const parentBlockType = getBlockType(parentBlockName);
    return {
      blockType: selectedBlockClientId && getBlockType(getBlockName(selectedBlockClientId)),
      hasParents: parents.length,
      showParentSelector: Object(external_wp_blocks_["hasBlockSupport"])(parentBlockType, '__experimentalParentSelector', true)
    };
  }, []);

  if (blockType) {
    if (!Object(external_wp_blocks_["hasBlockSupport"])(blockType, '__experimentalToolbar', true)) {
      return null;
    }
  } // Shifts the toolbar to make room for the parent block selector.


  const classes = classnames_default()('block-editor-block-contextual-toolbar', {
    'has-parent': hasParents && showParentSelector,
    'is-fixed': isFixed
  });
  return Object(external_wp_element_["createElement"])(navigable_toolbar, Object(esm_extends["a" /* default */])({
    focusOnMount: focusOnMount,
    className: classes
    /* translators: accessibility text for the block toolbar */
    ,
    "aria-label": Object(external_wp_i18n_["__"])('Block tools')
  }, props), Object(external_wp_element_["createElement"])(BlockToolbar, {
    hideDragHandle: isFixed
  }));
}

/* harmony default export */ var block_contextual_toolbar = (BlockContextualToolbar);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-tools/block-popover.js


/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */








/**
 * Internal dependencies
 */








function block_popover_selector(select) {
  const {
    isNavigationMode,
    isMultiSelecting,
    hasMultiSelection,
    isTyping,
    isCaretWithinFormattedText,
    getSettings,
    getLastMultiSelectedBlockClientId
  } = select(store);
  return {
    isNavigationMode: isNavigationMode(),
    isMultiSelecting: isMultiSelecting(),
    isTyping: isTyping(),
    isCaretWithinFormattedText: isCaretWithinFormattedText(),
    hasMultiSelection: hasMultiSelection(),
    hasFixedToolbar: getSettings().hasFixedToolbar,
    lastClientId: getLastMultiSelectedBlockClientId()
  };
}

function BlockPopover({
  clientId,
  rootClientId,
  isValid,
  isEmptyDefaultBlock,
  capturingClientId,
  __unstablePopoverSlot,
  __unstableContentRef
}) {
  const {
    isNavigationMode,
    isMultiSelecting,
    isTyping,
    isCaretWithinFormattedText,
    hasMultiSelection,
    hasFixedToolbar,
    lastClientId
  } = Object(external_wp_data_["useSelect"])(block_popover_selector, []);
  const isInsertionPointVisible = Object(external_wp_data_["useSelect"])(select => {
    const {
      isBlockInsertionPointVisible,
      getBlockInsertionPoint,
      getBlockOrder
    } = select(store);

    if (!isBlockInsertionPointVisible()) {
      return false;
    }

    const insertionPoint = getBlockInsertionPoint();
    const order = getBlockOrder(insertionPoint.rootClientId);
    return order[insertionPoint.index] === clientId;
  }, [clientId]);
  const isLargeViewport = Object(external_wp_compose_["useViewportMatch"])('medium');
  const [isToolbarForced, setIsToolbarForced] = Object(external_wp_element_["useState"])(false);
  const [isInserterShown, setIsInserterShown] = Object(external_wp_element_["useState"])(false);
  const {
    stopTyping
  } = Object(external_wp_data_["useDispatch"])(store); // Controls when the side inserter on empty lines should
  // be shown, including writing and selection modes.

  const showEmptyBlockSideInserter = !isTyping && !isNavigationMode && isEmptyDefaultBlock && isValid;
  const shouldShowBreadcrumb = isNavigationMode;
  const shouldShowContextualToolbar = !isNavigationMode && !hasFixedToolbar && isLargeViewport && !showEmptyBlockSideInserter && !isMultiSelecting && (!isTyping || isCaretWithinFormattedText);
  const canFocusHiddenToolbar = !isNavigationMode && !shouldShowContextualToolbar && !hasFixedToolbar && !isEmptyDefaultBlock;
  Object(external_wp_keyboardShortcuts_["useShortcut"])('core/block-editor/focus-toolbar', Object(external_wp_element_["useCallback"])(() => {
    setIsToolbarForced(true);
    stopTyping(true);
  }, []), {
    bindGlobal: true,
    eventName: 'keydown',
    isDisabled: !canFocusHiddenToolbar
  });
  Object(external_wp_element_["useEffect"])(() => {
    if (!shouldShowContextualToolbar) {
      setIsToolbarForced(false);
    }
  }, [shouldShowContextualToolbar]); // Stores the active toolbar item index so the block toolbar can return focus
  // to it when re-mounting.

  const initialToolbarItemIndexRef = Object(external_wp_element_["useRef"])();
  const selectedElement = useBlockElement(clientId);
  const lastSelectedElement = useBlockElement(lastClientId);
  const capturingElement = useBlockElement(capturingClientId);
  const popoverScrollRef = usePopoverScroll(__unstableContentRef);

  if (!shouldShowBreadcrumb && !shouldShowContextualToolbar && !isToolbarForced && !showEmptyBlockSideInserter) {
    return null;
  }

  let node = selectedElement;

  if (!node) {
    return null;
  }

  if (capturingClientId) {
    node = capturingElement;
  }

  let anchorRef = node;

  if (hasMultiSelection) {
    // Wait to render the popover until the bottom reference is available
    // as well.
    if (!lastSelectedElement) {
      return null;
    }

    anchorRef = {
      top: node,
      bottom: lastSelectedElement
    };
  }

  function onFocus() {
    setIsInserterShown(true);
  }

  function onBlur() {
    setIsInserterShown(false);
  } // Position above the anchor, pop out towards the right, and position in the
  // left corner. For the side inserter, pop out towards the left, and
  // position in the right corner.
  // To do: refactor `Popover` to make this prop clearer.


  const popoverPosition = showEmptyBlockSideInserter ? 'top left right' : 'top right left';
  const {
    ownerDocument
  } = node;
  const stickyBoundaryElement = showEmptyBlockSideInserter ? undefined : // The sticky boundary element should be the boundary at which the
  // the block toolbar becomes sticky when the block scolls out of view.
  // In case of an iframe, this should be the iframe boundary, otherwise
  // the scroll container.
  ownerDocument.defaultView.frameElement || Object(external_wp_dom_["getScrollContainer"])(node) || ownerDocument.body;
  return Object(external_wp_element_["createElement"])(external_wp_components_["Popover"], {
    ref: popoverScrollRef,
    noArrow: true,
    animate: false,
    position: popoverPosition,
    focusOnMount: false,
    anchorRef: anchorRef,
    className: classnames_default()('block-editor-block-list__block-popover', {
      'is-insertion-point-visible': isInsertionPointVisible
    }),
    __unstableStickyBoundaryElement: stickyBoundaryElement // Render in the old slot if needed for backward compatibility,
    // otherwise render in place (not in the the default popover slot).
    ,
    __unstableSlotName: __unstablePopoverSlot || null,
    __unstableBoundaryParent: true // Observe movement for block animations (especially horizontal).
    ,
    __unstableObserveElement: node,
    shouldAnchorIncludePadding: true
  }, (shouldShowContextualToolbar || isToolbarForced) && Object(external_wp_element_["createElement"])("div", {
    onFocus: onFocus,
    onBlur: onBlur // While ideally it would be enough to capture the
    // bubbling focus event from the Inserter, due to the
    // characteristics of click focusing of `button`s in
    // Firefox and Safari, it is not reliable.
    //
    // See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
    ,
    tabIndex: -1,
    className: classnames_default()('block-editor-block-list__block-popover-inserter', {
      'is-visible': isInserterShown
    })
  }, Object(external_wp_element_["createElement"])(inserter, {
    clientId: clientId,
    rootClientId: rootClientId,
    __experimentalIsQuick: true
  })), (shouldShowContextualToolbar || isToolbarForced) && Object(external_wp_element_["createElement"])(block_contextual_toolbar // If the toolbar is being shown because of being forced
  // it should focus the toolbar right after the mount.
  , {
    focusOnMount: isToolbarForced,
    __experimentalInitialIndex: initialToolbarItemIndexRef.current,
    __experimentalOnIndexChange: index => {
      initialToolbarItemIndexRef.current = index;
    } // Resets the index whenever the active block changes so
    // this is not persisted. See https://github.com/WordPress/gutenberg/pull/25760#issuecomment-717906169
    ,
    key: clientId
  }), shouldShowBreadcrumb && Object(external_wp_element_["createElement"])(block_selection_button, {
    clientId: clientId,
    rootClientId: rootClientId,
    blockElement: node
  }), showEmptyBlockSideInserter && Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-list__empty-block-inserter"
  }, Object(external_wp_element_["createElement"])(inserter, {
    position: "bottom right",
    rootClientId: rootClientId,
    clientId: clientId,
    __experimentalIsQuick: true
  })));
}

function wrapperSelector(select) {
  const {
    getSelectedBlockClientId,
    getFirstMultiSelectedBlockClientId,
    getBlockRootClientId,
    __unstableGetBlockWithoutInnerBlocks,
    getBlockParents,
    __experimentalGetBlockListSettingsForBlocks
  } = select(store);
  const clientId = getSelectedBlockClientId() || getFirstMultiSelectedBlockClientId();

  if (!clientId) {
    return;
  }

  const {
    name,
    attributes = {},
    isValid
  } = __unstableGetBlockWithoutInnerBlocks(clientId) || {};
  const blockParentsClientIds = getBlockParents(clientId); // Get Block List Settings for all ancestors of the current Block clientId

  const parentBlockListSettings = __experimentalGetBlockListSettingsForBlocks(blockParentsClientIds); // Get the clientId of the topmost parent with the capture toolbars setting.


  const capturingClientId = Object(external_lodash_["find"])(blockParentsClientIds, parentClientId => {
    var _parentBlockListSetti;

    return (_parentBlockListSetti = parentBlockListSettings[parentClientId]) === null || _parentBlockListSetti === void 0 ? void 0 : _parentBlockListSetti.__experimentalCaptureToolbars;
  });
  return {
    clientId,
    rootClientId: getBlockRootClientId(clientId),
    name,
    isValid,
    isEmptyDefaultBlock: name && Object(external_wp_blocks_["isUnmodifiedDefaultBlock"])({
      name,
      attributes
    }),
    capturingClientId
  };
}

function WrappedBlockPopover({
  __unstablePopoverSlot,
  __unstableContentRef
}) {
  const selected = Object(external_wp_data_["useSelect"])(wrapperSelector, []);

  if (!selected) {
    return null;
  }

  const {
    clientId,
    rootClientId,
    name,
    isValid,
    isEmptyDefaultBlock,
    capturingClientId
  } = selected;

  if (!name) {
    return null;
  }

  return Object(external_wp_element_["createElement"])(BlockPopover, {
    clientId: clientId,
    rootClientId: rootClientId,
    isValid: isValid,
    isEmptyDefaultBlock: isEmptyDefaultBlock,
    capturingClientId: capturingClientId,
    __unstablePopoverSlot: __unstablePopoverSlot,
    __unstableContentRef: __unstableContentRef
  });
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-tools/back-compat.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function BlockToolsBackCompat({
  children
}) {
  const openRef = Object(external_wp_element_["useContext"])(InsertionPointOpenRef);
  const isDisabled = Object(external_wp_element_["useContext"])(external_wp_components_["Disabled"].Context); // If context is set, `BlockTools` is a parent component.

  if (openRef || isDisabled) {
    return children;
  }

  external_wp_deprecated_default()('wp.components.Popover.Slot name="block-toolbar"', {
    alternative: 'wp.blockEditor.BlockTools'
  });
  return Object(external_wp_element_["createElement"])(InsertionPoint, {
    __unstablePopoverSlot: "block-toolbar"
  }, Object(external_wp_element_["createElement"])(WrappedBlockPopover, {
    __unstablePopoverSlot: "block-toolbar"
  }), children);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-selection-clearer/index.js



/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Pass the returned ref callback to an element that should clear block
 * selection. Selection will only be cleared if the element is clicked directly,
 * not if a child element is clicked.
 *
 * @return {import('react').RefCallback} Ref callback.
 */

function useBlockSelectionClearer() {
  const {
    hasSelectedBlock,
    hasMultiSelection
  } = Object(external_wp_data_["useSelect"])(store);
  const {
    clearSelectedBlock
  } = Object(external_wp_data_["useDispatch"])(store);
  return Object(external_wp_compose_["useRefEffect"])(node => {
    function onMouseDown(event) {
      if (!hasSelectedBlock() && !hasMultiSelection()) {
        return;
      } // Only handle clicks on the element, not the children.


      if (event.target !== node) {
        return;
      }

      clearSelectedBlock();
    }

    node.addEventListener('mousedown', onMouseDown);
    return () => {
      node.removeEventListener('mousedown', onMouseDown);
    };
  }, [hasSelectedBlock, hasMultiSelection, clearSelectedBlock]);
}
function BlockSelectionClearer(props) {
  return Object(external_wp_element_["createElement"])("div", Object(esm_extends["a" /* default */])({
    ref: useBlockSelectionClearer()
  }, props));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */











const IntersectionObserver = Object(external_wp_element_["createContext"])();

function Root({
  className,
  children
}) {
  const isLargeViewport = Object(external_wp_compose_["useViewportMatch"])('medium');
  const {
    isOutlineMode,
    isFocusMode,
    isNavigationMode
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getSettings,
      isNavigationMode: _isNavigationMode
    } = select(store);
    const {
      outlineMode,
      focusMode
    } = getSettings();
    return {
      isOutlineMode: outlineMode,
      isFocusMode: focusMode,
      isNavigationMode: _isNavigationMode()
    };
  }, []);
  return Object(external_wp_element_["createElement"])(Head, null, Object(external_wp_element_["createElement"])("div", {
    ref: Object(external_wp_compose_["useMergeRefs"])([useBlockSelectionClearer(), useBlockDropZone(), useInBetweenInserter()]),
    className: classnames_default()('block-editor-block-list__layout is-root-container', className, {
      'is-outline-mode': isOutlineMode,
      'is-focus-mode': isFocusMode && isLargeViewport,
      'is-navigate-mode': isNavigationMode
    })
  }, children));
}

function BlockList({
  className,
  ...props
}) {
  usePreParsePatterns();
  return Object(external_wp_element_["createElement"])(BlockToolsBackCompat, null, Object(external_wp_element_["createElement"])(Root, {
    className: className
  }, Object(external_wp_element_["createElement"])(BlockListItems, props)));
}

function Items({
  placeholder,
  rootClientId,
  renderAppender,
  __experimentalAppenderTagName,
  __experimentalLayout: layout = layout_defaultLayout
}) {
  const [intersectingBlocks, setIntersectingBlocks] = Object(external_wp_element_["useState"])(new Set());
  const intersectionObserver = Object(external_wp_element_["useMemo"])(() => {
    const {
      IntersectionObserver: Observer
    } = window;

    if (!Observer) {
      return;
    }

    return new Observer(entries => {
      setIntersectingBlocks(oldIntersectingBlocks => {
        const newIntersectingBlocks = new Set(oldIntersectingBlocks);

        for (const entry of entries) {
          const clientId = entry.target.getAttribute('data-block');
          const action = entry.isIntersecting ? 'add' : 'delete';
          newIntersectingBlocks[action](clientId);
        }

        return newIntersectingBlocks;
      });
    });
  }, [setIntersectingBlocks]);
  const {
    order,
    selectedBlocks
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getBlockOrder,
      getSelectedBlockClientIds
    } = select(store);
    return {
      order: getBlockOrder(rootClientId),
      selectedBlocks: getSelectedBlockClientIds()
    };
  }, [rootClientId]);
  return Object(external_wp_element_["createElement"])(LayoutProvider, {
    value: layout
  }, Object(external_wp_element_["createElement"])(IntersectionObserver.Provider, {
    value: intersectionObserver
  }, order.map(clientId => Object(external_wp_element_["createElement"])(external_wp_data_["AsyncModeProvider"], {
    key: clientId,
    value: // Only provide data asynchronously if the block is
    // not visible and not selected.
    !intersectingBlocks.has(clientId) && !selectedBlocks.includes(clientId)
  }, Object(external_wp_element_["createElement"])(block_list_block, {
    rootClientId: rootClientId,
    clientId: clientId
  })))), order.length < 1 && placeholder, Object(external_wp_element_["createElement"])(block_list_appender, {
    tagName: __experimentalAppenderTagName,
    rootClientId: rootClientId,
    renderAppender: renderAppender
  }));
}

function BlockListItems(props) {
  // This component needs to always be synchronous as it's the one changing
  // the async mode depending on the block selection.
  return Object(external_wp_element_["createElement"])(external_wp_data_["AsyncModeProvider"], {
    value: false
  }, Object(external_wp_element_["createElement"])(Items, props));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-intersection-observer.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function useIntersectionObserver() {
  const observer = Object(external_wp_element_["useContext"])(IntersectionObserver);
  return Object(external_wp_compose_["useRefEffect"])(node => {
    if (observer) {
      observer.observe(node);
      return () => {
        observer.unobserve(node);
      };
    }
  }, [observer]);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */

















/**
 * If the block count exceeds the threshold, we disable the reordering animation
 * to avoid laginess.
 */

const BLOCK_ANIMATION_THRESHOLD = 200;
/**
 * This hook is used to lightly mark an element as a block element. The element
 * should be the outermost element of a block. Call this hook and pass the
 * returned props to the element to mark as a block. If you define a ref for the
 * element, it is important to pass the ref to this hook, which the hook in turn
 * will pass to the component through the props it returns. Optionally, you can
 * also pass any other props through this hook, and they will be merged and
 * returned.
 *
 * @param {Object}  props   Optional. Props to pass to the element. Must contain
 *                          the ref if one is defined.
 * @param {Object}  options Options for internal use only.
 * @param {boolean} options.__unstableIsHtml
 *
 * @return {Object} Props to pass to the element to mark as a block.
 */

function useBlockProps(props = {}, {
  __unstableIsHtml
} = {}) {
  const {
    clientId,
    className,
    wrapperProps = {},
    isAligned
  } = Object(external_wp_element_["useContext"])(BlockListBlockContext);
  const {
    index,
    mode,
    name,
    blockTitle,
    isPartOfSelection,
    adjustScrolling,
    enableAnimation
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getBlockRootClientId,
      getBlockIndex,
      getBlockMode,
      getBlockName,
      isTyping,
      getGlobalBlockCount,
      isBlockSelected,
      isBlockMultiSelected,
      isAncestorMultiSelected,
      isFirstMultiSelectedBlock
    } = select(store);
    const isSelected = isBlockSelected(clientId);
    const isPartOfMultiSelection = isBlockMultiSelected(clientId) || isAncestorMultiSelected(clientId);
    const blockName = getBlockName(clientId);
    const rootClientId = getBlockRootClientId(clientId);
    return {
      index: getBlockIndex(clientId, rootClientId),
      mode: getBlockMode(clientId),
      name: blockName,
      blockTitle: Object(external_wp_blocks_["getBlockType"])(blockName).title,
      isPartOfSelection: isSelected || isPartOfMultiSelection,
      adjustScrolling: isSelected || isFirstMultiSelectedBlock(clientId),
      enableAnimation: !isTyping() && getGlobalBlockCount() <= BLOCK_ANIMATION_THRESHOLD
    };
  }, [clientId]); // translators: %s: Type of block (i.e. Text, Image etc)

  const blockLabel = Object(external_wp_i18n_["sprintf"])(Object(external_wp_i18n_["__"])('Block: %s'), blockTitle);
  const htmlSuffix = mode === 'html' && !__unstableIsHtml ? '-visual' : '';
  const mergedRefs = Object(external_wp_compose_["useMergeRefs"])([props.ref, useFocusFirstElement(clientId), // Must happen after focus because we check for focus in the block.
  useScrollIntoView(clientId), useBlockRefProvider(clientId), useFocusHandler(clientId), useMultiSelection(clientId), useEventHandlers(clientId), useNavModeExit(clientId), useIsHovered(), useIntersectionObserver(), use_moving_animation({
    isSelected: isPartOfSelection,
    adjustScrolling,
    enableAnimation,
    triggerAnimationOnChange: index
  })]);
  return { ...wrapperProps,
    ...props,
    ref: mergedRefs,
    id: `block-${clientId}${htmlSuffix}`,
    tabIndex: 0,
    role: 'group',
    'aria-label': blockLabel,
    'data-block': clientId,
    'data-type': name,
    'data-title': blockTitle,
    className: classnames_default()( // The wp-block className is important for editor styles.
    classnames_default()('block-editor-block-list__block', {
      'wp-block': !isAligned
    }), className, props.className, wrapperProps.className, useBlockClassNames(clientId), useBlockDefaultClassName(clientId), useBlockCustomClassName(clientId), useBlockMovingModeClassNames(clientId)),
    style: { ...wrapperProps.style,
      ...props.style
    }
  };
}
/**
 * Call within a save function to get the props for the block wrapper.
 *
 * @param {Object} props Optional. Props to pass to the element.
 */

useBlockProps.save = external_wp_blocks_["__unstableGetBlockProps"];

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-list/block.js


/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */








const BlockListBlockContext = Object(external_wp_element_["createContext"])();
/**
 * Merges wrapper props with special handling for classNames and styles.
 *
 * @param {Object} propsA
 * @param {Object} propsB
 *
 * @return {Object} Merged props.
 */

function mergeWrapperProps(propsA, propsB) {
  const newProps = { ...propsA,
    ...propsB
  };

  if (propsA && propsB && propsA.className && propsB.className) {
    newProps.className = classnames_default()(propsA.className, propsB.className);
  }

  if (propsA && propsB && propsA.style && propsB.style) {
    newProps.style = { ...propsA.style,
      ...propsB.style
    };
  }

  return newProps;
}

function Block({
  children,
  isHtml,
  ...props
}) {
  return Object(external_wp_element_["createElement"])("div", useBlockProps(props, {
    __unstableIsHtml: isHtml
  }), children);
}

function block_BlockListBlock({
  mode,
  isLocked,
  clientId,
  isSelected,
  isSelectionEnabled,
  className,
  name,
  isValid,
  attributes,
  wrapperProps,
  setAttributes,
  onReplace,
  onInsertBlocksAfter,
  onMerge,
  toggleSelection
}) {
  const {
    removeBlock
  } = Object(external_wp_data_["useDispatch"])(store);
  const onRemove = Object(external_wp_element_["useCallback"])(() => removeBlock(clientId), [clientId]); // We wrap the BlockEdit component in a div that hides it when editing in
  // HTML mode. This allows us to render all of the ancillary pieces
  // (InspectorControls, etc.) which are inside `BlockEdit` but not
  // `BlockHTML`, even in HTML mode.

  let blockEdit = Object(external_wp_element_["createElement"])(block_edit_BlockEdit, {
    name: name,
    isSelected: isSelected,
    attributes: attributes,
    setAttributes: setAttributes,
    insertBlocksAfter: isLocked ? undefined : onInsertBlocksAfter,
    onReplace: isLocked ? undefined : onReplace,
    onRemove: isLocked ? undefined : onRemove,
    mergeBlocks: isLocked ? undefined : onMerge,
    clientId: clientId,
    isSelectionEnabled: isSelectionEnabled,
    toggleSelection: toggleSelection
  });
  const blockType = Object(external_wp_blocks_["getBlockType"])(name);
  const lightBlockWrapper = blockType.apiVersion > 1 || Object(external_wp_blocks_["hasBlockSupport"])(blockType, 'lightBlockWrapper', false); // Determine whether the block has props to apply to the wrapper.

  if (blockType.getEditWrapperProps) {
    wrapperProps = mergeWrapperProps(wrapperProps, blockType.getEditWrapperProps(attributes));
  }

  const isAligned = wrapperProps && !!wrapperProps['data-align']; // For aligned blocks, provide a wrapper element so the block can be
  // positioned relative to the block column.

  if (isAligned) {
    blockEdit = Object(external_wp_element_["createElement"])("div", {
      className: "wp-block",
      "data-align": wrapperProps['data-align']
    }, blockEdit);
  }

  let block;

  if (!isValid) {
    const saveContent = Object(external_wp_blocks_["getSaveContent"])(blockType, attributes);
    block = Object(external_wp_element_["createElement"])(Block, {
      className: "has-warning"
    }, Object(external_wp_element_["createElement"])(block_invalid_warning, {
      clientId: clientId
    }), Object(external_wp_element_["createElement"])(external_wp_element_["RawHTML"], null, Object(external_wp_dom_["safeHTML"])(saveContent)));
  } else if (mode === 'html') {
    // Render blockEdit so the inspector controls don't disappear.
    // See #8969.
    block = Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])("div", {
      style: {
        display: 'none'
      }
    }, blockEdit), Object(external_wp_element_["createElement"])(Block, {
      isHtml: true
    }, Object(external_wp_element_["createElement"])(block_html, {
      clientId: clientId
    })));
  } else if (lightBlockWrapper) {
    block = blockEdit;
  } else {
    block = Object(external_wp_element_["createElement"])(Block, wrapperProps, blockEdit);
  }

  const value = {
    clientId,
    className,
    wrapperProps: Object(external_lodash_["omit"])(wrapperProps, ['data-align']),
    isAligned
  };
  const memoizedValue = Object(external_wp_element_["useMemo"])(() => value, Object.values(value));
  return Object(external_wp_element_["createElement"])(BlockListBlockContext.Provider, {
    value: memoizedValue
  }, Object(external_wp_element_["createElement"])(block_crash_boundary, {
    fallback: Object(external_wp_element_["createElement"])(Block, {
      className: "has-warning"
    }, Object(external_wp_element_["createElement"])(block_crash_warning, null))
  }, block));
}

const applyWithSelect = Object(external_wp_data_["withSelect"])((select, {
  clientId,
  rootClientId
}) => {
  const {
    isBlockSelected,
    getBlockMode,
    isSelectionEnabled,
    getTemplateLock,
    __unstableGetBlockWithoutInnerBlocks
  } = select(store);

  const block = __unstableGetBlockWithoutInnerBlocks(clientId);

  const isSelected = isBlockSelected(clientId);
  const templateLock = getTemplateLock(rootClientId); // The fallback to `{}` is a temporary fix.
  // This function should never be called when a block is not present in
  // the state. It happens now because the order in withSelect rendering
  // is not correct.

  const {
    name,
    attributes,
    isValid
  } = block || {}; // Do not add new properties here, use `useSelect` instead to avoid
  // leaking new props to the public API (editor.BlockListBlock filter).

  return {
    mode: getBlockMode(clientId),
    isSelectionEnabled: isSelectionEnabled(),
    isLocked: !!templateLock,
    // Users of the editor.BlockListBlock filter used to be able to
    // access the block prop.
    // Ideally these blocks would rely on the clientId prop only.
    // This is kept for backward compatibility reasons.
    block,
    name,
    attributes,
    isValid,
    isSelected
  };
});
const applyWithDispatch = Object(external_wp_data_["withDispatch"])((dispatch, ownProps, {
  select
}) => {
  const {
    updateBlockAttributes,
    insertBlocks,
    mergeBlocks,
    replaceBlocks,
    toggleSelection,
    __unstableMarkLastChangeAsPersistent
  } = dispatch(store); // Do not add new properties here, use `useDispatch` instead to avoid
  // leaking new props to the public API (editor.BlockListBlock filter).

  return {
    setAttributes(newAttributes) {
      const {
        getMultiSelectedBlockClientIds
      } = select(store);
      const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds();
      const {
        clientId
      } = ownProps;
      const clientIds = multiSelectedBlockClientIds.length ? multiSelectedBlockClientIds : [clientId];
      updateBlockAttributes(clientIds, newAttributes);
    },

    onInsertBlocks(blocks, index) {
      const {
        rootClientId
      } = ownProps;
      insertBlocks(blocks, index, rootClientId);
    },

    onInsertBlocksAfter(blocks) {
      const {
        clientId,
        rootClientId
      } = ownProps;
      const {
        getBlockIndex
      } = select(store);
      const index = getBlockIndex(clientId, rootClientId);
      insertBlocks(blocks, index + 1, rootClientId);
    },

    onMerge(forward) {
      const {
        clientId
      } = ownProps;
      const {
        getPreviousBlockClientId,
        getNextBlockClientId
      } = select(store);

      if (forward) {
        const nextBlockClientId = getNextBlockClientId(clientId);

        if (nextBlockClientId) {
          mergeBlocks(clientId, nextBlockClientId);
        }
      } else {
        const previousBlockClientId = getPreviousBlockClientId(clientId);

        if (previousBlockClientId) {
          mergeBlocks(previousBlockClientId, clientId);
        }
      }
    },

    onReplace(blocks, indexToSelect, initialPosition) {
      if (blocks.length && !Object(external_wp_blocks_["isUnmodifiedDefaultBlock"])(blocks[blocks.length - 1])) {
        __unstableMarkLastChangeAsPersistent();
      }

      replaceBlocks([ownProps.clientId], blocks, indexToSelect, initialPosition);
    },

    toggleSelection(selectionEnabled) {
      toggleSelection(selectionEnabled);
    }

  };
});
/* harmony default export */ var block_list_block = (Object(external_wp_compose_["compose"])(external_wp_compose_["pure"], applyWithSelect, applyWithDispatch, // block is sometimes not mounted at the right time, causing it be undefined
// see issue for more info
// https://github.com/WordPress/gutenberg/issues/17013
Object(external_wp_compose_["ifCondition"])(({
  block
}) => !!block), Object(external_wp_components_["withFilters"])('editor.BlockListBlock'))(block_BlockListBlock));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-navigation/utils.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


const getBlockPositionDescription = (position, siblingCount, level) => Object(external_wp_i18n_["sprintf"])(
/* translators: 1: The numerical position of the block. 2: The total number of blocks. 3. The level of nesting for the block. */
Object(external_wp_i18n_["__"])('Block %1$d of %2$d, Level %3$d'), position, siblingCount, level);
/**
 * Returns true if the client ID occurs within the block selection or multi-selection,
 * or false otherwise.
 *
 * @param {string}          clientId               Block client ID.
 * @param {string|string[]} selectedBlockClientIds Selected block client ID, or an array of multi-selected blocks client IDs.
 *
 * @return {boolean} Whether the block is in multi-selection set.
 */

const isClientIdSelected = (clientId, selectedBlockClientIds) => Object(external_lodash_["isArray"])(selectedBlockClientIds) && selectedBlockClientIds.length ? selectedBlockClientIds.indexOf(clientId) !== -1 : selectedBlockClientIds === clientId;

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-navigation/block-select-button.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */






function BlockNavigationBlockSelectButton({
  className,
  block: {
    clientId
  },
  isSelected,
  onClick,
  position,
  siblingBlockCount,
  level,
  tabIndex,
  onFocus,
  onDragStart,
  onDragEnd,
  draggable
}, ref) {
  const blockInformation = useBlockDisplayInformation(clientId);
  const instanceId = Object(external_wp_compose_["useInstanceId"])(BlockNavigationBlockSelectButton);
  const descriptionId = `block-navigation-block-select-button__${instanceId}`;
  const blockPositionDescription = getBlockPositionDescription(position, siblingBlockCount, level);
  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    className: classnames_default()('block-editor-block-navigation-block-select-button', className),
    onClick: onClick,
    "aria-describedby": descriptionId,
    ref: ref,
    tabIndex: tabIndex,
    onFocus: onFocus,
    onDragStart: onDragStart,
    onDragEnd: onDragEnd,
    draggable: draggable
  }, Object(external_wp_element_["createElement"])(BlockIcon, {
    icon: blockInformation === null || blockInformation === void 0 ? void 0 : blockInformation.icon,
    showColors: true
  }), Object(external_wp_element_["createElement"])(BlockTitle, {
    clientId: clientId
  }), (blockInformation === null || blockInformation === void 0 ? void 0 : blockInformation.anchor) && Object(external_wp_element_["createElement"])("span", {
    className: "block-editor-block-navigation-block-select-button__anchor"
  }, blockInformation.anchor), isSelected && Object(external_wp_element_["createElement"])(external_wp_components_["VisuallyHidden"], null, Object(external_wp_i18n_["__"])('(selected block)'))), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-navigation-block-select-button__description",
    id: descriptionId
  }, blockPositionDescription));
}

/* harmony default export */ var block_select_button = (Object(external_wp_element_["forwardRef"])(BlockNavigationBlockSelectButton));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-navigation/block-slot.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */







const getSlotName = clientId => `BlockNavigationBlock-${clientId}`;

function BlockNavigationBlockSlot(props, ref) {
  const {
    clientId
  } = props.block;
  const {
    name
  } = Object(external_wp_data_["useSelect"])(select => select(store).getBlockName(clientId), [clientId]);
  const instanceId = Object(external_wp_compose_["useInstanceId"])(BlockNavigationBlockSlot);
  return Object(external_wp_element_["createElement"])(external_wp_components_["Slot"], {
    name: getSlotName(clientId)
  }, fills => {
    if (!fills.length) {
      return Object(external_wp_element_["createElement"])(block_select_button, Object(esm_extends["a" /* default */])({
        ref: ref
      }, props));
    }

    const {
      className,
      isSelected,
      position,
      siblingBlockCount,
      level,
      tabIndex,
      onFocus
    } = props;
    const blockType = Object(external_wp_blocks_["getBlockType"])(name);
    const descriptionId = `block-navigation-block-slot__${instanceId}`;
    const blockPositionDescription = getBlockPositionDescription(position, siblingBlockCount, level);
    const forwardedFillProps = {
      // Ensure that the component in the slot can receive
      // keyboard navigation.
      tabIndex,
      onFocus,
      ref,
      // Give the element rendered in the slot a description
      // that describes its position.
      'aria-describedby': descriptionId
    };
    return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])("div", {
      className: classnames_default()('block-editor-block-navigation-block-slot', className)
    }, Object(external_wp_element_["createElement"])(BlockIcon, {
      icon: blockType.icon,
      showColors: true
    }), external_wp_element_["Children"].map(fills, fill => Object(external_wp_element_["cloneElement"])(fill, { ...fill.props,
      ...forwardedFillProps
    })), isSelected && Object(external_wp_element_["createElement"])(external_wp_components_["VisuallyHidden"], null, Object(external_wp_i18n_["__"])('(selected block)')), Object(external_wp_element_["createElement"])("div", {
      className: "block-editor-block-navigation-block-slot__description",
      id: descriptionId
    }, blockPositionDescription)));
  });
}

/* harmony default export */ var block_slot = (Object(external_wp_element_["forwardRef"])(BlockNavigationBlockSlot));
const BlockNavigationBlockFill = props => {
  const {
    clientId
  } = Object(external_wp_element_["useContext"])(BlockListBlockContext);
  return Object(external_wp_element_["createElement"])(external_wp_components_["Fill"], Object(esm_extends["a" /* default */])({}, props, {
    name: getSlotName(clientId)
  }));
};

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-navigation/block-contents.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */






const BlockNavigationBlockContents = Object(external_wp_element_["forwardRef"])(({
  onClick,
  block,
  isSelected,
  position,
  siblingBlockCount,
  level,
  ...props
}, ref) => {
  const {
    __experimentalFeatures,
    blockDropTarget = {}
  } = useBlockNavigationContext();
  const {
    clientId
  } = block;
  const {
    rootClientId,
    blockMovingClientId,
    selectedBlockInBlockEditor
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getBlockRootClientId,
      hasBlockMovingClientId,
      getSelectedBlockClientId
    } = select(store);
    return {
      rootClientId: getBlockRootClientId(clientId) || '',
      blockMovingClientId: hasBlockMovingClientId(),
      selectedBlockInBlockEditor: getSelectedBlockClientId()
    };
  }, [clientId]);
  const isBlockMoveTarget = blockMovingClientId && selectedBlockInBlockEditor === clientId;
  const {
    rootClientId: dropTargetRootClientId,
    clientId: dropTargetClientId,
    dropPosition
  } = blockDropTarget;
  const isDroppingBefore = dropTargetRootClientId === rootClientId && dropTargetClientId === clientId && dropPosition === 'top';
  const isDroppingAfter = dropTargetRootClientId === rootClientId && dropTargetClientId === clientId && dropPosition === 'bottom';
  const isDroppingToInnerBlocks = dropTargetRootClientId === clientId && dropPosition === 'inside';
  const className = classnames_default()('block-editor-block-navigation-block-contents', {
    'is-dropping-before': isDroppingBefore || isBlockMoveTarget,
    'is-dropping-after': isDroppingAfter,
    'is-dropping-to-inner-blocks': isDroppingToInnerBlocks
  });
  return Object(external_wp_element_["createElement"])(block_draggable, {
    clientIds: [block.clientId],
    elementId: `block-navigation-block-${block.clientId}`
  }, ({
    draggable,
    onDragStart,
    onDragEnd
  }) => __experimentalFeatures ? Object(external_wp_element_["createElement"])(block_slot, Object(esm_extends["a" /* default */])({
    ref: ref,
    className: className,
    block: block,
    onClick: onClick,
    isSelected: isSelected,
    position: position,
    siblingBlockCount: siblingBlockCount,
    level: level,
    draggable: draggable && __experimentalFeatures,
    onDragStart: onDragStart,
    onDragEnd: onDragEnd
  }, props)) : Object(external_wp_element_["createElement"])(block_select_button, Object(esm_extends["a" /* default */])({
    ref: ref,
    className: className,
    block: block,
    onClick: onClick,
    isSelected: isSelected,
    position: position,
    siblingBlockCount: siblingBlockCount,
    level: level,
    draggable: draggable && __experimentalFeatures,
    onDragStart: onDragStart,
    onDragEnd: onDragEnd
  }, props)));
});
/* harmony default export */ var block_contents = (BlockNavigationBlockContents);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-navigation/block.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */







function BlockNavigationBlock({
  block,
  isSelected,
  isBranchSelected,
  isLastOfSelectedBranch,
  onClick,
  position,
  level,
  rowCount,
  siblingBlockCount,
  showBlockMovers,
  path
}) {
  const cellRef = Object(external_wp_element_["useRef"])(null);
  const [isHovered, setIsHovered] = Object(external_wp_element_["useState"])(false);
  const {
    clientId
  } = block;
  const {
    isDragging,
    blockParents
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      isBlockBeingDragged,
      isAncestorBeingDragged,
      getBlockParents
    } = select(store);
    return {
      isDragging: isBlockBeingDragged(clientId) || isAncestorBeingDragged(clientId),
      blockParents: getBlockParents(clientId)
    };
  }, [clientId]);
  const {
    selectBlock: selectEditorBlock,
    toggleBlockHighlight
  } = Object(external_wp_data_["useDispatch"])(store);
  const hasSiblings = siblingBlockCount > 0;
  const hasRenderedMovers = showBlockMovers && hasSiblings;
  const moverCellClassName = classnames_default()('block-editor-block-navigation-block__mover-cell', {
    'is-visible': isHovered
  });
  const {
    __experimentalFeatures: withExperimentalFeatures,
    __experimentalPersistentListViewFeatures: withExperimentalPersistentListViewFeatures,
    isTreeGridMounted
  } = useBlockNavigationContext();
  const blockNavigationBlockSettingsClassName = classnames_default()('block-editor-block-navigation-block__menu-cell', {
    'is-visible': isHovered
  }); // If BlockNavigation has experimental features related to the Persistent List View,
  // only focus the selected list item on mount; otherwise the list would always
  // try to steal the focus from the editor canvas.

  Object(external_wp_element_["useEffect"])(() => {
    if (withExperimentalPersistentListViewFeatures && !isTreeGridMounted && isSelected) {
      cellRef.current.focus();
    }
  }, []); // If BlockNavigation has experimental features (such as drag and drop) enabled,
  // leave the focus handling as it was before, to avoid accidental regressions.

  Object(external_wp_element_["useEffect"])(() => {
    if (withExperimentalFeatures && isSelected) {
      cellRef.current.focus();
    }
  }, [withExperimentalFeatures, isSelected]);
  const highlightBlock = withExperimentalPersistentListViewFeatures ? toggleBlockHighlight : () => {};

  const onMouseEnter = () => {
    setIsHovered(true);
    highlightBlock(clientId, true);
  };

  const onMouseLeave = () => {
    setIsHovered(false);
    highlightBlock(clientId, false);
  };

  const classes = classnames_default()({
    'is-selected': isSelected,
    'is-branch-selected': withExperimentalPersistentListViewFeatures && isBranchSelected,
    'is-last-of-selected-branch': withExperimentalPersistentListViewFeatures && isLastOfSelectedBranch,
    'is-dragging': isDragging
  });
  return Object(external_wp_element_["createElement"])(BlockNavigationLeaf, {
    className: classes,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    onFocus: onMouseEnter,
    onBlur: onMouseLeave,
    level: level,
    position: position,
    rowCount: rowCount,
    path: path,
    id: `block-navigation-block-${clientId}`,
    "data-block": clientId
  }, Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalTreeGridCell"], {
    className: "block-editor-block-navigation-block__contents-cell",
    colSpan: hasRenderedMovers ? undefined : 2,
    ref: cellRef
  }, ({
    ref,
    tabIndex,
    onFocus
  }) => Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-navigation-block__contents-container"
  }, Object(external_wp_element_["createElement"])(block_contents, {
    block: block,
    onClick: () => onClick(block.clientId),
    isSelected: isSelected,
    position: position,
    siblingBlockCount: siblingBlockCount,
    level: level,
    ref: ref,
    tabIndex: tabIndex,
    onFocus: onFocus
  }))), hasRenderedMovers && Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalTreeGridCell"], {
    className: moverCellClassName,
    withoutGridItem: true
  }, Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalTreeGridItem"], null, ({
    ref,
    tabIndex,
    onFocus
  }) => Object(external_wp_element_["createElement"])(BlockMoverUpButton, {
    orientation: "vertical",
    clientIds: [clientId],
    ref: ref,
    tabIndex: tabIndex,
    onFocus: onFocus
  })), Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalTreeGridItem"], null, ({
    ref,
    tabIndex,
    onFocus
  }) => Object(external_wp_element_["createElement"])(BlockMoverDownButton, {
    orientation: "vertical",
    clientIds: [clientId],
    ref: ref,
    tabIndex: tabIndex,
    onFocus: onFocus
  })))), withExperimentalFeatures && Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalTreeGridCell"], {
    className: blockNavigationBlockSettingsClassName
  }, ({
    ref,
    tabIndex,
    onFocus
  }) => Object(external_wp_element_["createElement"])(block_settings_dropdown, {
    clientIds: [clientId],
    icon: more_vertical["a" /* default */],
    toggleProps: {
      ref,
      tabIndex,
      onFocus
    },
    disableOpenOnArrowDown: true,
    __experimentalSelectBlock: onClick
  }, ({
    onClose
  }) => Object(external_wp_element_["createElement"])(external_wp_components_["MenuGroup"], null, Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
    onClick: async () => {
      if (blockParents.length) {
        // If the block to select is inside a dropdown, we need to open the dropdown.
        // Otherwise focus won't transfer to the block.
        for (const parent of blockParents) {
          await selectEditorBlock(parent);
        }
      } else {
        // If clientId is already selected, it won't be focused (see block-wrapper.js)
        // This removes the selection first to ensure the focus will always switch.
        await selectEditorBlock(null);
      }

      await selectEditorBlock(clientId);
      onClose();
    }
  }, Object(external_wp_i18n_["__"])('Go to block'))))));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-navigation/appender.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




function BlockNavigationAppender({
  parentBlockClientId,
  position,
  level,
  rowCount,
  path
}) {
  const isDragging = Object(external_wp_data_["useSelect"])(select => {
    const {
      isBlockBeingDragged,
      isAncestorBeingDragged
    } = select(store);
    return isBlockBeingDragged(parentBlockClientId) || isAncestorBeingDragged(parentBlockClientId);
  }, [parentBlockClientId]);
  const instanceId = Object(external_wp_compose_["useInstanceId"])(BlockNavigationAppender);
  const descriptionId = `block-navigation-appender-row__description_${instanceId}`;
  const appenderPositionDescription = Object(external_wp_i18n_["sprintf"])(
  /* translators: 1: The numerical position of the block that will be inserted. 2: The level of nesting for the block that will be inserted. */
  Object(external_wp_i18n_["__"])('Add block at position %1$d, Level %2$d'), position, level);
  return Object(external_wp_element_["createElement"])(BlockNavigationLeaf, {
    className: classnames_default()({
      'is-dragging': isDragging
    }),
    level: level,
    position: position,
    rowCount: rowCount,
    path: path
  }, Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalTreeGridCell"], {
    className: "block-editor-block-navigation-appender__cell",
    colSpan: "3"
  }, ({
    ref,
    tabIndex,
    onFocus
  }) => Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-navigation-appender__container"
  }, Object(external_wp_element_["createElement"])(inserter, {
    rootClientId: parentBlockClientId,
    __experimentalIsQuick: true,
    "aria-describedby": descriptionId,
    toggleProps: {
      ref,
      tabIndex,
      onFocus
    }
  }), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-navigation-appender__description",
    id: descriptionId
  }, appenderPositionDescription))));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-navigation/branch.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function BlockNavigationBranch(props) {
  const {
    blocks,
    selectBlock,
    selectedBlockClientIds,
    showAppender,
    showBlockMovers,
    showNestedBlocks,
    parentBlockClientId,
    level = 1,
    terminatedLevels = [],
    path = [],
    isBranchSelected = false,
    isLastOfBranch = false
  } = props;
  const isTreeRoot = !parentBlockClientId;
  const filteredBlocks = Object(external_lodash_["compact"])(blocks);

  const itemHasAppender = parentClientId => showAppender && !isTreeRoot && isClientIdSelected(parentClientId, selectedBlockClientIds);

  const hasAppender = itemHasAppender(parentBlockClientId); // Add +1 to the rowCount to take the block appender into account.

  const blockCount = filteredBlocks.length;
  const rowCount = hasAppender ? blockCount + 1 : blockCount;
  const appenderPosition = rowCount;
  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_lodash_["map"])(filteredBlocks, (block, index) => {
    const {
      clientId,
      innerBlocks
    } = block;
    const position = index + 1;
    const isLastRowAtLevel = rowCount === position;
    const updatedTerminatedLevels = isLastRowAtLevel ? [...terminatedLevels, level] : terminatedLevels;
    const updatedPath = [...path, position];
    const hasNestedBlocks = showNestedBlocks && !!innerBlocks && !!innerBlocks.length;
    const hasNestedAppender = itemHasAppender(clientId);
    const hasNestedBranch = hasNestedBlocks || hasNestedAppender;
    const isSelected = isClientIdSelected(clientId, selectedBlockClientIds);
    const isSelectedBranch = isBranchSelected || isSelected && hasNestedBranch; // Logic needed to target the last item of a selected branch which might be deeply nested.
    // This is currently only needed for styling purposes. See: `.is-last-of-selected-branch`.

    const isLastBlock = index === blockCount - 1;
    const isLast = isSelected || isLastOfBranch && isLastBlock;
    const isLastOfSelectedBranch = isLastOfBranch && !hasNestedBranch && isLastBlock;
    return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], {
      key: clientId
    }, Object(external_wp_element_["createElement"])(BlockNavigationBlock, {
      block: block,
      onClick: selectBlock,
      isSelected: isSelected,
      isBranchSelected: isSelectedBranch,
      isLastOfSelectedBranch: isLastOfSelectedBranch,
      level: level,
      position: position,
      rowCount: rowCount,
      siblingBlockCount: blockCount,
      showBlockMovers: showBlockMovers,
      terminatedLevels: terminatedLevels,
      path: updatedPath
    }), hasNestedBranch && Object(external_wp_element_["createElement"])(BlockNavigationBranch, {
      blocks: innerBlocks,
      selectedBlockClientIds: selectedBlockClientIds,
      selectBlock: selectBlock,
      isBranchSelected: isSelectedBranch,
      isLastOfBranch: isLast,
      showAppender: showAppender,
      showBlockMovers: showBlockMovers,
      showNestedBlocks: showNestedBlocks,
      parentBlockClientId: clientId,
      level: level + 1,
      terminatedLevels: updatedTerminatedLevels,
      path: updatedPath
    }));
  }), hasAppender && Object(external_wp_element_["createElement"])(BlockNavigationAppender, {
    parentBlockClientId: parentBlockClientId,
    position: rowCount,
    rowCount: appenderPosition,
    level: level,
    terminatedLevels: terminatedLevels,
    path: [...path, appenderPosition]
  }));
}
BlockNavigationBranch.defaultProps = {
  selectBlock: () => {}
};

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-navigation/use-block-navigation-client-ids.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




const useBlockNavigationSelectedClientIds = __experimentalPersistentListViewFeatures => Object(external_wp_data_["useSelect"])(select => {
  const {
    getSelectedBlockClientId,
    getSelectedBlockClientIds
  } = select(store);

  if (__experimentalPersistentListViewFeatures) {
    return getSelectedBlockClientIds();
  }

  return getSelectedBlockClientId();
}, [__experimentalPersistentListViewFeatures]);

const useBlockNavigationClientIdsTree = (blocks, selectedClientIds, showOnlyCurrentHierarchy) => Object(external_wp_data_["useSelect"])(select => {
  const {
    getBlockHierarchyRootClientId,
    __unstableGetClientIdsTree,
    __unstableGetClientIdWithClientIdsTree
  } = select(store);

  if (blocks) {
    return blocks;
  }

  const isSingleBlockSelected = selectedClientIds && !Array.isArray(selectedClientIds);

  if (!showOnlyCurrentHierarchy || !isSingleBlockSelected) {
    return __unstableGetClientIdsTree();
  }

  const rootBlock = __unstableGetClientIdWithClientIdsTree(getBlockHierarchyRootClientId(selectedClientIds));

  if (!rootBlock) {
    return __unstableGetClientIdsTree();
  }

  const hasHierarchy = !isClientIdSelected(rootBlock.clientId, selectedClientIds) || rootBlock.innerBlocks && rootBlock.innerBlocks.length !== 0;

  if (hasHierarchy) {
    return [rootBlock];
  }

  return __unstableGetClientIdsTree();
}, [blocks, selectedClientIds, showOnlyCurrentHierarchy]);

function useBlockNavigationClientIds(blocks, showOnlyCurrentHierarchy, __experimentalPersistentListViewFeatures) {
  const selectedClientIds = useBlockNavigationSelectedClientIds(__experimentalPersistentListViewFeatures);
  const clientIdsTree = useBlockNavigationClientIdsTree(blocks, selectedClientIds, showOnlyCurrentHierarchy);
  return {
    clientIdsTree,
    selectedClientIds
  };
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-navigation/use-block-navigation-drop-zone.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




/** @typedef {import('../../utils/math').WPPoint} WPPoint */

/**
 * The type of a drag event.
 *
 * @typedef {'default'|'file'|'html'} WPDragEventType
 */

/**
 * An array representing data for blocks in the DOM used by drag and drop.
 *
 * @typedef {Object} WPBlockNavigationDropZoneBlocks
 * @property {string}  clientId                        The client id for the block.
 * @property {string}  rootClientId                    The root client id for the block.
 * @property {number}  blockIndex                      The block's index.
 * @property {Element} element                         The DOM element representing the block.
 * @property {number}  innerBlockCount                 The number of inner blocks the block has.
 * @property {boolean} isDraggedBlock                  Whether the block is currently being dragged.
 * @property {boolean} canInsertDraggedBlocksAsSibling Whether the dragged block can be a sibling of this block.
 * @property {boolean} canInsertDraggedBlocksAsChild   Whether the dragged block can be a child of this block.
 */

/**
 * An object containing details of a drop target.
 *
 * @typedef {Object} WPBlockNavigationDropZoneTarget
 * @property {string}                   blockIndex   The insertion index.
 * @property {string}                   rootClientId The root client id for the block.
 * @property {string|undefined}         clientId     The client id for the block.
 * @property {'top'|'bottom'|'inside'}  dropPosition The position relative to the block that the user is dropping to.
 *                                                   'inside' refers to nesting as an inner block.
 */

/**
 * Is the point contained by the rectangle.
 *
 * @param {WPPoint} point The point.
 * @param {DOMRect} rect  The rectangle.
 *
 * @return {boolean} True if the point is contained by the rectangle, false otherwise.
 */

function isPointContainedByRect(point, rect) {
  return rect.left <= point.x && rect.right >= point.x && rect.top <= point.y && rect.bottom >= point.y;
}
/**
 * Determines whether the user positioning the dragged block to nest as an
 * inner block.
 *
 * Presently this is determined by whether the cursor is on the right hand side
 * of the block.
 *
 * @param {WPPoint} point The point representing the cursor position when dragging.
 * @param {DOMRect} rect  The rectangle.
 */


function isNestingGesture(point, rect) {
  const blockCenterX = rect.left + rect.width / 2;
  return point.x > blockCenterX;
} // Block navigation is always a vertical list, so only allow dropping
// to the above or below a block.


const ALLOWED_DROP_EDGES = ['top', 'bottom'];
/**
 * Given blocks data and the cursor position, compute the drop target.
 *
 * @param {WPBlockNavigationDropZoneBlocks} blocksData Data about the blocks in block navigation.
 * @param {WPPoint} position The point representing the cursor position when dragging.
 *
 * @return {WPBlockNavigationDropZoneTarget} An object containing data about the drop target.
 */

function getBlockNavigationDropTarget(blocksData, position) {
  let candidateEdge;
  let candidateBlockData;
  let candidateDistance;
  let candidateRect;

  for (const blockData of blocksData) {
    if (blockData.isDraggedBlock) {
      continue;
    }

    const rect = blockData.element.getBoundingClientRect();
    const [distance, edge] = getDistanceToNearestEdge(position, rect, ALLOWED_DROP_EDGES);
    const isCursorWithinBlock = isPointContainedByRect(position, rect);

    if (candidateDistance === undefined || distance < candidateDistance || isCursorWithinBlock) {
      candidateDistance = distance;
      const index = blocksData.indexOf(blockData);
      const previousBlockData = blocksData[index - 1]; // If dragging near the top of a block and the preceding block
      // is at the same level, use the preceding block as the candidate
      // instead, as later it makes determining a nesting drop easier.

      if (edge === 'top' && previousBlockData && previousBlockData.rootClientId === blockData.rootClientId && !previousBlockData.isDraggedBlock) {
        candidateBlockData = previousBlockData;
        candidateEdge = 'bottom';
        candidateRect = previousBlockData.element.getBoundingClientRect();
      } else {
        candidateBlockData = blockData;
        candidateEdge = edge;
        candidateRect = rect;
      } // If the mouse position is within the block, break early
      // as the user would intend to drop either before or after
      // this block.
      //
      // This solves an issue where some rows in the block navigation
      // tree overlap slightly due to sub-pixel rendering.


      if (isCursorWithinBlock) {
        break;
      }
    }
  }

  if (!candidateBlockData) {
    return;
  }

  const isDraggingBelow = candidateEdge === 'bottom'; // If the user is dragging towards the bottom of the block check whether
  // they might be trying to nest the block as a child.
  // If the block already has inner blocks, this should always be treated
  // as nesting since the next block in the tree will be the first child.

  if (isDraggingBelow && candidateBlockData.canInsertDraggedBlocksAsChild && (candidateBlockData.innerBlockCount > 0 || isNestingGesture(position, candidateRect))) {
    return {
      rootClientId: candidateBlockData.clientId,
      blockIndex: 0,
      dropPosition: 'inside'
    };
  } // If dropping as a sibling, but block cannot be inserted in
  // this context, return early.


  if (!candidateBlockData.canInsertDraggedBlocksAsSibling) {
    return;
  }

  const offset = isDraggingBelow ? 1 : 0;
  return {
    rootClientId: candidateBlockData.rootClientId,
    clientId: candidateBlockData.clientId,
    blockIndex: candidateBlockData.blockIndex + offset,
    dropPosition: candidateEdge
  };
}
/**
 * A react hook for implementing a drop zone in block navigation.
 *
 * @return {WPBlockNavigationDropZoneTarget} The drop target.
 */


function useBlockNavigationDropZone() {
  const {
    getBlockRootClientId,
    getBlockIndex,
    getBlockCount,
    getDraggedBlockClientIds,
    canInsertBlocks
  } = Object(external_wp_data_["useSelect"])(store);
  const [target, setTarget] = Object(external_wp_element_["useState"])();
  const {
    rootClientId: targetRootClientId,
    blockIndex: targetBlockIndex
  } = target || {};
  const onBlockDrop = useOnBlockDrop(targetRootClientId, targetBlockIndex);
  const throttled = Object(external_wp_compose_["useThrottle"])(Object(external_wp_element_["useCallback"])((event, currentTarget) => {
    const position = {
      x: event.clientX,
      y: event.clientY
    };
    const isBlockDrag = !!event.dataTransfer.getData('wp-blocks');
    const draggedBlockClientIds = isBlockDrag ? getDraggedBlockClientIds() : undefined;
    const blockElements = Array.from(currentTarget.querySelectorAll('[data-block]'));
    const blocksData = blockElements.map(blockElement => {
      const clientId = blockElement.dataset.block;
      const rootClientId = getBlockRootClientId(clientId);
      return {
        clientId,
        rootClientId,
        blockIndex: getBlockIndex(clientId, rootClientId),
        element: blockElement,
        isDraggedBlock: isBlockDrag ? draggedBlockClientIds.includes(clientId) : false,
        innerBlockCount: getBlockCount(clientId),
        canInsertDraggedBlocksAsSibling: isBlockDrag ? canInsertBlocks(draggedBlockClientIds, rootClientId) : true,
        canInsertDraggedBlocksAsChild: isBlockDrag ? canInsertBlocks(draggedBlockClientIds, clientId) : true
      };
    });
    const newTarget = getBlockNavigationDropTarget(blocksData, position);

    if (newTarget) {
      setTarget(newTarget);
    }
  }, []), 200);
  const ref = Object(external_wp_compose_["__experimentalUseDropZone"])({
    onDrop: onBlockDrop,

    onDragOver(event) {
      // `currentTarget` is only available while the event is being
      // handled, so get it now and pass it to the thottled function.
      // https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget
      throttled(event, event.currentTarget);
    },

    onDragEnd() {
      throttled.cancel();
      setTarget(null);
    }

  });
  return {
    ref,
    target
  };
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-navigation/tree.js



/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */







const noop = () => {};
/**
 * Wrap `BlockNavigationRows` with `TreeGrid`. BlockNavigationRows is a
 * recursive component (it renders itself), so this ensures TreeGrid is only
 * present at the very top of the navigation grid.
 *
 * @param {Object}   props                                          Components props.
 * @param {Array}    props.blocks                                   Custom subset of block client IDs to be used instead of the default hierarchy.
 * @param {Function} props.onSelect                                 Block selection callback.
 * @param {boolean}  props.showNestedBlocks                         Flag to enable displaying nested blocks.
 * @param {boolean}  props.showOnlyCurrentHierarchy                 Flag to limit the list to the current hierarchy of blocks.
 * @param {boolean}  props.__experimentalFeatures                   Flag to enable experimental features.
 * @param {boolean}  props.__experimentalPersistentListViewFeatures Flag to enable features for the Persistent List View experiment.
 */


function BlockNavigationTree({
  blocks,
  showOnlyCurrentHierarchy,
  onSelect = noop,
  __experimentalFeatures,
  __experimentalPersistentListViewFeatures,
  ...props
}) {
  const {
    clientIdsTree,
    selectedClientIds
  } = useBlockNavigationClientIds(blocks, showOnlyCurrentHierarchy, __experimentalPersistentListViewFeatures);
  const {
    selectBlock
  } = Object(external_wp_data_["useDispatch"])(store);
  const selectEditorBlock = Object(external_wp_element_["useCallback"])(clientId => {
    selectBlock(clientId);
    onSelect(clientId);
  }, [selectBlock, onSelect]);
  let {
    ref: treeGridRef,
    target: blockDropTarget
  } = useBlockNavigationDropZone();
  const isMounted = Object(external_wp_element_["useRef"])(false);
  Object(external_wp_element_["useEffect"])(() => {
    isMounted.current = true;
  }, []);

  if (!__experimentalFeatures) {
    blockDropTarget = undefined;
  }

  const contextValue = Object(external_wp_element_["useMemo"])(() => ({
    __experimentalFeatures,
    __experimentalPersistentListViewFeatures,
    blockDropTarget,
    isTreeGridMounted: isMounted.current
  }), [__experimentalFeatures, __experimentalPersistentListViewFeatures, blockDropTarget, isMounted.current]);
  return Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalTreeGrid"], {
    className: "block-editor-block-navigation-tree",
    "aria-label": Object(external_wp_i18n_["__"])('Block navigation structure'),
    ref: treeGridRef
  }, Object(external_wp_element_["createElement"])(BlockNavigationContext.Provider, {
    value: contextValue
  }, Object(external_wp_element_["createElement"])(BlockNavigationBranch, Object(esm_extends["a" /* default */])({
    blocks: clientIdsTree,
    selectBlock: selectEditorBlock,
    selectedBlockClientIds: selectedClientIds
  }, props))));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-navigation/dropdown.js



/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




function BlockNavigationDropdownToggle({
  isEnabled,
  onToggle,
  isOpen,
  innerRef,
  ...props
}) {
  return Object(external_wp_element_["createElement"])(external_wp_components_["Button"], Object(esm_extends["a" /* default */])({}, props, {
    ref: innerRef,
    icon: list_view["a" /* default */],
    "aria-expanded": isOpen,
    "aria-haspopup": "true",
    onClick: isEnabled ? onToggle : undefined
    /* translators: button label text should, if possible, be under 16 characters. */
    ,
    label: Object(external_wp_i18n_["__"])('List view'),
    className: "block-editor-block-navigation",
    "aria-disabled": !isEnabled
  }));
}

function BlockNavigationDropdown({
  isDisabled,
  __experimentalFeatures,
  ...props
}, ref) {
  const hasBlocks = Object(external_wp_data_["useSelect"])(select => !!select(store).getBlockCount(), []);
  const isEnabled = hasBlocks && !isDisabled;
  return Object(external_wp_element_["createElement"])(external_wp_components_["Dropdown"], {
    contentClassName: "block-editor-block-navigation__popover",
    position: "bottom right",
    renderToggle: ({
      isOpen,
      onToggle
    }) => Object(external_wp_element_["createElement"])(BlockNavigationDropdownToggle, Object(esm_extends["a" /* default */])({}, props, {
      innerRef: ref,
      isOpen: isOpen,
      onToggle: onToggle,
      isEnabled: isEnabled
    })),
    renderContent: () => Object(external_wp_element_["createElement"])("div", {
      className: "block-editor-block-navigation__container"
    }, Object(external_wp_element_["createElement"])("p", {
      className: "block-editor-block-navigation__label"
    }, Object(external_wp_i18n_["__"])('List view')), Object(external_wp_element_["createElement"])(BlockNavigationTree, {
      showNestedBlocks: true,
      showOnlyCurrentHierarchy: true,
      __experimentalFeatures: __experimentalFeatures
    }))
  });
}

/* harmony default export */ var dropdown = (Object(external_wp_element_["forwardRef"])(BlockNavigationDropdown));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/remove-browser-shortcuts.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Set of keyboard shortcuts handled internally by RichText.
 *
 * @type {Array}
 */

const HANDLED_SHORTCUTS = [external_wp_keycodes_["rawShortcut"].primary('z'), external_wp_keycodes_["rawShortcut"].primaryShift('z'), external_wp_keycodes_["rawShortcut"].primary('y')];
/**
 * An instance of a KeyboardShortcuts element pre-bound for the handled
 * shortcuts. Since shortcuts never change, the element can be considered
 * static, and can be skipped in reconciliation.
 *
 * @type {WPElement}
 */

const SHORTCUTS_ELEMENT = Object(external_wp_element_["createElement"])(external_wp_components_["KeyboardShortcuts"], {
  bindGlobal: true,
  shortcuts: Object(external_lodash_["fromPairs"])(HANDLED_SHORTCUTS.map(shortcut => {
    return [shortcut, event => event.preventDefault()];
  }))
});
/**
 * Component which registered keyboard event handlers to prevent default
 * behaviors for key combinations otherwise handled internally by RichText.
 *
 * @return {WPComponent} The component to be rendered.
 */

const RemoveBrowserShortcuts = () => SHORTCUTS_ELEMENT;

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/format-toolbar/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




const format_toolbar_POPOVER_PROPS = {
  position: 'bottom right',
  isAlternate: true
};

const FormatToolbar = () => {
  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, ['bold', 'italic', 'link', 'text-color'].map(format => Object(external_wp_element_["createElement"])(external_wp_components_["Slot"], {
    name: `RichText.ToolbarControls.${format}`,
    key: format
  })), Object(external_wp_element_["createElement"])(external_wp_components_["Slot"], {
    name: "RichText.ToolbarControls"
  }, fills => fills.length !== 0 && Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarItem"], null, toggleProps => Object(external_wp_element_["createElement"])(external_wp_components_["DropdownMenu"], {
    icon: chevron_down["a" /* default */]
    /* translators: button label text should, if possible, be under 16 characters. */
    ,
    label: Object(external_wp_i18n_["__"])('More'),
    toggleProps: toggleProps,
    controls: Object(external_lodash_["orderBy"])(fills.map(([{
      props
    }]) => props), 'title'),
    popoverProps: format_toolbar_POPOVER_PROPS
  }))));
};

/* harmony default export */ var format_toolbar = (FormatToolbar);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/format-toolbar-container.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




const FormatToolbarContainer = ({
  inline,
  anchorRef
}) => {
  if (inline) {
    // Render in popover
    return Object(external_wp_element_["createElement"])(external_wp_components_["Popover"], {
      noArrow: true,
      position: "top center",
      focusOnMount: false,
      anchorRef: anchorRef,
      className: "block-editor-rich-text__inline-format-toolbar",
      __unstableSlotName: "block-toolbar"
    }, Object(external_wp_element_["createElement"])("div", {
      className: "block-editor-rich-text__inline-format-toolbar-group"
    }, Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarGroup"], null, Object(external_wp_element_["createElement"])(format_toolbar, null))));
  } // Render regular toolbar


  return Object(external_wp_element_["createElement"])(block_controls, {
    group: "inline"
  }, Object(external_wp_element_["createElement"])(format_toolbar, null));
};

/* harmony default export */ var format_toolbar_container = (FormatToolbarContainer);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-undo-automatic-change.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


function useUndoAutomaticChange() {
  const {
    didAutomaticChange,
    getSettings
  } = Object(external_wp_data_["useSelect"])(store);
  return Object(external_wp_compose_["useRefEffect"])(element => {
    function onKeyDown(event) {
      const {
        keyCode
      } = event;

      if (keyCode !== external_wp_keycodes_["DELETE"] && keyCode !== external_wp_keycodes_["BACKSPACE"] && keyCode !== external_wp_keycodes_["ESCAPE"]) {
        return;
      }

      if (!didAutomaticChange()) {
        return;
      }

      event.preventDefault();

      getSettings().__experimentalUndo();
    }

    element.addEventListener('keydown', onKeyDown);
    return () => {
      element.removeEventListener('keydown', onKeyDown);
    };
  }, []);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-caret-in-format.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function useCaretInFormat({
  value
}) {
  const hasActiveFormats = value.activeFormats && !!value.activeFormats.length;
  const {
    isCaretWithinFormattedText
  } = Object(external_wp_data_["useSelect"])(store);
  const {
    enterFormattedText,
    exitFormattedText
  } = Object(external_wp_data_["useDispatch"])(store);
  Object(external_wp_element_["useEffect"])(() => {
    if (hasActiveFormats) {
      if (!isCaretWithinFormattedText()) {
        enterFormattedText();
      }
    } else if (isCaretWithinFormattedText()) {
      exitFormattedText();
    }
  }, [hasActiveFormats]);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-mark-persistent.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function useMarkPersistent({
  html,
  value
}) {
  const previousText = Object(external_wp_element_["useRef"])();
  const hasActiveFormats = value.activeFormats && !!value.activeFormats.length;
  const {
    __unstableMarkLastChangeAsPersistent
  } = Object(external_wp_data_["useDispatch"])(store); // Must be set synchronously to make sure it applies to the last change.

  Object(external_wp_element_["useLayoutEffect"])(() => {
    // Ignore mount.
    if (!previousText.current) {
      previousText.current = value.text;
      return;
    } // Text input, so don't create an undo level for every character.
    // Create an undo level after 1 second of no input.


    if (previousText.current !== value.text) {
      const timeout = window.setTimeout(() => {
        __unstableMarkLastChangeAsPersistent();
      }, 1000);
      previousText.current = value.text;
      return () => {
        window.clearTimeout(timeout);
      };
    }

    __unstableMarkLastChangeAsPersistent();
  }, [html, hasActiveFormats]);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/file-paste-handler.js
/**
 * WordPress dependencies
 */

function filePasteHandler(files) {
  return files.filter(({
    type
  }) => /^image\/(?:jpe?g|png|gif)$/.test(type)).map(file => `<img src="${Object(external_wp_blob_["createBlobURL"])(file)}">`).join('');
}

// EXTERNAL MODULE: external ["wp","shortcode"]
var external_wp_shortcode_ = __webpack_require__("SVSp");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/utils.js
/**
 * WordPress dependencies
 */


function addActiveFormats(value, activeFormats) {
  if (activeFormats !== null && activeFormats !== void 0 && activeFormats.length) {
    let index = value.formats.length;

    while (index--) {
      value.formats[index] = [...activeFormats, ...(value.formats[index] || [])];
    }
  }
}
/**
 * Get the multiline tag based on the multiline prop.
 *
 * @param {?(string|boolean)} multiline The multiline prop.
 *
 * @return {?string} The multiline tag.
 */

function getMultilineTag(multiline) {
  if (multiline !== true && multiline !== 'p' && multiline !== 'li') {
    return;
  }

  return multiline === true ? 'p' : multiline;
}
function getAllowedFormats({
  allowedFormats,
  formattingControls,
  disableFormats
}) {
  if (disableFormats) {
    return getAllowedFormats.EMPTY_ARRAY;
  }

  if (!allowedFormats && !formattingControls) {
    return;
  }

  if (allowedFormats) {
    return allowedFormats;
  }

  external_wp_deprecated_default()('wp.blockEditor.RichText formattingControls prop', {
    since: '5.4',
    alternative: 'allowedFormats'
  });
  return formattingControls.map(name => `core/${name}`);
}
getAllowedFormats.EMPTY_ARRAY = [];
const isShortcode = text => Object(external_wp_shortcode_["regexp"])('.*').test(text);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/split-value.js
/**
 * WordPress dependencies
 */

/*
 * Signals to the RichText owner that the block can be replaced with two blocks
 * as a result of splitting the block by pressing enter, or with blocks as a
 * result of splitting the block by pasting block content in the instance.
 */

function splitValue({
  value,
  pastedBlocks = [],
  onReplace,
  onSplit,
  onSplitMiddle,
  multilineTag
}) {
  if (!onReplace || !onSplit) {
    return;
  }

  const blocks = [];
  const [before, after] = Object(external_wp_richText_["split"])(value);
  const hasPastedBlocks = pastedBlocks.length > 0;
  let lastPastedBlockIndex = -1; // Consider the after value to be the original it is not empty and the
  // before value *is* empty.

  const isAfterOriginal = Object(external_wp_richText_["isEmpty"])(before) && !Object(external_wp_richText_["isEmpty"])(after); // Create a block with the content before the caret if there's no pasted
  // blocks, or if there are pasted blocks and the value is not empty. We do
  // not want a leading empty block on paste, but we do if split with e.g. the
  // enter key.

  if (!hasPastedBlocks || !Object(external_wp_richText_["isEmpty"])(before)) {
    blocks.push(onSplit(Object(external_wp_richText_["toHTMLString"])({
      value: before,
      multilineTag
    }), !isAfterOriginal));
    lastPastedBlockIndex += 1;
  }

  if (hasPastedBlocks) {
    blocks.push(...pastedBlocks);
    lastPastedBlockIndex += pastedBlocks.length;
  } else if (onSplitMiddle) {
    blocks.push(onSplitMiddle());
  } // If there's pasted blocks, append a block with non empty content / after
  // the caret. Otherwise, do append an empty block if there is no
  // `onSplitMiddle` prop, but if there is and the content is empty, the
  // middle block is enough to set focus in.


  if (hasPastedBlocks ? !Object(external_wp_richText_["isEmpty"])(after) : !onSplitMiddle || !Object(external_wp_richText_["isEmpty"])(after)) {
    blocks.push(onSplit(Object(external_wp_richText_["toHTMLString"])({
      value: after,
      multilineTag
    }), isAfterOriginal));
  } // If there are pasted blocks, set the selection to the last one. Otherwise,
  // set the selection to the second block.


  const indexToSelect = hasPastedBlocks ? lastPastedBlockIndex : 1; // If there are pasted blocks, move the caret to the end of the selected
  // block Otherwise, retain the default value.

  const initialPosition = hasPastedBlocks ? -1 : 0;
  onReplace(blocks, indexToSelect, initialPosition);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-paste-handler.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




function usePasteHandler(props) {
  const propsRef = Object(external_wp_element_["useRef"])(props);
  propsRef.current = props;
  return Object(external_wp_compose_["useRefEffect"])(element => {
    function _onPaste(event) {
      const {
        isSelected,
        disableFormats,
        onChange,
        value,
        formatTypes,
        tagName,
        onReplace,
        onSplit,
        onSplitMiddle,
        __unstableEmbedURLOnPaste,
        multilineTag,
        preserveWhiteSpace,
        pastePlainText
      } = propsRef.current;

      if (!isSelected) {
        event.preventDefault();
        return;
      }

      const {
        clipboardData
      } = event;
      let plainText = '';
      let html = ''; // IE11 only supports `Text` as an argument for `getData` and will
      // otherwise throw an invalid argument error, so we try the standard
      // arguments first, then fallback to `Text` if they fail.

      try {
        plainText = clipboardData.getData('text/plain');
        html = clipboardData.getData('text/html');
      } catch (error1) {
        try {
          html = clipboardData.getData('Text');
        } catch (error2) {
          // Some browsers like UC Browser paste plain text by default and
          // don't support clipboardData at all, so allow default
          // behaviour.
          return;
        }
      }

      event.preventDefault(); // Allows us to ask for this information when we get a report.

      window.console.log('Received HTML:\n\n', html);
      window.console.log('Received plain text:\n\n', plainText);

      if (disableFormats) {
        onChange(Object(external_wp_richText_["insert"])(value, plainText));
        return;
      }

      const transformed = formatTypes.reduce((accumlator, {
        __unstablePasteRule
      }) => {
        // Only allow one transform.
        if (__unstablePasteRule && accumlator === value) {
          accumlator = __unstablePasteRule(value, {
            html,
            plainText
          });
        }

        return accumlator;
      }, value);

      if (transformed !== value) {
        onChange(transformed);
        return;
      }

      const files = [...Object(external_wp_dom_["getFilesFromDataTransfer"])(clipboardData)];
      const isInternal = clipboardData.getData('rich-text') === 'true'; // If the data comes from a rich text instance, we can directly use it
      // without filtering the data. The filters are only meant for externally
      // pasted content and remove inline styles.

      if (isInternal) {
        const pastedValue = Object(external_wp_richText_["create"])({
          html,
          multilineTag,
          multilineWrapperTags: multilineTag === 'li' ? ['ul', 'ol'] : undefined,
          preserveWhiteSpace
        });
        addActiveFormats(pastedValue, value.activeFormats);
        onChange(Object(external_wp_richText_["insert"])(value, pastedValue));
        return;
      }

      if (pastePlainText) {
        onChange(Object(external_wp_richText_["insert"])(value, Object(external_wp_richText_["create"])({
          text: plainText
        })));
        return;
      } // Only process file if no HTML is present.
      // Note: a pasted file may have the URL as plain text.


      if (files && files.length && !html) {
        const content = Object(external_wp_blocks_["pasteHandler"])({
          HTML: filePasteHandler(files),
          mode: 'BLOCKS',
          tagName,
          preserveWhiteSpace
        }); // Allows us to ask for this information when we get a report.
        // eslint-disable-next-line no-console

        window.console.log('Received items:\n\n', files);

        if (onReplace && Object(external_wp_richText_["isEmpty"])(value)) {
          onReplace(content);
        } else {
          splitValue({
            value,
            pastedBlocks: content,
            onReplace,
            onSplit,
            onSplitMiddle,
            multilineTag
          });
        }

        return;
      }

      let mode = onReplace && onSplit ? 'AUTO' : 'INLINE'; // Force the blocks mode when the user is pasting
      // on a new line & the content resembles a shortcode.
      // Otherwise it's going to be detected as inline
      // and the shortcode won't be replaced.

      if (mode === 'AUTO' && Object(external_wp_richText_["isEmpty"])(value) && isShortcode(plainText)) {
        mode = 'BLOCKS';
      }

      if (__unstableEmbedURLOnPaste && Object(external_wp_richText_["isEmpty"])(value) && Object(external_wp_url_["isURL"])(plainText.trim())) {
        mode = 'BLOCKS';
      }

      const content = Object(external_wp_blocks_["pasteHandler"])({
        HTML: html,
        plainText,
        mode,
        tagName,
        preserveWhiteSpace
      });

      if (typeof content === 'string') {
        let valueToInsert = Object(external_wp_richText_["create"])({
          html: content
        });
        addActiveFormats(valueToInsert, value.activeFormats); // If the content should be multiline, we should process text
        // separated by a line break as separate lines.

        if (multilineTag) {
          valueToInsert = Object(external_wp_richText_["replace"])(valueToInsert, /\n+/g, external_wp_richText_["__UNSTABLE_LINE_SEPARATOR"]);
        }

        onChange(Object(external_wp_richText_["insert"])(value, valueToInsert));
      } else if (content.length > 0) {
        if (onReplace && Object(external_wp_richText_["isEmpty"])(value)) {
          onReplace(content, content.length - 1, -1);
        } else {
          splitValue({
            value,
            pastedBlocks: content,
            onReplace,
            onSplit,
            onSplitMiddle,
            multilineTag
          });
        }
      }
    }

    element.addEventListener('paste', _onPaste);
    return () => {
      element.removeEventListener('paste', _onPaste);
    };
  }, []);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-input-rules.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


function useInputRules(props) {
  const {
    __unstableMarkLastChangeAsPersistent,
    __unstableMarkAutomaticChange
  } = Object(external_wp_data_["useDispatch"])(store);
  const propsRef = Object(external_wp_element_["useRef"])(props);
  propsRef.current = props;
  return Object(external_wp_compose_["useRefEffect"])(element => {
    function inputRule() {
      const {
        value,
        onReplace
      } = propsRef.current;

      if (!onReplace) {
        return;
      }

      const {
        start,
        text
      } = value;
      const characterBefore = text.slice(start - 1, start); // The character right before the caret must be a plain space.

      if (characterBefore !== ' ') {
        return;
      }

      const trimmedTextBefore = text.slice(0, start).trim();
      const prefixTransforms = Object(external_wp_blocks_["getBlockTransforms"])('from').filter(({
        type
      }) => type === 'prefix');
      const transformation = Object(external_wp_blocks_["findTransform"])(prefixTransforms, ({
        prefix
      }) => {
        return trimmedTextBefore === prefix;
      });

      if (!transformation) {
        return;
      }

      const content = Object(external_wp_richText_["toHTMLString"])({
        value: Object(external_wp_richText_["slice"])(value, start, text.length)
      });
      const block = transformation.transform(content);
      onReplace([block]);

      __unstableMarkAutomaticChange();
    }

    function onInput(event) {
      const {
        inputType,
        type
      } = event;
      const {
        value,
        onChange,
        __unstableAllowPrefixTransformations,
        formatTypes
      } = propsRef.current; // Only run input rules when inserting text.

      if (inputType !== 'insertText' && type !== 'compositionend') {
        return;
      }

      if (__unstableAllowPrefixTransformations && inputRule) {
        inputRule();
      }

      const transformed = formatTypes.reduce((accumlator, {
        __unstableInputRule
      }) => {
        if (__unstableInputRule) {
          accumlator = __unstableInputRule(accumlator);
        }

        return accumlator;
      }, value);

      if (transformed !== value) {
        __unstableMarkLastChangeAsPersistent();

        onChange({ ...transformed,
          activeFormats: value.activeFormats
        });

        __unstableMarkAutomaticChange();
      }
    }

    element.addEventListener('input', onInput);
    element.addEventListener('compositionend', onInput);
    return () => {
      element.removeEventListener('input', onInput);
      element.removeEventListener('compositionend', onInput);
    };
  }, []);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-enter.js
/**
 * WordPress dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */



function useEnter(props) {
  const {
    __unstableMarkAutomaticChange
  } = Object(external_wp_data_["useDispatch"])(store);
  const propsRef = Object(external_wp_element_["useRef"])(props);
  propsRef.current = props;
  return Object(external_wp_compose_["useRefEffect"])(element => {
    function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }

      const {
        removeEditorOnlyFormats,
        value,
        onReplace,
        onSplit,
        onSplitMiddle,
        multilineTag,
        onChange,
        disableLineBreaks,
        onSplitAtEnd
      } = propsRef.current;

      if (event.keyCode !== external_wp_keycodes_["ENTER"]) {
        return;
      }

      event.preventDefault();
      const _value = { ...value
      };
      _value.formats = removeEditorOnlyFormats(value);
      const canSplit = onReplace && onSplit;

      if (onReplace) {
        const transforms = Object(external_wp_blocks_["getBlockTransforms"])('from').filter(({
          type
        }) => type === 'enter');
        const transformation = Object(external_wp_blocks_["findTransform"])(transforms, item => {
          return item.regExp.test(_value.text);
        });

        if (transformation) {
          onReplace([transformation.transform({
            content: _value.text
          })]);

          __unstableMarkAutomaticChange();
        }
      }

      if (multilineTag) {
        if (event.shiftKey) {
          if (!disableLineBreaks) {
            onChange(Object(external_wp_richText_["insert"])(_value, '\n'));
          }
        } else if (canSplit && Object(external_wp_richText_["__unstableIsEmptyLine"])(_value)) {
          splitValue({
            value: _value,
            onReplace,
            onSplit,
            onSplitMiddle,
            multilineTag
          });
        } else {
          onChange(Object(external_wp_richText_["__unstableInsertLineSeparator"])(_value));
        }
      } else {
        const {
          text,
          start,
          end
        } = _value;
        const canSplitAtEnd = onSplitAtEnd && start === end && end === text.length;

        if (event.shiftKey || !canSplit && !canSplitAtEnd) {
          if (!disableLineBreaks) {
            onChange(Object(external_wp_richText_["insert"])(_value, '\n'));
          }
        } else if (!canSplit && canSplitAtEnd) {
          onSplitAtEnd();
        } else if (canSplit) {
          splitValue({
            value: _value,
            onReplace,
            onSplit,
            onSplitMiddle,
            multilineTag
          });
        }
      }
    }

    element.addEventListener('keydown', onKeyDown);
    return () => {
      element.removeEventListener('keydown', onKeyDown);
    };
  }, []);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-format-types.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function formatTypesSelector(select) {
  return select(external_wp_richText_["store"]).getFormatTypes();
}
/**
 * Set of all interactive content tags.
 *
 * @see https://html.spec.whatwg.org/multipage/dom.html#interactive-content
 */


const interactiveContentTags = new Set(['a', 'audio', 'button', 'details', 'embed', 'iframe', 'input', 'label', 'select', 'textarea', 'video']);
/**
 * This hook provides RichText with the `formatTypes` and its derived props from
 * experimental format type settings.
 *
 * @param {Object} $0                               Options
 * @param {string} $0.clientId                      Block client ID.
 * @param {string} $0.identifier                    Block attribute.
 * @param {boolean} $0.withoutInteractiveFormatting Whether to clean the interactive formattings or not.
 * @param {Array} $0.allowedFormats                 Allowed formats
 */

function useFormatTypes({
  clientId,
  identifier,
  withoutInteractiveFormatting,
  allowedFormats
}) {
  const allFormatTypes = Object(external_wp_data_["useSelect"])(formatTypesSelector, []);
  const formatTypes = Object(external_wp_element_["useMemo"])(() => {
    return allFormatTypes.filter(({
      name,
      tagName
    }) => {
      if (allowedFormats && !allowedFormats.includes(name)) {
        return false;
      }

      if (withoutInteractiveFormatting && interactiveContentTags.has(tagName)) {
        return false;
      }

      return true;
    });
  }, [allFormatTypes, allowedFormats, interactiveContentTags]);
  const keyedSelected = Object(external_wp_data_["useSelect"])(select => formatTypes.reduce((accumulator, type) => {
    if (type.__experimentalGetPropsForEditableTreePreparation) {
      accumulator[type.name] = type.__experimentalGetPropsForEditableTreePreparation(select, {
        richTextIdentifier: identifier,
        blockClientId: clientId
      });
    }

    return accumulator;
  }, {}), [formatTypes, clientId, identifier]);
  const dispatch = Object(external_wp_data_["useDispatch"])();
  const prepareHandlers = [];
  const valueHandlers = [];
  const changeHandlers = [];
  const dependencies = [];
  formatTypes.forEach(type => {
    if (type.__experimentalCreatePrepareEditableTree) {
      const selected = keyedSelected[type.name];

      const handler = type.__experimentalCreatePrepareEditableTree(selected, {
        richTextIdentifier: identifier,
        blockClientId: clientId
      });

      if (type.__experimentalCreateOnChangeEditableValue) {
        valueHandlers.push(handler);
      } else {
        prepareHandlers.push(handler);
      }

      for (const key in selected) {
        dependencies.push(selected[key]);
      }
    }

    if (type.__experimentalCreateOnChangeEditableValue) {
      let dispatchers = {};

      if (type.__experimentalGetPropsForEditableTreeChangeHandler) {
        dispatchers = type.__experimentalGetPropsForEditableTreeChangeHandler(dispatch, {
          richTextIdentifier: identifier,
          blockClientId: clientId
        });
      }

      changeHandlers.push(type.__experimentalCreateOnChangeEditableValue({ ...(keyedSelected[type.name] || {}),
        ...dispatchers
      }, {
        richTextIdentifier: identifier,
        blockClientId: clientId
      }));
    }
  });
  return {
    formatTypes,
    prepareHandlers,
    valueHandlers,
    changeHandlers,
    dependencies
  };
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/format-edit.js


/**
 * WordPress dependencies
 */

function FormatEdit({
  formatTypes,
  onChange,
  onFocus,
  value,
  forwardedRef
}) {
  return formatTypes.map(settings => {
    const {
      name,
      edit: Edit
    } = settings;

    if (!Edit) {
      return null;
    }

    const activeFormat = Object(external_wp_richText_["getActiveFormat"])(value, name);
    const isActive = activeFormat !== undefined;
    const activeObject = Object(external_wp_richText_["getActiveObject"])(value);
    const isObjectActive = activeObject !== undefined && activeObject.type === name;
    return Object(external_wp_element_["createElement"])(Edit, {
      key: name,
      isActive: isActive,
      activeAttributes: isActive ? activeFormat.attributes || {} : {},
      isObjectActive: isObjectActive,
      activeObjectAttributes: isObjectActive ? activeObject.attributes || {} : {},
      value: value,
      onChange: onChange,
      onFocus: onFocus,
      contentRef: forwardedRef
    });
  });
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/index.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */








/**
 * Internal dependencies
 */















/**
 * Removes props used for the native version of RichText so that they are not
 * passed to the DOM element and log warnings.
 *
 * @param {Object} props Props to filter.
 *
 * @return {Object} Filtered props.
 */

function removeNativeProps(props) {
  return Object(external_lodash_["omit"])(props, ['__unstableMobileNoFocusOnMount', 'deleteEnter', 'placeholderTextColor', 'textAlign', 'selectionColor', 'tagsToEliminate', 'rootTagsToEliminate', 'disableEditingMenu', 'fontSize', 'fontFamily', 'fontWeight', 'fontStyle', 'minWidth', 'maxWidth', 'setRef']);
}

function RichTextWrapper({
  children,
  tagName = 'div',
  value: originalValue = '',
  onChange: originalOnChange,
  isSelected: originalIsSelected,
  multiline,
  inlineToolbar,
  wrapperClassName,
  autocompleters,
  onReplace,
  placeholder,
  allowedFormats,
  formattingControls,
  withoutInteractiveFormatting,
  onRemove,
  onMerge,
  onSplit,
  __unstableOnSplitAtEnd: onSplitAtEnd,
  __unstableOnSplitMiddle: onSplitMiddle,
  identifier,
  preserveWhiteSpace,
  __unstablePastePlainText: pastePlainText,
  __unstableEmbedURLOnPaste,
  __unstableDisableFormats: disableFormats,
  disableLineBreaks,
  unstableOnFocus,
  __unstableAllowPrefixTransformations,
  ...props
}, forwardedRef) {
  const instanceId = Object(external_wp_compose_["useInstanceId"])(RichTextWrapper);
  identifier = identifier || instanceId;
  props = removeNativeProps(props);
  const anchorRef = Object(external_wp_element_["useRef"])();
  const {
    clientId
  } = useBlockEditContext();

  const selector = select => {
    const {
      getSelectionStart,
      getSelectionEnd,
      isMultiSelecting,
      hasMultiSelection
    } = select(store);
    const selectionStart = getSelectionStart();
    const selectionEnd = getSelectionEnd();
    let isSelected;

    if (originalIsSelected === undefined) {
      isSelected = selectionStart.clientId === clientId && selectionStart.attributeKey === identifier;
    } else if (originalIsSelected) {
      isSelected = selectionStart.clientId === clientId;
    }

    return {
      selectionStart: isSelected ? selectionStart.offset : undefined,
      selectionEnd: isSelected ? selectionEnd.offset : undefined,
      isSelected,
      disabled: isMultiSelecting() || hasMultiSelection()
    };
  }; // This selector must run on every render so the right selection state is
  // retreived from the store on merge.
  // To do: fix this somehow.


  const {
    selectionStart,
    selectionEnd,
    isSelected,
    disabled
  } = Object(external_wp_data_["useSelect"])(selector);
  const {
    selectionChange
  } = Object(external_wp_data_["useDispatch"])(store);
  const multilineTag = getMultilineTag(multiline);
  const adjustedAllowedFormats = getAllowedFormats({
    allowedFormats,
    formattingControls,
    disableFormats
  });
  const hasFormats = !adjustedAllowedFormats || adjustedAllowedFormats.length > 0;
  let adjustedValue = originalValue;
  let adjustedOnChange = originalOnChange; // Handle deprecated format.

  if (Array.isArray(originalValue)) {
    adjustedValue = external_wp_blocks_["children"].toHTML(originalValue);

    adjustedOnChange = newValue => originalOnChange(external_wp_blocks_["children"].fromDOM(Object(external_wp_richText_["__unstableCreateElement"])(document, newValue).childNodes));
  }

  const onSelectionChange = Object(external_wp_element_["useCallback"])((start, end) => {
    selectionChange(clientId, identifier, start, end);
  }, [clientId, identifier]);
  const {
    formatTypes,
    prepareHandlers,
    valueHandlers,
    changeHandlers,
    dependencies
  } = useFormatTypes({
    clientId,
    identifier,
    withoutInteractiveFormatting,
    allowedFormats: adjustedAllowedFormats
  });

  function addEditorOnlyFormats(value) {
    return valueHandlers.reduce((accumulator, fn) => fn(accumulator, value.text), value.formats);
  }

  function removeEditorOnlyFormats(value) {
    formatTypes.forEach(formatType => {
      // Remove formats created by prepareEditableTree, because they are editor only.
      if (formatType.__experimentalCreatePrepareEditableTree) {
        value = Object(external_wp_richText_["removeFormat"])(value, formatType.name, 0, value.text.length);
      }
    });
    return value.formats;
  }

  function addInvisibleFormats(value) {
    return prepareHandlers.reduce((accumulator, fn) => fn(accumulator, value.text), value.formats);
  }

  const {
    value,
    onChange,
    onFocus,
    ref: richTextRef
  } = Object(external_wp_richText_["__unstableUseRichText"])({
    value: adjustedValue,

    onChange(html, {
      __unstableFormats,
      __unstableText
    }) {
      adjustedOnChange(html);
      Object.values(changeHandlers).forEach(changeHandler => {
        changeHandler(__unstableFormats, __unstableText);
      });
    },

    selectionStart,
    selectionEnd,
    onSelectionChange,
    placeholder,
    __unstableIsSelected: isSelected,
    __unstableMultilineTag: multilineTag,
    __unstableDisableFormats: disableFormats,
    preserveWhiteSpace,
    __unstableDependencies: [...dependencies, tagName],
    __unstableAfterParse: addEditorOnlyFormats,
    __unstableBeforeSerialize: removeEditorOnlyFormats,
    __unstableAddInvisibleFormats: addInvisibleFormats
  });
  const autocompleteProps = useBlockEditorAutocompleteProps({
    onReplace,
    completers: autocompleters,
    record: value,
    onChange
  });
  useCaretInFormat({
    value
  });
  useMarkPersistent({
    html: adjustedValue,
    value
  });

  function onKeyDown(event) {
    const {
      keyCode
    } = event;

    if (event.defaultPrevented) {
      return;
    }

    if (keyCode === external_wp_keycodes_["DELETE"] || keyCode === external_wp_keycodes_["BACKSPACE"]) {
      const {
        start,
        end,
        text
      } = value;
      const isReverse = keyCode === external_wp_keycodes_["BACKSPACE"];
      const hasActiveFormats = value.activeFormats && !!value.activeFormats.length; // Only process delete if the key press occurs at an uncollapsed edge.

      if (!Object(external_wp_richText_["isCollapsed"])(value) || hasActiveFormats || isReverse && start !== 0 || !isReverse && end !== text.length) {
        return;
      }

      if (onMerge) {
        onMerge(!isReverse);
      } // Only handle remove on Backspace. This serves dual-purpose of being
      // an intentional user interaction distinguishing between Backspace and
      // Delete to remove the empty field, but also to avoid merge & remove
      // causing destruction of two fields (merge, then removed merged).


      if (onRemove && Object(external_wp_richText_["isEmpty"])(value) && isReverse) {
        onRemove(!isReverse);
      }

      event.preventDefault();
    }
  }

  const TagName = tagName;
  const content = Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, isSelected && children && children({
    value,
    onChange,
    onFocus
  }), isSelected && Object(external_wp_element_["createElement"])(RemoveBrowserShortcuts, null), isSelected && Object(external_wp_element_["createElement"])(FormatEdit, {
    value: value,
    onChange: onChange,
    onFocus: onFocus,
    formatTypes: formatTypes,
    forwardedRef: anchorRef
  }), isSelected && hasFormats && Object(external_wp_element_["createElement"])(format_toolbar_container, {
    inline: inlineToolbar,
    anchorRef: anchorRef.current
  }), Object(external_wp_element_["createElement"])(TagName // Overridable props.
  , Object(esm_extends["a" /* default */])({
    role: "textbox",
    "aria-multiline": true,
    "aria-label": placeholder
  }, props, autocompleteProps, {
    ref: Object(external_wp_compose_["useMergeRefs"])([autocompleteProps.ref, props.ref, richTextRef, useInputRules({
      value,
      onChange,
      __unstableAllowPrefixTransformations,
      formatTypes,
      onReplace
    }), useUndoAutomaticChange(), usePasteHandler({
      isSelected,
      disableFormats,
      onChange,
      value,
      formatTypes,
      tagName,
      onReplace,
      onSplit,
      onSplitMiddle,
      __unstableEmbedURLOnPaste,
      multilineTag,
      preserveWhiteSpace,
      pastePlainText
    }), useEnter({
      removeEditorOnlyFormats,
      value,
      onReplace,
      onSplit,
      onSplitMiddle,
      multilineTag,
      onChange,
      disableLineBreaks,
      onSplitAtEnd
    }), anchorRef, forwardedRef]) // Do not set the attribute if disabled.
    ,
    contentEditable: disabled ? undefined : true,
    suppressContentEditableWarning: !disabled,
    className: classnames_default()('block-editor-rich-text__editable', props.className, 'rich-text'),
    onFocus: unstableOnFocus,
    onKeyDown: onKeyDown
  })));

  if (!wrapperClassName) {
    return content;
  }

  external_wp_deprecated_default()('wp.blockEditor.RichText wrapperClassName prop', {
    since: '5.4',
    alternative: 'className prop or create your own wrapper div'
  });
  const className = classnames_default()('block-editor-rich-text', wrapperClassName);
  return Object(external_wp_element_["createElement"])("div", {
    className: className
  }, content);
}

const ForwardedRichTextContainer = Object(external_wp_element_["forwardRef"])(RichTextWrapper);

ForwardedRichTextContainer.Content = ({
  value,
  tagName: Tag,
  multiline,
  ...props
}) => {
  // Handle deprecated `children` and `node` sources.
  if (Array.isArray(value)) {
    value = external_wp_blocks_["children"].toHTML(value);
  }

  const MultilineTag = getMultilineTag(multiline);

  if (!value && MultilineTag) {
    value = `<${MultilineTag}></${MultilineTag}>`;
  }

  const content = Object(external_wp_element_["createElement"])(external_wp_element_["RawHTML"], null, value);

  if (Tag) {
    return Object(external_wp_element_["createElement"])(Tag, Object(external_lodash_["omit"])(props, ['format']), content);
  }

  return content;
};

ForwardedRichTextContainer.isEmpty = value => {
  return !value || value.length === 0;
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/rich-text/README.md
 */


/* harmony default export */ var rich_text = (ForwardedRichTextContainer);




// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-navigation/editor.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



function BlockNavigationEditor({
  value,
  onChange
}) {
  return Object(external_wp_element_["createElement"])(BlockNavigationBlockFill, null, Object(external_wp_element_["createElement"])(rich_text, {
    value: value,
    onChange: onChange,
    placeholder: Object(external_wp_i18n_["__"])('Navigation item'),
    withoutInteractiveFormatting: true,
    allowedFormats: ['core/bold', 'core/italic', 'core/image', 'core/strikethrough']
  }));
}

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/layout.js
var library_layout = __webpack_require__("Civd");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-variation-picker/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





function BlockVariationPicker({
  icon = library_layout["a" /* default */],
  label = Object(external_wp_i18n_["__"])('Choose variation'),
  instructions = Object(external_wp_i18n_["__"])('Select a variation to start with.'),
  variations,
  onSelect,
  allowSkip
}) {
  const classes = classnames_default()('block-editor-block-variation-picker', {
    'has-many-variations': variations.length > 4
  });
  return Object(external_wp_element_["createElement"])(external_wp_components_["Placeholder"], {
    icon: icon,
    label: label,
    instructions: instructions,
    className: classes
  }, Object(external_wp_element_["createElement"])("ul", {
    className: "block-editor-block-variation-picker__variations",
    role: "list",
    "aria-label": Object(external_wp_i18n_["__"])('Block variations')
  }, variations.map(variation => Object(external_wp_element_["createElement"])("li", {
    key: variation.name
  }, Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    isSecondary: true,
    icon: variation.icon,
    iconSize: 48,
    onClick: () => onSelect(variation),
    className: "block-editor-block-variation-picker__variation",
    label: variation.description || variation.title
  }), Object(external_wp_element_["createElement"])("span", {
    className: "block-editor-block-variation-picker__variation-label",
    role: "presentation"
  }, variation.title)))), allowSkip && Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-variation-picker__skip"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    isLink: true,
    onClick: () => onSelect()
  }, Object(external_wp_i18n_["__"])('Skip'))));
}

/* harmony default export */ var block_variation_picker = (BlockVariationPicker);

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/grid.js
var grid = __webpack_require__("b2RC");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-pattern-setup/constants.js
const VIEWMODES = {
  carousel: 'carousel',
  grid: 'grid'
};

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-pattern-setup/setup-toolbar.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



const Actions = ({
  onStartBlank,
  onBlockPatternSelect
}) => Object(external_wp_element_["createElement"])("div", {
  className: "block-editor-block-pattern-setup__actions"
}, Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
  onClick: onStartBlank
}, Object(external_wp_i18n_["__"])('Start blank')), Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
  isPrimary: true,
  onClick: onBlockPatternSelect
}, Object(external_wp_i18n_["__"])('Choose')));

const CarouselNavigation = ({
  handlePrevious,
  handleNext,
  activeSlide,
  totalSlides
}) => Object(external_wp_element_["createElement"])("div", {
  className: "block-editor-block-pattern-setup__navigation"
}, Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
  icon: chevron_left["a" /* default */],
  label: Object(external_wp_i18n_["__"])('Previous pattern'),
  onClick: handlePrevious,
  disabled: activeSlide === 0
}), Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
  icon: chevron_right["a" /* default */],
  label: Object(external_wp_i18n_["__"])('Next pattern'),
  onClick: handleNext,
  disabled: activeSlide === totalSlides - 1
}));

const SetupToolbar = ({
  viewMode,
  setViewMode,
  handlePrevious,
  handleNext,
  activeSlide,
  totalSlides,
  onBlockPatternSelect,
  onStartBlank
}) => {
  const isCarouselView = viewMode === VIEWMODES.carousel;
  const displayControls = Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-pattern-setup__display-controls"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    icon: stretch_full_width,
    label: Object(external_wp_i18n_["__"])('Carousel view'),
    onClick: () => setViewMode(VIEWMODES.carousel),
    isPressed: isCarouselView
  }), Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    icon: grid["a" /* default */],
    label: Object(external_wp_i18n_["__"])('Grid view'),
    onClick: () => setViewMode(VIEWMODES.grid),
    isPressed: viewMode === VIEWMODES.grid
  }));
  return Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-pattern-setup__toolbar"
  }, isCarouselView && Object(external_wp_element_["createElement"])(CarouselNavigation, {
    handlePrevious: handlePrevious,
    handleNext: handleNext,
    activeSlide: activeSlide,
    totalSlides: totalSlides
  }), displayControls, isCarouselView && Object(external_wp_element_["createElement"])(Actions, {
    onBlockPatternSelect: onBlockPatternSelect,
    onStartBlank: onStartBlank
  }));
};

/* harmony default export */ var setup_toolbar = (SetupToolbar);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-pattern-setup/use-patterns-setup.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



function usePatternsSetup(clientId, blockName, filterPatternsFn) {
  return Object(external_wp_data_["useSelect"])(select => {
    const {
      getBlockRootClientId,
      __experimentalGetPatternsByBlockTypes,
      __experimentalGetAllowedPatterns
    } = select(store);
    const rootClientId = getBlockRootClientId(clientId);

    if (filterPatternsFn) {
      return __experimentalGetAllowedPatterns(rootClientId).filter(filterPatternsFn);
    }

    return __experimentalGetPatternsByBlockTypes(blockName, rootClientId);
  }, [clientId, blockName, filterPatternsFn]);
}

/* harmony default export */ var use_patterns_setup = (usePatternsSetup);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-pattern-setup/index.js



/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */







const SetupContent = ({
  viewMode,
  activeSlide,
  patterns,
  onBlockPatternSelect
}) => {
  const composite = Object(external_wp_components_["__unstableUseCompositeState"])();
  const containerClass = 'block-editor-block-pattern-setup__container';

  if (viewMode === VIEWMODES.carousel) {
    const slideClass = new Map([[activeSlide, 'active-slide'], [activeSlide - 1, 'previous-slide'], [activeSlide + 1, 'next-slide']]);
    return Object(external_wp_element_["createElement"])("div", {
      className: containerClass
    }, Object(external_wp_element_["createElement"])("ul", {
      className: "carousel-container"
    }, patterns.map((pattern, index) => Object(external_wp_element_["createElement"])(BlockPatternSlide, {
      className: slideClass.get(index) || '',
      key: pattern.name,
      pattern: pattern
    }))));
  }

  return Object(external_wp_element_["createElement"])(external_wp_components_["__unstableComposite"], Object(esm_extends["a" /* default */])({}, composite, {
    role: "listbox",
    className: containerClass,
    "aria-label": Object(external_wp_i18n_["__"])('Patterns list')
  }), patterns.map(pattern => Object(external_wp_element_["createElement"])(block_pattern_setup_BlockPattern, {
    key: pattern.name,
    pattern: pattern,
    onSelect: onBlockPatternSelect,
    composite: composite
  })));
};

function block_pattern_setup_BlockPattern({
  pattern,
  onSelect,
  composite
}) {
  const baseClassName = 'block-editor-block-pattern-setup-list';
  const {
    blocks,
    title,
    description,
    viewportWidth = 700
  } = pattern;
  const descriptionId = Object(external_wp_compose_["useInstanceId"])(block_pattern_setup_BlockPattern, `${baseClassName}__item-description`);
  return Object(external_wp_element_["createElement"])("div", {
    className: `${baseClassName}__list-item`,
    "aria-label": pattern.title,
    "aria-describedby": pattern.description ? descriptionId : undefined
  }, Object(external_wp_element_["createElement"])(external_wp_components_["__unstableCompositeItem"], Object(esm_extends["a" /* default */])({
    role: "option",
    as: "div"
  }, composite, {
    className: `${baseClassName}__item`,
    onClick: () => onSelect(blocks)
  }), Object(external_wp_element_["createElement"])(block_preview, {
    blocks: blocks,
    viewportWidth: viewportWidth
  }), Object(external_wp_element_["createElement"])("div", {
    className: `${baseClassName}__item-title`
  }, title)), !!description && Object(external_wp_element_["createElement"])(external_wp_components_["VisuallyHidden"], {
    id: descriptionId
  }, description));
}

function BlockPatternSlide({
  className,
  pattern
}) {
  const {
    blocks,
    title,
    description
  } = pattern;
  const descriptionId = Object(external_wp_compose_["useInstanceId"])(BlockPatternSlide, 'block-editor-block-pattern-setup-list__item-description');
  return Object(external_wp_element_["createElement"])("li", {
    className: `pattern-slide ${className}`,
    "aria-label": title,
    "aria-describedby": description ? descriptionId : undefined
  }, Object(external_wp_element_["createElement"])(block_preview, {
    blocks: blocks,
    __experimentalLive: true
  }), !!description && Object(external_wp_element_["createElement"])(external_wp_components_["VisuallyHidden"], {
    id: descriptionId
  }, description));
}

const BlockPatternSetup = ({
  clientId,
  blockName,
  filterPatternsFn,
  startBlankComponent,
  onBlockPatternSelect
}) => {
  const [viewMode, setViewMode] = Object(external_wp_element_["useState"])(VIEWMODES.carousel);
  const [activeSlide, setActiveSlide] = Object(external_wp_element_["useState"])(0);
  const [showBlank, setShowBlank] = Object(external_wp_element_["useState"])(false);
  const {
    replaceBlock
  } = Object(external_wp_data_["useDispatch"])(store);
  const patterns = use_patterns_setup(clientId, blockName, filterPatternsFn);

  if (!(patterns !== null && patterns !== void 0 && patterns.length) || showBlank) {
    return startBlankComponent;
  }

  const onBlockPatternSelectDefault = blocks => {
    const clonedBlocks = blocks.map(block => Object(external_wp_blocks_["cloneBlock"])(block));
    replaceBlock(clientId, clonedBlocks);
  };

  const onPatternSelectCallback = onBlockPatternSelect || onBlockPatternSelectDefault;
  return Object(external_wp_element_["createElement"])("div", {
    className: `block-editor-block-pattern-setup view-mode-${viewMode}`
  }, Object(external_wp_element_["createElement"])(setup_toolbar, {
    viewMode: viewMode,
    setViewMode: setViewMode,
    activeSlide: activeSlide,
    totalSlides: patterns.length,
    handleNext: () => {
      setActiveSlide(active => active + 1);
    },
    handlePrevious: () => {
      setActiveSlide(active => active - 1);
    },
    onBlockPatternSelect: () => {
      onPatternSelectCallback(patterns[activeSlide].blocks);
    },
    onStartBlank: () => {
      setShowBlank(true);
    }
  }), Object(external_wp_element_["createElement"])(SetupContent, {
    viewMode: viewMode,
    activeSlide: activeSlide,
    patterns: patterns,
    onBlockPatternSelect: onPatternSelectCallback
  }));
};

/* harmony default export */ var block_pattern_setup = (BlockPatternSetup);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/block-variation-transforms.js
/**
 * External dependencies
 */

/** @typedef {import('@wordpress/blocks').WPBlockVariation} WPBlockVariation */

/**
 * Matches the provided block variations with a block's attributes. If no match
 * or more than one matches are found it returns `undefined`. If a single match is
 * found it returns it.
 *
 * This is a simple implementation for now as it takes into account only the attributes
 * of a block variation and not `InnerBlocks`.
 *
 * @param {Object} blockAttributes - The block attributes to try to find a match.
 * @param {WPBlockVariation[]} variations - A list of block variations to test for a match.
 * @return {?WPBlockVariation} - If a match is found returns it. If not or more than one matches are found returns `undefined`.
 */

const __experimentalGetMatchingVariation = (blockAttributes, variations) => {
  if (!variations || !blockAttributes) return;
  const matches = variations.filter(({
    attributes
  }) => {
    if (!attributes || !Object.keys(attributes).length) return false;
    return Object(external_lodash_["isMatch"])(blockAttributes, attributes);
  });
  if (matches.length !== 1) return;
  return matches[0];
};

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-variation-transforms/index.js


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




function __experimentalBlockVariationTransforms({
  blockClientId
}) {
  const [selectedValue, setSelectedValue] = Object(external_wp_element_["useState"])();
  const {
    updateBlockAttributes
  } = Object(external_wp_data_["useDispatch"])(store);
  const {
    variations,
    blockAttributes
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getBlockVariations
    } = select(external_wp_blocks_["store"]);
    const {
      getBlockName,
      getBlockAttributes
    } = select(store);
    const blockName = blockClientId && getBlockName(blockClientId);
    return {
      variations: blockName && getBlockVariations(blockName, 'transform'),
      blockAttributes: getBlockAttributes(blockClientId)
    };
  }, [blockClientId]);
  Object(external_wp_element_["useEffect"])(() => {
    var _getMatchingVariation;

    setSelectedValue((_getMatchingVariation = __experimentalGetMatchingVariation(blockAttributes, variations)) === null || _getMatchingVariation === void 0 ? void 0 : _getMatchingVariation.name);
  }, [blockAttributes, variations]);
  if (!(variations !== null && variations !== void 0 && variations.length)) return null;
  const selectOptions = variations.map(({
    name,
    title,
    description
  }) => ({
    value: name,
    label: title,
    info: description
  }));

  const onSelectVariation = variationName => {
    updateBlockAttributes(blockClientId, { ...variations.find(({
        name
      }) => name === variationName).attributes
    });
  };

  const baseClass = 'block-editor-block-variation-transforms';
  return Object(external_wp_element_["createElement"])(external_wp_components_["DropdownMenu"], {
    className: baseClass,
    label: Object(external_wp_i18n_["__"])('Transform to variation'),
    text: Object(external_wp_i18n_["__"])('Transform to variation'),
    popoverProps: {
      position: 'bottom center',
      className: `${baseClass}__popover`
    },
    icon: chevron_down["a" /* default */],
    toggleProps: {
      iconPosition: 'right'
    }
  }, () => Object(external_wp_element_["createElement"])("div", {
    className: `${baseClass}__container`
  }, Object(external_wp_element_["createElement"])(external_wp_components_["MenuGroup"], null, Object(external_wp_element_["createElement"])(external_wp_components_["MenuItemsChoice"], {
    choices: selectOptions,
    value: selectedValue,
    onSelect: onSelectVariation
  }))));
}

/* harmony default export */ var block_variation_transforms = (__experimentalBlockVariationTransforms);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-vertical-alignment-control/icons.js


/**
 * WordPress dependencies
 */

const alignBottom = Object(external_wp_element_["createElement"])(external_wp_components_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_components_["Path"], {
  d: "M15 4H9v11h6V4zM4 18.5V20h16v-1.5H4z"
}));
const alignCenter = Object(external_wp_element_["createElement"])(external_wp_components_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_components_["Path"], {
  d: "M20 11h-5V4H9v7H4v1.5h5V20h6v-7.5h5z"
}));
const alignTop = Object(external_wp_element_["createElement"])(external_wp_components_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_components_["Path"], {
  d: "M9 20h6V9H9v11zM4 4v1.5h16V4H4z"
}));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-vertical-alignment-control/ui.js



/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


const ui_BLOCK_ALIGNMENTS_CONTROLS = {
  top: {
    icon: alignTop,
    title: Object(external_wp_i18n_["_x"])('Align top', 'Block vertical alignment setting')
  },
  center: {
    icon: alignCenter,
    title: Object(external_wp_i18n_["_x"])('Align middle', 'Block vertical alignment setting')
  },
  bottom: {
    icon: alignBottom,
    title: Object(external_wp_i18n_["_x"])('Align bottom', 'Block vertical alignment setting')
  }
};
const ui_DEFAULT_CONTROLS = ['top', 'center', 'bottom'];
const ui_DEFAULT_CONTROL = 'top';
const block_vertical_alignment_control_ui_POPOVER_PROPS = {
  isAlternate: true
};

function BlockVerticalAlignmentUI({
  value,
  onChange,
  controls = ui_DEFAULT_CONTROLS,
  isCollapsed = true,
  isToolbar
}) {
  function applyOrUnset(align) {
    return () => onChange(value === align ? undefined : align);
  }

  const activeAlignment = ui_BLOCK_ALIGNMENTS_CONTROLS[value];
  const defaultAlignmentControl = ui_BLOCK_ALIGNMENTS_CONTROLS[ui_DEFAULT_CONTROL];
  const UIComponent = isToolbar ? external_wp_components_["ToolbarGroup"] : external_wp_components_["ToolbarDropdownMenu"];
  const extraProps = isToolbar ? {
    isCollapsed
  } : {};
  return Object(external_wp_element_["createElement"])(UIComponent, Object(esm_extends["a" /* default */])({
    popoverProps: block_vertical_alignment_control_ui_POPOVER_PROPS,
    icon: activeAlignment ? activeAlignment.icon : defaultAlignmentControl.icon,
    label: Object(external_wp_i18n_["_x"])('Change vertical alignment', 'Block vertical alignment setting label'),
    controls: controls.map(control => {
      return { ...ui_BLOCK_ALIGNMENTS_CONTROLS[control],
        isActive: value === control,
        role: isCollapsed ? 'menuitemradio' : undefined,
        onClick: applyOrUnset(control)
      };
    })
  }, extraProps));
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-vertical-alignment-toolbar/README.md
 */


/* harmony default export */ var block_vertical_alignment_control_ui = (BlockVerticalAlignmentUI);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-vertical-alignment-control/index.js



/**
 * Internal dependencies
 */

function BlockVerticalAlignmentControl(props) {
  return Object(external_wp_element_["createElement"])(block_vertical_alignment_control_ui, Object(esm_extends["a" /* default */])({}, props, {
    isToolbar: false
  }));
}
function BlockVerticalAlignmentToolbar(props) {
  return Object(external_wp_element_["createElement"])(block_vertical_alignment_control_ui, Object(esm_extends["a" /* default */])({}, props, {
    isToolbar: true
  }));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/color-palette/with-color-context.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/* harmony default export */ var with_color_context = (Object(external_wp_compose_["createHigherOrderComponent"])(WrappedComponent => {
  return props => {
    const colorsFeature = useSetting('color.palette');
    const disableCustomColorsFeature = !useSetting('color.custom');
    const colors = props.colors === undefined ? colorsFeature : props.colors;
    const disableCustomColors = props.disableCustomColors === undefined ? disableCustomColorsFeature : props.disableCustomColors;
    const hasColorsToChoose = !Object(external_lodash_["isEmpty"])(colors) || !disableCustomColors;
    return Object(external_wp_element_["createElement"])(WrappedComponent, Object(esm_extends["a" /* default */])({}, props, {
      colors,
      disableCustomColors,
      hasColorsToChoose
    }));
  };
}, 'withColorContext'));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/color-palette/index.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/* harmony default export */ var color_palette = (with_color_context(external_wp_components_["ColorPalette"]));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/color-palette/control.js



/**
 * Internal dependencies
 */

function ColorPaletteControl({
  onChange,
  value,
  ...otherProps
}) {
  return Object(external_wp_element_["createElement"])(control, Object(esm_extends["a" /* default */])({}, otherProps, {
    onColorChange: onChange,
    colorValue: value,
    gradients: [],
    disableCustomGradients: true
  }));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/gradient-picker/index.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


const gradient_picker_EMPTY_ARRAY = [];

function GradientPickerWithGradients(props) {
  const gradients = useSetting('color.gradients') || gradient_picker_EMPTY_ARRAY;
  const disableCustomGradients = !useSetting('color.customGradient');
  return Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalGradientPicker"], Object(esm_extends["a" /* default */])({
    gradients: props.gradients !== undefined ? props.gradient : gradients,
    disableCustomGradients: props.disableCustomGradients !== undefined ? props.disableCustomGradients : disableCustomGradients
  }, props));
}

/* harmony default export */ var gradient_picker = (function (props) {
  const ComponentToUse = props.gradients !== undefined && props.disableCustomGradients !== undefined ? external_wp_components_["__experimentalGradientPicker"] : GradientPickerWithGradients;
  return Object(external_wp_element_["createElement"])(ComponentToUse, props);
});

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/gradient-picker/control.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function GradientPickerControl({
  className,
  value,
  onChange,
  label = Object(external_wp_i18n_["__"])('Gradient Presets'),
  ...props
}) {
  const gradients = useSetting('color.gradients');
  const disableCustomGradients = !useSetting('color.customGradient');

  if (Object(external_lodash_["isEmpty"])(gradients) && disableCustomGradients) {
    return null;
  }

  return Object(external_wp_element_["createElement"])(external_wp_components_["BaseControl"], {
    className: classnames_default()('block-editor-gradient-picker-control', className)
  }, Object(external_wp_element_["createElement"])(external_wp_components_["BaseControl"].VisualLabel, null, label), Object(external_wp_element_["createElement"])(gradient_picker, Object(esm_extends["a" /* default */])({
    value: value,
    onChange: onChange,
    className: "block-editor-gradient-picker-control__gradient-picker-presets",
    gradients: gradients,
    disableCustomGradients: disableCustomGradients
  }, props)));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/gradient-picker/panel.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function GradientPanel(props) {
  const gradients = useSetting('color.gradients');

  if (Object(external_lodash_["isEmpty"])(gradients)) {
    return null;
  }

  return Object(external_wp_element_["createElement"])(external_wp_components_["PanelBody"], {
    title: Object(external_wp_i18n_["__"])('Gradient')
  }, Object(external_wp_element_["createElement"])(GradientPickerControl, props));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/image-size-control/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



const IMAGE_SIZE_PRESETS = [25, 50, 75, 100];
function ImageSizeControl({
  imageWidth,
  imageHeight,
  imageSizeOptions = [],
  isResizable = true,
  slug,
  width,
  height,
  onChange,
  onChangeImage = external_lodash_["noop"]
}) {
  var _ref, _ref2;

  function updateDimensions(nextWidth, nextHeight) {
    return () => {
      onChange({
        width: nextWidth,
        height: nextHeight
      });
    };
  }

  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, !Object(external_lodash_["isEmpty"])(imageSizeOptions) && Object(external_wp_element_["createElement"])(external_wp_components_["SelectControl"], {
    label: Object(external_wp_i18n_["__"])('Image size'),
    value: slug,
    options: imageSizeOptions,
    onChange: onChangeImage
  }), isResizable && Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-image-size-control"
  }, Object(external_wp_element_["createElement"])("p", {
    className: "block-editor-image-size-control__row"
  }, Object(external_wp_i18n_["__"])('Image dimensions')), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-image-size-control__row"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["TextControl"], {
    type: "number",
    className: "block-editor-image-size-control__width",
    label: Object(external_wp_i18n_["__"])('Width'),
    value: (_ref = width !== null && width !== void 0 ? width : imageWidth) !== null && _ref !== void 0 ? _ref : '',
    min: 1,
    onChange: value => onChange({
      width: parseInt(value, 10)
    })
  }), Object(external_wp_element_["createElement"])(external_wp_components_["TextControl"], {
    type: "number",
    className: "block-editor-image-size-control__height",
    label: Object(external_wp_i18n_["__"])('Height'),
    value: (_ref2 = height !== null && height !== void 0 ? height : imageHeight) !== null && _ref2 !== void 0 ? _ref2 : '',
    min: 1,
    onChange: value => onChange({
      height: parseInt(value, 10)
    })
  })), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-image-size-control__row"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["ButtonGroup"], {
    "aria-label": Object(external_wp_i18n_["__"])('Image size presets')
  }, IMAGE_SIZE_PRESETS.map(scale => {
    const scaledWidth = Math.round(imageWidth * (scale / 100));
    const scaledHeight = Math.round(imageHeight * (scale / 100));
    const isCurrent = width === scaledWidth && height === scaledHeight;
    return Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
      key: scale,
      isSmall: true,
      isPrimary: isCurrent,
      isPressed: isCurrent,
      onClick: updateDimensions(scaledWidth, scaledHeight)
    }, scale, "%");
  })), Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    isSmall: true,
    onClick: updateDimensions()
  }, Object(external_wp_i18n_["__"])('Reset')))));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/with-client-id.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


const withClientId = Object(external_wp_compose_["createHigherOrderComponent"])(WrappedComponent => props => {
  const {
    clientId
  } = useBlockEditContext();
  return Object(external_wp_element_["createElement"])(WrappedComponent, Object(esm_extends["a" /* default */])({}, props, {
    clientId: clientId
  }));
}, 'withClientId');
/* harmony default export */ var with_client_id = (withClientId);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/button-block-appender.js


/**
 * Internal dependencies
 */


const button_block_appender_ButtonBlockAppender = ({
  clientId,
  showSeparator,
  isFloating,
  onAddBlock
}) => {
  return Object(external_wp_element_["createElement"])(button_block_appender, {
    rootClientId: clientId,
    showSeparator: showSeparator,
    isFloating: isFloating,
    onAddBlock: onAddBlock
  });
};
/* harmony default export */ var inner_blocks_button_block_appender = (with_client_id(button_block_appender_ButtonBlockAppender));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/default-block-appender.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




const default_block_appender_DefaultBlockAppender = ({
  clientId,
  lastBlockClientId
}) => {
  return Object(external_wp_element_["createElement"])(default_block_appender, {
    rootClientId: clientId,
    lastBlockClientId: lastBlockClientId
  });
};
/* harmony default export */ var inner_blocks_default_block_appender = (Object(external_wp_compose_["compose"])([with_client_id, Object(external_wp_data_["withSelect"])((select, {
  clientId
}) => {
  const {
    getBlockOrder
  } = select(store);
  const blockClientIds = getBlockOrder(clientId);
  return {
    lastBlockClientId: Object(external_lodash_["last"])(blockClientIds)
  };
})])(default_block_appender_DefaultBlockAppender));

// EXTERNAL MODULE: external ["wp","isShallowEqual"]
var external_wp_isShallowEqual_ = __webpack_require__("rl8x");
var external_wp_isShallowEqual_default = /*#__PURE__*/__webpack_require__.n(external_wp_isShallowEqual_);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/use-nested-settings-update.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * This hook is a side effect which updates the block-editor store when changes
 * happen to inner block settings. The given props are transformed into a
 * settings object, and if that is different from the current settings object in
 * the block-editor store, then the store is updated with the new settings which
 * came from props.
 *
 * @param {string}   clientId        The client ID of the block to update.
 * @param {string[]} allowedBlocks   An array of block names which are permitted
 *                                   in inner blocks.
 * @param {string}   [templateLock]  The template lock specified for the inner
 *                                   blocks component. (e.g. "all")
 * @param {boolean}  captureToolbars Whether or children toolbars should be shown
 *                                   in the inner blocks component rather than on
 *                                   the child block.
 * @param {string}   orientation     The direction in which the block
 *                                   should face.
 */

function useNestedSettingsUpdate(clientId, allowedBlocks, templateLock, captureToolbars, orientation) {
  const {
    updateBlockListSettings
  } = Object(external_wp_data_["useDispatch"])(store);
  const {
    blockListSettings,
    parentLock
  } = Object(external_wp_data_["useSelect"])(select => {
    const rootClientId = select(store).getBlockRootClientId(clientId);
    return {
      blockListSettings: select(store).getBlockListSettings(clientId),
      parentLock: select(store).getTemplateLock(rootClientId)
    };
  }, [clientId]); // Memoize as inner blocks implementors often pass a new array on every
  // render.

  const _allowedBlocks = Object(external_wp_element_["useMemo"])(() => allowedBlocks, allowedBlocks);

  Object(external_wp_element_["useLayoutEffect"])(() => {
    const newSettings = {
      allowedBlocks: _allowedBlocks,
      templateLock: templateLock === undefined ? parentLock : templateLock
    }; // These values are not defined for RN, so only include them if they
    // are defined.

    if (captureToolbars !== undefined) {
      newSettings.__experimentalCaptureToolbars = captureToolbars;
    }

    if (orientation !== undefined) {
      newSettings.orientation = orientation;
    }

    if (!external_wp_isShallowEqual_default()(blockListSettings, newSettings)) {
      updateBlockListSettings(clientId, newSettings);
    }
  }, [clientId, blockListSettings, _allowedBlocks, templateLock, parentLock, captureToolbars, orientation, updateBlockListSettings]);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/use-inner-block-template-sync.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/**
 * This hook makes sure that a block's inner blocks stay in sync with the given
 * block "template". The template is a block hierarchy to which inner blocks must
 * conform. If the blocks get "out of sync" with the template and the template
 * is meant to be locked (e.g. templateLock = "all"), then we replace the inner
 * blocks with the correct value after synchronizing it with the template.
 *
 * @param {string} clientId     The block client ID.
 * @param {Object} template     The template to match.
 * @param {string} templateLock The template lock state for the inner blocks. For
 *                              example, if the template lock is set to "all",
 *                              then the inner blocks will stay in sync with the
 *                              template. If not defined or set to false, then
 *                              the inner blocks will not be synchronized with
 *                              the given template.
 * @param {boolean} templateInsertUpdatesSelection Whether or not to update the
 *                              block-editor selection state when inner blocks
 *                              are replaced after template synchronization.
 */

function useInnerBlockTemplateSync(clientId, template, templateLock, templateInsertUpdatesSelection) {
  const {
    getSelectedBlocksInitialCaretPosition
  } = Object(external_wp_data_["useSelect"])(store);
  const {
    replaceInnerBlocks
  } = Object(external_wp_data_["useDispatch"])(store);
  const innerBlocks = Object(external_wp_data_["useSelect"])(select => select(store).getBlocks(clientId), [clientId]); // Maintain a reference to the previous value so we can do a deep equality check.

  const existingTemplate = Object(external_wp_element_["useRef"])(null);
  Object(external_wp_element_["useLayoutEffect"])(() => {
    // Only synchronize innerBlocks with template if innerBlocks are empty or
    // a locking all exists directly on the block.
    if (innerBlocks.length === 0 || templateLock === 'all') {
      const hasTemplateChanged = !Object(external_lodash_["isEqual"])(template, existingTemplate.current);

      if (hasTemplateChanged) {
        existingTemplate.current = template;
        const nextBlocks = Object(external_wp_blocks_["synchronizeBlocksWithTemplate"])(innerBlocks, template);

        if (!Object(external_lodash_["isEqual"])(nextBlocks, innerBlocks)) {
          replaceInnerBlocks(clientId, nextBlocks, innerBlocks.length === 0 && templateInsertUpdatesSelection && nextBlocks.length !== 0, // This ensures the "initialPosition" doesn't change when applying the template
          // If we're supposed to focus the block, we'll focus the first inner block
          // otherwise, we won't apply any auto-focus.
          // This ensures for instance that the focus stays in the inserter when inserting the "buttons" block.
          getSelectedBlocksInitialCaretPosition());
        }
      }
    }
  }, [innerBlocks, template, templateLock, clientId]);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/get-block-context.js
/**
 * External dependencies
 */

/**
 * Block context cache, implemented as a WeakMap mapping block types to a
 * WeakMap mapping attributes object to context value.
 *
 * @type {WeakMap<string,WeakMap<string,*>>}
 */

const BLOCK_CONTEXT_CACHE = new WeakMap();
/**
 * Returns a cached context object value for a given set of attributes for the
 * block type.
 *
 * @param {Record<string,*>} attributes Block attributes object.
 * @param {WPBlockType}      blockType  Block type settings.
 *
 * @return {Record<string,*>} Context value.
 */

function getBlockContext(attributes, blockType) {
  if (!BLOCK_CONTEXT_CACHE.has(blockType)) {
    BLOCK_CONTEXT_CACHE.set(blockType, new WeakMap());
  }

  const blockTypeCache = BLOCK_CONTEXT_CACHE.get(blockType);

  if (!blockTypeCache.has(attributes)) {
    const context = Object(external_lodash_["mapValues"])(blockType.providesContext, attributeName => attributes[attributeName]);
    blockTypeCache.set(attributes, context);
  }

  return blockTypeCache.get(attributes);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */












/**
 * InnerBlocks is a component which allows a single block to have multiple blocks
 * as children. The UncontrolledInnerBlocks component is used whenever the inner
 * blocks are not controlled by another entity. In other words, it is normally
 * used for inner blocks in the post editor
 *
 * @param {Object} props The component props.
 */

function UncontrolledInnerBlocks(props) {
  const {
    clientId,
    allowedBlocks,
    template,
    templateLock,
    wrapperRef,
    templateInsertUpdatesSelection,
    __experimentalCaptureToolbars: captureToolbars,
    __experimentalAppenderTagName,
    renderAppender,
    orientation,
    placeholder,
    __experimentalLayout
  } = props;
  useNestedSettingsUpdate(clientId, allowedBlocks, templateLock, captureToolbars, orientation);
  useInnerBlockTemplateSync(clientId, template, templateLock, templateInsertUpdatesSelection);
  const context = Object(external_wp_data_["useSelect"])(select => {
    const block = select(store).getBlock(clientId);
    const blockType = Object(external_wp_blocks_["getBlockType"])(block.name);

    if (!blockType || !blockType.providesContext) {
      return;
    }

    return getBlockContext(block.attributes, blockType);
  }, [clientId]); // This component needs to always be synchronous as it's the one changing
  // the async mode depending on the block selection.

  return Object(external_wp_element_["createElement"])(BlockContextProvider, {
    value: context
  }, Object(external_wp_element_["createElement"])(BlockListItems, {
    rootClientId: clientId,
    renderAppender: renderAppender,
    __experimentalAppenderTagName: __experimentalAppenderTagName,
    __experimentalLayout: __experimentalLayout,
    wrapperRef: wrapperRef,
    placeholder: placeholder
  }));
}
/**
 * The controlled inner blocks component wraps the uncontrolled inner blocks
 * component with the blockSync hook. This keeps the innerBlocks of the block in
 * the block-editor store in sync with the blocks of the controlling entity. An
 * example of an inner block controller is a template part block, which provides
 * its own blocks from the template part entity data source.
 *
 * @param {Object} props The component props.
 */


function ControlledInnerBlocks(props) {
  useBlockSync(props);
  return Object(external_wp_element_["createElement"])(UncontrolledInnerBlocks, props);
}

const ForwardedInnerBlocks = Object(external_wp_element_["forwardRef"])((props, ref) => {
  const innerBlocksProps = useInnerBlocksProps({
    ref
  }, props);
  return Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-inner-blocks"
  }, Object(external_wp_element_["createElement"])("div", innerBlocksProps));
});
/**
 * This hook is used to lightly mark an element as an inner blocks wrapper
 * element. Call this hook and pass the returned props to the element to mark as
 * an inner blocks wrapper, automatically rendering inner blocks as children. If
 * you define a ref for the element, it is important to pass the ref to this
 * hook, which the hook in turn will pass to the component through the props it
 * returns. Optionally, you can also pass any other props through this hook, and
 * they will be merged and returned.
 *
 * @param {Object} props   Optional. Props to pass to the element. Must contain
 *                         the ref if one is defined.
 * @param {Object} options Optional. Inner blocks options.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/inner-blocks/README.md
 */

function useInnerBlocksProps(props = {}, options = {}) {
  const {
    clientId
  } = useBlockEditContext();
  const isSmallScreen = Object(external_wp_compose_["useViewportMatch"])('medium', '<');
  const hasOverlay = Object(external_wp_data_["useSelect"])(select => {
    const {
      getBlockName,
      isBlockSelected,
      hasSelectedInnerBlock,
      isNavigationMode
    } = select(store);
    const enableClickThrough = isNavigationMode() || isSmallScreen;
    return getBlockName(clientId) !== 'core/template' && !isBlockSelected(clientId) && !hasSelectedInnerBlock(clientId, true) && enableClickThrough;
  }, [clientId, isSmallScreen]);
  const ref = Object(external_wp_compose_["useMergeRefs"])([props.ref, useBlockDropZone({
    rootClientId: clientId
  })]);
  const InnerBlocks = options.value && options.onChange ? ControlledInnerBlocks : UncontrolledInnerBlocks;
  return { ...props,
    ref,
    className: classnames_default()(props.className, 'block-editor-block-list__layout', {
      'has-overlay': hasOverlay
    }),
    children: Object(external_wp_element_["createElement"])(InnerBlocks, Object(esm_extends["a" /* default */])({}, options, {
      clientId: clientId
    }))
  };
} // Expose default appender placeholders as components.

ForwardedInnerBlocks.DefaultBlockAppender = inner_blocks_default_block_appender;
ForwardedInnerBlocks.ButtonBlockAppender = inner_blocks_button_block_appender;
ForwardedInnerBlocks.Content = Object(external_wp_blocks_["withBlockContentContext"])(({
  BlockContent
}) => Object(external_wp_element_["createElement"])(BlockContent, null));
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/inner-blocks/README.md
 */

/* harmony default export */ var inner_blocks = (ForwardedInnerBlocks);

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/justify-left.js


/**
 * WordPress dependencies
 */

const justifyLeft = Object(external_wp_element_["createElement"])(external_wp_primitives_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_primitives_["Path"], {
  d: "M9 9v6h11V9H9zM4 20h1.5V4H4v16z"
}));
/* harmony default export */ var justify_left = (justifyLeft);

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/justify-center.js


/**
 * WordPress dependencies
 */

const justifyCenter = Object(external_wp_element_["createElement"])(external_wp_primitives_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_primitives_["Path"], {
  d: "M20 9h-7.2V4h-1.6v5H4v6h7.2v5h1.6v-5H20z"
}));
/* harmony default export */ var justify_center = (justifyCenter);

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/justify-right.js


/**
 * WordPress dependencies
 */

const justifyRight = Object(external_wp_element_["createElement"])(external_wp_primitives_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_primitives_["Path"], {
  d: "M4 15h11V9H4v6zM18.5 4v16H20V4h-1.5z"
}));
/* harmony default export */ var justify_right = (justifyRight);

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/justify-space-between.js


/**
 * WordPress dependencies
 */

const justifySpaceBetween = Object(external_wp_element_["createElement"])(external_wp_primitives_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_primitives_["Path"], {
  d: "M9 15h6V9H9v6zm-5 5h1.5V4H4v16zM18.5 4v16H20V4h-1.5z"
}));
/* harmony default export */ var justify_space_between = (justifySpaceBetween);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/justify-content-control/ui.js



/**
 * WordPress dependencies
 */



const icons = {
  left: justify_left,
  center: justify_center,
  right: justify_right,
  'space-between': justify_space_between
};

function JustifyContentUI({
  allowedControls = ['left', 'center', 'right', 'space-between'],
  isCollapsed = true,
  onChange,
  value,
  popoverProps,
  isToolbar
}) {
  // If the control is already selected we want a click
  // again on the control to deselect the item, so we
  // call onChange( undefined )
  const handleClick = next => {
    if (next === value) {
      onChange(undefined);
    } else {
      onChange(next);
    }
  };

  const icon = value ? icons[value] : icons.left;
  const allControls = [{
    name: 'left',
    icon: justify_left,
    title: Object(external_wp_i18n_["__"])('Justify items left'),
    isActive: 'left' === value,
    onClick: () => handleClick('left')
  }, {
    name: 'center',
    icon: justify_center,
    title: Object(external_wp_i18n_["__"])('Justify items center'),
    isActive: 'center' === value,
    onClick: () => handleClick('center')
  }, {
    name: 'right',
    icon: justify_right,
    title: Object(external_wp_i18n_["__"])('Justify items right'),
    isActive: 'right' === value,
    onClick: () => handleClick('right')
  }, {
    name: 'space-between',
    icon: justify_space_between,
    title: Object(external_wp_i18n_["__"])('Space between items'),
    isActive: 'space-between' === value,
    onClick: () => handleClick('space-between')
  }];
  const UIComponent = isToolbar ? external_wp_components_["ToolbarGroup"] : external_wp_components_["ToolbarDropdownMenu"];
  const extraProps = isToolbar ? {
    isCollapsed
  } : {};
  return Object(external_wp_element_["createElement"])(UIComponent, Object(esm_extends["a" /* default */])({
    icon: icon,
    popoverProps: popoverProps,
    label: Object(external_wp_i18n_["__"])('Change items justification'),
    controls: allControls.filter(elem => allowedControls.includes(elem.name))
  }, extraProps));
}

/* harmony default export */ var justify_content_control_ui = (JustifyContentUI);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/justify-content-control/index.js



/**
 * Internal dependencies
 */

function JustifyContentControl(props) {
  return Object(external_wp_element_["createElement"])(justify_content_control_ui, Object(esm_extends["a" /* default */])({}, props, {
    isToolbar: false
  }));
}
function JustifyToolbar(props) {
  return Object(external_wp_element_["createElement"])(justify_content_control_ui, Object(esm_extends["a" /* default */])({}, props, {
    isToolbar: true
  }));
}

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/keyboard-return.js
var keyboard_return = __webpack_require__("btIw");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/settings-drawer.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



const defaultSettings = [{
  id: 'opensInNewTab',
  title: Object(external_wp_i18n_["__"])('Open in new tab')
}];

const LinkControlSettingsDrawer = ({
  value,
  onChange = external_lodash_["noop"],
  settings = defaultSettings
}) => {
  if (!settings || !settings.length) {
    return null;
  }

  const handleSettingChange = setting => newValue => {
    onChange({ ...value,
      [setting.id]: newValue
    });
  };

  const theSettings = settings.map(setting => Object(external_wp_element_["createElement"])(external_wp_components_["ToggleControl"], {
    className: "block-editor-link-control__setting",
    key: setting.id,
    label: setting.title,
    onChange: handleSettingChange(setting),
    checked: value ? !!value[setting.id] : false
  }));
  return Object(external_wp_element_["createElement"])("fieldset", {
    className: "block-editor-link-control__settings"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["VisuallyHidden"], {
    as: "legend"
  }, Object(external_wp_i18n_["__"])('Currently selected link settings')), theSettings);
};

/* harmony default export */ var settings_drawer = (LinkControlSettingsDrawer);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/url-input/index.js



/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */








/**
 * Internal dependencies
 */



class url_input_URLInput extends external_wp_element_["Component"] {
  constructor(props) {
    super(props);
    this.onChange = this.onChange.bind(this);
    this.onFocus = this.onFocus.bind(this);
    this.onKeyDown = this.onKeyDown.bind(this);
    this.selectLink = this.selectLink.bind(this);
    this.handleOnClick = this.handleOnClick.bind(this);
    this.bindSuggestionNode = this.bindSuggestionNode.bind(this);
    this.autocompleteRef = props.autocompleteRef || Object(external_wp_element_["createRef"])();
    this.inputRef = Object(external_wp_element_["createRef"])();
    this.updateSuggestions = Object(external_lodash_["debounce"])(this.updateSuggestions.bind(this), 200);
    this.suggestionNodes = [];
    this.isUpdatingSuggestions = false;
    this.state = {
      suggestions: [],
      showSuggestions: false,
      selectedSuggestion: null,
      suggestionsListboxId: '',
      suggestionOptionIdPrefix: ''
    };
  }

  componentDidUpdate(prevProps) {
    const {
      showSuggestions,
      selectedSuggestion
    } = this.state;
    const {
      value
    } = this.props; // only have to worry about scrolling selected suggestion into view
    // when already expanded

    if (showSuggestions && selectedSuggestion !== null && this.suggestionNodes[selectedSuggestion] && !this.scrollingIntoView) {
      this.scrollingIntoView = true;
      dom_scroll_into_view_lib_default()(this.suggestionNodes[selectedSuggestion], this.autocompleteRef.current, {
        onlyScrollIfNeeded: true
      });
      this.props.setTimeout(() => {
        this.scrollingIntoView = false;
      }, 100);
    } // Only attempt an update on suggestions if the input value has actually changed.


    if (prevProps.value !== value && this.shouldShowInitialSuggestions()) {
      this.updateSuggestions();
    }
  }

  componentDidMount() {
    if (this.shouldShowInitialSuggestions()) {
      this.updateSuggestions();
    }
  }

  componentWillUnmount() {
    var _this$suggestionsRequ, _this$suggestionsRequ2;

    (_this$suggestionsRequ = this.suggestionsRequest) === null || _this$suggestionsRequ === void 0 ? void 0 : (_this$suggestionsRequ2 = _this$suggestionsRequ.cancel) === null || _this$suggestionsRequ2 === void 0 ? void 0 : _this$suggestionsRequ2.call(_this$suggestionsRequ);
    delete this.suggestionsRequest;
  }

  bindSuggestionNode(index) {
    return ref => {
      this.suggestionNodes[index] = ref;
    };
  }

  shouldShowInitialSuggestions() {
    const {
      suggestions
    } = this.state;
    const {
      __experimentalShowInitialSuggestions = false,
      value
    } = this.props;
    return !this.isUpdatingSuggestions && __experimentalShowInitialSuggestions && !(value && value.length) && !(suggestions && suggestions.length);
  }

  updateSuggestions(value = '') {
    const {
      __experimentalFetchLinkSuggestions: fetchLinkSuggestions,
      __experimentalHandleURLSuggestions: handleURLSuggestions
    } = this.props;

    if (!fetchLinkSuggestions) {
      return;
    }

    const isInitialSuggestions = !(value && value.length); // Allow a suggestions request if:
    // - there are at least 2 characters in the search input (except manual searches where
    //   search input length is not required to trigger a fetch)
    // - this is a direct entry (eg: a URL)

    if (!isInitialSuggestions && (value.length < 2 || !handleURLSuggestions && Object(external_wp_url_["isURL"])(value))) {
      this.setState({
        showSuggestions: false,
        selectedSuggestion: null,
        loading: false
      });
      return;
    }

    this.isUpdatingSuggestions = true;
    this.setState({
      selectedSuggestion: null,
      loading: true
    });
    const request = fetchLinkSuggestions(value, {
      isInitialSuggestions
    });
    request.then(suggestions => {
      // A fetch Promise doesn't have an abort option. It's mimicked by
      // comparing the request reference in on the instance, which is
      // reset or deleted on subsequent requests or unmounting.
      if (this.suggestionsRequest !== request) {
        return;
      }

      this.setState({
        suggestions,
        loading: false,
        showSuggestions: !!suggestions.length
      });

      if (!!suggestions.length) {
        this.props.debouncedSpeak(Object(external_wp_i18n_["sprintf"])(
        /* translators: %s: number of results. */
        Object(external_wp_i18n_["_n"])('%d result found, use up and down arrow keys to navigate.', '%d results found, use up and down arrow keys to navigate.', suggestions.length), suggestions.length), 'assertive');
      } else {
        this.props.debouncedSpeak(Object(external_wp_i18n_["__"])('No results.'), 'assertive');
      }

      this.isUpdatingSuggestions = false;
    }).catch(() => {
      if (this.suggestionsRequest === request) {
        this.setState({
          loading: false
        });
        this.isUpdatingSuggestions = false;
      }
    }); // Note that this assignment is handled *before* the async search request
    // as a Promise always resolves on the next tick of the event loop.

    this.suggestionsRequest = request;
  }

  onChange(event) {
    const inputValue = event.target.value;
    this.props.onChange(inputValue);

    if (!this.props.disableSuggestions) {
      this.updateSuggestions(inputValue.trim());
    }
  }

  onFocus() {
    const {
      suggestions
    } = this.state;
    const {
      disableSuggestions,
      value
    } = this.props; // When opening the link editor, if there's a value present, we want to load the suggestions pane with the results for this input search value
    // Don't re-run the suggestions on focus if there are already suggestions present (prevents searching again when tabbing between the input and buttons)

    if (value && !disableSuggestions && !this.isUpdatingSuggestions && !(suggestions && suggestions.length)) {
      // Ensure the suggestions are updated with the current input value
      this.updateSuggestions(value.trim());
    }
  }

  onKeyDown(event) {
    const {
      showSuggestions,
      selectedSuggestion,
      suggestions,
      loading
    } = this.state; // If the suggestions are not shown or loading, we shouldn't handle the arrow keys
    // We shouldn't preventDefault to allow block arrow keys navigation

    if (!showSuggestions || !suggestions.length || loading) {
      // In the Windows version of Firefox the up and down arrows don't move the caret
      // within an input field like they do for Mac Firefox/Chrome/Safari. This causes
      // a form of focus trapping that is disruptive to the user experience. This disruption
      // only happens if the caret is not in the first or last position in the text input.
      // See: https://github.com/WordPress/gutenberg/issues/5693#issuecomment-436684747
      switch (event.keyCode) {
        // When UP is pressed, if the caret is at the start of the text, move it to the 0
        // position.
        case external_wp_keycodes_["UP"]:
          {
            if (0 !== event.target.selectionStart) {
              event.stopPropagation();
              event.preventDefault(); // Set the input caret to position 0

              event.target.setSelectionRange(0, 0);
            }

            break;
          }
        // When DOWN is pressed, if the caret is not at the end of the text, move it to the
        // last position.

        case external_wp_keycodes_["DOWN"]:
          {
            if (this.props.value.length !== event.target.selectionStart) {
              event.stopPropagation();
              event.preventDefault(); // Set the input caret to the last position

              event.target.setSelectionRange(this.props.value.length, this.props.value.length);
            }

            break;
          }
      }

      return;
    }

    const suggestion = this.state.suggestions[this.state.selectedSuggestion];

    switch (event.keyCode) {
      case external_wp_keycodes_["UP"]:
        {
          event.stopPropagation();
          event.preventDefault();
          const previousIndex = !selectedSuggestion ? suggestions.length - 1 : selectedSuggestion - 1;
          this.setState({
            selectedSuggestion: previousIndex
          });
          break;
        }

      case external_wp_keycodes_["DOWN"]:
        {
          event.stopPropagation();
          event.preventDefault();
          const nextIndex = selectedSuggestion === null || selectedSuggestion === suggestions.length - 1 ? 0 : selectedSuggestion + 1;
          this.setState({
            selectedSuggestion: nextIndex
          });
          break;
        }

      case external_wp_keycodes_["TAB"]:
        {
          if (this.state.selectedSuggestion !== null) {
            this.selectLink(suggestion); // Announce a link has been selected when tabbing away from the input field.

            this.props.speak(Object(external_wp_i18n_["__"])('Link selected.'));
          }

          break;
        }

      case external_wp_keycodes_["ENTER"]:
        {
          if (this.state.selectedSuggestion !== null) {
            event.stopPropagation();
            this.selectLink(suggestion);
          }

          break;
        }
    }
  }

  selectLink(suggestion) {
    this.props.onChange(suggestion.url, suggestion);
    this.setState({
      selectedSuggestion: null,
      showSuggestions: false
    });
  }

  handleOnClick(suggestion) {
    this.selectLink(suggestion); // Move focus to the input field when a link suggestion is clicked.

    this.inputRef.current.focus();
  }

  static getDerivedStateFromProps({
    value,
    instanceId,
    disableSuggestions,
    __experimentalShowInitialSuggestions = false
  }, {
    showSuggestions
  }) {
    let shouldShowSuggestions = showSuggestions;
    const hasValue = value && value.length;

    if (!__experimentalShowInitialSuggestions && !hasValue) {
      shouldShowSuggestions = false;
    }

    if (disableSuggestions === true) {
      shouldShowSuggestions = false;
    }

    return {
      showSuggestions: shouldShowSuggestions,
      suggestionsListboxId: `block-editor-url-input-suggestions-${instanceId}`,
      suggestionOptionIdPrefix: `block-editor-url-input-suggestion-${instanceId}`
    };
  }

  render() {
    return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, this.renderControl(), this.renderSuggestions());
  }

  renderControl() {
    const {
      label,
      className,
      isFullWidth,
      instanceId,
      placeholder = Object(external_wp_i18n_["__"])('Paste URL or type to search'),
      __experimentalRenderControl: renderControl,
      value = ''
    } = this.props;
    const {
      loading,
      showSuggestions,
      selectedSuggestion,
      suggestionsListboxId,
      suggestionOptionIdPrefix
    } = this.state;
    const controlProps = {
      id: `url-input-control-${instanceId}`,
      label,
      className: classnames_default()('block-editor-url-input', className, {
        'is-full-width': isFullWidth
      })
    };
    const inputProps = {
      value,
      required: true,
      className: 'block-editor-url-input__input',
      type: 'text',
      onChange: this.onChange,
      onFocus: this.onFocus,
      placeholder,
      onKeyDown: this.onKeyDown,
      role: 'combobox',
      'aria-label': Object(external_wp_i18n_["__"])('URL'),
      'aria-expanded': showSuggestions,
      'aria-autocomplete': 'list',
      'aria-owns': suggestionsListboxId,
      'aria-activedescendant': selectedSuggestion !== null ? `${suggestionOptionIdPrefix}-${selectedSuggestion}` : undefined,
      ref: this.inputRef
    };

    if (renderControl) {
      return renderControl(controlProps, inputProps, loading);
    }

    return Object(external_wp_element_["createElement"])(external_wp_components_["BaseControl"], controlProps, Object(external_wp_element_["createElement"])("input", inputProps), loading && Object(external_wp_element_["createElement"])(external_wp_components_["Spinner"], null));
  }

  renderSuggestions() {
    const {
      className,
      __experimentalRenderSuggestions: renderSuggestions,
      value = '',
      __experimentalShowInitialSuggestions = false
    } = this.props;
    const {
      showSuggestions,
      suggestions,
      selectedSuggestion,
      suggestionsListboxId,
      suggestionOptionIdPrefix,
      loading
    } = this.state;
    const suggestionsListProps = {
      id: suggestionsListboxId,
      ref: this.autocompleteRef,
      role: 'listbox'
    };

    const buildSuggestionItemProps = (suggestion, index) => {
      return {
        role: 'option',
        tabIndex: '-1',
        id: `${suggestionOptionIdPrefix}-${index}`,
        ref: this.bindSuggestionNode(index),
        'aria-selected': index === selectedSuggestion
      };
    };

    if (Object(external_lodash_["isFunction"])(renderSuggestions) && showSuggestions && !!suggestions.length) {
      return renderSuggestions({
        suggestions,
        selectedSuggestion,
        suggestionsListProps,
        buildSuggestionItemProps,
        isLoading: loading,
        handleSuggestionClick: this.handleOnClick,
        isInitialSuggestions: __experimentalShowInitialSuggestions && !(value && value.length)
      });
    }

    if (!Object(external_lodash_["isFunction"])(renderSuggestions) && showSuggestions && !!suggestions.length) {
      return Object(external_wp_element_["createElement"])(external_wp_components_["Popover"], {
        position: "bottom",
        noArrow: true,
        focusOnMount: false
      }, Object(external_wp_element_["createElement"])("div", Object(esm_extends["a" /* default */])({}, suggestionsListProps, {
        className: classnames_default()('block-editor-url-input__suggestions', `${className}__suggestions`)
      }), suggestions.map((suggestion, index) => Object(external_wp_element_["createElement"])(external_wp_components_["Button"], Object(esm_extends["a" /* default */])({}, buildSuggestionItemProps(suggestion, index), {
        key: suggestion.id,
        className: classnames_default()('block-editor-url-input__suggestion', {
          'is-selected': index === selectedSuggestion
        }),
        onClick: () => this.handleOnClick(suggestion)
      }), suggestion.title))));
    }

    return null;
  }

}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/url-input/README.md
 */


/* harmony default export */ var url_input = (Object(external_wp_compose_["compose"])(external_wp_compose_["withSafeTimeout"], external_wp_components_["withSpokenMessages"], external_wp_compose_["withInstanceId"], Object(external_wp_data_["withSelect"])((select, props) => {
  // If a link suggestions handler is already provided then
  // bail
  if (Object(external_lodash_["isFunction"])(props.__experimentalFetchLinkSuggestions)) {
    return;
  }

  const {
    getSettings
  } = select(store);
  return {
    __experimentalFetchLinkSuggestions: getSettings().__experimentalFetchLinkSuggestions
  };
}))(url_input_URLInput));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/search-create-button.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */





const LinkControlSearchCreate = ({
  searchTerm,
  onClick,
  itemProps,
  isSelected,
  buttonText
}) => {
  if (!searchTerm) {
    return null;
  }

  let text;

  if (buttonText) {
    text = Object(external_lodash_["isFunction"])(buttonText) ? buttonText(searchTerm) : buttonText;
  } else {
    text = Object(external_wp_element_["createInterpolateElement"])(Object(external_wp_i18n_["sprintf"])(
    /* translators: %s: search term. */
    Object(external_wp_i18n_["__"])('Create: <mark>%s</mark>'), searchTerm), {
      mark: Object(external_wp_element_["createElement"])("mark", null)
    });
  }

  return Object(external_wp_element_["createElement"])(external_wp_components_["Button"], Object(esm_extends["a" /* default */])({}, itemProps, {
    className: classnames_default()('block-editor-link-control__search-create block-editor-link-control__search-item', {
      'is-selected': isSelected
    }),
    onClick: onClick
  }), Object(external_wp_element_["createElement"])(build_module_icon["a" /* default */], {
    className: "block-editor-link-control__search-item-icon",
    icon: plus["a" /* default */]
  }), Object(external_wp_element_["createElement"])("span", {
    className: "block-editor-link-control__search-item-header"
  }, Object(external_wp_element_["createElement"])("span", {
    className: "block-editor-link-control__search-item-title"
  }, text)));
};
/* harmony default export */ var search_create_button = (LinkControlSearchCreate);

// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/globe.js


/**
 * WordPress dependencies
 */

const globe = Object(external_wp_element_["createElement"])(external_wp_primitives_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "-2 -2 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_primitives_["Path"], {
  d: "M9 0C4.03 0 0 4.03 0 9s4.03 9 9 9 9-4.03 9-9-4.03-9-9-9zM1.11 9.68h2.51c.04.91.167 1.814.38 2.7H1.84c-.403-.85-.65-1.764-.73-2.7zm8.57-5.4V1.19c.964.366 1.756 1.08 2.22 2 .205.347.386.708.54 1.08l-2.76.01zm3.22 1.35c.232.883.37 1.788.41 2.7H9.68v-2.7h3.22zM8.32 1.19v3.09H5.56c.154-.372.335-.733.54-1.08.462-.924 1.255-1.64 2.22-2.01zm0 4.44v2.7H4.7c.04-.912.178-1.817.41-2.7h3.21zm-4.7 2.69H1.11c.08-.936.327-1.85.73-2.7H4c-.213.886-.34 1.79-.38 2.7zM4.7 9.68h3.62v2.7H5.11c-.232-.883-.37-1.788-.41-2.7zm3.63 4v3.09c-.964-.366-1.756-1.08-2.22-2-.205-.347-.386-.708-.54-1.08l2.76-.01zm1.35 3.09v-3.04h2.76c-.154.372-.335.733-.54 1.08-.464.92-1.256 1.634-2.22 2v-.04zm0-4.44v-2.7h3.62c-.04.912-.178 1.817-.41 2.7H9.68zm4.71-2.7h2.51c-.08.936-.327 1.85-.73 2.7H14c.21-.87.337-1.757.38-2.65l.01-.05zm0-1.35c-.046-.894-.176-1.78-.39-2.65h2.16c.403.85.65 1.764.73 2.7l-2.5-.05zm1-4H13.6c-.324-.91-.793-1.76-1.39-2.52 1.244.56 2.325 1.426 3.14 2.52h.04zm-9.6-2.52c-.597.76-1.066 1.61-1.39 2.52H2.65c.815-1.094 1.896-1.96 3.14-2.52zm-3.15 12H4.4c.324.91.793 1.76 1.39 2.52-1.248-.567-2.33-1.445-3.14-2.55l-.01.03zm9.56 2.52c.597-.76 1.066-1.61 1.39-2.52h1.76c-.82 1.08-1.9 1.933-3.14 2.48l-.01.04z"
}));
/* harmony default export */ var library_globe = (globe);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/search-item.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





const LinkControlSearchItem = ({
  itemProps,
  suggestion,
  isSelected = false,
  onClick,
  isURL = false,
  searchTerm = '',
  shouldShowType = false
}) => {
  return Object(external_wp_element_["createElement"])(external_wp_components_["Button"], Object(esm_extends["a" /* default */])({}, itemProps, {
    onClick: onClick,
    className: classnames_default()('block-editor-link-control__search-item', {
      'is-selected': isSelected,
      'is-url': isURL,
      'is-entity': !isURL
    })
  }), isURL && Object(external_wp_element_["createElement"])(build_module_icon["a" /* default */], {
    className: "block-editor-link-control__search-item-icon",
    icon: library_globe
  }), Object(external_wp_element_["createElement"])("span", {
    className: "block-editor-link-control__search-item-header"
  }, Object(external_wp_element_["createElement"])("span", {
    className: "block-editor-link-control__search-item-title"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["TextHighlight"], {
    text: suggestion.title,
    highlight: searchTerm
  })), Object(external_wp_element_["createElement"])("span", {
    "aria-hidden": !isURL,
    className: "block-editor-link-control__search-item-info"
  }, !isURL && (Object(external_wp_url_["filterURLForDisplay"])(Object(external_wp_url_["safeDecodeURI"])(suggestion.url)) || ''), isURL && Object(external_wp_i18n_["__"])('Press ENTER to add this link'))), shouldShowType && suggestion.type && Object(external_wp_element_["createElement"])("span", {
    className: "block-editor-link-control__search-item-type"
  }, suggestion.type === 'post_tag' ? 'tag' : suggestion.type));
};
/* harmony default export */ var search_item = (LinkControlSearchItem);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/constants.js
// Used as a unique identifier for the "Create" option within search results.
// Used to help distinguish the "Create" suggestion within the search results in
// order to handle it as a unique case.
const CREATE_TYPE = '__CREATE__';

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/search-results.js


/**
 * WordPress dependencies
 */


/**
 * External dependencies
 */



/**
 * Internal dependencies
 */




function LinkControlSearchResults({
  instanceId,
  withCreateSuggestion,
  currentInputValue,
  handleSuggestionClick,
  suggestionsListProps,
  buildSuggestionItemProps,
  suggestions,
  selectedSuggestion,
  isLoading,
  isInitialSuggestions,
  createSuggestionButtonText,
  suggestionsQuery
}) {
  const resultsListClasses = classnames_default()('block-editor-link-control__search-results', {
    'is-loading': isLoading
  });
  const directLinkEntryTypes = ['url', 'mailto', 'tel', 'internal'];
  const isSingleDirectEntryResult = suggestions.length === 1 && directLinkEntryTypes.includes(suggestions[0].type.toLowerCase());
  const shouldShowCreateSuggestion = withCreateSuggestion && !isSingleDirectEntryResult && !isInitialSuggestions; // If the query has a specified type, then we can skip showing them in the result. See #24839.

  const shouldShowSuggestionsTypes = !(suggestionsQuery !== null && suggestionsQuery !== void 0 && suggestionsQuery.type); // According to guidelines aria-label should be added if the label
  // itself is not visible.
  // See: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/listbox_role

  const searchResultsLabelId = `block-editor-link-control-search-results-label-${instanceId}`;
  const labelText = isInitialSuggestions ? Object(external_wp_i18n_["__"])('Recently updated') : Object(external_wp_i18n_["sprintf"])(
  /* translators: %s: search term. */
  Object(external_wp_i18n_["__"])('Search results for "%s"'), currentInputValue); // VisuallyHidden rightly doesn't accept custom classNames
  // so we conditionally render it as a wrapper to visually hide the label
  // when that is required.

  const searchResultsLabel = Object(external_wp_element_["createElement"])(isInitialSuggestions ? external_wp_element_["Fragment"] : external_wp_components_["VisuallyHidden"], {}, // empty props
  Object(external_wp_element_["createElement"])("span", {
    className: "block-editor-link-control__search-results-label",
    id: searchResultsLabelId
  }, labelText));
  return Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-link-control__search-results-wrapper"
  }, searchResultsLabel, Object(external_wp_element_["createElement"])("div", Object(esm_extends["a" /* default */])({}, suggestionsListProps, {
    className: resultsListClasses,
    "aria-labelledby": searchResultsLabelId
  }), suggestions.map((suggestion, index) => {
    if (shouldShowCreateSuggestion && CREATE_TYPE === suggestion.type) {
      return Object(external_wp_element_["createElement"])(search_create_button, {
        searchTerm: currentInputValue,
        buttonText: createSuggestionButtonText,
        onClick: () => handleSuggestionClick(suggestion) // Intentionally only using `type` here as
        // the constant is enough to uniquely
        // identify the single "CREATE" suggestion.
        ,
        key: suggestion.type,
        itemProps: buildSuggestionItemProps(suggestion, index),
        isSelected: index === selectedSuggestion
      });
    } // If we're not handling "Create" suggestions above then
    // we don't want them in the main results so exit early


    if (CREATE_TYPE === suggestion.type) {
      return null;
    }

    return Object(external_wp_element_["createElement"])(search_item, {
      key: `${suggestion.id}-${suggestion.type}`,
      itemProps: buildSuggestionItemProps(suggestion, index),
      suggestion: suggestion,
      index: index,
      onClick: () => {
        handleSuggestionClick(suggestion);
      },
      isSelected: index === selectedSuggestion,
      isURL: directLinkEntryTypes.includes(suggestion.type.toLowerCase()),
      searchTerm: currentInputValue,
      shouldShowType: shouldShowSuggestionsTypes
    });
  })));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/is-url-like.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Determines whether a given value could be a URL. Note this does not
 * guarantee the value is a URL only that it looks like it might be one. For
 * example, just because a string has `www.` in it doesn't make it a URL,
 * but it does make it highly likely that it will be so in the context of
 * creating a link it makes sense to treat it like one.
 *
 * @param {string} val the candidate for being URL-like (or not).
 * @return {boolean}   whether or not the value is potentially a URL.
 */

function isURLLike(val) {
  const isInternal = Object(external_lodash_["startsWith"])(val, '#');
  return Object(external_wp_url_["isURL"])(val) || val && val.includes('www.') || isInternal;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/use-search-handler.js
/**
 * WordPress dependencies
 */



/**
 * External dependencies
 */


/**
 * Internal dependencies
 */




const handleNoop = () => Promise.resolve([]);
const handleDirectEntry = val => {
  let type = 'URL';
  const protocol = Object(external_wp_url_["getProtocol"])(val) || '';

  if (protocol.includes('mailto')) {
    type = 'mailto';
  }

  if (protocol.includes('tel')) {
    type = 'tel';
  }

  if (Object(external_lodash_["startsWith"])(val, '#')) {
    type = 'internal';
  }

  return Promise.resolve([{
    id: val,
    title: val,
    url: type === 'URL' ? Object(external_wp_url_["prependHTTP"])(val) : val,
    type
  }]);
};

const handleEntitySearch = async (val, suggestionsQuery, fetchSearchSuggestions, directEntryHandler, withCreateSuggestion, withURLSuggestion) => {
  const {
    isInitialSuggestions
  } = suggestionsQuery;
  let results = await Promise.all([fetchSearchSuggestions(val, suggestionsQuery), directEntryHandler(val)]);
  const couldBeURL = !val.includes(' '); // If it's potentially a URL search then concat on a URL search suggestion
  // just for good measure. That way once the actual results run out we always
  // have a URL option to fallback on.

  if (couldBeURL && withURLSuggestion && !isInitialSuggestions) {
    results = results[0].concat(results[1]);
  } else {
    results = results[0];
  } // If displaying initial suggestions just return plain results.


  if (isInitialSuggestions) {
    return results;
  } // Here we append a faux suggestion to represent a "CREATE" option. This
  // is detected in the rendering of the search results and handled as a
  // special case. This is currently necessary because the suggestions
  // dropdown will only appear if there are valid suggestions and
  // therefore unless the create option is a suggestion it will not
  // display in scenarios where there are no results returned from the
  // API. In addition promoting CREATE to a first class suggestion affords
  // the a11y benefits afforded by `URLInput` to all suggestions (eg:
  // keyboard handling, ARIA roles...etc).
  //
  // Note also that the value of the `title` and `url` properties must correspond
  // to the text value of the `<input>`. This is because `title` is used
  // when creating the suggestion. Similarly `url` is used when using keyboard to select
  // the suggestion (the <form> `onSubmit` handler falls-back to `url`).


  return isURLLike(val) || !withCreateSuggestion ? results : results.concat({
    // the `id` prop is intentionally ommitted here because it
    // is never exposed as part of the component's public API.
    // see: https://github.com/WordPress/gutenberg/pull/19775#discussion_r378931316.
    title: val,
    // must match the existing `<input>`s text value
    url: val,
    // must match the existing `<input>`s text value
    type: CREATE_TYPE
  });
};

function useSearchHandler(suggestionsQuery, allowDirectEntry, withCreateSuggestion, withURLSuggestion) {
  const {
    fetchSearchSuggestions
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getSettings
    } = select(store);
    return {
      fetchSearchSuggestions: getSettings().__experimentalFetchLinkSuggestions
    };
  }, []);
  const directEntryHandler = allowDirectEntry ? handleDirectEntry : handleNoop;
  return Object(external_wp_element_["useCallback"])((val, {
    isInitialSuggestions
  }) => {
    return isURLLike(val) ? directEntryHandler(val, {
      isInitialSuggestions
    }) : handleEntitySearch(val, { ...suggestionsQuery,
      isInitialSuggestions
    }, fetchSearchSuggestions, directEntryHandler, withCreateSuggestion, withURLSuggestion);
  }, [directEntryHandler, fetchSearchSuggestions, withCreateSuggestion]);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/search-input.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





const noopSearchHandler = Promise.resolve([]);
const LinkControlSearchInput = Object(external_wp_element_["forwardRef"])(({
  value,
  children,
  currentLink = {},
  className = null,
  placeholder = null,
  withCreateSuggestion = false,
  onCreateSuggestion = external_lodash_["noop"],
  onChange = external_lodash_["noop"],
  onSelect = external_lodash_["noop"],
  showSuggestions = true,
  renderSuggestions = props => Object(external_wp_element_["createElement"])(LinkControlSearchResults, props),
  fetchSuggestions = null,
  allowDirectEntry = true,
  showInitialSuggestions = false,
  suggestionsQuery = {},
  withURLSuggestion = true,
  createSuggestionButtonText
}, ref) => {
  const genericSearchHandler = useSearchHandler(suggestionsQuery, allowDirectEntry, withCreateSuggestion, withURLSuggestion);
  const searchHandler = showSuggestions ? fetchSuggestions || genericSearchHandler : noopSearchHandler;
  const instanceId = Object(external_wp_compose_["useInstanceId"])(LinkControlSearchInput);
  const [focusedSuggestion, setFocusedSuggestion] = Object(external_wp_element_["useState"])();
  /**
   * Handles the user moving between different suggestions. Does not handle
   * choosing an individual item.
   *
   * @param {string} selection the url of the selected suggestion.
   * @param {Object} suggestion the suggestion object.
   */

  const onInputChange = (selection, suggestion) => {
    onChange(selection);
    setFocusedSuggestion(suggestion);
  };

  const onFormSubmit = event => {
    event.preventDefault();
    onSuggestionSelected(focusedSuggestion || {
      url: value
    });
  };

  const handleRenderSuggestions = props => renderSuggestions({ ...props,
    instanceId,
    withCreateSuggestion,
    currentInputValue: value,
    createSuggestionButtonText,
    suggestionsQuery,
    handleSuggestionClick: suggestion => {
      if (props.handleSuggestionClick) {
        props.handleSuggestionClick(suggestion);
      }

      onSuggestionSelected(suggestion);
    }
  });

  const onSuggestionSelected = async selectedSuggestion => {
    let suggestion = selectedSuggestion;

    if (CREATE_TYPE === selectedSuggestion.type) {
      // Create a new page and call onSelect with the output from the onCreateSuggestion callback
      try {
        var _suggestion;

        suggestion = await onCreateSuggestion(selectedSuggestion.title);

        if ((_suggestion = suggestion) !== null && _suggestion !== void 0 && _suggestion.url) {
          onSelect(suggestion);
        }
      } catch (e) {}

      return;
    }

    if (allowDirectEntry || suggestion && Object.keys(suggestion).length >= 1) {
      onSelect( // Some direct entries don't have types or IDs, and we still need to clear the previous ones.
      { ...Object(external_lodash_["omit"])(currentLink, 'id', 'url'),
        ...suggestion
      }, suggestion);
    }
  };

  return Object(external_wp_element_["createElement"])("form", {
    onSubmit: onFormSubmit
  }, Object(external_wp_element_["createElement"])(url_input, {
    className: className,
    value: value,
    onChange: onInputChange,
    placeholder: placeholder !== null && placeholder !== void 0 ? placeholder : Object(external_wp_i18n_["__"])('Search or type url'),
    __experimentalRenderSuggestions: showSuggestions ? handleRenderSuggestions : null,
    __experimentalFetchLinkSuggestions: searchHandler,
    __experimentalHandleURLSuggestions: true,
    __experimentalShowInitialSuggestions: showInitialSuggestions,
    ref: ref
  }), children);
});
/* harmony default export */ var search_input = (LinkControlSearchInput);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/viewer-slot.js
/**
 * WordPress dependencies
 */

const {
  Slot: ViewerSlot,
  Fill: ViewerFill
} = Object(external_wp_components_["createSlotFill"])('BlockEditorLinkControlViewer');

/* harmony default export */ var viewer_slot = (ViewerSlot);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/link-preview.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


function LinkPreview({
  value,
  onEditClick
}) {
  const displayURL = value && Object(external_wp_url_["filterURLForDisplay"])(Object(external_wp_url_["safeDecodeURI"])(value.url), 16) || '';
  return Object(external_wp_element_["createElement"])("div", {
    "aria-label": Object(external_wp_i18n_["__"])('Currently selected'),
    "aria-selected": "true",
    className: classnames_default()('block-editor-link-control__search-item', {
      'is-current': true
    })
  }, Object(external_wp_element_["createElement"])("span", {
    className: "block-editor-link-control__search-item-header"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["ExternalLink"], {
    className: "block-editor-link-control__search-item-title",
    href: value.url
  }, value && value.title || displayURL), value && value.title && Object(external_wp_element_["createElement"])("span", {
    className: "block-editor-link-control__search-item-info"
  }, displayURL)), Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    isSecondary: true,
    onClick: () => onEditClick(),
    className: "block-editor-link-control__search-item-action"
  }, Object(external_wp_i18n_["__"])('Edit')), Object(external_wp_element_["createElement"])(ViewerSlot, {
    fillProps: value
  }));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/use-create-page.js
/**
 * WordPress dependencies
 */


function useCreatePage(handleCreatePage) {
  const cancelableCreateSuggestion = Object(external_wp_element_["useRef"])();
  const [isCreatingPage, setIsCreatingPage] = Object(external_wp_element_["useState"])(false);
  const [errorMessage, setErrorMessage] = Object(external_wp_element_["useState"])(null);

  const createPage = async function (suggestionTitle) {
    setIsCreatingPage(true);
    setErrorMessage(null);

    try {
      // Make cancellable in order that we can avoid setting State
      // if the component unmounts during the call to `createSuggestion`
      cancelableCreateSuggestion.current = makeCancelable( // Using Promise.resolve to allow createSuggestion to return a
      // non-Promise based value.
      Promise.resolve(handleCreatePage(suggestionTitle)));
      return await cancelableCreateSuggestion.current.promise;
    } catch (error) {
      if (error && error.isCanceled) {
        return; // bail if canceled to avoid setting state
      }

      setErrorMessage(error.message || Object(external_wp_i18n_["__"])('An unknown error occurred during creation. Please try again.'));
      throw error;
    } finally {
      setIsCreatingPage(false);
    }
  };
  /**
   * Handles cancelling any pending Promises that have been made cancelable.
   */


  Object(external_wp_element_["useEffect"])(() => {
    return () => {
      // componentDidUnmount
      if (cancelableCreateSuggestion.current) {
        cancelableCreateSuggestion.current.cancel();
      }
    };
  }, []);
  return {
    createPage,
    isCreatingPage,
    errorMessage
  };
}
/**
 * Creates a wrapper around a promise which allows it to be programmatically
 * cancelled.
 * See: https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html
 *
 * @param {Promise} promise the Promise to make cancelable
 */

const makeCancelable = promise => {
  let hasCanceled_ = false;
  const wrappedPromise = new Promise((resolve, reject) => {
    promise.then(val => hasCanceled_ ? reject({
      isCanceled: true
    }) : resolve(val), error => hasCanceled_ ? reject({
      isCanceled: true
    }) : reject(error));
  });
  return {
    promise: wrappedPromise,

    cancel() {
      hasCanceled_ = true;
    }

  };
};

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/link-control/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */






/**
 * Default properties associated with a link control value.
 *
 * @typedef WPLinkControlDefaultValue
 *
 * @property {string}   url           Link URL.
 * @property {string=}  title         Link title.
 * @property {boolean=} opensInNewTab Whether link should open in a new browser
 *                                    tab. This value is only assigned if not
 *                                    providing a custom `settings` prop.
 */

/* eslint-disable jsdoc/valid-types */

/**
 * Custom settings values associated with a link.
 *
 * @typedef {{[setting:string]:any}} WPLinkControlSettingsValue
 */

/* eslint-enable */

/**
 * Custom settings values associated with a link.
 *
 * @typedef WPLinkControlSetting
 *
 * @property {string} id    Identifier to use as property for setting value.
 * @property {string} title Human-readable label to show in user interface.
 */

/**
 * Properties associated with a link control value, composed as a union of the
 * default properties and any custom settings values.
 *
 * @typedef {WPLinkControlDefaultValue&WPLinkControlSettingsValue} WPLinkControlValue
 */

/** @typedef {(nextValue:WPLinkControlValue)=>void} WPLinkControlOnChangeProp */

/**
 * Properties associated with a search suggestion used within the LinkControl.
 *
 * @typedef WPLinkControlSuggestion
 *
 * @property {string} id    Identifier to use to uniquely identify the suggestion.
 * @property {string} type  Identifies the type of the suggestion (eg: `post`,
 *                          `page`, `url`...etc)
 * @property {string} title Human-readable label to show in user interface.
 * @property {string} url   A URL for the suggestion.
 */

/** @typedef {(title:string)=>WPLinkControlSuggestion} WPLinkControlCreateSuggestionProp */

/**
 * @typedef WPLinkControlProps
 *
 * @property {(WPLinkControlSetting[])=}  settings                   An array of settings objects. Each object will used to
 *                                                                   render a `ToggleControl` for that setting.
 * @property {boolean=}                   forceIsEditingLink         If passed as either `true` or `false`, controls the
 *                                                                   internal editing state of the component to respective
 *                                                                   show or not show the URL input field.
 * @property {WPLinkControlValue=}        value                      Current link value.
 * @property {WPLinkControlOnChangeProp=} onChange                   Value change handler, called with the updated value if
 *                                                                   the user selects a new link or updates settings.
 * @property {boolean=}                   noDirectEntry              Whether to allow turning a URL-like search query directly into a link.
 * @property {boolean=}                   showSuggestions            Whether to present suggestions when typing the URL.
 * @property {boolean=}                   showInitialSuggestions     Whether to present initial suggestions immediately.
 * @property {boolean=}                   withCreateSuggestion       Whether to allow creation of link value from suggestion.
 * @property {Object=}                    suggestionsQuery           Query parameters to pass along to wp.blockEditor.__experimentalFetchLinkSuggestions.
 * @property {boolean=}                   noURLSuggestion            Whether to add a fallback suggestion which treats the search query as a URL.
 * @property {string|Function|undefined}  createSuggestionButtonText The text to use in the button that calls createSuggestion.
 */

/**
 * Renders a link control. A link control is a controlled input which maintains
 * a value associated with a link (HTML anchor element) and relevant settings
 * for how that link is expected to behave.
 *
 * @param {WPLinkControlProps} props Component props.
 */

function LinkControl({
  searchInputPlaceholder,
  value,
  settings,
  onChange = external_lodash_["noop"],
  noDirectEntry = false,
  showSuggestions = true,
  showInitialSuggestions,
  forceIsEditingLink,
  createSuggestion,
  withCreateSuggestion,
  inputValue: propInputValue = '',
  suggestionsQuery = {},
  noURLSuggestion = false,
  createSuggestionButtonText
}) {
  if (withCreateSuggestion === undefined && createSuggestion) {
    withCreateSuggestion = true;
  }

  const isMounting = Object(external_wp_element_["useRef"])(true);
  const wrapperNode = Object(external_wp_element_["useRef"])();
  const [internalInputValue, setInternalInputValue] = Object(external_wp_element_["useState"])(value && value.url || '');
  const currentInputValue = propInputValue || internalInputValue;
  const [isEditingLink, setIsEditingLink] = Object(external_wp_element_["useState"])(forceIsEditingLink !== undefined ? forceIsEditingLink : !value || !value.url);
  const isEndingEditWithFocus = Object(external_wp_element_["useRef"])(false);
  Object(external_wp_element_["useEffect"])(() => {
    if (forceIsEditingLink !== undefined && forceIsEditingLink !== isEditingLink) {
      setIsEditingLink(forceIsEditingLink);
    }
  }, [forceIsEditingLink]);
  Object(external_wp_element_["useEffect"])(() => {
    if (isMounting.current) {
      isMounting.current = false;
      return;
    } // When `isEditingLink` changes, a focus loss could occur
    // since the link input may be removed from the DOM. To avoid this,
    // reinstate focus to a suitable target if focus has in-fact been lost.
    // Note that the check is necessary because while typically unsetting
    // edit mode would render the read-only mode's link element, it isn't
    // guaranteed. The link input may continue to be shown if the next value
    // is still unassigned after calling `onChange`.


    const hadFocusLoss = !wrapperNode.current.contains(wrapperNode.current.ownerDocument.activeElement);

    if (hadFocusLoss) {
      // Prefer to focus a natural focusable descendent of the wrapper,
      // but settle for the wrapper if there are no other options.
      const nextFocusTarget = external_wp_dom_["focus"].focusable.find(wrapperNode.current)[0] || wrapperNode.current;
      nextFocusTarget.focus();
    }

    isEndingEditWithFocus.current = false;
  }, [isEditingLink]);
  /**
   * Cancels editing state and marks that focus may need to be restored after
   * the next render, if focus was within the wrapper when editing finished.
   */

  function stopEditing() {
    var _wrapperNode$current;

    isEndingEditWithFocus.current = !!((_wrapperNode$current = wrapperNode.current) !== null && _wrapperNode$current !== void 0 && _wrapperNode$current.contains(wrapperNode.current.ownerDocument.activeElement));
    setIsEditingLink(false);
  }

  const {
    createPage,
    isCreatingPage,
    errorMessage
  } = useCreatePage(createSuggestion);

  const handleSelectSuggestion = updatedValue => {
    onChange(updatedValue);
    stopEditing();
  };

  return Object(external_wp_element_["createElement"])("div", {
    tabIndex: -1,
    ref: wrapperNode,
    className: "block-editor-link-control"
  }, isCreatingPage && Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-link-control__loading"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["Spinner"], null), " ", Object(external_wp_i18n_["__"])('Creating'), "\u2026"), (isEditingLink || !value) && !isCreatingPage && Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-link-control__search-input-wrapper"
  }, Object(external_wp_element_["createElement"])(search_input, {
    currentLink: value,
    className: "block-editor-link-control__search-input",
    placeholder: searchInputPlaceholder,
    value: currentInputValue,
    withCreateSuggestion: withCreateSuggestion,
    onCreateSuggestion: createPage,
    onChange: setInternalInputValue,
    onSelect: handleSelectSuggestion,
    showInitialSuggestions: showInitialSuggestions,
    allowDirectEntry: !noDirectEntry,
    showSuggestions: showSuggestions,
    suggestionsQuery: suggestionsQuery,
    withURLSuggestion: !noURLSuggestion,
    createSuggestionButtonText: createSuggestionButtonText
  }, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-link-control__search-actions"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    type: "submit",
    label: Object(external_wp_i18n_["__"])('Submit'),
    icon: keyboard_return["a" /* default */],
    className: "block-editor-link-control__search-submit"
  })))), errorMessage && Object(external_wp_element_["createElement"])(external_wp_components_["Notice"], {
    className: "block-editor-link-control__search-error",
    status: "error",
    isDismissible: false
  }, errorMessage)), value && !isEditingLink && !isCreatingPage && Object(external_wp_element_["createElement"])(LinkPreview, {
    value: value,
    onEditClick: () => setIsEditingLink(true)
  }), Object(external_wp_element_["createElement"])(settings_drawer, {
    value: value,
    settings: settings,
    onChange: onChange
  }));
}

LinkControl.ViewerFill = ViewerFill;
/* harmony default export */ var link_control = (LinkControl);

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/media.js
var library_media = __webpack_require__("rH4q");

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/upload.js
var upload = __webpack_require__("NTP4");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/media-upload/index.js
/**
 * WordPress dependencies
 */

/**
 * This is a placeholder for the media upload component necessary to make it possible to provide
 * an integration with the core blocks that handle media files. By default it renders nothing but
 * it provides a way to have it overridden with the `editor.MediaUpload` filter.
 *
 * @return {WPComponent} The component to be rendered.
 */

const MediaUpload = () => null;
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/media-upload/README.md
 */


/* harmony default export */ var media_upload = (Object(external_wp_components_["withFilters"])('editor.MediaUpload')(MediaUpload));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/media-upload/check.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


function MediaUploadCheck({
  fallback = null,
  children
}) {
  const hasUploadPermissions = Object(external_wp_data_["useSelect"])(select => {
    const {
      getSettings
    } = select(store);
    return !!getSettings().mediaUpload;
  }, []);
  return hasUploadPermissions ? children : fallback;
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/media-upload/README.md
 */

/* harmony default export */ var check = (MediaUploadCheck);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/media-replace-flow/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */










/**
 * Internal dependencies
 */






const MediaReplaceFlow = ({
  mediaURL,
  mediaId,
  allowedTypes,
  accept,
  onSelect,
  onSelectURL,
  onFilesUpload = external_lodash_["noop"],
  name = Object(external_wp_i18n_["__"])('Replace'),
  createNotice,
  removeNotice
}) => {
  const [mediaURLValue, setMediaURLValue] = Object(external_wp_element_["useState"])(mediaURL);
  const mediaUpload = Object(external_wp_data_["useSelect"])(select => {
    return select(store).getSettings().mediaUpload;
  }, []);
  const editMediaButtonRef = Object(external_wp_element_["createRef"])();
  const errorNoticeID = Object(external_lodash_["uniqueId"])('block-editor/media-replace-flow/error-notice/');

  const onError = message => {
    const errorElement = document.createElement('div');
    errorElement.innerHTML = Object(external_wp_element_["renderToString"])(message); // The default error contains some HTML that,
    // for example, makes the filename bold.
    // The notice, by default, accepts strings only and so
    // we need to remove the html from the error.

    const renderMsg = errorElement.textContent || errorElement.innerText || ''; // We need to set a timeout for showing the notice
    // so that VoiceOver and possibly other screen readers
    // can announce the error afer the toolbar button
    // regains focus once the upload dialog closes.
    // Otherwise VO simply skips over the notice and announces
    // the focused element and the open menu.

    setTimeout(() => {
      createNotice('error', renderMsg, {
        speak: true,
        id: errorNoticeID,
        isDismissible: true
      });
    }, 1000);
  };

  const selectMedia = media => {
    onSelect(media);
    setMediaURLValue(media.url);
    Object(external_wp_a11y_["speak"])(Object(external_wp_i18n_["__"])('The media file has been replaced'));
    removeNotice(errorNoticeID);
  };

  const selectURL = newURL => {
    onSelectURL(newURL);
  };

  const uploadFiles = event => {
    const files = event.target.files;
    onFilesUpload(files);

    const setMedia = ([media]) => {
      selectMedia(media);
    };

    mediaUpload({
      allowedTypes,
      filesList: files,
      onFileChange: setMedia,
      onError
    });
  };

  const openOnArrowDown = event => {
    if (event.keyCode === external_wp_keycodes_["DOWN"]) {
      event.preventDefault();
      event.stopPropagation();
      event.target.click();
    }
  };

  const POPOVER_PROPS = {
    isAlternate: true
  };
  return Object(external_wp_element_["createElement"])(external_wp_components_["Dropdown"], {
    popoverProps: POPOVER_PROPS,
    contentClassName: "block-editor-media-replace-flow__options",
    renderToggle: ({
      isOpen,
      onToggle
    }) => Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarButton"], {
      ref: editMediaButtonRef,
      "aria-expanded": isOpen,
      "aria-haspopup": "true",
      onClick: onToggle,
      onKeyDown: openOnArrowDown
    }, name),
    renderContent: ({
      onClose
    }) => Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(external_wp_components_["NavigableMenu"], {
      className: "block-editor-media-replace-flow__media-upload-menu"
    }, Object(external_wp_element_["createElement"])(media_upload, {
      value: mediaId,
      onSelect: media => selectMedia(media),
      allowedTypes: allowedTypes,
      render: ({
        open
      }) => Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
        icon: library_media["a" /* default */],
        onClick: open
      }, Object(external_wp_i18n_["__"])('Open Media Library'))
    }), Object(external_wp_element_["createElement"])(check, null, Object(external_wp_element_["createElement"])(external_wp_components_["FormFileUpload"], {
      onChange: event => {
        uploadFiles(event, onClose);
      },
      accept: accept,
      render: ({
        openFileDialog
      }) => {
        return Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
          icon: upload["a" /* default */],
          onClick: () => {
            openFileDialog();
          }
        }, Object(external_wp_i18n_["__"])('Upload'));
      }
    }))), onSelectURL && // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
    Object(external_wp_element_["createElement"])("form", {
      className: "block-editor-media-flow__url-input",
      onKeyDown: event => {
        if (![external_wp_keycodes_["TAB"], external_wp_keycodes_["ESCAPE"]].includes(event.keyCode)) {
          event.stopPropagation();
        }
      },
      onKeyPress: event => {
        if (![external_wp_keycodes_["TAB"], external_wp_keycodes_["ESCAPE"]].includes(event.keyCode)) {
          event.stopPropagation();
        }
      }
    }, Object(external_wp_element_["createElement"])("span", {
      className: "block-editor-media-replace-flow__image-url-label"
    }, Object(external_wp_i18n_["__"])('Current media URL:')), Object(external_wp_element_["createElement"])(link_control, {
      value: {
        url: mediaURLValue
      },
      settings: [],
      showSuggestions: false,
      onChange: ({
        url
      }) => {
        setMediaURLValue(url);
        selectURL(url);
        editMediaButtonRef.current.focus();
      }
    })))
  });
};

/* harmony default export */ var media_replace_flow = (Object(external_wp_compose_["compose"])([Object(external_wp_data_["withDispatch"])(dispatch => {
  const {
    createNotice,
    removeNotice
  } = dispatch(external_wp_notices_["store"]);
  return {
    createNotice,
    removeNotice
  };
}), Object(external_wp_components_["withFilters"])('editor.MediaReplaceFlow')])(MediaReplaceFlow));

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/edit.js + 1 modules
var library_edit = __webpack_require__("B9Az");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/url-popover/link-viewer-url.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



function LinkViewerURL({
  url,
  urlLabel,
  className
}) {
  const linkClassName = classnames_default()(className, 'block-editor-url-popover__link-viewer-url');

  if (!url) {
    return Object(external_wp_element_["createElement"])("span", {
      className: linkClassName
    });
  }

  return Object(external_wp_element_["createElement"])(external_wp_components_["ExternalLink"], {
    className: linkClassName,
    href: url
  }, urlLabel || Object(external_wp_url_["filterURLForDisplay"])(Object(external_wp_url_["safeDecodeURI"])(url)));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/url-popover/link-viewer.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


function LinkViewer({
  className,
  linkClassName,
  onEditLinkClick,
  url,
  urlLabel,
  ...props
}) {
  return Object(external_wp_element_["createElement"])("div", Object(esm_extends["a" /* default */])({
    className: classnames_default()('block-editor-url-popover__link-viewer', className)
  }, props), Object(external_wp_element_["createElement"])(LinkViewerURL, {
    url: url,
    urlLabel: urlLabel,
    className: linkClassName
  }), onEditLinkClick && Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    icon: library_edit["a" /* default */],
    label: Object(external_wp_i18n_["__"])('Edit'),
    onClick: onEditLinkClick
  }));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/url-popover/link-editor.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


function LinkEditor({
  autocompleteRef,
  className,
  onChangeInputValue,
  value,
  ...props
}) {
  return Object(external_wp_element_["createElement"])("form", Object(esm_extends["a" /* default */])({
    className: classnames_default()('block-editor-url-popover__link-editor', className)
  }, props), Object(external_wp_element_["createElement"])(url_input, {
    value: value,
    onChange: onChangeInputValue,
    autocompleteRef: autocompleteRef
  }), Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    icon: keyboard_return["a" /* default */],
    label: Object(external_wp_i18n_["__"])('Apply'),
    type: "submit"
  }));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/url-popover/index.js



/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




function URLPopover({
  additionalControls,
  children,
  renderSettings,
  position = 'bottom center',
  focusOnMount = 'firstElement',
  ...popoverProps
}) {
  const [isSettingsExpanded, setIsSettingsExpanded] = Object(external_wp_element_["useState"])(false);
  const showSettings = !!renderSettings && isSettingsExpanded;

  const toggleSettingsVisibility = () => {
    setIsSettingsExpanded(!isSettingsExpanded);
  };

  return Object(external_wp_element_["createElement"])(external_wp_components_["Popover"], Object(esm_extends["a" /* default */])({
    className: "block-editor-url-popover",
    focusOnMount: focusOnMount,
    position: position
  }, popoverProps), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-url-popover__input-container"
  }, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-url-popover__row"
  }, children, !!renderSettings && Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    className: "block-editor-url-popover__settings-toggle",
    icon: chevron_down["a" /* default */],
    label: Object(external_wp_i18n_["__"])('Link settings'),
    onClick: toggleSettingsVisibility,
    "aria-expanded": isSettingsExpanded
  })), showSettings && Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-url-popover__row block-editor-url-popover__settings"
  }, renderSettings())), additionalControls && !showSettings && Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-url-popover__additional-controls"
  }, additionalControls));
}

URLPopover.LinkEditor = LinkEditor;
URLPopover.LinkViewer = LinkViewer;
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/url-popover/README.md
 */

/* harmony default export */ var url_popover = (URLPopover);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/media-placeholder/index.js


/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */






const InsertFromURLPopover = ({
  src,
  onChange,
  onSubmit,
  onClose
}) => Object(external_wp_element_["createElement"])(url_popover, {
  onClose: onClose
}, Object(external_wp_element_["createElement"])("form", {
  className: "block-editor-media-placeholder__url-input-form",
  onSubmit: onSubmit
}, Object(external_wp_element_["createElement"])("input", {
  className: "block-editor-media-placeholder__url-input-field",
  type: "url",
  "aria-label": Object(external_wp_i18n_["__"])('URL'),
  placeholder: Object(external_wp_i18n_["__"])('Paste or type URL'),
  onChange: onChange,
  value: src
}), Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
  className: "block-editor-media-placeholder__url-input-submit-button",
  icon: keyboard_return["a" /* default */],
  label: Object(external_wp_i18n_["__"])('Apply'),
  type: "submit"
})));

function MediaPlaceholder({
  value = {},
  allowedTypes,
  className,
  icon,
  labels = {},
  mediaPreview,
  notices,
  isAppender,
  accept,
  addToGallery,
  multiple = false,
  dropZoneUIOnly,
  disableDropZone,
  disableMediaButtons,
  onError,
  onSelect,
  onCancel,
  onSelectURL,
  onDoubleClick,
  onFilesPreUpload = external_lodash_["noop"],
  onHTMLDrop = external_lodash_["noop"],
  children
}) {
  const mediaUpload = Object(external_wp_data_["useSelect"])(select => {
    const {
      getSettings
    } = select(store);
    return getSettings().mediaUpload;
  }, []);
  const [src, setSrc] = Object(external_wp_element_["useState"])('');
  const [isURLInputVisible, setIsURLInputVisible] = Object(external_wp_element_["useState"])(false);
  Object(external_wp_element_["useEffect"])(() => {
    var _value$src;

    setSrc((_value$src = value === null || value === void 0 ? void 0 : value.src) !== null && _value$src !== void 0 ? _value$src : '');
  }, [value === null || value === void 0 ? void 0 : value.src]);

  const onlyAllowsImages = () => {
    if (!allowedTypes || allowedTypes.length === 0) {
      return false;
    }

    return allowedTypes.every(allowedType => allowedType === 'image' || allowedType.startsWith('image/'));
  };

  const onChangeSrc = event => {
    setSrc(event.target.value);
  };

  const openURLInput = () => {
    setIsURLInputVisible(true);
  };

  const closeURLInput = () => {
    setIsURLInputVisible(false);
  };

  const onSubmitSrc = event => {
    event.preventDefault();

    if (src && onSelectURL) {
      onSelectURL(src);
      closeURLInput();
    }
  };

  const onFilesUpload = files => {
    onFilesPreUpload(files);
    let setMedia;

    if (multiple) {
      if (addToGallery) {
        // Since the setMedia function runs multiple times per upload group
        // and is passed newMedia containing every item in its group each time, we must
        // filter out whatever this upload group had previously returned to the
        // gallery before adding and returning the image array with replacement newMedia
        // values.
        // Define an array to store urls from newMedia between subsequent function calls.
        let lastMediaPassed = [];

        setMedia = newMedia => {
          // Remove any images this upload group is responsible for (lastMediaPassed).
          // Their replacements are contained in newMedia.
          const filteredMedia = (value !== null && value !== void 0 ? value : []).filter(item => {
            // If Item has id, only remove it if lastMediaPassed has an item with that id.
            if (item.id) {
              return !lastMediaPassed.some( // Be sure to convert to number for comparison.
              ({
                id
              }) => Number(id) === Number(item.id));
            } // Compare transient images via .includes since gallery may append extra info onto the url.


            return !lastMediaPassed.some(({
              urlSlug
            }) => item.url.includes(urlSlug));
          }); // Return the filtered media array along with newMedia.

          onSelect(filteredMedia.concat(newMedia)); // Reset lastMediaPassed and set it with ids and urls from newMedia.

          lastMediaPassed = newMedia.map(media => {
            // Add everything up to '.fileType' to compare via .includes.
            const cutOffIndex = media.url.lastIndexOf('.');
            const urlSlug = media.url.slice(0, cutOffIndex);
            return {
              id: media.id,
              urlSlug
            };
          });
        };
      } else {
        setMedia = onSelect;
      }
    } else {
      setMedia = ([media]) => onSelect(media);
    }

    mediaUpload({
      allowedTypes,
      filesList: files,
      onFileChange: setMedia,
      onError
    });
  };

  const onUpload = event => {
    onFilesUpload(event.target.files);
  };

  const renderPlaceholder = (content, onClick) => {
    let {
      instructions,
      title
    } = labels;

    if (!mediaUpload && !onSelectURL) {
      instructions = Object(external_wp_i18n_["__"])('To edit this block, you need permission to upload media.');
    }

    if (instructions === undefined || title === undefined) {
      const typesAllowed = allowedTypes !== null && allowedTypes !== void 0 ? allowedTypes : [];
      const [firstAllowedType] = typesAllowed;
      const isOneType = 1 === typesAllowed.length;
      const isAudio = isOneType && 'audio' === firstAllowedType;
      const isImage = isOneType && 'image' === firstAllowedType;
      const isVideo = isOneType && 'video' === firstAllowedType;

      if (instructions === undefined && mediaUpload) {
        instructions = Object(external_wp_i18n_["__"])('Upload a media file or pick one from your media library.');

        if (isAudio) {
          instructions = Object(external_wp_i18n_["__"])('Upload an audio file, pick one from your media library, or add one with a URL.');
        } else if (isImage) {
          instructions = Object(external_wp_i18n_["__"])('Upload an image file, pick one from your media library, or add one with a URL.');
        } else if (isVideo) {
          instructions = Object(external_wp_i18n_["__"])('Upload a video file, pick one from your media library, or add one with a URL.');
        }
      }

      if (title === undefined) {
        title = Object(external_wp_i18n_["__"])('Media');

        if (isAudio) {
          title = Object(external_wp_i18n_["__"])('Audio');
        } else if (isImage) {
          title = Object(external_wp_i18n_["__"])('Image');
        } else if (isVideo) {
          title = Object(external_wp_i18n_["__"])('Video');
        }
      }
    }

    const placeholderClassName = classnames_default()('block-editor-media-placeholder', className, {
      'is-appender': isAppender
    });
    return Object(external_wp_element_["createElement"])(external_wp_components_["Placeholder"], {
      icon: icon,
      label: title,
      instructions: instructions,
      className: placeholderClassName,
      notices: notices,
      onClick: onClick,
      onDoubleClick: onDoubleClick,
      preview: mediaPreview
    }, content, children);
  };

  const renderDropZone = () => {
    if (disableDropZone) {
      return null;
    }

    return Object(external_wp_element_["createElement"])(external_wp_components_["DropZone"], {
      onFilesDrop: onFilesUpload,
      onHTMLDrop: onHTMLDrop
    });
  };

  const renderCancelLink = () => {
    return onCancel && Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
      className: "block-editor-media-placeholder__cancel-button",
      title: Object(external_wp_i18n_["__"])('Cancel'),
      isLink: true,
      onClick: onCancel
    }, Object(external_wp_i18n_["__"])('Cancel'));
  };

  const renderUrlSelectionUI = () => {
    return onSelectURL && Object(external_wp_element_["createElement"])("div", {
      className: "block-editor-media-placeholder__url-input-container"
    }, Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
      className: "block-editor-media-placeholder__button",
      onClick: openURLInput,
      isPressed: isURLInputVisible,
      isTertiary: true
    }, Object(external_wp_i18n_["__"])('Insert from URL')), isURLInputVisible && Object(external_wp_element_["createElement"])(InsertFromURLPopover, {
      src: src,
      onChange: onChangeSrc,
      onSubmit: onSubmitSrc,
      onClose: closeURLInput
    }));
  };

  const renderMediaUploadChecked = () => {
    const mediaLibraryButton = Object(external_wp_element_["createElement"])(media_upload, {
      addToGallery: addToGallery,
      gallery: multiple && onlyAllowsImages(),
      multiple: multiple,
      onSelect: onSelect,
      allowedTypes: allowedTypes,
      value: Array.isArray(value) ? value.map(({
        id
      }) => id) : value.id,
      render: ({
        open
      }) => {
        return Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
          isTertiary: true,
          onClick: event => {
            event.stopPropagation();
            open();
          }
        }, Object(external_wp_i18n_["__"])('Media Library'));
      }
    });

    if (mediaUpload && isAppender) {
      return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, renderDropZone(), Object(external_wp_element_["createElement"])(external_wp_components_["FormFileUpload"], {
        onChange: onUpload,
        accept: accept,
        multiple: multiple,
        render: ({
          openFileDialog
        }) => {
          const content = Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
            isPrimary: true,
            className: classnames_default()('block-editor-media-placeholder__button', 'block-editor-media-placeholder__upload-button')
          }, Object(external_wp_i18n_["__"])('Upload')), mediaLibraryButton, renderUrlSelectionUI(), renderCancelLink());
          return renderPlaceholder(content, openFileDialog);
        }
      }));
    }

    if (mediaUpload) {
      const content = Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, renderDropZone(), Object(external_wp_element_["createElement"])(external_wp_components_["FormFileUpload"], {
        isPrimary: true,
        className: classnames_default()('block-editor-media-placeholder__button', 'block-editor-media-placeholder__upload-button'),
        onChange: onUpload,
        accept: accept,
        multiple: multiple
      }, Object(external_wp_i18n_["__"])('Upload')), mediaLibraryButton, renderUrlSelectionUI(), renderCancelLink());
      return renderPlaceholder(content);
    }

    return renderPlaceholder(mediaLibraryButton);
  };

  if (dropZoneUIOnly || disableMediaButtons) {
    if (dropZoneUIOnly) {
      external_wp_deprecated_default()('wp.blockEditor.MediaPlaceholder dropZoneUIOnly prop', {
        since: '5.4',
        alternative: 'disableMediaButtons'
      });
    }

    return Object(external_wp_element_["createElement"])(check, null, renderDropZone());
  }

  return Object(external_wp_element_["createElement"])(check, {
    fallback: renderPlaceholder(renderUrlSelectionUI())
  }, renderMediaUploadChecked());
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/media-placeholder/README.md
 */

/* harmony default export */ var media_placeholder = (Object(external_wp_components_["withFilters"])('editor.MediaPlaceholder')(MediaPlaceholder));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/editable-text/index.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


const EditableText = Object(external_wp_element_["forwardRef"])((props, ref) => {
  return Object(external_wp_element_["createElement"])(rich_text, Object(esm_extends["a" /* default */])({
    ref: ref
  }, props, {
    __unstableDisableFormats: true,
    preserveWhiteSpace: true
  }));
});

EditableText.Content = ({
  value = '',
  tagName: Tag = 'div',
  ...props
}) => {
  return Object(external_wp_element_["createElement"])(Tag, props, value);
};
/**
 * Renders an editable text input in which text formatting is not allowed.
 */


/* harmony default export */ var editable_text = (EditableText);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/plain-text/index.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/plain-text/README.md
 */

const PlainText = Object(external_wp_element_["forwardRef"])(({
  __experimentalVersion,
  ...props
}, ref) => {
  if (__experimentalVersion === 2) {
    return Object(external_wp_element_["createElement"])(editable_text, Object(esm_extends["a" /* default */])({
      ref: ref
    }, props));
  }

  const {
    className,
    onChange,
    ...remainingProps
  } = props;
  return Object(external_wp_element_["createElement"])(lib_default.a, Object(esm_extends["a" /* default */])({
    ref: ref,
    className: classnames_default()('block-editor-plain-text', className),
    onChange: event => onChange(event.target.value)
  }, remainingProps));
});
/* harmony default export */ var plain_text = (PlainText);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/responsive-block-control/label.js


/**
 * WordPress dependencies
 */




function ResponsiveBlockControlLabel({
  property,
  viewport,
  desc
}) {
  const instanceId = Object(external_wp_compose_["useInstanceId"])(ResponsiveBlockControlLabel);
  const accessibleLabel = desc || Object(external_wp_i18n_["sprintf"])(
  /* translators: 1: property name. 2: viewport name. */
  Object(external_wp_i18n_["_x"])('Controls the %1$s property for %2$s viewports.', 'Text labelling a interface as controlling a given layout property (eg: margin) for a given screen size.'), property, viewport.label);
  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])("span", {
    "aria-describedby": `rbc-desc-${instanceId}`
  }, viewport.label), Object(external_wp_element_["createElement"])(external_wp_components_["VisuallyHidden"], {
    as: "span",
    id: `rbc-desc-${instanceId}`
  }, accessibleLabel));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/responsive-block-control/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



function ResponsiveBlockControl(props) {
  const {
    title,
    property,
    toggleLabel,
    onIsResponsiveChange,
    renderDefaultControl,
    renderResponsiveControls,
    isResponsive = false,
    defaultLabel = {
      id: 'all',

      /* translators: 'Label. Used to signify a layout property (eg: margin, padding) will apply uniformly to all screensizes.' */
      label: Object(external_wp_i18n_["__"])('All')
    },
    viewports = [{
      id: 'small',
      label: Object(external_wp_i18n_["__"])('Small screens')
    }, {
      id: 'medium',
      label: Object(external_wp_i18n_["__"])('Medium screens')
    }, {
      id: 'large',
      label: Object(external_wp_i18n_["__"])('Large screens')
    }]
  } = props;

  if (!title || !property || !renderDefaultControl) {
    return null;
  }

  const toggleControlLabel = toggleLabel || Object(external_wp_i18n_["sprintf"])(
  /* translators: 'Toggle control label. Should the property be the same across all screen sizes or unique per screen size.'. %s property value for the control (eg: margin, padding...etc) */
  Object(external_wp_i18n_["__"])('Use the same %s on all screensizes.'), property);
  /* translators: 'Help text for the responsive mode toggle control.' */

  const toggleHelpText = Object(external_wp_i18n_["__"])('Toggle between using the same value for all screen sizes or using a unique value per screen size.');

  const defaultControl = renderDefaultControl(Object(external_wp_element_["createElement"])(ResponsiveBlockControlLabel, {
    property: property,
    viewport: defaultLabel
  }), defaultLabel);

  const defaultResponsiveControls = () => {
    return viewports.map(viewport => Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], {
      key: viewport.id
    }, renderDefaultControl(Object(external_wp_element_["createElement"])(ResponsiveBlockControlLabel, {
      property: property,
      viewport: viewport
    }), viewport)));
  };

  return Object(external_wp_element_["createElement"])("fieldset", {
    className: "block-editor-responsive-block-control"
  }, Object(external_wp_element_["createElement"])("legend", {
    className: "block-editor-responsive-block-control__title"
  }, title), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-responsive-block-control__inner"
  }, Object(external_wp_element_["createElement"])(external_wp_components_["ToggleControl"], {
    className: "block-editor-responsive-block-control__toggle",
    label: toggleControlLabel,
    checked: !isResponsive,
    onChange: onIsResponsiveChange,
    help: toggleHelpText
  }), Object(external_wp_element_["createElement"])("div", {
    className: classnames_default()('block-editor-responsive-block-control__group', {
      'is-responsive': isResponsive
    })
  }, !isResponsive && defaultControl, isResponsive && (renderResponsiveControls ? renderResponsiveControls(viewports) : defaultResponsiveControls()))));
}

/* harmony default export */ var responsive_block_control = (ResponsiveBlockControl);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/shortcut.js
/**
 * WordPress dependencies
 */


function RichTextShortcut({
  character,
  type,
  onUse
}) {
  const callback = () => {
    onUse();
    return false;
  };

  Object(external_wp_compose_["useKeyboardShortcut"])(external_wp_keycodes_["rawShortcut"][type](character), callback, {
    bindGlobal: true
  });
  return null;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/toolbar-button.js



/**
 * WordPress dependencies
 */


function RichTextToolbarButton({
  name,
  shortcutType,
  shortcutCharacter,
  ...props
}) {
  let shortcut;
  let fillName = 'RichText.ToolbarControls';

  if (name) {
    fillName += `.${name}`;
  }

  if (shortcutType && shortcutCharacter) {
    shortcut = external_wp_keycodes_["displayShortcut"][shortcutType](shortcutCharacter);
  }

  return Object(external_wp_element_["createElement"])(external_wp_components_["Fill"], {
    name: fillName
  }, Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarButton"], Object(esm_extends["a" /* default */])({}, props, {
    shortcut: shortcut
  })));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/rich-text/input-event.js
/**
 * WordPress dependencies
 */

class input_event_unstableRichTextInputEvent extends external_wp_element_["Component"] {
  constructor() {
    super(...arguments);
    this.onInput = this.onInput.bind(this);
  }

  onInput(event) {
    if (event.inputType === this.props.inputType) {
      this.props.onInput();
    }
  }

  componentDidMount() {
    document.addEventListener('input', this.onInput, true);
  }

  componentWillUnmount() {
    document.removeEventListener('input', this.onInput, true);
  }

  render() {
    return null;
  }

}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/tool-selector/index.js



/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


const selectIcon = Object(external_wp_element_["createElement"])(external_wp_components_["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24"
}, Object(external_wp_element_["createElement"])(external_wp_components_["Path"], {
  d: "M9.4 20.5L5.2 3.8l14.6 9-2 .3c-.2 0-.4.1-.7.1-.9.2-1.6.3-2.2.5-.8.3-1.4.5-1.8.8-.4.3-.8.8-1.3 1.5-.4.5-.8 1.2-1.2 2l-.3.6-.9 1.9zM7.6 7.1l2.4 9.3c.2-.4.5-.8.7-1.1.6-.8 1.1-1.4 1.6-1.8.5-.4 1.3-.8 2.2-1.1l1.2-.3-8.1-5z"
}));

function ToolSelector(props, ref) {
  const isNavigationTool = Object(external_wp_data_["useSelect"])(select => select(store).isNavigationMode(), []);
  const {
    setNavigationMode
  } = Object(external_wp_data_["useDispatch"])(store);

  const onSwitchMode = mode => {
    setNavigationMode(mode === 'edit' ? false : true);
  };

  return Object(external_wp_element_["createElement"])(external_wp_components_["Dropdown"], {
    renderToggle: ({
      isOpen,
      onToggle
    }) => Object(external_wp_element_["createElement"])(external_wp_components_["Button"], Object(esm_extends["a" /* default */])({}, props, {
      ref: ref,
      icon: isNavigationTool ? selectIcon : library_edit["a" /* default */],
      "aria-expanded": isOpen,
      "aria-haspopup": "true",
      onClick: onToggle
      /* translators: button label text should, if possible, be under 16 characters. */
      ,
      label: Object(external_wp_i18n_["__"])('Tools')
    })),
    position: "bottom right",
    renderContent: () => Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(external_wp_components_["NavigableMenu"], {
      role: "menu",
      "aria-label": Object(external_wp_i18n_["__"])('Tools')
    }, Object(external_wp_element_["createElement"])(external_wp_components_["MenuItemsChoice"], {
      value: isNavigationTool ? 'select' : 'edit',
      onSelect: onSwitchMode,
      choices: [{
        value: 'edit',
        label: Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(build_module_icon["a" /* default */], {
          icon: library_edit["a" /* default */]
        }), Object(external_wp_i18n_["__"])('Edit'))
      }, {
        value: 'select',
        label: Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, selectIcon, Object(external_wp_i18n_["__"])('Select'))
      }]
    })), Object(external_wp_element_["createElement"])("div", {
      className: "block-editor-tool-selector__help"
    }, Object(external_wp_i18n_["__"])('Tools provide different interactions for selecting, navigating, and editing blocks. Toggle between select and edit by pressing Escape and Enter.')))
  });
}

/* harmony default export */ var tool_selector = (Object(external_wp_element_["forwardRef"])(ToolSelector));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/unit-control/index.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


function UnitControl({
  units: unitsProp,
  ...props
}) {
  const units = Object(external_wp_components_["__experimentalUseCustomUnits"])({
    availableUnits: useSetting('spacing.units') || ['%', 'px', 'em', 'rem', 'vw'],
    units: unitsProp
  });
  return Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalUnitControl"], Object(esm_extends["a" /* default */])({
    units: units
  }, props));
}

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/link.js
var library_link = __webpack_require__("Bpkj");

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/arrow-left.js
var arrow_left = __webpack_require__("cjQ8");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/url-input/button.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



class button_URLInputButton extends external_wp_element_["Component"] {
  constructor() {
    super(...arguments);
    this.toggle = this.toggle.bind(this);
    this.submitLink = this.submitLink.bind(this);
    this.state = {
      expanded: false
    };
  }

  toggle() {
    this.setState({
      expanded: !this.state.expanded
    });
  }

  submitLink(event) {
    event.preventDefault();
    this.toggle();
  }

  render() {
    const {
      url,
      onChange
    } = this.props;
    const {
      expanded
    } = this.state;
    const buttonLabel = url ? Object(external_wp_i18n_["__"])('Edit link') : Object(external_wp_i18n_["__"])('Insert link');
    return Object(external_wp_element_["createElement"])("div", {
      className: "block-editor-url-input__button"
    }, Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
      icon: library_link["a" /* default */],
      label: buttonLabel,
      onClick: this.toggle,
      className: "components-toolbar__control",
      isPressed: !!url
    }), expanded && Object(external_wp_element_["createElement"])("form", {
      className: "block-editor-url-input__button-modal",
      onSubmit: this.submitLink
    }, Object(external_wp_element_["createElement"])("div", {
      className: "block-editor-url-input__button-modal-line"
    }, Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
      className: "block-editor-url-input__back",
      icon: arrow_left["a" /* default */],
      label: Object(external_wp_i18n_["__"])('Close'),
      onClick: this.toggle
    }), Object(external_wp_element_["createElement"])(url_input, {
      value: url || '',
      onChange: onChange
    }), Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
      icon: keyboard_return["a" /* default */],
      label: Object(external_wp_i18n_["__"])('Submit'),
      type: "submit"
    }))));
  }

}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/url-input/README.md
 */


/* harmony default export */ var url_input_button = (button_URLInputButton);

// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/close.js
var library_close = __webpack_require__("w95h");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/url-popover/image-url-input-ui.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


const LINK_DESTINATION_NONE = 'none';
const LINK_DESTINATION_CUSTOM = 'custom';
const LINK_DESTINATION_MEDIA = 'media';
const LINK_DESTINATION_ATTACHMENT = 'attachment';
const NEW_TAB_REL = ['noreferrer', 'noopener'];
const image_url_input_ui_icon = Object(external_wp_element_["createElement"])(external_wp_components_["SVG"], {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, Object(external_wp_element_["createElement"])(external_wp_components_["Path"], {
  d: "M0,0h24v24H0V0z",
  fill: "none"
}), Object(external_wp_element_["createElement"])(external_wp_components_["Path"], {
  d: "m19 5v14h-14v-14h14m0-2h-14c-1.1 0-2 0.9-2 2v14c0 1.1 0.9 2 2 2h14c1.1 0 2-0.9 2-2v-14c0-1.1-0.9-2-2-2z"
}), Object(external_wp_element_["createElement"])(external_wp_components_["Path"], {
  d: "m14.14 11.86l-3 3.87-2.14-2.59-3 3.86h12l-3.86-5.14z"
}));

const ImageURLInputUI = ({
  linkDestination,
  onChangeUrl,
  url,
  mediaType = 'image',
  mediaUrl,
  mediaLink,
  linkTarget,
  linkClass,
  rel
}) => {
  const [isOpen, setIsOpen] = Object(external_wp_element_["useState"])(false);
  const openLinkUI = Object(external_wp_element_["useCallback"])(() => {
    setIsOpen(true);
  });
  const [isEditingLink, setIsEditingLink] = Object(external_wp_element_["useState"])(false);
  const [urlInput, setUrlInput] = Object(external_wp_element_["useState"])(null);
  const autocompleteRef = Object(external_wp_element_["useRef"])(null);
  const startEditLink = Object(external_wp_element_["useCallback"])(() => {
    if (linkDestination === LINK_DESTINATION_MEDIA || linkDestination === LINK_DESTINATION_ATTACHMENT) {
      setUrlInput('');
    }

    setIsEditingLink(true);
  });
  const stopEditLink = Object(external_wp_element_["useCallback"])(() => {
    setIsEditingLink(false);
  });
  const closeLinkUI = Object(external_wp_element_["useCallback"])(() => {
    setUrlInput(null);
    stopEditLink();
    setIsOpen(false);
  });

  const removeNewTabRel = currentRel => {
    let newRel = currentRel;

    if (currentRel !== undefined && !Object(external_lodash_["isEmpty"])(newRel)) {
      if (!Object(external_lodash_["isEmpty"])(newRel)) {
        Object(external_lodash_["each"])(NEW_TAB_REL, relVal => {
          const regExp = new RegExp('\\b' + relVal + '\\b', 'gi');
          newRel = newRel.replace(regExp, '');
        }); // Only trim if NEW_TAB_REL values was replaced.

        if (newRel !== currentRel) {
          newRel = newRel.trim();
        }

        if (Object(external_lodash_["isEmpty"])(newRel)) {
          newRel = undefined;
        }
      }
    }

    return newRel;
  };

  const getUpdatedLinkTargetSettings = value => {
    const newLinkTarget = value ? '_blank' : undefined;
    let updatedRel;

    if (!newLinkTarget && !rel) {
      updatedRel = undefined;
    } else {
      updatedRel = removeNewTabRel(rel);
    }

    return {
      linkTarget: newLinkTarget,
      rel: updatedRel
    };
  };

  const onFocusOutside = Object(external_wp_element_["useCallback"])(() => {
    return event => {
      // The autocomplete suggestions list renders in a separate popover (in a portal),
      // so onFocusOutside fails to detect that a click on a suggestion occurred in the
      // LinkContainer. Detect clicks on autocomplete suggestions using a ref here, and
      // return to avoid the popover being closed.
      const autocompleteElement = autocompleteRef.current;

      if (autocompleteElement && autocompleteElement.contains(event.target)) {
        return;
      }

      setIsOpen(false);
      setUrlInput(null);
      stopEditLink();
    };
  });
  const onSubmitLinkChange = Object(external_wp_element_["useCallback"])(() => {
    return event => {
      if (urlInput) {
        var _getLinkDestinations$;

        // It is possible the entered URL actually matches a named link destination.
        // This check will ensure our link destination is correct.
        const selectedDestination = ((_getLinkDestinations$ = getLinkDestinations().find(destination => destination.url === urlInput)) === null || _getLinkDestinations$ === void 0 ? void 0 : _getLinkDestinations$.linkDestination) || LINK_DESTINATION_CUSTOM;
        onChangeUrl({
          href: urlInput,
          linkDestination: selectedDestination
        });
      }

      stopEditLink();
      setUrlInput(null);
      event.preventDefault();
    };
  });
  const onLinkRemove = Object(external_wp_element_["useCallback"])(() => {
    onChangeUrl({
      linkDestination: LINK_DESTINATION_NONE,
      href: ''
    });
  });

  const getLinkDestinations = () => {
    const linkDestinations = [{
      linkDestination: LINK_DESTINATION_MEDIA,
      title: Object(external_wp_i18n_["__"])('Media File'),
      url: mediaType === 'image' ? mediaUrl : undefined,
      icon: image_url_input_ui_icon
    }];

    if (mediaType === 'image' && mediaLink) {
      linkDestinations.push({
        linkDestination: LINK_DESTINATION_ATTACHMENT,
        title: Object(external_wp_i18n_["__"])('Attachment Page'),
        url: mediaType === 'image' ? mediaLink : undefined,
        icon: Object(external_wp_element_["createElement"])(external_wp_components_["SVG"], {
          viewBox: "0 0 24 24",
          xmlns: "http://www.w3.org/2000/svg"
        }, Object(external_wp_element_["createElement"])(external_wp_components_["Path"], {
          d: "M0 0h24v24H0V0z",
          fill: "none"
        }), Object(external_wp_element_["createElement"])(external_wp_components_["Path"], {
          d: "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zM6 20V4h7v5h5v11H6z"
        }))
      });
    }

    return linkDestinations;
  };

  const onSetHref = value => {
    const linkDestinations = getLinkDestinations();
    let linkDestinationInput;

    if (!value) {
      linkDestinationInput = LINK_DESTINATION_NONE;
    } else {
      linkDestinationInput = (Object(external_lodash_["find"])(linkDestinations, destination => {
        return destination.url === value;
      }) || {
        linkDestination: LINK_DESTINATION_CUSTOM
      }).linkDestination;
    }

    onChangeUrl({
      linkDestination: linkDestinationInput,
      href: value
    });
  };

  const onSetNewTab = value => {
    const updatedLinkTarget = getUpdatedLinkTargetSettings(value);
    onChangeUrl(updatedLinkTarget);
  };

  const onSetLinkRel = value => {
    onChangeUrl({
      rel: value
    });
  };

  const onSetLinkClass = value => {
    onChangeUrl({
      linkClass: value
    });
  };

  const advancedOptions = Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(external_wp_components_["ToggleControl"], {
    label: Object(external_wp_i18n_["__"])('Open in new tab'),
    onChange: onSetNewTab,
    checked: linkTarget === '_blank'
  }), Object(external_wp_element_["createElement"])(external_wp_components_["TextControl"], {
    label: Object(external_wp_i18n_["__"])('Link Rel'),
    value: removeNewTabRel(rel) || '',
    onChange: onSetLinkRel
  }), Object(external_wp_element_["createElement"])(external_wp_components_["TextControl"], {
    label: Object(external_wp_i18n_["__"])('Link CSS Class'),
    value: linkClass || '',
    onChange: onSetLinkClass
  }));
  const linkEditorValue = urlInput !== null ? urlInput : url;
  const urlLabel = (Object(external_lodash_["find"])(getLinkDestinations(), ['linkDestination', linkDestination]) || {}).title;
  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(external_wp_components_["ToolbarButton"], {
    icon: library_link["a" /* default */],
    className: "components-toolbar__control",
    label: url ? Object(external_wp_i18n_["__"])('Edit link') : Object(external_wp_i18n_["__"])('Insert link'),
    "aria-expanded": isOpen,
    onClick: openLinkUI
  }), isOpen && Object(external_wp_element_["createElement"])(url_popover, {
    onFocusOutside: onFocusOutside(),
    onClose: closeLinkUI,
    renderSettings: () => advancedOptions,
    additionalControls: !linkEditorValue && Object(external_wp_element_["createElement"])(external_wp_components_["NavigableMenu"], null, Object(external_lodash_["map"])(getLinkDestinations(), link => Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
      key: link.linkDestination,
      icon: link.icon,
      onClick: () => {
        setUrlInput(null);
        onSetHref(link.url);
        stopEditLink();
      }
    }, link.title)))
  }, (!url || isEditingLink) && Object(external_wp_element_["createElement"])(url_popover.LinkEditor, {
    className: "block-editor-format-toolbar__link-container-content",
    value: linkEditorValue,
    onChangeInputValue: setUrlInput,
    onSubmit: onSubmitLinkChange(),
    autocompleteRef: autocompleteRef
  }), url && !isEditingLink && Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(url_popover.LinkViewer, {
    className: "block-editor-format-toolbar__link-container-content",
    url: url,
    onEditLinkClick: startEditLink,
    urlLabel: urlLabel
  }), Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    icon: library_close["a" /* default */],
    label: Object(external_wp_i18n_["__"])('Remove link'),
    onClick: onLinkRemove
  }))));
};



// EXTERNAL MODULE: ./node_modules/@wordpress/icons/build-module/library/check.js
var library_check = __webpack_require__("RMJe");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/preview-options/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





function PreviewOptions({
  children,
  className,
  isEnabled = true,
  deviceType,
  setDeviceType
}) {
  const isMobile = Object(external_wp_compose_["useViewportMatch"])('small', '<');
  if (isMobile) return null;
  const popoverProps = {
    className: classnames_default()(className, 'block-editor-post-preview__dropdown-content'),
    position: 'bottom left'
  };
  const toggleProps = {
    isTertiary: true,
    className: 'block-editor-post-preview__button-toggle',
    disabled: !isEnabled,

    /* translators: button label text should, if possible, be under 16 characters. */
    children: Object(external_wp_i18n_["__"])('Preview')
  };
  return Object(external_wp_element_["createElement"])(external_wp_components_["DropdownMenu"], {
    className: "block-editor-post-preview__dropdown",
    popoverProps: popoverProps,
    toggleProps: toggleProps,
    icon: null
  }, () => Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])(external_wp_components_["MenuGroup"], null, Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
    className: "block-editor-post-preview__button-resize",
    onClick: () => setDeviceType('Desktop'),
    icon: deviceType === 'Desktop' && library_check["a" /* default */]
  }, Object(external_wp_i18n_["__"])('Desktop')), Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
    className: "block-editor-post-preview__button-resize",
    onClick: () => setDeviceType('Tablet'),
    icon: deviceType === 'Tablet' && library_check["a" /* default */]
  }, Object(external_wp_i18n_["__"])('Tablet')), Object(external_wp_element_["createElement"])(external_wp_components_["MenuItem"], {
    className: "block-editor-post-preview__button-resize",
    onClick: () => setDeviceType('Mobile'),
    icon: deviceType === 'Mobile' && library_check["a" /* default */]
  }, Object(external_wp_i18n_["__"])('Mobile'))), children));
}

// EXTERNAL MODULE: ./node_modules/css-mediaquery/index.js
var css_mediaquery = __webpack_require__("6fKw");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/use-simulated-media-query/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



const ENABLED_MEDIA_QUERY = '(min-width:0px)';
const DISABLED_MEDIA_QUERY = '(min-width:999999px)';
const VALID_MEDIA_QUERY_REGEX = /\((min|max)-width:[^\(]*?\)/g;

function getStyleSheetsThatMatchHostname() {
  var _window$document$styl, _window, _window$document;

  if (typeof window === 'undefined') {
    return [];
  }

  return Object(external_lodash_["filter"])((_window$document$styl = (_window = window) === null || _window === void 0 ? void 0 : (_window$document = _window.document) === null || _window$document === void 0 ? void 0 : _window$document.styleSheets) !== null && _window$document$styl !== void 0 ? _window$document$styl : [], styleSheet => {
    if (!styleSheet.href) {
      return false;
    }

    return Object(external_wp_url_["getProtocol"])(styleSheet.href) === window.location.protocol && Object(external_wp_url_["getAuthority"])(styleSheet.href) === window.location.host;
  });
}

function isReplaceableMediaRule(rule) {
  if (!rule.media) {
    return false;
  } // Need to use "media.mediaText" instead of "conditionText" for IE support.


  return !!rule.media.mediaText.match(VALID_MEDIA_QUERY_REGEX);
}

function replaceRule(styleSheet, newRuleText, index) {
  styleSheet.deleteRule(index);
  styleSheet.insertRule(newRuleText, index);
}

function replaceMediaQueryWithWidthEvaluation(ruleText, widthValue) {
  return ruleText.replace(VALID_MEDIA_QUERY_REGEX, matchedSubstring => {
    if (Object(css_mediaquery["match"])(matchedSubstring, {
      type: 'screen',
      width: widthValue
    })) {
      return ENABLED_MEDIA_QUERY;
    }

    return DISABLED_MEDIA_QUERY;
  });
}
/**
 * Function that manipulates media queries from stylesheets to simulate a given
 * viewport width.
 *
 * @param {string}  marker CSS selector string defining start and end of
 *                         manipulable styles.
 * @param {number?} width  Viewport width to simulate. If provided null, the
 *                         stylesheets will not be modified.
 */


function useSimulatedMediaQuery(marker, width) {
  Object(external_wp_element_["useEffect"])(() => {
    if (!width) {
      return;
    }

    const styleSheets = getStyleSheetsThatMatchHostname();
    const originalStyles = [];
    styleSheets.forEach((styleSheet, styleSheetIndex) => {
      let relevantSection = false;

      for (let ruleIndex = 0; ruleIndex < styleSheet.cssRules.length; ++ruleIndex) {
        const rule = styleSheet.cssRules[ruleIndex];

        if (rule.type !== window.CSSRule.STYLE_RULE && rule.type !== window.CSSRule.MEDIA_RULE) {
          continue;
        }

        if (!relevantSection && !!rule.cssText.match(new RegExp(`#start-${marker}`))) {
          relevantSection = true;
        }

        if (relevantSection && !!rule.cssText.match(new RegExp(`#end-${marker}`))) {
          relevantSection = false;
        }

        if (!relevantSection || !isReplaceableMediaRule(rule)) {
          continue;
        }

        const ruleText = rule.cssText;

        if (!originalStyles[styleSheetIndex]) {
          originalStyles[styleSheetIndex] = [];
        }

        originalStyles[styleSheetIndex][ruleIndex] = ruleText;
        replaceRule(styleSheet, replaceMediaQueryWithWidthEvaluation(ruleText, width), ruleIndex);
      }
    });
    return () => {
      originalStyles.forEach((rulesCollection, styleSheetIndex) => {
        if (!rulesCollection) {
          return;
        }

        for (let ruleIndex = 0; ruleIndex < rulesCollection.length; ++ruleIndex) {
          const originalRuleText = rulesCollection[ruleIndex];

          if (originalRuleText) {
            replaceRule(styleSheets[styleSheetIndex], originalRuleText, ruleIndex);
          }
        }
      });
    };
  }, [width]);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/use-resize-canvas/index.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Function to resize the editor window.
 *
 * @param {string}  deviceType                  Used for determining the size of the container (e.g. Desktop, Tablet, Mobile)
 * @param {boolean} __unstableDisableSimulation Whether to disable media query simulation.
 *
 * @return {Object} Inline styles to be added to resizable container.
 */

function useResizeCanvas(deviceType, __unstableDisableSimulation) {
  const [actualWidth, updateActualWidth] = Object(external_wp_element_["useState"])(window.innerWidth);
  Object(external_wp_element_["useEffect"])(() => {
    if (deviceType === 'Desktop') {
      return;
    }

    const resizeListener = () => updateActualWidth(window.innerWidth);

    window.addEventListener('resize', resizeListener);
    return () => {
      window.removeEventListener('resize', resizeListener);
    };
  }, [deviceType]);

  const getCanvasWidth = device => {
    let deviceWidth;

    switch (device) {
      case 'Tablet':
        deviceWidth = 780;
        break;

      case 'Mobile':
        deviceWidth = 360;
        break;

      default:
        return null;
    }

    return deviceWidth < actualWidth ? deviceWidth : actualWidth;
  };

  const marginValue = () => window.innerHeight < 800 ? 36 : 72;

  const contentInlineStyles = device => {
    const height = device === 'Mobile' ? '768px' : '1024px';

    switch (device) {
      case 'Tablet':
      case 'Mobile':
        return {
          width: getCanvasWidth(device),
          margin: marginValue() + 'px auto',
          height,
          borderRadius: '2px 2px 2px 2px',
          border: '1px solid #ddd',
          overflowY: 'auto'
        };

      default:
        return null;
    }
  };

  const width = __unstableDisableSimulation ? null : getCanvasWidth(deviceType);
  useSimulatedMediaQuery('resizable-editor-section', width);
  return contentInlineStyles(deviceType);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/skip-to-selected-block/index.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




const SkipToSelectedBlock = ({
  selectedBlockClientId
}) => {
  const ref = useBlockRef(selectedBlockClientId);

  const onClick = () => {
    ref.current.focus();
  };

  return selectedBlockClientId ? Object(external_wp_element_["createElement"])(external_wp_components_["Button"], {
    isSecondary: true,
    className: "block-editor-skip-to-selected-block",
    onClick: onClick
  }, Object(external_wp_i18n_["__"])('Skip to the selected block')) : null;
};

/* harmony default export */ var skip_to_selected_block = (Object(external_wp_data_["withSelect"])(select => {
  return {
    selectedBlockClientId: select(store).getBlockSelectionStart()
  };
})(SkipToSelectedBlock));

// EXTERNAL MODULE: external ["wp","wordcount"]
var external_wp_wordcount_ = __webpack_require__("7fqt");

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/multi-selection-inspector/index.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




function MultiSelectionInspector({
  blocks
}) {
  const words = Object(external_wp_wordcount_["count"])(Object(external_wp_blocks_["serialize"])(blocks), 'words');
  return Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-multi-selection-inspector__card"
  }, Object(external_wp_element_["createElement"])(BlockIcon, {
    icon: library_stack,
    showColors: true
  }), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-multi-selection-inspector__card-content"
  }, Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-multi-selection-inspector__card-title"
  }, Object(external_wp_i18n_["sprintf"])(
  /* translators: %d: number of blocks */
  Object(external_wp_i18n_["_n"])('%d block', '%d blocks', blocks.length), blocks.length)), Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-multi-selection-inspector__card-description"
  }, Object(external_wp_i18n_["sprintf"])(
  /* translators: %d: number of words */
  Object(external_wp_i18n_["_n"])('%d word', '%d words', words), words))));
}

/* harmony default export */ var multi_selection_inspector = (Object(external_wp_data_["withSelect"])(select => {
  const {
    getMultiSelectedBlocks
  } = select(store);
  return {
    blocks: getMultiSelectedBlocks()
  };
})(MultiSelectionInspector));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/default-style-picker/index.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


function DefaultStylePicker({
  blockName
}) {
  const {
    preferredStyle,
    onUpdatePreferredStyleVariations,
    styles
  } = Object(external_wp_data_["useSelect"])(select => {
    var _preferredStyleVariat, _preferredStyleVariat2;

    const settings = select(store).getSettings();
    const preferredStyleVariations = settings.__experimentalPreferredStyleVariations;
    return {
      preferredStyle: preferredStyleVariations === null || preferredStyleVariations === void 0 ? void 0 : (_preferredStyleVariat = preferredStyleVariations.value) === null || _preferredStyleVariat === void 0 ? void 0 : _preferredStyleVariat[blockName],
      onUpdatePreferredStyleVariations: (_preferredStyleVariat2 = preferredStyleVariations === null || preferredStyleVariations === void 0 ? void 0 : preferredStyleVariations.onChange) !== null && _preferredStyleVariat2 !== void 0 ? _preferredStyleVariat2 : null,
      styles: select(external_wp_blocks_["store"]).getBlockStyles(blockName)
    };
  }, [blockName]);
  const selectOptions = Object(external_wp_element_["useMemo"])(() => [{
    label: Object(external_wp_i18n_["__"])('Not set'),
    value: ''
  }, ...styles.map(({
    label,
    name
  }) => ({
    label,
    value: name
  }))], [styles]);
  const selectOnChange = Object(external_wp_element_["useCallback"])(blockStyle => {
    onUpdatePreferredStyleVariations(blockName, blockStyle);
  }, [blockName, onUpdatePreferredStyleVariations]);
  return onUpdatePreferredStyleVariations && Object(external_wp_element_["createElement"])(external_wp_components_["SelectControl"], {
    options: selectOptions,
    value: preferredStyle || '',
    label: Object(external_wp_i18n_["__"])('Default Style'),
    onChange: selectOnChange
  });
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-inspector/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */












const BlockInspector = ({
  showNoBlockSelectedMessage = true,
  bubblesVirtually = true
}) => {
  const {
    count,
    hasBlockStyles,
    selectedBlockName,
    selectedBlockClientId,
    blockType
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getSelectedBlockClientId,
      getSelectedBlockCount,
      getBlockName
    } = select(store);
    const {
      getBlockStyles
    } = select(external_wp_blocks_["store"]);

    const _selectedBlockClientId = getSelectedBlockClientId();

    const _selectedBlockName = _selectedBlockClientId && getBlockName(_selectedBlockClientId);

    const _blockType = _selectedBlockName && Object(external_wp_blocks_["getBlockType"])(_selectedBlockName);

    const blockStyles = _selectedBlockName && getBlockStyles(_selectedBlockName);

    return {
      count: getSelectedBlockCount(),
      selectedBlockClientId: _selectedBlockClientId,
      selectedBlockName: _selectedBlockName,
      blockType: _blockType,
      hasBlockStyles: blockStyles && blockStyles.length > 0
    };
  }, []);

  if (count > 1) {
    return Object(external_wp_element_["createElement"])("div", {
      className: "block-editor-block-inspector"
    }, Object(external_wp_element_["createElement"])(multi_selection_inspector, null), Object(external_wp_element_["createElement"])(inspector_controls.Slot, {
      bubblesVirtually: bubblesVirtually
    }));
  }

  const isSelectedBlockUnregistered = selectedBlockName === Object(external_wp_blocks_["getUnregisteredTypeHandlerName"])();
  /*
   * If the selected block is of an unregistered type, avoid showing it as an actual selection
   * because we want the user to focus on the unregistered block warning, not block settings.
   */

  if (!blockType || !selectedBlockClientId || isSelectedBlockUnregistered) {
    if (showNoBlockSelectedMessage) {
      return Object(external_wp_element_["createElement"])("span", {
        className: "block-editor-block-inspector__no-blocks"
      }, Object(external_wp_i18n_["__"])('No block selected.'));
    }

    return null;
  }

  return Object(external_wp_element_["createElement"])(BlockInspectorSingleBlock, {
    clientId: selectedBlockClientId,
    blockName: blockType.name,
    hasBlockStyles: hasBlockStyles,
    bubblesVirtually: bubblesVirtually
  });
};

const BlockInspectorSingleBlock = ({
  clientId,
  blockName,
  hasBlockStyles,
  bubblesVirtually
}) => {
  const blockInformation = useBlockDisplayInformation(clientId);
  return Object(external_wp_element_["createElement"])("div", {
    className: "block-editor-block-inspector"
  }, Object(external_wp_element_["createElement"])(block_card, blockInformation), Object(external_wp_element_["createElement"])(block_variation_transforms, {
    blockClientId: clientId
  }), hasBlockStyles && Object(external_wp_element_["createElement"])("div", null, Object(external_wp_element_["createElement"])(external_wp_components_["PanelBody"], {
    title: Object(external_wp_i18n_["__"])('Styles')
  }, Object(external_wp_element_["createElement"])(block_styles, {
    clientId: clientId
  }), Object(external_wp_blocks_["hasBlockSupport"])(blockName, 'defaultStylePicker', true) && Object(external_wp_element_["createElement"])(DefaultStylePicker, {
    blockName: blockName
  }))), Object(external_wp_element_["createElement"])(inspector_controls.Slot, {
    bubblesVirtually: bubblesVirtually
  }), Object(external_wp_element_["createElement"])("div", null, Object(external_wp_element_["createElement"])(AdvancedControls, {
    slotName: inspector_advanced_controls.slotName,
    bubblesVirtually: bubblesVirtually
  })), Object(external_wp_element_["createElement"])(skip_to_selected_block, {
    key: "back"
  }));
};

const AdvancedControls = ({
  slotName,
  bubblesVirtually
}) => {
  const slot = Object(external_wp_components_["__experimentalUseSlot"])(slotName);
  const hasFills = Boolean(slot.fills && slot.fills.length);

  if (!hasFills) {
    return null;
  }

  return Object(external_wp_element_["createElement"])(external_wp_components_["PanelBody"], {
    className: "block-editor-block-inspector__advanced",
    title: Object(external_wp_i18n_["__"])('Advanced'),
    initialOpen: false
  }, Object(external_wp_element_["createElement"])(inspector_advanced_controls.Slot, {
    bubblesVirtually: bubblesVirtually
  }));
};

/* harmony default export */ var block_inspector = (BlockInspector);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/block-tools/index.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */






/**
 * Renders block tools (the block toolbar, select/navigation mode toolbar, the
 * insertion point and a slot for the inline rich text toolbar). Must be wrapped
 * around the block content and editor styles wrapper or iframe.
 *
 * @param {Object} $0          Props.
 * @param {Object} $0.children The block content and style container.
 * @param {Object} $0.__unstableContentRef Ref holding the content scroll container.
 */

function BlockTools({
  children,
  __unstableContentRef
}) {
  const isLargeViewport = Object(external_wp_compose_["useViewportMatch"])('medium');
  const hasFixedToolbar = Object(external_wp_data_["useSelect"])(select => select(store).getSettings().hasFixedToolbar, []);
  return Object(external_wp_element_["createElement"])(InsertionPoint, {
    __unstableContentRef: __unstableContentRef
  }, (hasFixedToolbar || !isLargeViewport) && Object(external_wp_element_["createElement"])(block_contextual_toolbar, {
    isFixed: true
  }), Object(external_wp_element_["createElement"])(WrappedBlockPopover, {
    __unstableContentRef: __unstableContentRef
  }), Object(external_wp_element_["createElement"])(external_wp_components_["Popover"].Slot, {
    name: "block-toolbar",
    ref: usePopoverScroll(__unstableContentRef)
  }), children);
}

// EXTERNAL MODULE: ./node_modules/traverse/index.js
var traverse = __webpack_require__("eGrx");
var traverse_default = /*#__PURE__*/__webpack_require__.n(traverse);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/parse.js
/* eslint-disable @wordpress/no-unused-vars-before-return */
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.
// http://www.w3.org/TR/CSS21/grammar.htm
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
const commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
/* harmony default export */ var parse = (function (css, options) {
  options = options || {};
  /**
   * Positional.
   */

  let lineno = 1;
  let column = 1;
  /**
   * Update lineno and column based on `str`.
   */

  function updatePosition(str) {
    const lines = str.match(/\n/g);

    if (lines) {
      lineno += lines.length;
    }

    const i = str.lastIndexOf('\n'); // eslint-disable-next-line no-bitwise

    column = ~i ? str.length - i : column + str.length;
  }
  /**
   * Mark position and patch `node.position`.
   */


  function position() {
    const start = {
      line: lineno,
      column
    };
    return function (node) {
      node.position = new Position(start);
      whitespace();
      return node;
    };
  }
  /**
   * Store position information for a node
   */


  function Position(start) {
    this.start = start;
    this.end = {
      line: lineno,
      column
    };
    this.source = options.source;
  }
  /**
   * Non-enumerable source string
   */


  Position.prototype.content = css;
  /**
   * Error `msg`.
   */

  const errorsList = [];

  function error(msg) {
    const err = new Error(options.source + ':' + lineno + ':' + column + ': ' + msg);
    err.reason = msg;
    err.filename = options.source;
    err.line = lineno;
    err.column = column;
    err.source = css;

    if (options.silent) {
      errorsList.push(err);
    } else {
      throw err;
    }
  }
  /**
   * Parse stylesheet.
   */


  function stylesheet() {
    const rulesList = rules();
    return {
      type: 'stylesheet',
      stylesheet: {
        source: options.source,
        rules: rulesList,
        parsingErrors: errorsList
      }
    };
  }
  /**
   * Opening brace.
   */


  function open() {
    return match(/^{\s*/);
  }
  /**
   * Closing brace.
   */


  function close() {
    return match(/^}/);
  }
  /**
   * Parse ruleset.
   */


  function rules() {
    let node;
    const accumulator = [];
    whitespace();
    comments(accumulator);

    while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {
      if (node !== false) {
        accumulator.push(node);
        comments(accumulator);
      }
    }

    return accumulator;
  }
  /**
   * Match `re` and return captures.
   */


  function match(re) {
    const m = re.exec(css);

    if (!m) {
      return;
    }

    const str = m[0];
    updatePosition(str);
    css = css.slice(str.length);
    return m;
  }
  /**
   * Parse whitespace.
   */


  function whitespace() {
    match(/^\s*/);
  }
  /**
   * Parse comments;
   */


  function comments(accumulator) {
    let c;
    accumulator = accumulator || []; // eslint-disable-next-line no-cond-assign

    while (c = comment()) {
      if (c !== false) {
        accumulator.push(c);
      }
    }

    return accumulator;
  }
  /**
   * Parse comment.
   */


  function comment() {
    const pos = position();

    if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {
      return;
    }

    let i = 2;

    while ('' !== css.charAt(i) && ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))) {
      ++i;
    }

    i += 2;

    if ('' === css.charAt(i - 1)) {
      return error('End of comment missing');
    }

    const str = css.slice(2, i - 2);
    column += 2;
    updatePosition(str);
    css = css.slice(i);
    column += 2;
    return pos({
      type: 'comment',
      comment: str
    });
  }
  /**
   * Parse selector.
   */


  function selector() {
    const m = match(/^([^{]+)/);

    if (!m) {
      return;
    } // FIXME: Remove all comments from selectors http://ostermiller.org/findcomment.html


    return trim(m[0]).replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, '').replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function (matched) {
      return matched.replace(/,/g, '\u200C');
    }).split(/\s*(?![^(]*\)),\s*/).map(function (s) {
      return s.replace(/\u200C/g, ',');
    });
  }
  /**
   * Parse declaration.
   */


  function declaration() {
    const pos = position(); // prop

    let prop = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);

    if (!prop) {
      return;
    }

    prop = trim(prop[0]); // :

    if (!match(/^:\s*/)) {
      return error("property missing ':'");
    } // val


    const val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);
    const ret = pos({
      type: 'declaration',
      property: prop.replace(commentre, ''),
      value: val ? trim(val[0]).replace(commentre, '') : ''
    }); // ;

    match(/^[;\s]*/);
    return ret;
  }
  /**
   * Parse declarations.
   */


  function declarations() {
    const decls = [];

    if (!open()) {
      return error("missing '{'");
    }

    comments(decls); // declarations

    let decl; // eslint-disable-next-line no-cond-assign

    while (decl = declaration()) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }

    if (!close()) {
      return error("missing '}'");
    }

    return decls;
  }
  /**
   * Parse keyframe.
   */


  function keyframe() {
    let m;
    const vals = [];
    const pos = position(); // eslint-disable-next-line no-cond-assign

    while (m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
      vals.push(m[1]);
      match(/^,\s*/);
    }

    if (!vals.length) {
      return;
    }

    return pos({
      type: 'keyframe',
      values: vals,
      declarations: declarations()
    });
  }
  /**
   * Parse keyframes.
   */


  function atkeyframes() {
    const pos = position();
    let m = match(/^@([-\w]+)?keyframes\s*/);

    if (!m) {
      return;
    }

    const vendor = m[1]; // identifier

    m = match(/^([-\w]+)\s*/);

    if (!m) {
      return error('@keyframes missing name');
    }

    const name = m[1];

    if (!open()) {
      return error("@keyframes missing '{'");
    }

    let frame;
    let frames = comments(); // eslint-disable-next-line no-cond-assign

    while (frame = keyframe()) {
      frames.push(frame);
      frames = frames.concat(comments());
    }

    if (!close()) {
      return error("@keyframes missing '}'");
    }

    return pos({
      type: 'keyframes',
      name,
      vendor,
      keyframes: frames
    });
  }
  /**
   * Parse supports.
   */


  function atsupports() {
    const pos = position();
    const m = match(/^@supports *([^{]+)/);

    if (!m) {
      return;
    }

    const supports = trim(m[1]);

    if (!open()) {
      return error("@supports missing '{'");
    }

    const style = comments().concat(rules());

    if (!close()) {
      return error("@supports missing '}'");
    }

    return pos({
      type: 'supports',
      supports,
      rules: style
    });
  }
  /**
   * Parse host.
   */


  function athost() {
    const pos = position();
    const m = match(/^@host\s*/);

    if (!m) {
      return;
    }

    if (!open()) {
      return error("@host missing '{'");
    }

    const style = comments().concat(rules());

    if (!close()) {
      return error("@host missing '}'");
    }

    return pos({
      type: 'host',
      rules: style
    });
  }
  /**
   * Parse media.
   */


  function atmedia() {
    const pos = position();
    const m = match(/^@media *([^{]+)/);

    if (!m) {
      return;
    }

    const media = trim(m[1]);

    if (!open()) {
      return error("@media missing '{'");
    }

    const style = comments().concat(rules());

    if (!close()) {
      return error("@media missing '}'");
    }

    return pos({
      type: 'media',
      media,
      rules: style
    });
  }
  /**
   * Parse custom-media.
   */


  function atcustommedia() {
    const pos = position();
    const m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);

    if (!m) {
      return;
    }

    return pos({
      type: 'custom-media',
      name: trim(m[1]),
      media: trim(m[2])
    });
  }
  /**
   * Parse paged media.
   */


  function atpage() {
    const pos = position();
    const m = match(/^@page */);

    if (!m) {
      return;
    }

    const sel = selector() || [];

    if (!open()) {
      return error("@page missing '{'");
    }

    let decls = comments(); // declarations

    let decl; // eslint-disable-next-line no-cond-assign

    while (decl = declaration()) {
      decls.push(decl);
      decls = decls.concat(comments());
    }

    if (!close()) {
      return error("@page missing '}'");
    }

    return pos({
      type: 'page',
      selectors: sel,
      declarations: decls
    });
  }
  /**
   * Parse document.
   */


  function atdocument() {
    const pos = position();
    const m = match(/^@([-\w]+)?document *([^{]+)/);

    if (!m) {
      return;
    }

    const vendor = trim(m[1]);
    const doc = trim(m[2]);

    if (!open()) {
      return error("@document missing '{'");
    }

    const style = comments().concat(rules());

    if (!close()) {
      return error("@document missing '}'");
    }

    return pos({
      type: 'document',
      document: doc,
      vendor,
      rules: style
    });
  }
  /**
   * Parse font-face.
   */


  function atfontface() {
    const pos = position();
    const m = match(/^@font-face\s*/);

    if (!m) {
      return;
    }

    if (!open()) {
      return error("@font-face missing '{'");
    }

    let decls = comments(); // declarations

    let decl; // eslint-disable-next-line no-cond-assign

    while (decl = declaration()) {
      decls.push(decl);
      decls = decls.concat(comments());
    }

    if (!close()) {
      return error("@font-face missing '}'");
    }

    return pos({
      type: 'font-face',
      declarations: decls
    });
  }
  /**
   * Parse import
   */


  const atimport = _compileAtrule('import');
  /**
   * Parse charset
   */


  const atcharset = _compileAtrule('charset');
  /**
   * Parse namespace
   */


  const atnamespace = _compileAtrule('namespace');
  /**
   * Parse non-block at-rules
   */


  function _compileAtrule(name) {
    const re = new RegExp('^@' + name + '\\s*([^;]+);');
    return function () {
      const pos = position();
      const m = match(re);

      if (!m) {
        return;
      }

      const ret = {
        type: name
      };
      ret[name] = m[1].trim();
      return pos(ret);
    };
  }
  /**
   * Parse at rule.
   */


  function atrule() {
    if (css[0] !== '@') {
      return;
    }

    return atkeyframes() || atmedia() || atcustommedia() || atsupports() || atimport() || atcharset() || atnamespace() || atdocument() || atpage() || athost() || atfontface();
  }
  /**
   * Parse rule.
   */


  function rule() {
    const pos = position();
    const sel = selector();

    if (!sel) {
      return error('selector missing');
    }

    comments();
    return pos({
      type: 'rule',
      selectors: sel,
      declarations: declarations()
    });
  }

  return addParent(stylesheet());
});
/**
 * Trim `str`.
 */

function trim(str) {
  return str ? str.replace(/^\s+|\s+$/g, '') : '';
}
/**
 * Adds non-enumerable parent node reference to each node.
 */


function addParent(obj, parent) {
  const isNode = obj && typeof obj.type === 'string';
  const childParent = isNode ? obj : parent;

  for (const k in obj) {
    const value = obj[k];

    if (Array.isArray(value)) {
      value.forEach(function (v) {
        addParent(v, childParent);
      });
    } else if (value && typeof value === 'object') {
      addParent(value, childParent);
    }
  }

  if (isNode) {
    Object.defineProperty(obj, 'parent', {
      configurable: true,
      writable: true,
      enumerable: false,
      value: parent || null
    });
  }

  return obj;
}
/* eslint-enable @wordpress/no-unused-vars-before-return */

// EXTERNAL MODULE: ./node_modules/inherits/inherits_browser.js
var inherits_browser = __webpack_require__("P7XM");
var inherits_browser_default = /*#__PURE__*/__webpack_require__.n(inherits_browser);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/compiler.js
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.

/**
 * Expose `Compiler`.
 */
/* harmony default export */ var stringify_compiler = (Compiler);
/**
 * Initialize a compiler.
 */

function Compiler(opts) {
  this.options = opts || {};
}
/**
 * Emit `str`
 */


Compiler.prototype.emit = function (str) {
  return str;
};
/**
 * Visit `node`.
 */


Compiler.prototype.visit = function (node) {
  return this[node.type](node);
};
/**
 * Map visit over array of `nodes`, optionally using a `delim`
 */


Compiler.prototype.mapVisit = function (nodes, delim) {
  let buf = '';
  delim = delim || '';

  for (let i = 0, length = nodes.length; i < length; i++) {
    buf += this.visit(nodes[i]);

    if (delim && i < length - 1) {
      buf += this.emit(delim);
    }
  }

  return buf;
};

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/compress.js
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Expose compiler.
 */

/* harmony default export */ var compress = (compress_Compiler);
/**
 * Initialize a new `Compiler`.
 */

function compress_Compiler(options) {
  stringify_compiler.call(this, options);
}
/**
 * Inherit from `Base.prototype`.
 */


inherits_browser_default()(compress_Compiler, stringify_compiler);
/**
 * Compile `node`.
 */

compress_Compiler.prototype.compile = function (node) {
  return node.stylesheet.rules.map(this.visit, this).join('');
};
/**
 * Visit comment node.
 */


compress_Compiler.prototype.comment = function (node) {
  return this.emit('', node.position);
};
/**
 * Visit import node.
 */


compress_Compiler.prototype.import = function (node) {
  return this.emit('@import ' + node.import + ';', node.position);
};
/**
 * Visit media node.
 */


compress_Compiler.prototype.media = function (node) {
  return this.emit('@media ' + node.media, node.position) + this.emit('{') + this.mapVisit(node.rules) + this.emit('}');
};
/**
 * Visit document node.
 */


compress_Compiler.prototype.document = function (node) {
  const doc = '@' + (node.vendor || '') + 'document ' + node.document;
  return this.emit(doc, node.position) + this.emit('{') + this.mapVisit(node.rules) + this.emit('}');
};
/**
 * Visit charset node.
 */


compress_Compiler.prototype.charset = function (node) {
  return this.emit('@charset ' + node.charset + ';', node.position);
};
/**
 * Visit namespace node.
 */


compress_Compiler.prototype.namespace = function (node) {
  return this.emit('@namespace ' + node.namespace + ';', node.position);
};
/**
 * Visit supports node.
 */


compress_Compiler.prototype.supports = function (node) {
  return this.emit('@supports ' + node.supports, node.position) + this.emit('{') + this.mapVisit(node.rules) + this.emit('}');
};
/**
 * Visit keyframes node.
 */


compress_Compiler.prototype.keyframes = function (node) {
  return this.emit('@' + (node.vendor || '') + 'keyframes ' + node.name, node.position) + this.emit('{') + this.mapVisit(node.keyframes) + this.emit('}');
};
/**
 * Visit keyframe node.
 */


compress_Compiler.prototype.keyframe = function (node) {
  const decls = node.declarations;
  return this.emit(node.values.join(','), node.position) + this.emit('{') + this.mapVisit(decls) + this.emit('}');
};
/**
 * Visit page node.
 */


compress_Compiler.prototype.page = function (node) {
  const sel = node.selectors.length ? node.selectors.join(', ') : '';
  return this.emit('@page ' + sel, node.position) + this.emit('{') + this.mapVisit(node.declarations) + this.emit('}');
};
/**
 * Visit font-face node.
 */


compress_Compiler.prototype['font-face'] = function (node) {
  return this.emit('@font-face', node.position) + this.emit('{') + this.mapVisit(node.declarations) + this.emit('}');
};
/**
 * Visit host node.
 */


compress_Compiler.prototype.host = function (node) {
  return this.emit('@host', node.position) + this.emit('{') + this.mapVisit(node.rules) + this.emit('}');
};
/**
 * Visit custom-media node.
 */


compress_Compiler.prototype['custom-media'] = function (node) {
  return this.emit('@custom-media ' + node.name + ' ' + node.media + ';', node.position);
};
/**
 * Visit rule node.
 */


compress_Compiler.prototype.rule = function (node) {
  const decls = node.declarations;

  if (!decls.length) {
    return '';
  }

  return this.emit(node.selectors.join(','), node.position) + this.emit('{') + this.mapVisit(decls) + this.emit('}');
};
/**
 * Visit declaration node.
 */


compress_Compiler.prototype.declaration = function (node) {
  return this.emit(node.property + ':' + node.value, node.position) + this.emit(';');
};

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/identity.js
/* eslint-disable @wordpress/no-unused-vars-before-return */
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Expose compiler.
 */

/* harmony default export */ var identity = (identity_Compiler);
/**
 * Initialize a new `Compiler`.
 */

function identity_Compiler(options) {
  options = options || {};
  stringify_compiler.call(this, options);
  this.indentation = options.indent;
}
/**
 * Inherit from `Base.prototype`.
 */


inherits_browser_default()(identity_Compiler, stringify_compiler);
/**
 * Compile `node`.
 */

identity_Compiler.prototype.compile = function (node) {
  return this.stylesheet(node);
};
/**
 * Visit stylesheet node.
 */


identity_Compiler.prototype.stylesheet = function (node) {
  return this.mapVisit(node.stylesheet.rules, '\n\n');
};
/**
 * Visit comment node.
 */


identity_Compiler.prototype.comment = function (node) {
  return this.emit(this.indent() + '/*' + node.comment + '*/', node.position);
};
/**
 * Visit import node.
 */


identity_Compiler.prototype.import = function (node) {
  return this.emit('@import ' + node.import + ';', node.position);
};
/**
 * Visit media node.
 */


identity_Compiler.prototype.media = function (node) {
  return this.emit('@media ' + node.media, node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(node.rules, '\n\n') + this.emit(this.indent(-1) + '\n}');
};
/**
 * Visit document node.
 */


identity_Compiler.prototype.document = function (node) {
  const doc = '@' + (node.vendor || '') + 'document ' + node.document;
  return this.emit(doc, node.position) + this.emit(' ' + ' {\n' + this.indent(1)) + this.mapVisit(node.rules, '\n\n') + this.emit(this.indent(-1) + '\n}');
};
/**
 * Visit charset node.
 */


identity_Compiler.prototype.charset = function (node) {
  return this.emit('@charset ' + node.charset + ';', node.position);
};
/**
 * Visit namespace node.
 */


identity_Compiler.prototype.namespace = function (node) {
  return this.emit('@namespace ' + node.namespace + ';', node.position);
};
/**
 * Visit supports node.
 */


identity_Compiler.prototype.supports = function (node) {
  return this.emit('@supports ' + node.supports, node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(node.rules, '\n\n') + this.emit(this.indent(-1) + '\n}');
};
/**
 * Visit keyframes node.
 */


identity_Compiler.prototype.keyframes = function (node) {
  return this.emit('@' + (node.vendor || '') + 'keyframes ' + node.name, node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(node.keyframes, '\n') + this.emit(this.indent(-1) + '}');
};
/**
 * Visit keyframe node.
 */


identity_Compiler.prototype.keyframe = function (node) {
  const decls = node.declarations;
  return this.emit(this.indent()) + this.emit(node.values.join(', '), node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(decls, '\n') + this.emit(this.indent(-1) + '\n' + this.indent() + '}\n');
};
/**
 * Visit page node.
 */


identity_Compiler.prototype.page = function (node) {
  const sel = node.selectors.length ? node.selectors.join(', ') + ' ' : '';
  return this.emit('@page ' + sel, node.position) + this.emit('{\n') + this.emit(this.indent(1)) + this.mapVisit(node.declarations, '\n') + this.emit(this.indent(-1)) + this.emit('\n}');
};
/**
 * Visit font-face node.
 */


identity_Compiler.prototype['font-face'] = function (node) {
  return this.emit('@font-face ', node.position) + this.emit('{\n') + this.emit(this.indent(1)) + this.mapVisit(node.declarations, '\n') + this.emit(this.indent(-1)) + this.emit('\n}');
};
/**
 * Visit host node.
 */


identity_Compiler.prototype.host = function (node) {
  return this.emit('@host', node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(node.rules, '\n\n') + this.emit(this.indent(-1) + '\n}');
};
/**
 * Visit custom-media node.
 */


identity_Compiler.prototype['custom-media'] = function (node) {
  return this.emit('@custom-media ' + node.name + ' ' + node.media + ';', node.position);
};
/**
 * Visit rule node.
 */


identity_Compiler.prototype.rule = function (node) {
  const indent = this.indent();
  const decls = node.declarations;

  if (!decls.length) {
    return '';
  }

  return this.emit(node.selectors.map(function (s) {
    return indent + s;
  }).join(',\n'), node.position) + this.emit(' {\n') + this.emit(this.indent(1)) + this.mapVisit(decls, '\n') + this.emit(this.indent(-1)) + this.emit('\n' + this.indent() + '}');
};
/**
 * Visit declaration node.
 */


identity_Compiler.prototype.declaration = function (node) {
  return this.emit(this.indent()) + this.emit(node.property + ': ' + node.value, node.position) + this.emit(';');
};
/**
 * Increase, decrease or return current indentation.
 */


identity_Compiler.prototype.indent = function (level) {
  this.level = this.level || 1;

  if (null !== level) {
    this.level += level;
    return '';
  }

  return Array(this.level).join(this.indentation || '  ');
};
/* eslint-enable @wordpress/no-unused-vars-before-return */

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/index.js
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.

/**
 * Internal dependencies
 */


/**
 * Stringfy the given AST `node`.
 *
 * Options:
 *
 *  - `compress` space-optimized output
 *  - `sourcemap` return an object with `.code` and `.map`
 *
 * @param {Object} node
 * @param {Object} [options]
 * @return {string}
 */

/* harmony default export */ var stringify = (function (node, options) {
  options = options || {};
  const compiler = options.compress ? new compress(options) : new identity(options);
  const code = compiler.compile(node);
  return code;
});

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/transform-styles/traverse.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */



function traverseCSS(css, callback) {
  try {
    const parsed = parse(css);
    const updated = traverse_default.a.map(parsed, function (node) {
      if (!node) {
        return node;
      }

      const updatedNode = callback(node);
      return this.update(updatedNode);
    });
    return stringify(updated);
  } catch (err) {
    // eslint-disable-next-line no-console
    console.warn('Error while traversing the CSS: ' + err);
    return null;
  }
}

/* harmony default export */ var transform_styles_traverse = (traverseCSS);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/transform-styles/transforms/url-rewrite.js
/**
 * Return `true` if the given path is http/https.
 *
 * @param  {string}  filePath path
 *
 * @return {boolean} is remote path.
 */
function isRemotePath(filePath) {
  return /^(?:https?:)?\/\//.test(filePath);
}
/**
 * Return `true` if the given filePath is an absolute url.
 *
 * @param  {string}  filePath path
 *
 * @return {boolean} is absolute path.
 */


function isAbsolutePath(filePath) {
  return /^\/(?!\/)/.test(filePath);
}
/**
 * Whether or not the url should be inluded.
 *
 * @param  {Object} meta url meta info
 *
 * @return {boolean} is valid.
 */


function isValidURL(meta) {
  // ignore hashes or data uris
  if (meta.value.indexOf('data:') === 0 || meta.value.indexOf('#') === 0) {
    return false;
  }

  if (isAbsolutePath(meta.value)) {
    return false;
  } // do not handle the http/https urls if `includeRemote` is false


  if (isRemotePath(meta.value)) {
    return false;
  }

  return true;
}
/**
 * Get the absolute path of the url, relative to the basePath
 *
 * @param  {string} str          the url
 * @param  {string} baseURL      base URL
 *
 * @return {string}              the full path to the file
 */


function getResourcePath(str, baseURL) {
  return new URL(str, baseURL).toString();
}
/**
 * Process the single `url()` pattern
 *
 * @param  {string} baseURL  the base URL for relative URLs
 * @return {Promise}         the Promise
 */


function processURL(baseURL) {
  return meta => ({ ...meta,
    newUrl: 'url(' + meta.before + meta.quote + getResourcePath(meta.value, baseURL) + meta.quote + meta.after + ')'
  });
}
/**
 * Get all `url()`s, and return the meta info
 *
 * @param  {string} value decl.value
 *
 * @return {Array}        the urls
 */


function getURLs(value) {
  const reg = /url\((\s*)(['"]?)(.+?)\2(\s*)\)/g;
  let match;
  const URLs = [];

  while ((match = reg.exec(value)) !== null) {
    const meta = {
      source: match[0],
      before: match[1],
      quote: match[2],
      value: match[3],
      after: match[4]
    };

    if (isValidURL(meta)) {
      URLs.push(meta);
    }
  }

  return URLs;
}
/**
 * Replace the raw value's `url()` segment to the new value
 *
 * @param  {string} raw  the raw value
 * @param  {Array}  URLs the URLs to replace
 *
 * @return {string}     the new value
 */


function replaceURLs(raw, URLs) {
  URLs.forEach(item => {
    raw = raw.replace(item.source, item.newUrl);
  });
  return raw;
}

const rewrite = rootURL => node => {
  if (node.type === 'declaration') {
    const updatedURLs = getURLs(node.value).map(processURL(rootURL));
    return { ...node,
      value: replaceURLs(node.value, updatedURLs)
    };
  }

  return node;
};

/* harmony default export */ var url_rewrite = (rewrite);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/transform-styles/transforms/wrap.js
/**
 * @constant string IS_ROOT_TAG Regex to check if the selector is a root tag selector.
 */
const IS_ROOT_TAG = /^(body|html|:root).*$/;

const wrap = (namespace, ignore = []) => node => {
  const updateSelector = selector => {
    if (ignore.includes(selector.trim())) {
      return selector;
    } // Anything other than a root tag is always prefixed.


    {
      if (!selector.match(IS_ROOT_TAG)) {
        return namespace + ' ' + selector;
      }
    } // HTML and Body elements cannot be contained within our container so lets extract their styles.

    return selector.replace(/^(body|html|:root)/, namespace);
  };

  if (node.type === 'rule') {
    return { ...node,
      selectors: node.selectors.map(updateSelector)
    };
  }

  return node;
};

/* harmony default export */ var transforms_wrap = (wrap);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/transform-styles/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




/**
 * Applies a series of CSS rule transforms to wrap selectors inside a given class and/or rewrite URLs depending on the parameters passed.
 *
 * @param {Array} styles CSS rules.
 * @param {string} wrapperClassName Wrapper Class Name.
 * @return {Array} converted rules.
 */

const transformStyles = (styles, wrapperClassName = '') => {
  return Object(external_lodash_["map"])(styles, ({
    css,
    baseURL,
    __experimentalNoWrapper = false
  }) => {
    const transforms = [];

    if (wrapperClassName && !__experimentalNoWrapper) {
      transforms.push(transforms_wrap(wrapperClassName));
    }

    if (baseURL) {
      transforms.push(url_rewrite(baseURL));
    }

    if (transforms.length) {
      return transform_styles_traverse(css, Object(external_wp_compose_["compose"])(transforms));
    }

    return css;
  });
};

/* harmony default export */ var transform_styles = (transformStyles);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/editor-styles/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


const EDITOR_STYLES_SELECTOR = '.editor-styles-wrapper';

function useDarkThemeBodyClassName(styles) {
  return Object(external_wp_element_["useCallback"])(node => {
    if (!node) {
      return;
    }

    const {
      ownerDocument
    } = node;
    const {
      defaultView,
      body
    } = ownerDocument;
    const canvas = ownerDocument.querySelector(EDITOR_STYLES_SELECTOR);
    let backgroundColor;

    if (!canvas) {
      // The real .editor-styles-wrapper element might not exist in the
      // DOM, so calculate the background color by creating a fake
      // wrapper.
      const tempCanvas = ownerDocument.createElement('div');
      tempCanvas.classList.add('editor-styles-wrapper');
      body.appendChild(tempCanvas);
      backgroundColor = defaultView.getComputedStyle(tempCanvas, null).getPropertyValue('background-color');
      body.removeChild(tempCanvas);
    } else {
      backgroundColor = defaultView.getComputedStyle(canvas, null).getPropertyValue('background-color');
    } // If background is transparent, it should be treated as light color.


    if (tinycolor_default()(backgroundColor).getLuminance() > 0.5 || tinycolor_default()(backgroundColor).getAlpha() === 0) {
      body.classList.remove('is-dark-theme');
    } else {
      body.classList.add('is-dark-theme');
    }
  }, [styles]);
}

function EditorStyles({
  styles
}) {
  const transformedStyles = Object(external_wp_element_["useMemo"])(() => transform_styles(styles, EDITOR_STYLES_SELECTOR), [styles]);
  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])("style", {
    ref: useDarkThemeBodyClassName(styles)
  }), transformedStyles.map((css, index) => Object(external_wp_element_["createElement"])("style", {
    key: index
  }, css)));
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/inserter/library.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function InserterLibrary({
  rootClientId,
  clientId,
  isAppender,
  showInserterHelpPanel,
  showMostUsedBlocks = false,
  __experimentalInsertionIndex,
  onSelect = external_lodash_["noop"],
  shouldFocusBlock = false
}) {
  const destinationRootClientId = Object(external_wp_data_["useSelect"])(select => {
    const {
      getBlockRootClientId
    } = select(store);
    return rootClientId || getBlockRootClientId(clientId) || undefined;
  }, [clientId, rootClientId]);
  return Object(external_wp_element_["createElement"])(menu, {
    onSelect: onSelect,
    rootClientId: destinationRootClientId,
    clientId: clientId,
    isAppender: isAppender,
    showInserterHelpPanel: showInserterHelpPanel,
    showMostUsedBlocks: showMostUsedBlocks,
    __experimentalInsertionIndex: __experimentalInsertionIndex,
    shouldFocusBlock: shouldFocusBlock
  });
}

/* harmony default export */ var library = (InserterLibrary);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/keyboard-shortcuts/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



function KeyboardShortcuts() {
  // Shortcuts Logic
  const {
    clientIds,
    rootClientId
  } = Object(external_wp_data_["useSelect"])(select => {
    const {
      getSelectedBlockClientIds,
      getBlockRootClientId
    } = select(store);
    const selectedClientIds = getSelectedBlockClientIds();
    const [firstClientId] = selectedClientIds;
    return {
      clientIds: selectedClientIds,
      rootClientId: getBlockRootClientId(firstClientId)
    };
  }, []);
  const {
    duplicateBlocks,
    removeBlocks,
    insertAfterBlock,
    insertBeforeBlock,
    clearSelectedBlock,
    moveBlocksUp,
    moveBlocksDown
  } = Object(external_wp_data_["useDispatch"])(store); // Moves selected block/blocks up

  Object(external_wp_keyboardShortcuts_["useShortcut"])('core/block-editor/move-up', Object(external_wp_element_["useCallback"])(event => {
    event.preventDefault();
    moveBlocksUp(clientIds, rootClientId);
  }, [clientIds, moveBlocksUp]), {
    bindGlobal: true,
    isDisabled: clientIds.length === 0
  }); // Moves selected block/blocks up

  Object(external_wp_keyboardShortcuts_["useShortcut"])('core/block-editor/move-down', Object(external_wp_element_["useCallback"])(event => {
    event.preventDefault();
    moveBlocksDown(clientIds, rootClientId);
  }, [clientIds, moveBlocksDown]), {
    bindGlobal: true,
    isDisabled: clientIds.length === 0
  }); // Prevents bookmark all Tabs shortcut in Chrome when devtools are closed.
  // Prevents reposition Chrome devtools pane shortcut when devtools are open.

  Object(external_wp_keyboardShortcuts_["useShortcut"])('core/block-editor/duplicate', Object(external_wp_element_["useCallback"])(event => {
    event.preventDefault();
    duplicateBlocks(clientIds);
  }, [clientIds, duplicateBlocks]), {
    bindGlobal: true,
    isDisabled: clientIds.length === 0
  }); // Does not clash with any known browser/native shortcuts, but preventDefault
  // is used to prevent any obscure unknown shortcuts from triggering.

  Object(external_wp_keyboardShortcuts_["useShortcut"])('core/block-editor/remove', Object(external_wp_element_["useCallback"])(event => {
    event.preventDefault();
    removeBlocks(clientIds);
  }, [clientIds, removeBlocks]), {
    bindGlobal: true,
    isDisabled: clientIds.length === 0
  }); // Does not clash with any known browser/native shortcuts, but preventDefault
  // is used to prevent any obscure unknown shortcuts from triggering.

  Object(external_wp_keyboardShortcuts_["useShortcut"])('core/block-editor/insert-after', Object(external_wp_element_["useCallback"])(event => {
    event.preventDefault();
    insertAfterBlock(Object(external_lodash_["last"])(clientIds));
  }, [clientIds, insertAfterBlock]), {
    bindGlobal: true,
    isDisabled: clientIds.length === 0
  }); // Prevent 'view recently closed tabs' in Opera using preventDefault.

  Object(external_wp_keyboardShortcuts_["useShortcut"])('core/block-editor/insert-before', Object(external_wp_element_["useCallback"])(event => {
    event.preventDefault();
    insertBeforeBlock(Object(external_lodash_["first"])(clientIds));
  }, [clientIds, insertBeforeBlock]), {
    bindGlobal: true,
    isDisabled: clientIds.length === 0
  });
  Object(external_wp_keyboardShortcuts_["useShortcut"])('core/block-editor/delete-multi-selection', Object(external_wp_element_["useCallback"])(event => {
    event.preventDefault();
    removeBlocks(clientIds);
  }, [clientIds, removeBlocks]), {
    isDisabled: clientIds.length < 2
  });
  Object(external_wp_keyboardShortcuts_["useShortcut"])('core/block-editor/unselect', Object(external_wp_element_["useCallback"])(event => {
    event.preventDefault();
    clearSelectedBlock();
    event.target.ownerDocument.defaultView.getSelection().removeAllRanges();
  }, [clientIds, clearSelectedBlock]), {
    isDisabled: clientIds.length < 2
  });
  return null;
}

function KeyboardShortcutsRegister() {
  // Registering the shortcuts
  const {
    registerShortcut
  } = Object(external_wp_data_["useDispatch"])(external_wp_keyboardShortcuts_["store"]);
  Object(external_wp_element_["useEffect"])(() => {
    registerShortcut({
      name: 'core/block-editor/duplicate',
      category: 'block',
      description: Object(external_wp_i18n_["__"])('Duplicate the selected block(s).'),
      keyCombination: {
        modifier: 'primaryShift',
        character: 'd'
      }
    });
    registerShortcut({
      name: 'core/block-editor/remove',
      category: 'block',
      description: Object(external_wp_i18n_["__"])('Remove the selected block(s).'),
      keyCombination: {
        modifier: 'access',
        character: 'z'
      }
    });
    registerShortcut({
      name: 'core/block-editor/insert-before',
      category: 'block',
      description: Object(external_wp_i18n_["__"])('Insert a new block before the selected block(s).'),
      keyCombination: {
        modifier: 'primaryAlt',
        character: 't'
      }
    });
    registerShortcut({
      name: 'core/block-editor/insert-after',
      category: 'block',
      description: Object(external_wp_i18n_["__"])('Insert a new block after the selected block(s).'),
      keyCombination: {
        modifier: 'primaryAlt',
        character: 'y'
      }
    });
    registerShortcut({
      name: 'core/block-editor/delete-multi-selection',
      category: 'block',
      description: Object(external_wp_i18n_["__"])('Remove multiple selected blocks.'),
      keyCombination: {
        character: 'del'
      },
      aliases: [{
        character: 'backspace'
      }]
    });
    registerShortcut({
      name: 'core/block-editor/select-all',
      category: 'selection',
      description: Object(external_wp_i18n_["__"])('Select all text when typing. Press again to select all blocks.'),
      keyCombination: {
        modifier: 'primary',
        character: 'a'
      }
    });
    registerShortcut({
      name: 'core/block-editor/unselect',
      category: 'selection',
      description: Object(external_wp_i18n_["__"])('Clear selection.'),
      keyCombination: {
        character: 'escape'
      }
    });
    registerShortcut({
      name: 'core/block-editor/focus-toolbar',
      category: 'global',
      description: Object(external_wp_i18n_["__"])('Navigate to the nearest toolbar.'),
      keyCombination: {
        modifier: 'alt',
        character: 'F10'
      }
    });
    registerShortcut({
      name: 'core/block-editor/move-up',
      category: 'block',
      description: Object(external_wp_i18n_["__"])('Move the selected block(s) up.'),
      keyCombination: {
        modifier: 'secondary',
        character: 't'
      }
    });
    registerShortcut({
      name: 'core/block-editor/move-down',
      category: 'block',
      description: Object(external_wp_i18n_["__"])('Move the selected block(s) down.'),
      keyCombination: {
        modifier: 'secondary',
        character: 'y'
      }
    });
  }, [registerShortcut]);
  return null;
}

KeyboardShortcuts.Register = KeyboardShortcutsRegister;
/* harmony default export */ var keyboard_shortcuts = (KeyboardShortcuts);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/selection-scroll-into-view/index.js
/**
 * WordPress dependencies
 */

/**
 * Scrolls the multi block selection end into view if not in view already. This
 * is important to do after selection by keyboard.
 *
 * @deprecated
 */

function MultiSelectScrollIntoView() {
  external_wp_deprecated_default()('wp.blockEditor.MultiSelectScrollIntoView', {
    hint: 'This behaviour is now built-in.'
  });
  return null;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/observe-typing/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/**
 * Set of key codes upon which typing is to be initiated on a keydown event.
 *
 * @type {Set<number>}
 */

const KEY_DOWN_ELIGIBLE_KEY_CODES = new Set([external_wp_keycodes_["UP"], external_wp_keycodes_["RIGHT"], external_wp_keycodes_["DOWN"], external_wp_keycodes_["LEFT"], external_wp_keycodes_["ENTER"], external_wp_keycodes_["BACKSPACE"]]);
/**
 * Returns true if a given keydown event can be inferred as intent to start
 * typing, or false otherwise. A keydown is considered eligible if it is a
 * text navigation without shift active.
 *
 * @param {KeyboardEvent} event Keydown event to test.
 *
 * @return {boolean} Whether event is eligible to start typing.
 */

function isKeyDownEligibleForStartTyping(event) {
  const {
    keyCode,
    shiftKey
  } = event;
  return !shiftKey && KEY_DOWN_ELIGIBLE_KEY_CODES.has(keyCode);
}
/**
 * Removes the `isTyping` flag when the mouse moves in the document of the given
 * element.
 */


function useMouseMoveTypingReset() {
  const isTyping = Object(external_wp_data_["useSelect"])(select => select(store).isTyping());
  const {
    stopTyping
  } = Object(external_wp_data_["useDispatch"])(store);
  return Object(external_wp_compose_["useRefEffect"])(node => {
    if (!isTyping) {
      return;
    }

    const {
      ownerDocument
    } = node;
    let lastClientX;
    let lastClientY;
    /**
     * On mouse move, unset typing flag if user has moved cursor.
     *
     * @param {MouseEvent} event Mousemove event.
     */

    function stopTypingOnMouseMove(event) {
      const {
        clientX,
        clientY
      } = event; // We need to check that the mouse really moved because Safari
      // triggers mousemove events when shift or ctrl are pressed.

      if (lastClientX && lastClientY && (lastClientX !== clientX || lastClientY !== clientY)) {
        stopTyping();
      }

      lastClientX = clientX;
      lastClientY = clientY;
    }

    ownerDocument.addEventListener('mousemove', stopTypingOnMouseMove);
    return () => {
      ownerDocument.removeEventListener('mousemove', stopTypingOnMouseMove);
    };
  }, [isTyping, stopTyping]);
}
/**
 * Sets and removes the `isTyping` flag based on user actions:
 *
 * - Sets the flag if the user types within the given element.
 * - Removes the flag when the user selects some text, focusses a non-text
 *   field, presses ESC or TAB, or moves the mouse in the document.
 */

function useTypingObserver() {
  const isTyping = Object(external_wp_data_["useSelect"])(select => select(store).isTyping());
  const {
    startTyping,
    stopTyping
  } = Object(external_wp_data_["useDispatch"])(store);
  const ref1 = useMouseMoveTypingReset();
  const ref2 = Object(external_wp_compose_["useRefEffect"])(node => {
    const {
      ownerDocument
    } = node;
    const {
      defaultView
    } = ownerDocument; // Listeners to stop typing should only be added when typing.
    // Listeners to start typing should only be added when not typing.

    if (isTyping) {
      let timerId;
      /**
       * Stops typing when focus transitions to a non-text field element.
       *
       * @param {FocusEvent} event Focus event.
       */

      function stopTypingOnNonTextField(event) {
        const {
          target
        } = event; // Since focus to a non-text field via arrow key will trigger
        // before the keydown event, wait until after current stack
        // before evaluating whether typing is to be stopped. Otherwise,
        // typing will re-start.

        timerId = defaultView.setTimeout(() => {
          if (!Object(external_wp_dom_["isTextField"])(target)) {
            stopTyping();
          }
        });
      }
      /**
       * Unsets typing flag if user presses Escape while typing flag is
       * active.
       *
       * @param {KeyboardEvent} event Keypress or keydown event to
       *                              interpret.
       */


      function stopTypingOnEscapeKey(event) {
        const {
          keyCode
        } = event;

        if (keyCode === external_wp_keycodes_["ESCAPE"] || keyCode === external_wp_keycodes_["TAB"]) {
          stopTyping();
        }
      }
      /**
       * On selection change, unset typing flag if user has made an
       * uncollapsed (shift) selection.
       */


      function stopTypingOnSelectionUncollapse() {
        const selection = defaultView.getSelection();
        const isCollapsed = selection.rangeCount > 0 && selection.getRangeAt(0).collapsed;

        if (!isCollapsed) {
          stopTyping();
        }
      }

      node.addEventListener('focus', stopTypingOnNonTextField);
      node.addEventListener('keydown', stopTypingOnEscapeKey);
      ownerDocument.addEventListener('selectionchange', stopTypingOnSelectionUncollapse);
      return () => {
        defaultView.clearTimeout(timerId);
        node.removeEventListener('focus', stopTypingOnNonTextField);
        node.removeEventListener('keydown', stopTypingOnEscapeKey);
        ownerDocument.removeEventListener('selectionchange', stopTypingOnSelectionUncollapse);
      };
    }
    /**
     * Handles a keypress or keydown event to infer intention to start
     * typing.
     *
     * @param {KeyboardEvent} event Keypress or keydown event to interpret.
     */


    function startTypingInTextField(event) {
      const {
        type,
        target
      } = event; // Abort early if already typing, or key press is incurred outside a
      // text field (e.g. arrow-ing through toolbar buttons).
      // Ignore typing if outside the current DOM container

      if (!Object(external_wp_dom_["isTextField"])(target) || !node.contains(target)) {
        return;
      } // Special-case keydown because certain keys do not emit a keypress
      // event. Conversely avoid keydown as the canonical event since
      // there are many keydown which are explicitly not targeted for
      // typing.


      if (type === 'keydown' && !isKeyDownEligibleForStartTyping(event)) {
        return;
      }

      startTyping();
    }

    node.addEventListener('keypress', startTypingInTextField);
    node.addEventListener('keydown', startTypingInTextField);
    return () => {
      node.removeEventListener('keypress', startTypingInTextField);
      node.removeEventListener('keydown', startTypingInTextField);
    };
  }, [isTyping, startTyping, stopTyping]);
  return Object(external_wp_compose_["useMergeRefs"])([ref1, ref2]);
}

function ObserveTyping({
  children
}) {
  return Object(external_wp_element_["createElement"])("div", {
    ref: useTypingObserver()
  }, children);
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/observe-typing/README.md
 */


/* harmony default export */ var observe_typing = (ObserveTyping);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/preserve-scroll-in-reorder/index.js
/**
 * WordPress dependencies
 */

function PreserveScrollInReorder() {
  external_wp_deprecated_default()('PreserveScrollInReorder component', {
    since: '5.4',
    hint: 'This behavior is now built-in the block list'
  });
  return null;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/typewriter/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


const isIE = window.navigator.userAgent.indexOf('Trident') !== -1;
const arrowKeyCodes = new Set([external_wp_keycodes_["UP"], external_wp_keycodes_["DOWN"], external_wp_keycodes_["LEFT"], external_wp_keycodes_["RIGHT"]]);
const initialTriggerPercentage = 0.75;
function useTypewriter() {
  const hasSelectedBlock = Object(external_wp_data_["useSelect"])(select => select(store).hasSelectedBlock());
  return Object(external_wp_compose_["useRefEffect"])(node => {
    if (!hasSelectedBlock) {
      return;
    }

    const {
      ownerDocument
    } = node;
    const {
      defaultView
    } = ownerDocument;
    let scrollResizeRafId;
    let onKeyDownRafId;
    let caretRect;

    function onScrollResize() {
      if (scrollResizeRafId) {
        return;
      }

      scrollResizeRafId = defaultView.requestAnimationFrame(() => {
        computeCaretRectangle();
        scrollResizeRafId = null;
      });
    }

    function onKeyDown(event) {
      // Ensure the any remaining request is cancelled.
      if (onKeyDownRafId) {
        defaultView.cancelAnimationFrame(onKeyDownRafId);
      } // Use an animation frame for a smooth result.


      onKeyDownRafId = defaultView.requestAnimationFrame(() => {
        maintainCaretPosition(event);
        onKeyDownRafId = null;
      });
    }
    /**
     * Maintains the scroll position after a selection change caused by a
     * keyboard event.
     *
     * @param {KeyboardEvent} event Keyboard event.
     */


    function maintainCaretPosition({
      keyCode
    }) {
      if (!isSelectionEligibleForScroll()) {
        return;
      }

      const currentCaretRect = Object(external_wp_dom_["computeCaretRect"])(defaultView);

      if (!currentCaretRect) {
        return;
      } // If for some reason there is no position set to be scrolled to, let
      // this be the position to be scrolled to in the future.


      if (!caretRect) {
        caretRect = currentCaretRect;
        return;
      } // Even though enabling the typewriter effect for arrow keys results in
      // a pleasant experience, it may not be the case for everyone, so, for
      // now, let's disable it.


      if (arrowKeyCodes.has(keyCode)) {
        // Reset the caret position to maintain.
        caretRect = currentCaretRect;
        return;
      }

      const diff = currentCaretRect.top - caretRect.top;

      if (diff === 0) {
        return;
      }

      const scrollContainer = Object(external_wp_dom_["getScrollContainer"])(node); // The page must be scrollable.

      if (!scrollContainer) {
        return;
      }

      const windowScroll = scrollContainer === ownerDocument.body;
      const scrollY = windowScroll ? defaultView.scrollY : scrollContainer.scrollTop;
      const scrollContainerY = windowScroll ? 0 : scrollContainer.getBoundingClientRect().top;
      const relativeScrollPosition = windowScroll ? caretRect.top / defaultView.innerHeight : (caretRect.top - scrollContainerY) / (defaultView.innerHeight - scrollContainerY); // If the scroll position is at the start, the active editable element
      // is the last one, and the caret is positioned within the initial
      // trigger percentage of the page, do not scroll the page.
      // The typewriter effect should not kick in until an empty page has been
      // filled with the initial trigger percentage or the user scrolls
      // intentionally down.

      if (scrollY === 0 && relativeScrollPosition < initialTriggerPercentage && isLastEditableNode()) {
        // Reset the caret position to maintain.
        caretRect = currentCaretRect;
        return;
      }

      const scrollContainerHeight = windowScroll ? defaultView.innerHeight : scrollContainer.clientHeight; // Abort if the target scroll position would scroll the caret out of
      // view.

      if ( // The caret is under the lower fold.
      caretRect.top + caretRect.height > scrollContainerY + scrollContainerHeight || // The caret is above the upper fold.
      caretRect.top < scrollContainerY) {
        // Reset the caret position to maintain.
        caretRect = currentCaretRect;
        return;
      }

      if (windowScroll) {
        defaultView.scrollBy(0, diff);
      } else {
        scrollContainer.scrollTop += diff;
      }
    }
    /**
     * Adds a `selectionchange` listener to reset the scroll position to be
     * maintained.
     */


    function addSelectionChangeListener() {
      ownerDocument.addEventListener('selectionchange', computeCaretRectOnSelectionChange);
    }
    /**
     * Resets the scroll position to be maintained during a `selectionchange`
     * event. Also removes the listener, so it acts as a one-time listener.
     */


    function computeCaretRectOnSelectionChange() {
      ownerDocument.removeEventListener('selectionchange', computeCaretRectOnSelectionChange);
      computeCaretRectangle();
    }
    /**
     * Resets the scroll position to be maintained.
     */


    function computeCaretRectangle() {
      if (isSelectionEligibleForScroll()) {
        caretRect = Object(external_wp_dom_["computeCaretRect"])(defaultView);
      }
    }
    /**
     * Checks if the current situation is elegible for scroll:
     * - There should be one and only one block selected.
     * - The component must contain the selection.
     * - The active element must be contenteditable.
     */


    function isSelectionEligibleForScroll() {
      return node.contains(ownerDocument.activeElement) && ownerDocument.activeElement.isContentEditable;
    }

    function isLastEditableNode() {
      const editableNodes = node.querySelectorAll('[contenteditable="true"]');
      const lastEditableNode = editableNodes[editableNodes.length - 1];
      return lastEditableNode === ownerDocument.activeElement;
    } // When the user scrolls or resizes, the scroll position should be
    // reset.


    defaultView.addEventListener('scroll', onScrollResize, true);
    defaultView.addEventListener('resize', onScrollResize, true);
    node.addEventListener('keydown', onKeyDown);
    node.addEventListener('keyup', maintainCaretPosition);
    node.addEventListener('mousedown', addSelectionChangeListener);
    node.addEventListener('touchstart', addSelectionChangeListener);
    return () => {
      defaultView.removeEventListener('scroll', onScrollResize, true);
      defaultView.removeEventListener('resize', onScrollResize, true);
      node.removeEventListener('keydown', onKeyDown);
      node.removeEventListener('keyup', maintainCaretPosition);
      node.removeEventListener('mousedown', addSelectionChangeListener);
      node.removeEventListener('touchstart', addSelectionChangeListener);
      ownerDocument.removeEventListener('selectionchange', computeCaretRectOnSelectionChange);
      defaultView.cancelAnimationFrame(scrollResizeRafId);
      defaultView.cancelAnimationFrame(onKeyDownRafId);
    };
  }, [hasSelectedBlock]);
}

function Typewriter({
  children
}) {
  return Object(external_wp_element_["createElement"])("div", {
    ref: useTypewriter(),
    className: "block-editor__typewriter"
  }, children);
}
/**
 * The exported component. The implementation of Typewriter faced technical
 * challenges in Internet Explorer, and is simply skipped, rendering the given
 * props children instead.
 *
 * @type {WPComponent}
 */


const TypewriterOrIEBypass = isIE ? props => props.children : Typewriter;
/**
 * Ensures that the text selection keeps the same vertical distance from the
 * viewport during keyboard events within this component. The vertical distance
 * can vary. It is the last clicked or scrolled to position.
 */

/* harmony default export */ var typewriter = (TypewriterOrIEBypass);

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-multi-selection.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




function use_multi_selection_toggleRichText(container, toggle) {
  Array.from(container.querySelectorAll('.rich-text')).forEach(node => {
    if (toggle) {
      node.setAttribute('contenteditable', true);
    } else {
      node.removeAttribute('contenteditable');
    }
  });
}
/**
 * Returns for the deepest node at the start or end of a container node. Ignores
 * any text nodes that only contain HTML formatting whitespace.
 *
 * @param {Element} node Container to search.
 * @param {string} type 'start' or 'end'.
 */


function getDeepestNode(node, type) {
  const child = type === 'start' ? 'firstChild' : 'lastChild';
  const sibling = type === 'start' ? 'nextSibling' : 'previousSibling';

  while (node[child]) {
    node = node[child];

    while (node.nodeType === node.TEXT_NODE && /^[ \t\n]*$/.test(node.data) && node[sibling]) {
      node = node[sibling];
    }
  }

  return node;
}

function use_multi_selection_selector(select) {
  const {
    isMultiSelecting,
    getMultiSelectedBlockClientIds,
    hasMultiSelection,
    getSelectedBlockClientId
  } = select(store);
  return {
    isMultiSelecting: isMultiSelecting(),
    multiSelectedBlockClientIds: getMultiSelectedBlockClientIds(),
    hasMultiSelection: hasMultiSelection(),
    selectedBlockClientId: getSelectedBlockClientId()
  };
}

function use_multi_selection_useMultiSelection() {
  const ref = Object(external_wp_element_["useRef"])();
  const {
    isMultiSelecting,
    multiSelectedBlockClientIds,
    hasMultiSelection,
    selectedBlockClientId
  } = Object(external_wp_data_["useSelect"])(use_multi_selection_selector, []);
  const {
    selectBlock
  } = Object(external_wp_data_["useDispatch"])(store);
  const selectedRef = useBlockRef(selectedBlockClientId); // These must be in the right DOM order.

  const startRef = useBlockRef(Object(external_lodash_["first"])(multiSelectedBlockClientIds));
  const endRef = useBlockRef(Object(external_lodash_["last"])(multiSelectedBlockClientIds));
  /**
   * When the component updates, and there is multi selection, we need to
   * select the entire block contents.
   */

  Object(external_wp_element_["useEffect"])(() => {
    const {
      ownerDocument
    } = ref.current;
    const {
      defaultView
    } = ownerDocument;

    if (!hasMultiSelection || isMultiSelecting) {
      if (!selectedBlockClientId || isMultiSelecting) {
        return;
      }

      const selection = defaultView.getSelection();

      if (selection.rangeCount && !selection.isCollapsed) {
        const blockNode = selectedRef.current;
        const {
          startContainer,
          endContainer
        } = selection.getRangeAt(0);

        if (!!blockNode && (!blockNode.contains(startContainer) || !blockNode.contains(endContainer))) {
          selection.removeAllRanges();
        }
      }

      return;
    }

    const {
      length
    } = multiSelectedBlockClientIds;

    if (length < 2) {
      return;
    } // For some browsers, like Safari, it is important that focus happens
    // BEFORE selection.


    ref.current.focus();
    const selection = defaultView.getSelection();
    const range = ownerDocument.createRange(); // These must be in the right DOM order.
    // The most stable way to select the whole block contents is to start
    // and end at the deepest points.

    const startNode = getDeepestNode(startRef.current, 'start');
    const endNode = getDeepestNode(endRef.current, 'end'); // While rich text will be disabled with a delay when there is a multi
    // selection, we must do it immediately because it's not possible to set
    // selection across editable hosts.

    use_multi_selection_toggleRichText(ref.current, false);
    range.setStartBefore(startNode);
    range.setEndAfter(endNode);
    selection.removeAllRanges();
    selection.addRange(range);
  }, [hasMultiSelection, isMultiSelecting, multiSelectedBlockClientIds, selectBlock, selectedBlockClientId]);
  return ref;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-tab-nav.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



function isFormElement(element) {
  const {
    tagName
  } = element;
  return tagName === 'INPUT' || tagName === 'BUTTON' || tagName === 'SELECT' || tagName === 'TEXTAREA';
}

function useTabNav() {
  const container = Object(external_wp_element_["useRef"])();
  const focusCaptureBeforeRef = Object(external_wp_element_["useRef"])();
  const focusCaptureAfterRef = Object(external_wp_element_["useRef"])();
  const lastFocus = Object(external_wp_element_["useRef"])();
  const {
    hasMultiSelection,
    getSelectedBlockClientId
  } = Object(external_wp_data_["useSelect"])(store);
  const {
    setNavigationMode
  } = Object(external_wp_data_["useDispatch"])(store);
  const isNavigationMode = Object(external_wp_data_["useSelect"])(select => select(store).isNavigationMode(), []); // Don't allow tabbing to this element in Navigation mode.

  const focusCaptureTabIndex = !isNavigationMode ? '0' : undefined; // Reference that holds the a flag for enabling or disabling
  // capturing on the focus capture elements.

  const noCapture = Object(external_wp_element_["useRef"])();

  function onFocusCapture(event) {
    // Do not capture incoming focus if set by us in WritingFlow.
    if (noCapture.current) {
      noCapture.current = null;
    } else if (hasMultiSelection()) {
      container.current.focus();
    } else if (getSelectedBlockClientId()) {
      lastFocus.current.focus();
    } else {
      setNavigationMode(true);
      const isBefore = // eslint-disable-next-line no-bitwise
      event.target.compareDocumentPosition(container.current) & event.target.DOCUMENT_POSITION_FOLLOWING;
      const action = isBefore ? 'findNext' : 'findPrevious';
      external_wp_dom_["focus"].tabbable[action](event.target).focus();
    }
  }

  const before = Object(external_wp_element_["createElement"])("div", {
    ref: focusCaptureBeforeRef,
    tabIndex: focusCaptureTabIndex,
    onFocus: onFocusCapture
  });
  const after = Object(external_wp_element_["createElement"])("div", {
    ref: focusCaptureAfterRef,
    tabIndex: focusCaptureTabIndex,
    onFocus: onFocusCapture
  });
  const ref = Object(external_wp_compose_["useRefEffect"])(node => {
    function onKeyDown(event) {
      if (event.keyCode === external_wp_keycodes_["ESCAPE"] && !hasMultiSelection()) {
        event.stopPropagation();
        event.preventDefault();
        setNavigationMode(true);
        return;
      } // In Edit mode, Tab should focus the first tabbable element after
      // the content, which is normally the sidebar (with block controls)
      // and Shift+Tab should focus the first tabbable element before the
      // content, which is normally the block toolbar.
      // Arrow keys can be used, and Tab and arrow keys can be used in
      // Navigation mode (press Esc), to navigate through blocks.


      if (event.keyCode !== external_wp_keycodes_["TAB"]) {
        return;
      }

      const isShift = event.shiftKey;
      const direction = isShift ? 'findPrevious' : 'findNext';

      if (!hasMultiSelection() && !getSelectedBlockClientId()) {
        // Preserve the behaviour of entering navigation mode when
        // tabbing into the content without a block selection.
        // `onFocusCapture` already did this previously, but we need to
        // do it again here because after clearing block selection,
        // focus land on the writing flow container and pressing Tab
        // will no longer send focus through the focus capture element.
        if (event.target === node) setNavigationMode(true);
        return;
      } // Allow tabbing between form elements rendered in a block,
      // such as inside a placeholder. Form elements are generally
      // meant to be UI rather than part of the content. Ideally
      // these are not rendered in the content and perhaps in the
      // future they can be rendered in an iframe or shadow DOM.


      if (isFormElement(event.target) && isFormElement(external_wp_dom_["focus"].tabbable[direction](event.target))) {
        return;
      }

      const next = isShift ? focusCaptureBeforeRef : focusCaptureAfterRef; // Disable focus capturing on the focus capture element, so it
      // doesn't refocus this block and so it allows default behaviour
      // (moving focus to the next tabbable element).

      noCapture.current = true; // Focusing the focus capture element, which is located above and
      // below the editor, should not scroll the page all the way up or
      // down.

      next.current.focus({
        preventScroll: true
      });
    }

    function onFocusOut(event) {
      lastFocus.current = event.target;
    } // When tabbing back to an element in block list, this event handler prevents scrolling if the
    // focus capture divs (before/after) are outside of the viewport. (For example shift+tab back to a paragraph
    // when focus is on a sidebar element. This prevents the scrollable writing area from jumping either to the
    // top or bottom of the document.
    //
    // Note that it isn't possible to disable scrolling in the onFocus event. We need to intercept this
    // earlier in the keypress handler, and call focus( { preventScroll: true } ) instead.
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLOrForeignElement/focus#parameters


    function preventScrollOnTab(event) {
      var _event$target;

      if (event.keyCode !== external_wp_keycodes_["TAB"]) {
        return;
      }

      if (((_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.getAttribute('role')) === 'region') {
        return;
      }

      if (container.current === event.target) {
        return;
      }

      const isShift = event.shiftKey;
      const direction = isShift ? 'findPrevious' : 'findNext';
      const target = external_wp_dom_["focus"].tabbable[direction](event.target); // only do something when the next tabbable is a focus capture div (before/after)

      if (target === focusCaptureBeforeRef.current || target === focusCaptureAfterRef.current) {
        event.preventDefault();
        target.focus({
          preventScroll: true
        });
      }
    }

    node.ownerDocument.defaultView.addEventListener('keydown', preventScrollOnTab);
    node.addEventListener('keydown', onKeyDown);
    node.addEventListener('focusout', onFocusOut);
    return () => {
      node.ownerDocument.defaultView.removeEventListener('keydown', preventScrollOnTab);
      node.removeEventListener('keydown', onKeyDown);
      node.removeEventListener('focusout', onFocusOut);
    };
  }, []);
  const mergedRefs = Object(external_wp_compose_["useMergeRefs"])([container, ref]);
  return [before, mergedRefs, after];
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-arrow-nav.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



/**
 * Returns true if the element should consider edge navigation upon a keyboard
 * event of the given directional key code, or false otherwise.
 *
 * @param {Element} element     HTML element to test.
 * @param {number}  keyCode     KeyboardEvent keyCode to test.
 * @param {boolean} hasModifier Whether a modifier is pressed.
 *
 * @return {boolean} Whether element should consider edge navigation.
 */

function isNavigationCandidate(element, keyCode, hasModifier) {
  const isVertical = keyCode === external_wp_keycodes_["UP"] || keyCode === external_wp_keycodes_["DOWN"]; // Currently, all elements support unmodified vertical navigation.

  if (isVertical && !hasModifier) {
    return true;
  } // Native inputs should not navigate horizontally.


  const {
    tagName
  } = element;
  return tagName !== 'INPUT' && tagName !== 'TEXTAREA';
}
/**
 * Returns the optimal tab target from the given focused element in the desired
 * direction. A preference is made toward text fields, falling back to the block
 * focus stop if no other candidates exist for the block.
 *
 * @param {Element} target           Currently focused text field.
 * @param {boolean} isReverse        True if considering as the first field.
 * @param {Element} containerElement Element containing all blocks.
 * @param {boolean} onlyVertical     Whether to only consider tabbable elements
 *                                   that are visually above or under the
 *                                   target.
 *
 * @return {?Element} Optimal tab target, if one exists.
 */

function getClosestTabbable(target, isReverse, containerElement, onlyVertical) {
  // Since the current focus target is not guaranteed to be a text field, find
  // all focusables. Tabbability is considered later.
  let focusableNodes = external_wp_dom_["focus"].focusable.find(containerElement);

  if (isReverse) {
    focusableNodes = Object(external_lodash_["reverse"])(focusableNodes);
  } // Consider as candidates those focusables after the current target. It's
  // assumed this can only be reached if the target is focusable (on its
  // keydown event), so no need to verify it exists in the set.


  focusableNodes = focusableNodes.slice(focusableNodes.indexOf(target) + 1);
  let targetRect;

  if (onlyVertical) {
    targetRect = target.getBoundingClientRect();
  }

  function isTabCandidate(node) {
    // Not a candidate if the node is not tabbable.
    if (!external_wp_dom_["focus"].tabbable.isTabbableIndex(node)) {
      return false;
    } // Skip focusable elements such as links within content editable nodes.


    if (node.isContentEditable && node.contentEditable !== 'true') {
      return false;
    }

    if (onlyVertical) {
      const nodeRect = node.getBoundingClientRect();

      if (nodeRect.left >= targetRect.right || nodeRect.right <= targetRect.left) {
        return false;
      }
    }

    return true;
  }

  return Object(external_lodash_["find"])(focusableNodes, isTabCandidate);
}
function useArrowNav() {
  const {
    getSelectedBlockClientId,
    getMultiSelectedBlocksStartClientId,
    getMultiSelectedBlocksEndClientId,
    getPreviousBlockClientId,
    getNextBlockClientId,
    getFirstMultiSelectedBlockClientId,
    getLastMultiSelectedBlockClientId,
    getSettings,
    hasMultiSelection
  } = Object(external_wp_data_["useSelect"])(store);
  const {
    multiSelect,
    selectBlock
  } = Object(external_wp_data_["useDispatch"])(store);
  return Object(external_wp_compose_["useRefEffect"])(node => {
    // Here a DOMRect is stored while moving the caret vertically so
    // vertical position of the start position can be restored. This is to
    // recreate browser behaviour across blocks.
    let verticalRect;

    function onMouseDown() {
      verticalRect = null;
    }

    function expandSelection(isReverse) {
      const selectedBlockClientId = getSelectedBlockClientId();
      const selectionStartClientId = getMultiSelectedBlocksStartClientId();
      const selectionEndClientId = getMultiSelectedBlocksEndClientId();
      const selectionBeforeEndClientId = getPreviousBlockClientId(selectionEndClientId || selectedBlockClientId);
      const selectionAfterEndClientId = getNextBlockClientId(selectionEndClientId || selectedBlockClientId);
      const nextSelectionEndClientId = isReverse ? selectionBeforeEndClientId : selectionAfterEndClientId;

      if (nextSelectionEndClientId) {
        if (selectionStartClientId === nextSelectionEndClientId) {
          selectBlock(nextSelectionEndClientId);
        } else {
          multiSelect(selectionStartClientId || selectedBlockClientId, nextSelectionEndClientId);
        }
      }
    }

    function moveSelection(isReverse) {
      const selectedFirstClientId = getFirstMultiSelectedBlockClientId();
      const selectedLastClientId = getLastMultiSelectedBlockClientId();
      const focusedBlockClientId = isReverse ? selectedFirstClientId : selectedLastClientId;

      if (focusedBlockClientId) {
        selectBlock(focusedBlockClientId);
      }
    }
    /**
     * Returns true if the given target field is the last in its block which
     * can be considered for tab transition. For example, in a block with
     * two text fields, this would return true when reversing from the first
     * of the two fields, but false when reversing from the second.
     *
     * @param {Element} target    Currently focused text field.
     * @param {boolean} isReverse True if considering as the first field.
     *
     * @return {boolean} Whether field is at edge for tab transition.
     */


    function isTabbableEdge(target, isReverse) {
      const closestTabbable = getClosestTabbable(target, isReverse, node);
      return !closestTabbable || !isInSameBlock(target, closestTabbable);
    }

    function onKeyDown(event) {
      const {
        keyCode,
        target
      } = event;
      const isUp = keyCode === external_wp_keycodes_["UP"];
      const isDown = keyCode === external_wp_keycodes_["DOWN"];
      const isLeft = keyCode === external_wp_keycodes_["LEFT"];
      const isRight = keyCode === external_wp_keycodes_["RIGHT"];
      const isReverse = isUp || isLeft;
      const isHorizontal = isLeft || isRight;
      const isVertical = isUp || isDown;
      const isNav = isHorizontal || isVertical;
      const isShift = event.shiftKey;
      const hasModifier = isShift || event.ctrlKey || event.altKey || event.metaKey;
      const isNavEdge = isVertical ? external_wp_dom_["isVerticalEdge"] : external_wp_dom_["isHorizontalEdge"];
      const {
        ownerDocument
      } = node;
      const {
        defaultView
      } = ownerDocument;

      if (hasMultiSelection()) {
        if (isNav) {
          const action = isShift ? expandSelection : moveSelection;
          action(isReverse);
          event.preventDefault();
        }

        return;
      } // When presing any key other than up or down, the initial vertical
      // position must ALWAYS be reset. The vertical position is saved so
      // it can be restored as well as possible on sebsequent vertical
      // arrow key presses. It may not always be possible to restore the
      // exact same position (such as at an empty line), so it wouldn't be
      // good to compute the position right before any vertical arrow key
      // press.


      if (!isVertical) {
        verticalRect = null;
      } else if (!verticalRect) {
        verticalRect = Object(external_wp_dom_["computeCaretRect"])(defaultView);
      } // Abort if navigation has already been handled (e.g. RichText
      // inline boundaries).


      if (event.defaultPrevented) {
        return;
      }

      if (!isNav) {
        return;
      } // Abort if our current target is not a candidate for navigation
      // (e.g. preserve native input behaviors).


      if (!isNavigationCandidate(target, keyCode, hasModifier)) {
        return;
      } // In the case of RTL scripts, right means previous and left means
      // next, which is the exact reverse of LTR.


      const isReverseDir = Object(external_wp_dom_["isRTL"])(target) ? !isReverse : isReverse;
      const {
        keepCaretInsideBlock
      } = getSettings();
      const selectedBlockClientId = getSelectedBlockClientId();

      if (isShift) {
        const selectionEndClientId = getMultiSelectedBlocksEndClientId();
        const selectionBeforeEndClientId = getPreviousBlockClientId(selectionEndClientId || selectedBlockClientId);
        const selectionAfterEndClientId = getNextBlockClientId(selectionEndClientId || selectedBlockClientId);

        if ( // Ensure that there is a target block.
        (isReverse && selectionBeforeEndClientId || !isReverse && selectionAfterEndClientId) && isTabbableEdge(target, isReverse) && isNavEdge(target, isReverse)) {
          // Shift key is down, and there is multi selection or we're
          // at the end of the current block.
          expandSelection(isReverse);
          event.preventDefault();
        }
      } else if (isVertical && Object(external_wp_dom_["isVerticalEdge"])(target, isReverse) && !keepCaretInsideBlock) {
        const closestTabbable = getClosestTabbable(target, isReverse, node, true);

        if (closestTabbable) {
          Object(external_wp_dom_["placeCaretAtVerticalEdge"])(closestTabbable, isReverse, verticalRect);
          event.preventDefault();
        }
      } else if (isHorizontal && defaultView.getSelection().isCollapsed && Object(external_wp_dom_["isHorizontalEdge"])(target, isReverseDir) && !keepCaretInsideBlock) {
        const closestTabbable = getClosestTabbable(target, isReverseDir, node);
        Object(external_wp_dom_["placeCaretAtHorizontalEdge"])(closestTabbable, isReverse);
        event.preventDefault();
      }
    }

    node.addEventListener('mousedown', onMouseDown);
    node.addEventListener('keydown', onKeyDown);
    return () => {
      node.removeEventListener('mousedown', onMouseDown);
      node.removeEventListener('keydown', onKeyDown);
    };
  }, []);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-select-all.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


function useSelectAll() {
  const {
    getBlockOrder,
    getSelectedBlockClientIds,
    getBlockRootClientId
  } = Object(external_wp_data_["useSelect"])(store);
  const {
    multiSelect
  } = Object(external_wp_data_["useDispatch"])(store);
  const isMatch = Object(external_wp_keyboardShortcuts_["__unstableUseShortcutEventMatch"])();
  return Object(external_wp_compose_["useRefEffect"])(node => {
    function onKeyDown(event) {
      if (!isMatch('core/block-editor/select-all', event)) {
        return;
      }

      if (!Object(external_wp_dom_["isEntirelySelected"])(event.target)) {
        return;
      }

      const selectedClientIds = getSelectedBlockClientIds();
      const [firstSelectedClientId] = selectedClientIds;
      const rootClientId = getBlockRootClientId(firstSelectedClientId);
      let blockClientIds = getBlockOrder(rootClientId); // If we have selected all sibling nested blocks, try selecting up a
      // level. See: https://github.com/WordPress/gutenberg/pull/31859/

      if (selectedClientIds.length === blockClientIds.length) {
        blockClientIds = getBlockOrder(getBlockRootClientId(rootClientId));
      }

      const firstClientId = Object(external_lodash_["first"])(blockClientIds);
      const lastClientId = Object(external_lodash_["last"])(blockClientIds);

      if (firstClientId === lastClientId) {
        return;
      }

      multiSelect(firstClientId, lastClientId);
      event.preventDefault();
    }

    node.addEventListener('keydown', onKeyDown);
    return () => {
      node.removeEventListener('keydown', onKeyDown);
    };
  });
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */







function WritingFlow({
  children,
  ...props
}, forwardedRef) {
  const [before, ref, after] = useTabNav();
  const hasMultiSelection = Object(external_wp_data_["useSelect"])(select => select(store).hasMultiSelection(), []);
  return Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, before, Object(external_wp_element_["createElement"])("div", Object(esm_extends["a" /* default */])({}, props, {
    ref: Object(external_wp_compose_["useMergeRefs"])([forwardedRef, ref, use_multi_selection_useMultiSelection(), useSelectAll(), useArrowNav()]),
    className: classnames_default()(props.className, 'block-editor-writing-flow'),
    tabIndex: -1,
    "aria-label": hasMultiSelection ? Object(external_wp_i18n_["__"])('Multiple selected blocks') : undefined
  }), children), after);
}
/**
 * Handles selection and navigation across blocks. This component should be
 * wrapped around BlockList.
 *
 * @param {Object}    props          Component properties.
 * @param {WPElement} props.children Children to be rendered.
 */


/* harmony default export */ var writing_flow = (Object(external_wp_element_["forwardRef"])(WritingFlow));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/use-canvas-click-redirect/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Given an element, returns true if the element is a tabbable text field, or
 * false otherwise.
 *
 * @param {Element} element Element to test.
 *
 * @return {boolean} Whether element is a tabbable text field.
 */

const isTabbableTextField = Object(external_lodash_["overEvery"])([external_wp_dom_["isTextField"], external_wp_dom_["focus"].tabbable.isTabbableIndex]);
function useCanvasClickRedirect() {
  return Object(external_wp_compose_["useRefEffect"])(node => {
    function onMouseDown(event) {
      // Only handle clicks on the canvas, not the content.
      if (event.target !== node) {
        return;
      }

      const focusableNodes = external_wp_dom_["focus"].focusable.find(node);
      const target = Object(external_lodash_["findLast"])(focusableNodes, isTabbableTextField);

      if (!target) {
        return;
      }

      const {
        bottom
      } = target.getBoundingClientRect(); // Ensure the click is below the last block.

      if (event.clientY < bottom) {
        return;
      }

      Object(external_wp_dom_["placeCaretAtHorizontalEdge"])(target, true);
      event.preventDefault();
    }

    node.addEventListener('mousedown', onMouseDown);
    return () => {
      node.addEventListener('mousedown', onMouseDown);
    };
  }, []);
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/iframe/index.js



/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


const BODY_CLASS_NAME = 'editor-styles-wrapper';
const BLOCK_PREFIX = 'wp-block';
/**
 * Clones stylesheets targetting the editor canvas to the given document. A
 * stylesheet is considered targetting the editor a canvas if it contains the
 * `editor-styles-wrapper`, `wp-block`, or `wp-block-*` class selectors.
 *
 * Ideally, this hook should be removed in the future and styles should be added
 * explicitly as editor styles.
 *
 * @param {Document} doc The document to append cloned stylesheets to.
 */

function styleSheetsCompat(doc) {
  // Search the document for stylesheets targetting the editor canvas.
  Array.from(document.styleSheets).forEach(styleSheet => {
    try {
      // May fail for external styles.
      // eslint-disable-next-line no-unused-expressions
      styleSheet.cssRules;
    } catch (e) {
      return;
    }

    const {
      ownerNode,
      cssRules
    } = styleSheet;

    if (!cssRules) {
      return;
    } // Generally, ignore inline styles. We add inline styles belonging to a
    // stylesheet later, which may or may not match the selectors.


    if (ownerNode.tagName !== 'LINK') {
      return;
    } // Don't try to add the reset styles, which were removed as a dependency
    // from `edit-blocks` for the iframe since we don't need to reset admin
    // styles.


    if (ownerNode.id === 'wp-reset-editor-styles-css') {
      return;
    }

    const isMatch = Array.from(cssRules).find(({
      selectorText
    }) => selectorText && (selectorText.includes(`.${BODY_CLASS_NAME}`) || selectorText.includes(`.${BLOCK_PREFIX}`)));

    if (isMatch && !doc.getElementById(ownerNode.id)) {
      // eslint-disable-next-line no-console
      console.error(`Stylesheet ${ownerNode.id} was not properly added.
For blocks, use the block API's style (https://developer.wordpress.org/block-editor/reference-guides/block-api/block-metadata/#style) or editorStyle (https://developer.wordpress.org/block-editor/reference-guides/block-api/block-metadata/#editor-style).
For themes, use add_editor_style (https://developer.wordpress.org/block-editor/how-to-guides/themes/theme-support/#editor-styles).`, ownerNode.outerHTML);
      doc.head.appendChild(ownerNode.cloneNode(true)); // Add inline styles belonging to the stylesheet.

      const inlineCssId = ownerNode.id.replace('-css', '-inline-css');
      const inlineCssElement = document.getElementById(inlineCssId);

      if (inlineCssElement) {
        doc.head.appendChild(inlineCssElement.cloneNode(true));
      }
    }
  });
}
/**
 * Bubbles some event types (keydown, keypress, and dragover) to parent document
 * document to ensure that the keyboard shortcuts and drag and drop work.
 *
 * Ideally, we should remove event bubbling in the future. Keyboard shortcuts
 * should be context dependent, e.g. actions on blocks like Cmd+A should not
 * work globally outside the block editor.
 *
 * @param {Document} doc Document to attach listeners to.
 */


function bubbleEvents(doc) {
  const {
    defaultView
  } = doc;
  const {
    frameElement
  } = defaultView;

  function bubbleEvent(event) {
    const prototype = Object.getPrototypeOf(event);
    const constructorName = prototype.constructor.name;
    const Constructor = window[constructorName];
    const init = {};

    for (const key in event) {
      init[key] = event[key];
    }

    if (event instanceof defaultView.MouseEvent) {
      const rect = frameElement.getBoundingClientRect();
      init.clientX += rect.left;
      init.clientY += rect.top;
    }

    const newEvent = new Constructor(event.type, init);
    const cancelled = !frameElement.dispatchEvent(newEvent);

    if (cancelled) {
      event.preventDefault();
    }
  }

  const eventTypes = ['keydown', 'keypress', 'dragover'];

  for (const name of eventTypes) {
    doc.addEventListener(name, bubbleEvent);
  }
}
/**
 * Sets the document direction.
 *
 * Sets the `editor-styles-wrapper` class name on the body.
 *
 * Copies the `admin-color-*` class name to the body so that the admin color
 * scheme applies to components in the iframe.
 *
 * @param {Document} doc Document to add class name to.
 */


function setBodyClassName(doc) {
  doc.dir = document.dir;
  doc.body.className = BODY_CLASS_NAME;

  for (const name of document.body.classList) {
    if (name.startsWith('admin-color-')) {
      doc.body.classList.add(name);
    } else if (name === 'wp-embed-responsive') {
      // Ideally ALL classes that are added through get_body_class should
      // be added in the editor too, which we'll somehow have to get from
      // the server in the future (which will run the PHP filters).
      doc.body.classList.add('wp-embed-responsive');
    }
  }
}

function useParsedAssets(html) {
  return Object(external_wp_element_["useMemo"])(() => {
    const doc = document.implementation.createHTMLDocument('');
    doc.body.innerHTML = html;
    return Array.from(doc.body.children);
  }, [html]);
}

async function loadScript(doc, {
  id,
  src
}) {
  return new Promise((resolve, reject) => {
    const script = doc.createElement('script');
    script.id = id;

    if (src) {
      script.src = src;

      script.onload = () => resolve();

      script.onerror = () => reject();
    } else {
      resolve();
    }

    doc.head.appendChild(script);
  });
}

function Iframe({
  contentRef,
  children,
  head,
  ...props
}, ref) {
  const [, forceRender] = Object(external_wp_element_["useReducer"])(() => ({}));
  const [iframeDocument, setIframeDocument] = Object(external_wp_element_["useState"])();
  const styles = useParsedAssets(window.__editorAssets.styles);
  const scripts = useParsedAssets(window.__editorAssets.scripts);
  const clearerRef = useBlockSelectionClearer();
  const setRef = Object(external_wp_element_["useCallback"])(node => {
    if (!node) {
      return;
    }

    function setDocumentIfReady() {
      const {
        contentDocument
      } = node;
      const {
        readyState,
        body,
        documentElement
      } = contentDocument;

      if (readyState !== 'interactive' && readyState !== 'complete') {
        return false;
      }

      if (typeof contentRef === 'function') {
        contentRef(body);
      } else if (contentRef) {
        contentRef.current = body;
      }

      setBodyClassName(contentDocument);
      bubbleEvents(contentDocument);
      setBodyClassName(contentDocument);
      setIframeDocument(contentDocument);
      clearerRef(documentElement);
      clearerRef(body);
      scripts.reduce((promise, script) => promise.then(() => loadScript(contentDocument, script)), Promise.resolve()).finally(() => {
        // When script are loaded, re-render blocks to allow them
        // to initialise.
        forceRender();
      });
      return true;
    }

    if (setDocumentIfReady()) {
      return;
    } // Document is not immediately loaded in Firefox.


    node.addEventListener('load', () => {
      setDocumentIfReady();
    });
  }, []);
  Object(external_wp_element_["useEffect"])(() => {
    if (iframeDocument) {
      styleSheetsCompat(iframeDocument);
    }
  }, [iframeDocument]);
  head = Object(external_wp_element_["createElement"])(external_wp_element_["Fragment"], null, Object(external_wp_element_["createElement"])("style", null, 'body{margin:0}'), styles.map(({
    tagName,
    href,
    id,
    rel,
    media,
    textContent
  }) => {
    const TagName = tagName.toLowerCase();

    if (TagName === 'style') {
      return Object(external_wp_element_["createElement"])(TagName, {
        id,
        key: id
      }, textContent);
    }

    return Object(external_wp_element_["createElement"])(TagName, {
      href,
      id,
      rel,
      media,
      key: id
    });
  }), head);
  return Object(external_wp_element_["createElement"])("iframe", Object(esm_extends["a" /* default */])({}, props, {
    ref: Object(external_wp_compose_["useMergeRefs"])([ref, setRef]),
    tabIndex: "0",
    title: Object(external_wp_i18n_["__"])('Editor canvas'),
    name: "editor-canvas"
  }), iframeDocument && Object(external_wp_element_["createPortal"])(Object(external_wp_element_["createElement"])(external_wp_components_["__experimentalStyleProvider"], {
    document: iframeDocument
  }, children), iframeDocument.body), iframeDocument && Object(external_wp_element_["createPortal"])(head, iframeDocument.head));
}

/* harmony default export */ var iframe = (Object(external_wp_element_["forwardRef"])(Iframe));

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/use-no-recursive-renders/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


const RenderedRefsContext = Object(external_wp_element_["createContext"])({});
/**
 * Immutably adds an unique identifier to a set scoped for a given block type.
 *
 * @param {Object} renderedBlocks Rendered blocks grouped by block name
 * @param {string} blockName      Name of the block.
 * @param {*} uniqueId            Any value that acts as a unique identifier for a block instance.
 *
 * @return {Object} The list of rendered blocks grouped by block name.
 */

function addToBlockType(renderedBlocks, blockName, uniqueId) {
  const result = { ...renderedBlocks,
    [blockName]: renderedBlocks[blockName] ? new Set(renderedBlocks[blockName]) : new Set()
  };
  result[blockName].add(uniqueId);
  return result;
}
/**
 * A React hook for keeping track of blocks previously rendered up in the block
 * tree. Blocks susceptible to recursion can use this hook in their `Edit`
 * function to prevent said recursion.
 *
 * @param {*}      uniqueId  Any value that acts as a unique identifier for a block instance.
 * @param {string} blockName Optional block name.
 *
 * @return {[boolean, Function]} A tuple of:
 *                               - a boolean describing whether the provided id
 *                                 has already been rendered;
 *                               - a React context provider to be used to wrap
 *                                 other elements.
 */


function useNoRecursiveRenders(uniqueId, blockName = '') {
  var _previouslyRenderedBl;

  const previouslyRenderedBlocks = Object(external_wp_element_["useContext"])(RenderedRefsContext);
  const {
    name
  } = useBlockEditContext();
  blockName = blockName || name;
  const hasAlreadyRendered = Boolean((_previouslyRenderedBl = previouslyRenderedBlocks[blockName]) === null || _previouslyRenderedBl === void 0 ? void 0 : _previouslyRenderedBl.has(uniqueId));
  const newRenderedBlocks = Object(external_wp_element_["useMemo"])(() => addToBlockType(previouslyRenderedBlocks, blockName, uniqueId), [previouslyRenderedBlocks, blockName, uniqueId]);
  const Provider = Object(external_wp_element_["useCallback"])(({
    children
  }) => Object(external_wp_element_["createElement"])(RenderedRefsContext.Provider, {
    value: newRenderedBlocks
  }, children), [newRenderedBlocks]);
  return [hasAlreadyRendered, Provider];
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/components/index.js
/*
 * Block Creation Components
 */




























































/*
 * Content Related Components
 */




































/*
 * State Related Components
 */





// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/theme.js
/**
 * Internal dependencies
 */

/**
 * Given an array of theme colors checks colors for validity
 *
 * @param {Array}   colors  The array of theme colors
 *
 * @return {Array} The array of valid theme colors or the default colors
 */

function validateThemeColors(colors) {
  if (colors === undefined) {
    colors = SETTINGS_DEFAULTS.colors;
  } else {
    const validColors = colors.filter(c => c.color);

    if (validColors.length === 0) {
      colors = SETTINGS_DEFAULTS.colors;
    } else if (validColors.length < colors.length) {
      // Filter out invalid colors
      colors = validColors;
    }
  }

  return colors;
}
/**
 * Given an array of theme gradients checks gradients for validity
 *
 * @param {Array}   gradients  The array of theme gradients
 *
 * @return {Array} The array of valid theme gradients or the default gradients
 */

function validateThemeGradients(gradients) {
  if (gradients === undefined) {
    gradients = SETTINGS_DEFAULTS.gradients;
  } else {
    const validGradients = gradients.filter(c => c.gradient);

    if (validGradients.length === 0) {
      gradients = SETTINGS_DEFAULTS.gradients;
    } else if (validGradients.length < gradients.length) {
      // Filter out invalid gradients
      gradients = validGradients;
    }
  }

  return gradients;
}

// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/utils/index.js




// CONCATENATED MODULE: ./node_modules/@wordpress/block-editor/build-module/index.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */









/***/ }),

/***/ "w95h":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const close = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M13 11.8l6.1-6.3-1-1-6.1 6.2-6.1-6.2-1 1 6.1 6.3-6.5 6.7 1 1 6.5-6.6 6.5 6.6 1-1z"
}));
/* harmony default export */ __webpack_exports__["a"] = (close);


/***/ }),

/***/ "wx14":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _extends; });
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/***/ }),

/***/ "xTGt":
/***/ (function(module, exports) {

(function() { module.exports = window["wp"]["blob"]; }());

/***/ }),

/***/ "ziDm":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GRId");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Tqx9");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__);


/**
 * WordPress dependencies
 */

const alignRight = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__["Path"], {
  d: "M11.1 19.8H20v-1.5h-8.9v1.5zm0-15.6v1.5H20V4.2h-8.9zM4 12.8h16v-1.5H4v1.5z"
}));
/* harmony default export */ __webpack_exports__["a"] = (alignRight);


/***/ }),

/***/ "zt9T":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__("jB5C");

function scrollIntoView(elem, container, config) {
  config = config || {};
  // document 归一化到 window
  if (container.nodeType === 9) {
    container = util.getWindow(container);
  }

  var allowHorizontalScroll = config.allowHorizontalScroll;
  var onlyScrollIfNeeded = config.onlyScrollIfNeeded;
  var alignWithTop = config.alignWithTop;
  var alignWithLeft = config.alignWithLeft;
  var offsetTop = config.offsetTop || 0;
  var offsetLeft = config.offsetLeft || 0;
  var offsetBottom = config.offsetBottom || 0;
  var offsetRight = config.offsetRight || 0;

  allowHorizontalScroll = allowHorizontalScroll === undefined ? true : allowHorizontalScroll;

  var isWin = util.isWindow(container);
  var elemOffset = util.offset(elem);
  var eh = util.outerHeight(elem);
  var ew = util.outerWidth(elem);
  var containerOffset = undefined;
  var ch = undefined;
  var cw = undefined;
  var containerScroll = undefined;
  var diffTop = undefined;
  var diffBottom = undefined;
  var win = undefined;
  var winScroll = undefined;
  var ww = undefined;
  var wh = undefined;

  if (isWin) {
    win = container;
    wh = util.height(win);
    ww = util.width(win);
    winScroll = {
      left: util.scrollLeft(win),
      top: util.scrollTop(win)
    };
    // elem 相对 container 可视视窗的距离
    diffTop = {
      left: elemOffset.left - winScroll.left - offsetLeft,
      top: elemOffset.top - winScroll.top - offsetTop
    };
    diffBottom = {
      left: elemOffset.left + ew - (winScroll.left + ww) + offsetRight,
      top: elemOffset.top + eh - (winScroll.top + wh) + offsetBottom
    };
    containerScroll = winScroll;
  } else {
    containerOffset = util.offset(container);
    ch = container.clientHeight;
    cw = container.clientWidth;
    containerScroll = {
      left: container.scrollLeft,
      top: container.scrollTop
    };
    // elem 相对 container 可视视窗的距离
    // 注意边框, offset 是边框到根节点
    diffTop = {
      left: elemOffset.left - (containerOffset.left + (parseFloat(util.css(container, 'borderLeftWidth')) || 0)) - offsetLeft,
      top: elemOffset.top - (containerOffset.top + (parseFloat(util.css(container, 'borderTopWidth')) || 0)) - offsetTop
    };
    diffBottom = {
      left: elemOffset.left + ew - (containerOffset.left + cw + (parseFloat(util.css(container, 'borderRightWidth')) || 0)) + offsetRight,
      top: elemOffset.top + eh - (containerOffset.top + ch + (parseFloat(util.css(container, 'borderBottomWidth')) || 0)) + offsetBottom
    };
  }

  if (diffTop.top < 0 || diffBottom.top > 0) {
    // 强制向上
    if (alignWithTop === true) {
      util.scrollTop(container, containerScroll.top + diffTop.top);
    } else if (alignWithTop === false) {
      util.scrollTop(container, containerScroll.top + diffBottom.top);
    } else {
      // 自动调整
      if (diffTop.top < 0) {
        util.scrollTop(container, containerScroll.top + diffTop.top);
      } else {
        util.scrollTop(container, containerScroll.top + diffBottom.top);
      }
    }
  } else {
    if (!onlyScrollIfNeeded) {
      alignWithTop = alignWithTop === undefined ? true : !!alignWithTop;
      if (alignWithTop) {
        util.scrollTop(container, containerScroll.top + diffTop.top);
      } else {
        util.scrollTop(container, containerScroll.top + diffBottom.top);
      }
    }
  }

  if (allowHorizontalScroll) {
    if (diffTop.left < 0 || diffBottom.left > 0) {
      // 强制向上
      if (alignWithLeft === true) {
        util.scrollLeft(container, containerScroll.left + diffTop.left);
      } else if (alignWithLeft === false) {
        util.scrollLeft(container, containerScroll.left + diffBottom.left);
      } else {
        // 自动调整
        if (diffTop.left < 0) {
          util.scrollLeft(container, containerScroll.left + diffTop.left);
        } else {
          util.scrollLeft(container, containerScroll.left + diffBottom.left);
        }
      }
    } else {
      if (!onlyScrollIfNeeded) {
        alignWithLeft = alignWithLeft === undefined ? true : !!alignWithLeft;
        if (alignWithLeft) {
          util.scrollLeft(container, containerScroll.left + diffTop.left);
        } else {
          util.scrollLeft(container, containerScroll.left + diffBottom.left);
        }
      }
    }
  }
}

module.exports = scrollIntoView;

/***/ })

/******/ });